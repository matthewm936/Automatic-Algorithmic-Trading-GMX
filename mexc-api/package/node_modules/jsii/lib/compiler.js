"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Compiler = exports.JSII_DIAGNOSTICS_CODE = exports.DIAGNOSTICS = void 0;
const Case = require("case");
const colors = require("colors/safe");
const fs = require("fs-extra");
const log4js = require("log4js");
const path = require("path");
const ts = require("typescript");
const assembler_1 = require("./assembler");
const jsii_diagnostic_1 = require("./jsii-diagnostic");
const utils = require("./utils");
const BASE_COMPILER_OPTIONS = {
    alwaysStrict: true,
    charset: 'utf8',
    declaration: true,
    experimentalDecorators: true,
    incremental: true,
    inlineSourceMap: true,
    inlineSources: true,
    lib: ['lib.es2019.d.ts'],
    module: ts.ModuleKind.CommonJS,
    newLine: ts.NewLineKind.LineFeed,
    noEmitOnError: true,
    noFallthroughCasesInSwitch: true,
    noImplicitAny: true,
    noImplicitReturns: true,
    noImplicitThis: true,
    noUnusedLocals: true,
    noUnusedParameters: true,
    resolveJsonModule: true,
    strict: true,
    strictNullChecks: true,
    strictPropertyInitialization: true,
    stripInternal: false,
    target: ts.ScriptTarget.ES2019,
};
const LOG = log4js.getLogger('jsii/compiler');
exports.DIAGNOSTICS = 'diagnostics';
exports.JSII_DIAGNOSTICS_CODE = 9999;
class Compiler {
    constructor(options) {
        var _a;
        this.options = options;
        this.rootFiles = [];
        this.compilerHost = ts.createIncrementalCompilerHost(BASE_COMPILER_OPTIONS, {
            ...ts.sys,
            getCurrentDirectory: () => this.options.projectInfo.projectRoot,
        });
        const configFileName = (_a = options.generateTypeScriptConfig) !== null && _a !== void 0 ? _a : 'tsconfig.json';
        this.configPath = path.join(this.options.projectInfo.projectRoot, configFileName);
        this.projectReferences =
            options.projectReferences !== undefined
                ? options.projectReferences
                : options.projectInfo.projectReferences !== undefined
                    ? options.projectInfo.projectReferences
                    : false;
    }
    /**
     * Compiles the configured program.
     *
     * @param files can be specified to override the standard source code location logic. Useful for example when testing "negatives".
     */
    async emit(...files) {
        await this._prepareForBuild(...files);
        return this._buildOnce();
    }
    async watch(opts) {
        await this._prepareForBuild();
        const pi = this.options.projectInfo;
        const projectRoot = pi.projectRoot;
        const host = ts.createWatchCompilerHost(this.configPath, {
            ...pi.tsc,
            ...BASE_COMPILER_OPTIONS,
            noEmitOnError: false,
        }, {
            ...ts.sys,
            getCurrentDirectory() {
                return projectRoot;
            },
        }, ts.createEmitAndSemanticDiagnosticsBuilderProgram, opts === null || opts === void 0 ? void 0 : opts.reportDiagnostics, opts === null || opts === void 0 ? void 0 : opts.reportWatchStatus);
        if (!host.getDefaultLibLocation) {
            throw new Error('No default library location was found on the TypeScript compiler host!');
        }
        const orig = host.afterProgramCreate;
        host.afterProgramCreate = async (builderProgram) => {
            const emitResult = await this._consumeProgram(builderProgram.getProgram(), host.getDefaultLibLocation());
            for (const diag of emitResult.diagnostics.filter((d) => d.code === exports.JSII_DIAGNOSTICS_CODE)) {
                utils.logDiagnostic(diag, projectRoot);
            }
            if (orig) {
                orig.call(host, builderProgram);
            }
            if (opts === null || opts === void 0 ? void 0 : opts.compilationComplete) {
                await opts.compilationComplete(emitResult);
            }
        };
        const watch = ts.createWatchProgram(host);
        if (opts === null || opts === void 0 ? void 0 : opts.nonBlocking) {
            // In non-blocking mode, returns the handle to the TypeScript watch interface.
            return watch;
        }
        // In blocking mode, returns a never-resolving promise.
        return new Promise(() => null);
    }
    /**
     * Prepares the project for build, by creating the necessary configuration
     * file(s), and assigning the relevant root file(s).
     *
     * @param files the files that were specified as input in the CLI invocation.
     */
    async _prepareForBuild(...files) {
        await this.buildTypeScriptConfig();
        await this.writeTypeScriptConfig();
        this.rootFiles = this.determineSources(files);
    }
    /**
     * Do a single build
     */
    async _buildOnce() {
        var _a, _b;
        if (!this.compilerHost.getDefaultLibLocation) {
            throw new Error('No default library location was found on the TypeScript compiler host!');
        }
        const tsconf = this.typescriptConfig;
        const pi = this.options.projectInfo;
        const prog = ts.createIncrementalProgram({
            rootNames: this.rootFiles.concat(_pathOfLibraries(this.compilerHost)),
            options: {
                ...pi.tsc,
                ...((_a = tsconf === null || tsconf === void 0 ? void 0 : tsconf.compilerOptions) !== null && _a !== void 0 ? _a : BASE_COMPILER_OPTIONS),
            },
            // Make the references absolute for the compiler
            projectReferences: (_b = tsconf.references) === null || _b === void 0 ? void 0 : _b.map((ref) => ({
                path: path.resolve(path.dirname(this.configPath), ref.path),
            })),
            host: this.compilerHost,
        });
        return this._consumeProgram(prog.getProgram(), this.compilerHost.getDefaultLibLocation());
    }
    async _consumeProgram(program, stdlib) {
        const diagnostics = [...ts.getPreEmitDiagnostics(program)];
        let hasErrors = false;
        if (!hasErrors && this.diagsHaveAbortableErrors(diagnostics)) {
            hasErrors = true;
            LOG.error('Compilation errors prevented the JSII assembly from being created');
        }
        // Do the "Assembler" part first because we need some of the analysis done in there
        // to post-process the AST
        const assembler = new assembler_1.Assembler(this.options.projectInfo, program, stdlib, {
            stripDeprecated: this.options.stripDeprecated,
            stripDeprecatedAllowListFile: this.options.stripDeprecatedAllowListFile,
            addDeprecationWarnings: this.options.addDeprecationWarnings,
        });
        try {
            const assmEmit = await assembler.emit();
            if (!hasErrors &&
                (assmEmit.emitSkipped ||
                    this.diagsHaveAbortableErrors(assmEmit.diagnostics))) {
                hasErrors = true;
                LOG.error('Type model errors prevented the JSII assembly from being created');
            }
            diagnostics.push(...assmEmit.diagnostics);
        }
        catch (e) {
            diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_9997_UNKNOWN_ERROR.createDetached(e));
            hasErrors = true;
        }
        // Do the emit, but add in transformers which are going to replace real
        // comments with synthetic ones.
        const emit = program.emit(undefined, // targetSourceFile
        undefined, // writeFile
        undefined, // cancellationToken
        undefined, // emitOnlyDtsFiles
        assembler.customTransformers);
        diagnostics.push(...emit.diagnostics);
        if (!hasErrors &&
            (emit.emitSkipped || this.diagsHaveAbortableErrors(emit.diagnostics))) {
            hasErrors = true;
            LOG.error('Compilation errors prevented the JSII assembly from being created');
        }
        return {
            emitSkipped: hasErrors,
            diagnostics: ts.sortAndDeduplicateDiagnostics(diagnostics),
            emittedFiles: emit.emittedFiles,
        };
    }
    /**
     * Build the TypeScript config object
     *
     * This is the object that will be written to disk.
     */
    async buildTypeScriptConfig() {
        var _a, _b, _c, _d, _e, _f;
        let references;
        if (this.projectReferences) {
            references = await this.findProjectReferences();
        }
        const pi = this.options.projectInfo;
        this.typescriptConfig = {
            compilerOptions: {
                ...pi.tsc,
                ...BASE_COMPILER_OPTIONS,
                // Enable composite mode if project references are enabled
                composite: this.projectReferences,
                // When incremental, configure a tsbuildinfo file
                tsBuildInfoFile: path.join((_b = (_a = pi.tsc) === null || _a === void 0 ? void 0 : _a.outDir) !== null && _b !== void 0 ? _b : '.', 'tsconfig.tsbuildinfo'),
            },
            include: [
                ((_c = pi.tsc) === null || _c === void 0 ? void 0 : _c.rootDir) != null
                    ? path.join(pi.tsc.rootDir, '**', '*.ts')
                    : path.join('**', '*.ts'),
            ],
            exclude: [
                'node_modules',
                ...((_d = pi.excludeTypescript) !== null && _d !== void 0 ? _d : []),
                ...(((_e = pi.tsc) === null || _e === void 0 ? void 0 : _e.outDir) != null &&
                    (((_f = pi.tsc) === null || _f === void 0 ? void 0 : _f.rootDir) == null ||
                        path
                            .resolve(pi.tsc.outDir)
                            .startsWith(path.resolve(pi.tsc.rootDir) + path.sep))
                    ? [path.join(pi.tsc.outDir, '**', '*.ts')]
                    : []),
            ],
            // Change the references a little. We write 'originalpath' to the
            // file under the 'path' key, which is the same as what the
            // TypeScript compiler does. Make it relative so that the files are
            // movable. Not strictly required but looks better.
            references: references === null || references === void 0 ? void 0 : references.map((p) => ({ path: p })),
        };
    }
    /**
     * Creates a `tsconfig.json` file to improve the IDE experience.
     *
     * @return the fully qualified path to the `tsconfig.json` file
     */
    async writeTypeScriptConfig() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const commentKey = '_generated_by_jsii_';
        const commentValue = 'Generated by jsii - safe to delete, and ideally should be in .gitignore';
        this.typescriptConfig[commentKey] = commentValue;
        if (await fs.pathExists(this.configPath)) {
            const currentConfig = await fs.readJson(this.configPath);
            if (!(commentKey in currentConfig)) {
                throw new Error(`A '${this.configPath}' file that was not generated by jsii is in ${this.options.projectInfo.projectRoot}. Aborting instead of overwriting.`);
            }
        }
        const outputConfig = {
            ...this.typescriptConfig,
            compilerOptions: {
                ...(_a = this.typescriptConfig) === null || _a === void 0 ? void 0 : _a.compilerOptions,
                lib: (_d = (_c = (_b = this.typescriptConfig) === null || _b === void 0 ? void 0 : _b.compilerOptions) === null || _c === void 0 ? void 0 : _c.lib) === null || _d === void 0 ? void 0 : _d.map((lib) => 
                // Drop the "lib." prefix and ".d.ts" suffix before writing up the tsconfig.json file
                lib.slice(4, lib.length - 5)),
                // Re-write the module, targets & jsx to be the JSON format instead of Programmatic API
                module: (((_f = (_e = this.typescriptConfig) === null || _e === void 0 ? void 0 : _e.compilerOptions) === null || _f === void 0 ? void 0 : _f.module) &&
                    ts.ModuleKind[this.typescriptConfig.compilerOptions.module]),
                newLine: newLineForTsconfigJson((_g = this.typescriptConfig) === null || _g === void 0 ? void 0 : _g.compilerOptions.newLine),
                target: (((_j = (_h = this.typescriptConfig) === null || _h === void 0 ? void 0 : _h.compilerOptions) === null || _j === void 0 ? void 0 : _j.target) &&
                    ts.ScriptTarget[this.typescriptConfig.compilerOptions.target]),
                jsx: (((_l = (_k = this.typescriptConfig) === null || _k === void 0 ? void 0 : _k.compilerOptions) === null || _l === void 0 ? void 0 : _l.jsx) &&
                    Case.snake(ts.JsxEmit[this.typescriptConfig.compilerOptions.jsx])),
            },
        };
        LOG.debug(`Creating or updating ${colors.blue(this.configPath)}`);
        await fs.writeJson(this.configPath, outputConfig, {
            encoding: 'utf8',
            spaces: 2,
        });
        /**
         * This is annoying - the values expected in the tsconfig.json file are not
         * the same as the enum constant names, or their values. So we need this
         * function to map the "compiler API version" to the "tsconfig.json version"
         *
         * @param newLine the compiler form of the new line configuration
         *
         * @return the requivalent value to put in tsconfig.json
         */
        function newLineForTsconfigJson(newLine) {
            switch (newLine) {
                case ts.NewLineKind.CarriageReturnLineFeed:
                    return 'crlf';
                case ts.NewLineKind.LineFeed:
                    return 'lf';
                default:
                    return undefined;
            }
        }
    }
    /**
     * Find all dependencies that look like TypeScript projects.
     *
     * Enumerate all dependencies, if they have a tsconfig.json file with
     * "composite: true" we consider them project references.
     *
     * (Note: TypeScript seems to only correctly find transitive project references
     * if there's an "index" tsconfig.json of all projects somewhere up the directory
     * tree)
     */
    async findProjectReferences() {
        var _a;
        const pkg = this.options.projectInfo.packageJson;
        const ret = new Array();
        const dependencyNames = new Set();
        for (const dependencyMap of [
            pkg.dependencies,
            pkg.devDependencies,
            pkg.peerDependencies,
        ]) {
            if (dependencyMap === undefined) {
                continue;
            }
            Object.keys(dependencyMap).forEach(dependencyNames.add.bind(dependencyNames));
        }
        for (const tsconfigFile of await Promise.all(Array.from(dependencyNames).map((depName) => this.findMonorepoPeerTsconfig(depName)))) {
            if (!tsconfigFile) {
                continue;
            }
            const { config: tsconfig } = ts.readConfigFile(tsconfigFile, ts.sys.readFile);
            // Add references to any TypeScript package we find that is 'composite' enabled.
            // Make it relative.
            if ((_a = tsconfig.compilerOptions) === null || _a === void 0 ? void 0 : _a.composite) {
                ret.push(path.relative(this.options.projectInfo.projectRoot, path.dirname(tsconfigFile)));
            }
            else {
                // Not a composite package--if this package is in a node_modules directory, that is most
                // likely correct, otherwise it is most likely an error (heuristic here, I don't know how to
                // properly check this).
                if (tsconfigFile.includes('node_modules')) {
                    LOG.warn('%s: not a composite TypeScript package, but it probably should be', path.dirname(tsconfigFile));
                }
            }
        }
        return ret;
    }
    /**
     * Find source files using the same mechanism that the TypeScript compiler itself uses.
     *
     * Respects includes/excludes/etc.
     *
     * This makes it so that running 'tsc' and running 'jsii' has the same behavior.
     */
    determineSources(files) {
        const ret = new Array();
        if (files.length > 0) {
            ret.push(...files);
        }
        else {
            const parseConfigHost = parseConfigHostFromCompilerHost(this.compilerHost);
            const parsed = ts.parseJsonConfigFileContent(this.typescriptConfig, parseConfigHost, this.options.projectInfo.projectRoot);
            ret.push(...parsed.fileNames);
        }
        return ret;
    }
    /**
     * Resolve the given dependency name from the current package, and find the associated tsconfig.json location
     *
     * Because we have the following potential directory layout:
     *
     *   package/node_modules/some_dependency
     *   package/tsconfig.json
     *
     * We resolve symlinks and only find a "TypeScript" dependency if doesn't have 'node_modules' in
     * the path after resolving symlinks (i.e., if it's a peer package in the same monorepo).
     *
     * Returns undefined if no such tsconfig could be found.
     */
    async findMonorepoPeerTsconfig(depName) {
        const paths = nodeJsCompatibleSearchPaths(this.options.projectInfo.projectRoot);
        let dep;
        try {
            dep = require.resolve(`${depName}/tsconfig.json`, { paths });
        }
        catch {
            // Package does not have a tsconfig.json
            return undefined;
        }
        // Resolve symlinks, to check if this is a monorepo peer
        const dependencyRealPath = await fs.realpath(dep);
        if (dependencyRealPath.split(path.sep).includes('node_modules')) {
            return undefined;
        }
        return dependencyRealPath;
    }
    diagsHaveAbortableErrors(diags) {
        return diags.some((d) => d.category === ts.DiagnosticCategory.Error ||
            (this.options.failOnWarnings &&
                d.category === ts.DiagnosticCategory.Warning));
    }
}
exports.Compiler = Compiler;
function _pathOfLibraries(host) {
    var _a;
    if (!BASE_COMPILER_OPTIONS.lib || BASE_COMPILER_OPTIONS.lib.length === 0) {
        return [];
    }
    const lib = (_a = host.getDefaultLibLocation) === null || _a === void 0 ? void 0 : _a.call(host);
    if (!lib) {
        throw new Error(`Compiler host doesn't have a default library directory available for ${BASE_COMPILER_OPTIONS.lib.join(', ')}`);
    }
    return BASE_COMPILER_OPTIONS.lib.map((name) => path.join(lib, name));
}
/**
 * Return all possible 'node_modules' directories from a given starting directory.
 */
function nodeJsCompatibleSearchPaths(dir) {
    const ret = new Array();
    let lastDir;
    do {
        ret.push(path.join(dir, 'node_modules'));
        lastDir = dir;
        dir = path.dirname(dir);
    } while (dir !== lastDir); // path.dirname('/') === '/', also works on Windows
    return ret;
}
function parseConfigHostFromCompilerHost(host) {
    // Copied from upstream
    // https://github.com/Microsoft/TypeScript/blob/9e05abcfd3f8bb3d6775144ede807daceab2e321/src/compiler/program.ts#L3105
    return {
        fileExists: (f) => host.fileExists(f),
        readDirectory(root, extensions, excludes, includes, depth) {
            if (host.readDirectory === undefined) {
                throw new Error("'CompilerHost.readDirectory' must be implemented to correctly process 'projectReferences'");
            }
            return host.readDirectory(root, extensions, excludes, includes, depth);
        },
        readFile: (f) => host.readFile(f),
        useCaseSensitiveFileNames: host.useCaseSensitiveFileNames(),
        trace: host.trace ? (s) => host.trace(s) : undefined,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb21waWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw2QkFBNkI7QUFDN0Isc0NBQXNDO0FBQ3RDLCtCQUErQjtBQUMvQixpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCLGlDQUFpQztBQUVqQywyQ0FBd0M7QUFFeEMsdURBQW1EO0FBRW5ELGlDQUFpQztBQUVqQyxNQUFNLHFCQUFxQixHQUF1QjtJQUNoRCxZQUFZLEVBQUUsSUFBSTtJQUNsQixPQUFPLEVBQUUsTUFBTTtJQUNmLFdBQVcsRUFBRSxJQUFJO0lBQ2pCLHNCQUFzQixFQUFFLElBQUk7SUFDNUIsV0FBVyxFQUFFLElBQUk7SUFDakIsZUFBZSxFQUFFLElBQUk7SUFDckIsYUFBYSxFQUFFLElBQUk7SUFDbkIsR0FBRyxFQUFFLENBQUMsaUJBQWlCLENBQUM7SUFDeEIsTUFBTSxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsUUFBUTtJQUM5QixPQUFPLEVBQUUsRUFBRSxDQUFDLFdBQVcsQ0FBQyxRQUFRO0lBQ2hDLGFBQWEsRUFBRSxJQUFJO0lBQ25CLDBCQUEwQixFQUFFLElBQUk7SUFDaEMsYUFBYSxFQUFFLElBQUk7SUFDbkIsaUJBQWlCLEVBQUUsSUFBSTtJQUN2QixjQUFjLEVBQUUsSUFBSTtJQUNwQixjQUFjLEVBQUUsSUFBSTtJQUNwQixrQkFBa0IsRUFBRSxJQUFJO0lBQ3hCLGlCQUFpQixFQUFFLElBQUk7SUFDdkIsTUFBTSxFQUFFLElBQUk7SUFDWixnQkFBZ0IsRUFBRSxJQUFJO0lBQ3RCLDRCQUE0QixFQUFFLElBQUk7SUFDbEMsYUFBYSxFQUFFLEtBQUs7SUFDcEIsTUFBTSxFQUFFLEVBQUUsQ0FBQyxZQUFZLENBQUMsTUFBTTtDQUMvQixDQUFDO0FBRUYsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUNqQyxRQUFBLFdBQVcsR0FBRyxhQUFhLENBQUM7QUFDNUIsUUFBQSxxQkFBcUIsR0FBRyxJQUFJLENBQUM7QUErQjFDLE1BQWEsUUFBUTtJQU9uQixZQUFvQyxPQUF3Qjs7UUFBeEIsWUFBTyxHQUFQLE9BQU8sQ0FBaUI7UUFKcEQsY0FBUyxHQUFhLEVBQUUsQ0FBQztRQUsvQixJQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQyw2QkFBNkIsQ0FDbEQscUJBQXFCLEVBQ3JCO1lBQ0UsR0FBRyxFQUFFLENBQUMsR0FBRztZQUNULG1CQUFtQixFQUFFLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLFdBQVc7U0FDaEUsQ0FDRixDQUFDO1FBRUYsTUFBTSxjQUFjLFNBQUcsT0FBTyxDQUFDLHdCQUF3QixtQ0FBSSxlQUFlLENBQUM7UUFFM0UsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUN6QixJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxXQUFXLEVBQ3BDLGNBQWMsQ0FDZixDQUFDO1FBRUYsSUFBSSxDQUFDLGlCQUFpQjtZQUNwQixPQUFPLENBQUMsaUJBQWlCLEtBQUssU0FBUztnQkFDckMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxpQkFBaUI7Z0JBQzNCLENBQUMsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLGlCQUFpQixLQUFLLFNBQVM7b0JBQ3JELENBQUMsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLGlCQUFpQjtvQkFDdkMsQ0FBQyxDQUFDLEtBQUssQ0FBQztJQUNkLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQWU7UUFDbEMsTUFBTSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQztRQUN0QyxPQUFPLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUMzQixDQUFDO0lBZ0JNLEtBQUssQ0FBQyxLQUFLLENBQ2hCLElBQThCO1FBRTlCLE1BQU0sSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFFOUIsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUM7UUFDcEMsTUFBTSxXQUFXLEdBQUcsRUFBRSxDQUFDLFdBQVcsQ0FBQztRQUNuQyxNQUFNLElBQUksR0FBRyxFQUFFLENBQUMsdUJBQXVCLENBQ3JDLElBQUksQ0FBQyxVQUFVLEVBQ2Y7WUFDRSxHQUFHLEVBQUUsQ0FBQyxHQUFHO1lBQ1QsR0FBRyxxQkFBcUI7WUFDeEIsYUFBYSxFQUFFLEtBQUs7U0FDckIsRUFDRDtZQUNFLEdBQUcsRUFBRSxDQUFDLEdBQUc7WUFDVCxtQkFBbUI7Z0JBQ2pCLE9BQU8sV0FBVyxDQUFDO1lBQ3JCLENBQUM7U0FDRixFQUNELEVBQUUsQ0FBQyw4Q0FBOEMsRUFDakQsSUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLGlCQUFpQixFQUN2QixJQUFJLGFBQUosSUFBSSx1QkFBSixJQUFJLENBQUUsaUJBQWlCLENBQ3hCLENBQUM7UUFDRixJQUFJLENBQUMsSUFBSSxDQUFDLHFCQUFxQixFQUFFO1lBQy9CLE1BQU0sSUFBSSxLQUFLLENBQ2Isd0VBQXdFLENBQ3pFLENBQUM7U0FDSDtRQUNELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQztRQUNyQyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsS0FBSyxFQUFFLGNBQWMsRUFBRSxFQUFFO1lBQ2pELE1BQU0sVUFBVSxHQUFHLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FDM0MsY0FBYyxDQUFDLFVBQVUsRUFBRSxFQUMzQixJQUFJLENBQUMscUJBQXNCLEVBQUUsQ0FDOUIsQ0FBQztZQUVGLEtBQUssTUFBTSxJQUFJLElBQUksVUFBVSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQzlDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLDZCQUFxQixDQUN4QyxFQUFFO2dCQUNELEtBQUssQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDO2FBQ3hDO1lBRUQsSUFBSSxJQUFJLEVBQUU7Z0JBQ1IsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsY0FBYyxDQUFDLENBQUM7YUFDakM7WUFDRCxJQUFJLElBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxtQkFBbUIsRUFBRTtnQkFDN0IsTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQUMsVUFBVSxDQUFDLENBQUM7YUFDNUM7UUFDSCxDQUFDLENBQUM7UUFDRixNQUFNLEtBQUssR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFMUMsSUFBSSxJQUFJLGFBQUosSUFBSSx1QkFBSixJQUFJLENBQUUsV0FBVyxFQUFFO1lBQ3JCLDhFQUE4RTtZQUM5RSxPQUFPLEtBQUssQ0FBQztTQUNkO1FBQ0QsdURBQXVEO1FBQ3ZELE9BQU8sSUFBSSxPQUFPLENBQVEsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ssS0FBSyxDQUFDLGdCQUFnQixDQUFDLEdBQUcsS0FBZTtRQUMvQyxNQUFNLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1FBQ25DLE1BQU0sSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7UUFDbkMsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVEOztPQUVHO0lBQ0ssS0FBSyxDQUFDLFVBQVU7O1FBQ3RCLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLHFCQUFxQixFQUFFO1lBQzVDLE1BQU0sSUFBSSxLQUFLLENBQ2Isd0VBQXdFLENBQ3pFLENBQUM7U0FDSDtRQUVELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxnQkFBaUIsQ0FBQztRQUN0QyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQztRQUVwQyxNQUFNLElBQUksR0FBRyxFQUFFLENBQUMsd0JBQXdCLENBQUM7WUFDdkMsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUNyRSxPQUFPLEVBQUU7Z0JBQ1AsR0FBRyxFQUFFLENBQUMsR0FBRztnQkFDVCxHQUFHLE9BQUMsTUFBTSxhQUFOLE1BQU0sdUJBQU4sTUFBTSxDQUFFLGVBQWUsbUNBQUkscUJBQXFCLENBQUM7YUFDdEQ7WUFDRCxnREFBZ0Q7WUFDaEQsaUJBQWlCLFFBQUUsTUFBTSxDQUFDLFVBQVUsMENBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUNsRCxJQUFJLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDO2FBQzVELENBQUMsQ0FBQztZQUNILElBQUksRUFBRSxJQUFJLENBQUMsWUFBWTtTQUN4QixDQUFDLENBQUM7UUFFSCxPQUFPLElBQUksQ0FBQyxlQUFlLENBQ3pCLElBQUksQ0FBQyxVQUFVLEVBQUUsRUFDakIsSUFBSSxDQUFDLFlBQVksQ0FBQyxxQkFBcUIsRUFBRSxDQUMxQyxDQUFDO0lBQ0osQ0FBQztJQUVPLEtBQUssQ0FBQyxlQUFlLENBQzNCLE9BQW1CLEVBQ25CLE1BQWM7UUFFZCxNQUFNLFdBQVcsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFDM0QsSUFBSSxTQUFTLEdBQUcsS0FBSyxDQUFDO1FBRXRCLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLHdCQUF3QixDQUFDLFdBQVcsQ0FBQyxFQUFFO1lBQzVELFNBQVMsR0FBRyxJQUFJLENBQUM7WUFDakIsR0FBRyxDQUFDLEtBQUssQ0FDUCxtRUFBbUUsQ0FDcEUsQ0FBQztTQUNIO1FBRUQsbUZBQW1GO1FBQ25GLDBCQUEwQjtRQUMxQixNQUFNLFNBQVMsR0FBRyxJQUFJLHFCQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRTtZQUN6RSxlQUFlLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlO1lBQzdDLDRCQUE0QixFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsNEJBQTRCO1lBQ3ZFLHNCQUFzQixFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsc0JBQXNCO1NBQzVELENBQUMsQ0FBQztRQUVILElBQUk7WUFDRixNQUFNLFFBQVEsR0FBRyxNQUFNLFNBQVMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUN4QyxJQUNFLENBQUMsU0FBUztnQkFDVixDQUFDLFFBQVEsQ0FBQyxXQUFXO29CQUNuQixJQUFJLENBQUMsd0JBQXdCLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQ3REO2dCQUNBLFNBQVMsR0FBRyxJQUFJLENBQUM7Z0JBQ2pCLEdBQUcsQ0FBQyxLQUFLLENBQ1Asa0VBQWtFLENBQ25FLENBQUM7YUFDSDtZQUVELFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDM0M7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLFdBQVcsQ0FBQyxJQUFJLENBQ2QsZ0NBQWMsQ0FBQyx1QkFBdUIsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQ3pELENBQUM7WUFDRixTQUFTLEdBQUcsSUFBSSxDQUFDO1NBQ2xCO1FBRUQsdUVBQXVFO1FBQ3ZFLGdDQUFnQztRQUNoQyxNQUFNLElBQUksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUN2QixTQUFTLEVBQUUsbUJBQW1CO1FBQzlCLFNBQVMsRUFBRSxZQUFZO1FBQ3ZCLFNBQVMsRUFBRSxvQkFBb0I7UUFDL0IsU0FBUyxFQUFFLG1CQUFtQjtRQUM5QixTQUFTLENBQUMsa0JBQWtCLENBQzdCLENBQUM7UUFDRixXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRXRDLElBQ0UsQ0FBQyxTQUFTO1lBQ1YsQ0FBQyxJQUFJLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsRUFDckU7WUFDQSxTQUFTLEdBQUcsSUFBSSxDQUFDO1lBQ2pCLEdBQUcsQ0FBQyxLQUFLLENBQ1AsbUVBQW1FLENBQ3BFLENBQUM7U0FDSDtRQUVELE9BQU87WUFDTCxXQUFXLEVBQUUsU0FBUztZQUN0QixXQUFXLEVBQUUsRUFBRSxDQUFDLDZCQUE2QixDQUFDLFdBQVcsQ0FBQztZQUMxRCxZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVk7U0FDaEMsQ0FBQztJQUNKLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssS0FBSyxDQUFDLHFCQUFxQjs7UUFDakMsSUFBSSxVQUFnQyxDQUFDO1FBQ3JDLElBQUksSUFBSSxDQUFDLGlCQUFpQixFQUFFO1lBQzFCLFVBQVUsR0FBRyxNQUFNLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1NBQ2pEO1FBRUQsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUM7UUFFcEMsSUFBSSxDQUFDLGdCQUFnQixHQUFHO1lBQ3RCLGVBQWUsRUFBRTtnQkFDZixHQUFHLEVBQUUsQ0FBQyxHQUFHO2dCQUNULEdBQUcscUJBQXFCO2dCQUN4QiwwREFBMEQ7Z0JBQzFELFNBQVMsRUFBRSxJQUFJLENBQUMsaUJBQWlCO2dCQUNqQyxpREFBaUQ7Z0JBQ2pELGVBQWUsRUFBRSxJQUFJLENBQUMsSUFBSSxhQUN4QixFQUFFLENBQUMsR0FBRywwQ0FBRSxNQUFNLG1DQUFJLEdBQUcsRUFDckIsc0JBQXNCLENBQ3ZCO2FBQ0Y7WUFDRCxPQUFPLEVBQUU7Z0JBQ1AsT0FBQSxFQUFFLENBQUMsR0FBRywwQ0FBRSxPQUFPLEtBQUksSUFBSTtvQkFDckIsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQztvQkFDekMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQzthQUM1QjtZQUNELE9BQU8sRUFBRTtnQkFDUCxjQUFjO2dCQUNkLEdBQUcsT0FBQyxFQUFFLENBQUMsaUJBQWlCLG1DQUFJLEVBQUUsQ0FBQztnQkFDL0IsR0FBRyxDQUFDLE9BQUEsRUFBRSxDQUFDLEdBQUcsMENBQUUsTUFBTSxLQUFJLElBQUk7b0JBQzFCLENBQUMsT0FBQSxFQUFFLENBQUMsR0FBRywwQ0FBRSxPQUFPLEtBQUksSUFBSTt3QkFDdEIsSUFBSTs2QkFDRCxPQUFPLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUM7NkJBQ3RCLFVBQVUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUN2RCxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztvQkFDMUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQzthQUNSO1lBQ0QsaUVBQWlFO1lBQ2pFLDJEQUEyRDtZQUMzRCxtRUFBbUU7WUFDbkUsbURBQW1EO1lBQ25ELFVBQVUsRUFBRSxVQUFVLGFBQVYsVUFBVSx1QkFBVixVQUFVLENBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDbEQsQ0FBQztJQUNKLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssS0FBSyxDQUFDLHFCQUFxQjs7UUFDakMsTUFBTSxVQUFVLEdBQUcscUJBQXFCLENBQUM7UUFDekMsTUFBTSxZQUFZLEdBQ2hCLHlFQUF5RSxDQUFDO1FBRTNFLElBQUksQ0FBQyxnQkFBd0IsQ0FBQyxVQUFVLENBQUMsR0FBRyxZQUFZLENBQUM7UUFFMUQsSUFBSSxNQUFNLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ3hDLE1BQU0sYUFBYSxHQUFHLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDekQsSUFBSSxDQUFDLENBQUMsVUFBVSxJQUFJLGFBQWEsQ0FBQyxFQUFFO2dCQUNsQyxNQUFNLElBQUksS0FBSyxDQUNiLE1BQU0sSUFBSSxDQUFDLFVBQVUsK0NBQStDLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLFdBQVcsb0NBQW9DLENBQzdJLENBQUM7YUFDSDtTQUNGO1FBRUQsTUFBTSxZQUFZLEdBQUc7WUFDbkIsR0FBRyxJQUFJLENBQUMsZ0JBQWdCO1lBQ3hCLGVBQWUsRUFBRTtnQkFDZixTQUFHLElBQUksQ0FBQyxnQkFBZ0IsMENBQUUsZUFBZTtnQkFDekMsR0FBRyxvQkFBRSxJQUFJLENBQUMsZ0JBQWdCLDBDQUFFLGVBQWUsMENBQUUsR0FBRywwQ0FBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtnQkFDNUQscUZBQXFGO2dCQUNyRixHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUM3QjtnQkFDRCx1RkFBdUY7Z0JBQ3ZGLE1BQU0sRUFBRSxDQUFDLGFBQUEsSUFBSSxDQUFDLGdCQUFnQiwwQ0FBRSxlQUFlLDBDQUFFLE1BQU07b0JBQ3JELEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBUTtnQkFDckUsT0FBTyxFQUFFLHNCQUFzQixPQUM3QixJQUFJLENBQUMsZ0JBQWdCLDBDQUFFLGVBQWUsQ0FBQyxPQUFPLENBQy9DO2dCQUNELE1BQU0sRUFBRSxDQUFDLGFBQUEsSUFBSSxDQUFDLGdCQUFnQiwwQ0FBRSxlQUFlLDBDQUFFLE1BQU07b0JBQ3JELEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBUTtnQkFDdkUsR0FBRyxFQUFFLENBQUMsYUFBQSxJQUFJLENBQUMsZ0JBQWdCLDBDQUFFLGVBQWUsMENBQUUsR0FBRztvQkFDL0MsSUFBSSxDQUFDLEtBQUssQ0FDUixFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQ3RELENBQVE7YUFDWjtTQUNGLENBQUM7UUFFRixHQUFHLENBQUMsS0FBSyxDQUFDLHdCQUF3QixNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDbEUsTUFBTSxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsWUFBWSxFQUFFO1lBQ2hELFFBQVEsRUFBRSxNQUFNO1lBQ2hCLE1BQU0sRUFBRSxDQUFDO1NBQ1YsQ0FBQyxDQUFDO1FBRUg7Ozs7Ozs7O1dBUUc7UUFDSCxTQUFTLHNCQUFzQixDQUFDLE9BQW1DO1lBQ2pFLFFBQVEsT0FBTyxFQUFFO2dCQUNmLEtBQUssRUFBRSxDQUFDLFdBQVcsQ0FBQyxzQkFBc0I7b0JBQ3hDLE9BQU8sTUFBTSxDQUFDO2dCQUNoQixLQUFLLEVBQUUsQ0FBQyxXQUFXLENBQUMsUUFBUTtvQkFDMUIsT0FBTyxJQUFJLENBQUM7Z0JBQ2Q7b0JBQ0UsT0FBTyxTQUFTLENBQUM7YUFDcEI7UUFDSCxDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNLLEtBQUssQ0FBQyxxQkFBcUI7O1FBQ2pDLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQztRQUVqRCxNQUFNLEdBQUcsR0FBRyxJQUFJLEtBQUssRUFBVSxDQUFDO1FBRWhDLE1BQU0sZUFBZSxHQUFHLElBQUksR0FBRyxFQUFVLENBQUM7UUFDMUMsS0FBSyxNQUFNLGFBQWEsSUFBSTtZQUMxQixHQUFHLENBQUMsWUFBWTtZQUNoQixHQUFHLENBQUMsZUFBZTtZQUNuQixHQUFHLENBQUMsZ0JBQWdCO1NBQ3JCLEVBQUU7WUFDRCxJQUFJLGFBQWEsS0FBSyxTQUFTLEVBQUU7Z0JBQy9CLFNBQVM7YUFDVjtZQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsT0FBTyxDQUNoQyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FDMUMsQ0FBQztTQUNIO1FBRUQsS0FBSyxNQUFNLFlBQVksSUFBSSxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQzFDLEtBQUssQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FDMUMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLE9BQU8sQ0FBQyxDQUN2QyxDQUNGLEVBQUU7WUFDRCxJQUFJLENBQUMsWUFBWSxFQUFFO2dCQUNqQixTQUFTO2FBQ1Y7WUFFRCxNQUFNLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsQ0FBQyxjQUFjLENBQzVDLFlBQVksRUFDWixFQUFFLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FDaEIsQ0FBQztZQUVGLGdGQUFnRjtZQUNoRixvQkFBb0I7WUFDcEIsVUFBSSxRQUFRLENBQUMsZUFBZSwwQ0FBRSxTQUFTLEVBQUU7Z0JBQ3ZDLEdBQUcsQ0FBQyxJQUFJLENBQ04sSUFBSSxDQUFDLFFBQVEsQ0FDWCxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxXQUFXLEVBQ3BDLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQzNCLENBQ0YsQ0FBQzthQUNIO2lCQUFNO2dCQUNMLHdGQUF3RjtnQkFDeEYsNEZBQTRGO2dCQUM1Rix3QkFBd0I7Z0JBQ3hCLElBQUksWUFBWSxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsRUFBRTtvQkFDekMsR0FBRyxDQUFDLElBQUksQ0FDTixtRUFBbUUsRUFDbkUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FDM0IsQ0FBQztpQkFDSDthQUNGO1NBQ0Y7UUFFRCxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSyxnQkFBZ0IsQ0FBQyxLQUFlO1FBQ3RDLE1BQU0sR0FBRyxHQUFHLElBQUksS0FBSyxFQUFVLENBQUM7UUFFaEMsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNwQixHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUM7U0FDcEI7YUFBTTtZQUNMLE1BQU0sZUFBZSxHQUFHLCtCQUErQixDQUNyRCxJQUFJLENBQUMsWUFBWSxDQUNsQixDQUFDO1lBQ0YsTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDLDBCQUEwQixDQUMxQyxJQUFJLENBQUMsZ0JBQWdCLEVBQ3JCLGVBQWUsRUFDZixJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQ3JDLENBQUM7WUFDRixHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQy9CO1FBRUQsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7OztPQVlHO0lBQ0ssS0FBSyxDQUFDLHdCQUF3QixDQUNwQyxPQUFlO1FBRWYsTUFBTSxLQUFLLEdBQUcsMkJBQTJCLENBQ3ZDLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FDckMsQ0FBQztRQUVGLElBQUksR0FBRyxDQUFDO1FBQ1IsSUFBSTtZQUNGLEdBQUcsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsT0FBTyxnQkFBZ0IsRUFBRSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7U0FDOUQ7UUFBQyxNQUFNO1lBQ04sd0NBQXdDO1lBQ3hDLE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBRUQsd0RBQXdEO1FBQ3hELE1BQU0sa0JBQWtCLEdBQUcsTUFBTSxFQUFFLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2xELElBQUksa0JBQWtCLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLEVBQUU7WUFDL0QsT0FBTyxTQUFTLENBQUM7U0FDbEI7UUFFRCxPQUFPLGtCQUFrQixDQUFDO0lBQzVCLENBQUM7SUFFTyx3QkFBd0IsQ0FBQyxLQUErQjtRQUM5RCxPQUFPLEtBQUssQ0FBQyxJQUFJLENBQ2YsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUNKLENBQUMsQ0FBQyxRQUFRLEtBQUssRUFBRSxDQUFDLGtCQUFrQixDQUFDLEtBQUs7WUFDMUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWM7Z0JBQzFCLENBQUMsQ0FBQyxRQUFRLEtBQUssRUFBRSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxDQUNsRCxDQUFDO0lBQ0osQ0FBQztDQUNGO0FBemVELDRCQXllQztBQStCRCxTQUFTLGdCQUFnQixDQUN2QixJQUFpRDs7SUFFakQsSUFBSSxDQUFDLHFCQUFxQixDQUFDLEdBQUcsSUFBSSxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUN4RSxPQUFPLEVBQUUsQ0FBQztLQUNYO0lBQ0QsTUFBTSxHQUFHLFNBQUcsSUFBSSxDQUFDLHFCQUFxQiwrQ0FBMUIsSUFBSSxDQUEwQixDQUFDO0lBQzNDLElBQUksQ0FBQyxHQUFHLEVBQUU7UUFDUixNQUFNLElBQUksS0FBSyxDQUNiLHdFQUF3RSxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUNwRyxJQUFJLENBQ0wsRUFBRSxDQUNKLENBQUM7S0FDSDtJQUNELE9BQU8scUJBQXFCLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUN2RSxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLDJCQUEyQixDQUFDLEdBQVc7SUFDOUMsTUFBTSxHQUFHLEdBQUcsSUFBSSxLQUFLLEVBQVUsQ0FBQztJQUVoQyxJQUFJLE9BQU8sQ0FBQztJQUNaLEdBQUc7UUFDRCxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUM7UUFDekMsT0FBTyxHQUFHLEdBQUcsQ0FBQztRQUNkLEdBQUcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ3pCLFFBQVEsR0FBRyxLQUFLLE9BQU8sRUFBRSxDQUFDLG1EQUFtRDtJQUU5RSxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFFRCxTQUFTLCtCQUErQixDQUN0QyxJQUFxQjtJQUVyQix1QkFBdUI7SUFDdkIsc0hBQXNIO0lBQ3RILE9BQU87UUFDTCxVQUFVLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1FBQ3JDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsS0FBSztZQUN2RCxJQUFJLElBQUksQ0FBQyxhQUFhLEtBQUssU0FBUyxFQUFFO2dCQUNwQyxNQUFNLElBQUksS0FBSyxDQUNiLDJGQUEyRixDQUM1RixDQUFDO2FBQ0g7WUFDRCxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3pFLENBQUM7UUFDRCxRQUFRLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ2pDLHlCQUF5QixFQUFFLElBQUksQ0FBQyx5QkFBeUIsRUFBRTtRQUMzRCxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVM7S0FDdEQsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBDYXNlIGZyb20gJ2Nhc2UnO1xuaW1wb3J0ICogYXMgY29sb3JzIGZyb20gJ2NvbG9ycy9zYWZlJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIGxvZzRqcyBmcm9tICdsb2c0anMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5pbXBvcnQgeyBBc3NlbWJsZXIgfSBmcm9tICcuL2Fzc2VtYmxlcic7XG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSAnLi9lbWl0dGVyJztcbmltcG9ydCB7IEpzaWlEaWFnbm9zdGljIH0gZnJvbSAnLi9qc2lpLWRpYWdub3N0aWMnO1xuaW1wb3J0IHsgUHJvamVjdEluZm8gfSBmcm9tICcuL3Byb2plY3QtaW5mbyc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgQkFTRV9DT01QSUxFUl9PUFRJT05TOiB0cy5Db21waWxlck9wdGlvbnMgPSB7XG4gIGFsd2F5c1N0cmljdDogdHJ1ZSxcbiAgY2hhcnNldDogJ3V0ZjgnLFxuICBkZWNsYXJhdGlvbjogdHJ1ZSxcbiAgZXhwZXJpbWVudGFsRGVjb3JhdG9yczogdHJ1ZSxcbiAgaW5jcmVtZW50YWw6IHRydWUsXG4gIGlubGluZVNvdXJjZU1hcDogdHJ1ZSxcbiAgaW5saW5lU291cmNlczogdHJ1ZSxcbiAgbGliOiBbJ2xpYi5lczIwMTkuZC50cyddLFxuICBtb2R1bGU6IHRzLk1vZHVsZUtpbmQuQ29tbW9uSlMsXG4gIG5ld0xpbmU6IHRzLk5ld0xpbmVLaW5kLkxpbmVGZWVkLFxuICBub0VtaXRPbkVycm9yOiB0cnVlLFxuICBub0ZhbGx0aHJvdWdoQ2FzZXNJblN3aXRjaDogdHJ1ZSxcbiAgbm9JbXBsaWNpdEFueTogdHJ1ZSxcbiAgbm9JbXBsaWNpdFJldHVybnM6IHRydWUsXG4gIG5vSW1wbGljaXRUaGlzOiB0cnVlLFxuICBub1VudXNlZExvY2FsczogdHJ1ZSxcbiAgbm9VbnVzZWRQYXJhbWV0ZXJzOiB0cnVlLFxuICByZXNvbHZlSnNvbk1vZHVsZTogdHJ1ZSxcbiAgc3RyaWN0OiB0cnVlLFxuICBzdHJpY3ROdWxsQ2hlY2tzOiB0cnVlLFxuICBzdHJpY3RQcm9wZXJ0eUluaXRpYWxpemF0aW9uOiB0cnVlLFxuICBzdHJpcEludGVybmFsOiBmYWxzZSxcbiAgdGFyZ2V0OiB0cy5TY3JpcHRUYXJnZXQuRVMyMDE5LFxufTtcblxuY29uc3QgTE9HID0gbG9nNGpzLmdldExvZ2dlcignanNpaS9jb21waWxlcicpO1xuZXhwb3J0IGNvbnN0IERJQUdOT1NUSUNTID0gJ2RpYWdub3N0aWNzJztcbmV4cG9ydCBjb25zdCBKU0lJX0RJQUdOT1NUSUNTX0NPREUgPSA5OTk5O1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBpbGVyT3B0aW9ucyB7XG4gIC8qKiBUaGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHByb2plY3QgdG8gYmUgYnVpbHQgKi9cbiAgcHJvamVjdEluZm86IFByb2plY3RJbmZvO1xuICAvKiogV2hldGhlciB0aGUgY29tcGlsZXIgc2hvdWxkIHdhdGNoIGZvciBjaGFuZ2VzIG9yIGp1c3QgY29tcGlsZSBvbmNlICovXG4gIHdhdGNoPzogYm9vbGVhbjtcbiAgLyoqIFdoZXRoZXIgdG8gZGV0ZWN0IGFuZCBnZW5lcmF0ZSBUeXBlU2NyaXB0IHByb2plY3QgcmVmZXJlbmNlcyAqL1xuICBwcm9qZWN0UmVmZXJlbmNlcz86IGJvb2xlYW47XG4gIC8qKiBXaGV0aGVyIHRvIGZhaWwgd2hlbiBhIHdhcm5pbmcgaXMgZW1pdHRlZCAqL1xuICBmYWlsT25XYXJuaW5ncz86IGJvb2xlYW47XG4gIC8qKiBXaGV0aGVyIHRvIHN0cmlwIGRlcHJlY2F0ZWQgbWVtYmVycyBmcm9tIGVtaXR0ZWQgYXJ0aWZhY3RzICovXG4gIHN0cmlwRGVwcmVjYXRlZD86IGJvb2xlYW47XG4gIC8qKiBUaGUgcGF0aCB0byBhbiBhbGxvd2xpc3Qgb2YgRlFOcyB0byBzdHJpcCBpZiBzdHJpcERlcHJlY2F0ZWQgaXMgc2V0ICovXG4gIHN0cmlwRGVwcmVjYXRlZEFsbG93TGlzdEZpbGU/OiBzdHJpbmc7XG4gIC8qKiBXaGV0aGVyIHRvIGFkZCB3YXJuaW5ncyBmb3IgZGVwcmVjYXRlZCBlbGVtZW50cyAqL1xuICBhZGREZXByZWNhdGlvbldhcm5pbmdzPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSB0c2NvbmZpZyBmaWxlIHRvIGdlbmVyYXRlXG4gICAqIEBkZWZhdWx0IFwidHNjb25maWcuanNvblwiXG4gICAqL1xuICBnZW5lcmF0ZVR5cGVTY3JpcHRDb25maWc/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHlwZXNjcmlwdENvbmZpZyB7XG4gIGNvbXBpbGVyT3B0aW9uczogdHMuQ29tcGlsZXJPcHRpb25zO1xuICBpbmNsdWRlPzogc3RyaW5nW107XG4gIGV4Y2x1ZGU/OiBzdHJpbmdbXTtcbiAgcmVmZXJlbmNlcz86IHRzLlByb2plY3RSZWZlcmVuY2VbXTtcbn1cblxuZXhwb3J0IGNsYXNzIENvbXBpbGVyIGltcGxlbWVudHMgRW1pdHRlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgY29tcGlsZXJIb3N0OiB0cy5Db21waWxlckhvc3Q7XG4gIHByaXZhdGUgdHlwZXNjcmlwdENvbmZpZz86IFR5cGVzY3JpcHRDb25maWc7XG4gIHByaXZhdGUgcm9vdEZpbGVzOiBzdHJpbmdbXSA9IFtdO1xuICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZ1BhdGg6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBwcm9qZWN0UmVmZXJlbmNlczogYm9vbGVhbjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBvcHRpb25zOiBDb21waWxlck9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbXBpbGVySG9zdCA9IHRzLmNyZWF0ZUluY3JlbWVudGFsQ29tcGlsZXJIb3N0KFxuICAgICAgQkFTRV9DT01QSUxFUl9PUFRJT05TLFxuICAgICAge1xuICAgICAgICAuLi50cy5zeXMsXG4gICAgICAgIGdldEN1cnJlbnREaXJlY3Rvcnk6ICgpID0+IHRoaXMub3B0aW9ucy5wcm9qZWN0SW5mby5wcm9qZWN0Um9vdCxcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIGNvbnN0IGNvbmZpZ0ZpbGVOYW1lID0gb3B0aW9ucy5nZW5lcmF0ZVR5cGVTY3JpcHRDb25maWcgPz8gJ3RzY29uZmlnLmpzb24nO1xuXG4gICAgdGhpcy5jb25maWdQYXRoID0gcGF0aC5qb2luKFxuICAgICAgdGhpcy5vcHRpb25zLnByb2plY3RJbmZvLnByb2plY3RSb290LFxuICAgICAgY29uZmlnRmlsZU5hbWUsXG4gICAgKTtcblxuICAgIHRoaXMucHJvamVjdFJlZmVyZW5jZXMgPVxuICAgICAgb3B0aW9ucy5wcm9qZWN0UmVmZXJlbmNlcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy5wcm9qZWN0UmVmZXJlbmNlc1xuICAgICAgICA6IG9wdGlvbnMucHJvamVjdEluZm8ucHJvamVjdFJlZmVyZW5jZXMgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMucHJvamVjdEluZm8ucHJvamVjdFJlZmVyZW5jZXNcbiAgICAgICAgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21waWxlcyB0aGUgY29uZmlndXJlZCBwcm9ncmFtLlxuICAgKlxuICAgKiBAcGFyYW0gZmlsZXMgY2FuIGJlIHNwZWNpZmllZCB0byBvdmVycmlkZSB0aGUgc3RhbmRhcmQgc291cmNlIGNvZGUgbG9jYXRpb24gbG9naWMuIFVzZWZ1bCBmb3IgZXhhbXBsZSB3aGVuIHRlc3RpbmcgXCJuZWdhdGl2ZXNcIi5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBlbWl0KC4uLmZpbGVzOiBzdHJpbmdbXSk6IFByb21pc2U8dHMuRW1pdFJlc3VsdD4ge1xuICAgIGF3YWl0IHRoaXMuX3ByZXBhcmVGb3JCdWlsZCguLi5maWxlcyk7XG4gICAgcmV0dXJuIHRoaXMuX2J1aWxkT25jZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhdGNoZXMgZm9yIGZpbGUtc3lzdGVtIGNoYW5nZXMgYW5kIGR5bmFtaWNhbGx5IHJlY29tcGlsZXMgdGhlIHByb2plY3QgYXMgbmVlZGVkLiBJbiBub24tYmxvY2tpbmcgbW9kZSwgdGhpc1xuICAgKiByZXR1cm5zIHRoZSBUeXBlU2NyaXB0IHdhdGNoIGhhbmRsZSBmb3IgdGhlIGFwcGxpY2F0aW9uIHRvIHVzZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgd2F0Y2goXG4gICAgb3B0czogTm9uQmxvY2tpbmdXYXRjaE9wdGlvbnMsXG4gICk6IFByb21pc2U8dHMuV2F0Y2g8dHMuQnVpbGRlclByb2dyYW0+PjtcbiAgLyoqXG4gICAqIFdhdGNoZXMgZm9yIGZpbGUtc3lzdGVtIGNoYW5nZXMgYW5kIGR5bmFtaWNhbGx5IHJlY29tcGlsZXMgdGhlIHByb2plY3QgYXMgbmVlZGVkLiBJbiBibG9ja2luZyBtb2RlLCB0aGlzIHJlc3VsdHNcbiAgICogaW4gYSBuZXZlci1yZXNvbHZpbmcgcHJvbWlzZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyB3YXRjaCgpOiBQcm9taXNlPG5ldmVyPjtcbiAgcHVibGljIGFzeW5jIHdhdGNoKFxuICAgIG9wdHM/OiBOb25CbG9ja2luZ1dhdGNoT3B0aW9ucyxcbiAgKTogUHJvbWlzZTx0cy5XYXRjaDx0cy5CdWlsZGVyUHJvZ3JhbT4gfCBuZXZlcj4ge1xuICAgIGF3YWl0IHRoaXMuX3ByZXBhcmVGb3JCdWlsZCgpO1xuXG4gICAgY29uc3QgcGkgPSB0aGlzLm9wdGlvbnMucHJvamVjdEluZm87XG4gICAgY29uc3QgcHJvamVjdFJvb3QgPSBwaS5wcm9qZWN0Um9vdDtcbiAgICBjb25zdCBob3N0ID0gdHMuY3JlYXRlV2F0Y2hDb21waWxlckhvc3QoXG4gICAgICB0aGlzLmNvbmZpZ1BhdGgsXG4gICAgICB7XG4gICAgICAgIC4uLnBpLnRzYyxcbiAgICAgICAgLi4uQkFTRV9DT01QSUxFUl9PUFRJT05TLFxuICAgICAgICBub0VtaXRPbkVycm9yOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC4uLnRzLnN5cyxcbiAgICAgICAgZ2V0Q3VycmVudERpcmVjdG9yeSgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvamVjdFJvb3Q7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgdHMuY3JlYXRlRW1pdEFuZFNlbWFudGljRGlhZ25vc3RpY3NCdWlsZGVyUHJvZ3JhbSxcbiAgICAgIG9wdHM/LnJlcG9ydERpYWdub3N0aWNzLFxuICAgICAgb3B0cz8ucmVwb3J0V2F0Y2hTdGF0dXMsXG4gICAgKTtcbiAgICBpZiAoIWhvc3QuZ2V0RGVmYXVsdExpYkxvY2F0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdObyBkZWZhdWx0IGxpYnJhcnkgbG9jYXRpb24gd2FzIGZvdW5kIG9uIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyIGhvc3QhJyxcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IG9yaWcgPSBob3N0LmFmdGVyUHJvZ3JhbUNyZWF0ZTtcbiAgICBob3N0LmFmdGVyUHJvZ3JhbUNyZWF0ZSA9IGFzeW5jIChidWlsZGVyUHJvZ3JhbSkgPT4ge1xuICAgICAgY29uc3QgZW1pdFJlc3VsdCA9IGF3YWl0IHRoaXMuX2NvbnN1bWVQcm9ncmFtKFxuICAgICAgICBidWlsZGVyUHJvZ3JhbS5nZXRQcm9ncmFtKCksXG4gICAgICAgIGhvc3QuZ2V0RGVmYXVsdExpYkxvY2F0aW9uISgpLFxuICAgICAgKTtcblxuICAgICAgZm9yIChjb25zdCBkaWFnIG9mIGVtaXRSZXN1bHQuZGlhZ25vc3RpY3MuZmlsdGVyKFxuICAgICAgICAoZCkgPT4gZC5jb2RlID09PSBKU0lJX0RJQUdOT1NUSUNTX0NPREUsXG4gICAgICApKSB7XG4gICAgICAgIHV0aWxzLmxvZ0RpYWdub3N0aWMoZGlhZywgcHJvamVjdFJvb3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3JpZykge1xuICAgICAgICBvcmlnLmNhbGwoaG9zdCwgYnVpbGRlclByb2dyYW0pO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHM/LmNvbXBpbGF0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgYXdhaXQgb3B0cy5jb21waWxhdGlvbkNvbXBsZXRlKGVtaXRSZXN1bHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgd2F0Y2ggPSB0cy5jcmVhdGVXYXRjaFByb2dyYW0oaG9zdCk7XG5cbiAgICBpZiAob3B0cz8ubm9uQmxvY2tpbmcpIHtcbiAgICAgIC8vIEluIG5vbi1ibG9ja2luZyBtb2RlLCByZXR1cm5zIHRoZSBoYW5kbGUgdG8gdGhlIFR5cGVTY3JpcHQgd2F0Y2ggaW50ZXJmYWNlLlxuICAgICAgcmV0dXJuIHdhdGNoO1xuICAgIH1cbiAgICAvLyBJbiBibG9ja2luZyBtb2RlLCByZXR1cm5zIGEgbmV2ZXItcmVzb2x2aW5nIHByb21pc2UuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPG5ldmVyPigoKSA9PiBudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlcyB0aGUgcHJvamVjdCBmb3IgYnVpbGQsIGJ5IGNyZWF0aW5nIHRoZSBuZWNlc3NhcnkgY29uZmlndXJhdGlvblxuICAgKiBmaWxlKHMpLCBhbmQgYXNzaWduaW5nIHRoZSByZWxldmFudCByb290IGZpbGUocykuXG4gICAqXG4gICAqIEBwYXJhbSBmaWxlcyB0aGUgZmlsZXMgdGhhdCB3ZXJlIHNwZWNpZmllZCBhcyBpbnB1dCBpbiB0aGUgQ0xJIGludm9jYXRpb24uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9wcmVwYXJlRm9yQnVpbGQoLi4uZmlsZXM6IHN0cmluZ1tdKSB7XG4gICAgYXdhaXQgdGhpcy5idWlsZFR5cGVTY3JpcHRDb25maWcoKTtcbiAgICBhd2FpdCB0aGlzLndyaXRlVHlwZVNjcmlwdENvbmZpZygpO1xuICAgIHRoaXMucm9vdEZpbGVzID0gdGhpcy5kZXRlcm1pbmVTb3VyY2VzKGZpbGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEbyBhIHNpbmdsZSBidWlsZFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfYnVpbGRPbmNlKCk6IFByb21pc2U8dHMuRW1pdFJlc3VsdD4ge1xuICAgIGlmICghdGhpcy5jb21waWxlckhvc3QuZ2V0RGVmYXVsdExpYkxvY2F0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdObyBkZWZhdWx0IGxpYnJhcnkgbG9jYXRpb24gd2FzIGZvdW5kIG9uIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyIGhvc3QhJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgdHNjb25mID0gdGhpcy50eXBlc2NyaXB0Q29uZmlnITtcbiAgICBjb25zdCBwaSA9IHRoaXMub3B0aW9ucy5wcm9qZWN0SW5mbztcblxuICAgIGNvbnN0IHByb2cgPSB0cy5jcmVhdGVJbmNyZW1lbnRhbFByb2dyYW0oe1xuICAgICAgcm9vdE5hbWVzOiB0aGlzLnJvb3RGaWxlcy5jb25jYXQoX3BhdGhPZkxpYnJhcmllcyh0aGlzLmNvbXBpbGVySG9zdCkpLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICAuLi5waS50c2MsXG4gICAgICAgIC4uLih0c2NvbmY/LmNvbXBpbGVyT3B0aW9ucyA/PyBCQVNFX0NPTVBJTEVSX09QVElPTlMpLFxuICAgICAgfSxcbiAgICAgIC8vIE1ha2UgdGhlIHJlZmVyZW5jZXMgYWJzb2x1dGUgZm9yIHRoZSBjb21waWxlclxuICAgICAgcHJvamVjdFJlZmVyZW5jZXM6IHRzY29uZi5yZWZlcmVuY2VzPy5tYXAoKHJlZikgPT4gKHtcbiAgICAgICAgcGF0aDogcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZSh0aGlzLmNvbmZpZ1BhdGgpLCByZWYucGF0aCksXG4gICAgICB9KSksXG4gICAgICBob3N0OiB0aGlzLmNvbXBpbGVySG9zdCxcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLl9jb25zdW1lUHJvZ3JhbShcbiAgICAgIHByb2cuZ2V0UHJvZ3JhbSgpLFxuICAgICAgdGhpcy5jb21waWxlckhvc3QuZ2V0RGVmYXVsdExpYkxvY2F0aW9uKCksXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2NvbnN1bWVQcm9ncmFtKFxuICAgIHByb2dyYW06IHRzLlByb2dyYW0sXG4gICAgc3RkbGliOiBzdHJpbmcsXG4gICk6IFByb21pc2U8dHMuRW1pdFJlc3VsdD4ge1xuICAgIGNvbnN0IGRpYWdub3N0aWNzID0gWy4uLnRzLmdldFByZUVtaXREaWFnbm9zdGljcyhwcm9ncmFtKV07XG4gICAgbGV0IGhhc0Vycm9ycyA9IGZhbHNlO1xuXG4gICAgaWYgKCFoYXNFcnJvcnMgJiYgdGhpcy5kaWFnc0hhdmVBYm9ydGFibGVFcnJvcnMoZGlhZ25vc3RpY3MpKSB7XG4gICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgTE9HLmVycm9yKFxuICAgICAgICAnQ29tcGlsYXRpb24gZXJyb3JzIHByZXZlbnRlZCB0aGUgSlNJSSBhc3NlbWJseSBmcm9tIGJlaW5nIGNyZWF0ZWQnLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEbyB0aGUgXCJBc3NlbWJsZXJcIiBwYXJ0IGZpcnN0IGJlY2F1c2Ugd2UgbmVlZCBzb21lIG9mIHRoZSBhbmFseXNpcyBkb25lIGluIHRoZXJlXG4gICAgLy8gdG8gcG9zdC1wcm9jZXNzIHRoZSBBU1RcbiAgICBjb25zdCBhc3NlbWJsZXIgPSBuZXcgQXNzZW1ibGVyKHRoaXMub3B0aW9ucy5wcm9qZWN0SW5mbywgcHJvZ3JhbSwgc3RkbGliLCB7XG4gICAgICBzdHJpcERlcHJlY2F0ZWQ6IHRoaXMub3B0aW9ucy5zdHJpcERlcHJlY2F0ZWQsXG4gICAgICBzdHJpcERlcHJlY2F0ZWRBbGxvd0xpc3RGaWxlOiB0aGlzLm9wdGlvbnMuc3RyaXBEZXByZWNhdGVkQWxsb3dMaXN0RmlsZSxcbiAgICAgIGFkZERlcHJlY2F0aW9uV2FybmluZ3M6IHRoaXMub3B0aW9ucy5hZGREZXByZWNhdGlvbldhcm5pbmdzLFxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFzc21FbWl0ID0gYXdhaXQgYXNzZW1ibGVyLmVtaXQoKTtcbiAgICAgIGlmIChcbiAgICAgICAgIWhhc0Vycm9ycyAmJlxuICAgICAgICAoYXNzbUVtaXQuZW1pdFNraXBwZWQgfHxcbiAgICAgICAgICB0aGlzLmRpYWdzSGF2ZUFib3J0YWJsZUVycm9ycyhhc3NtRW1pdC5kaWFnbm9zdGljcykpXG4gICAgICApIHtcbiAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgTE9HLmVycm9yKFxuICAgICAgICAgICdUeXBlIG1vZGVsIGVycm9ycyBwcmV2ZW50ZWQgdGhlIEpTSUkgYXNzZW1ibHkgZnJvbSBiZWluZyBjcmVhdGVkJyxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZGlhZ25vc3RpY3MucHVzaCguLi5hc3NtRW1pdC5kaWFnbm9zdGljcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV85OTk3X1VOS05PV05fRVJST1IuY3JlYXRlRGV0YWNoZWQoZSksXG4gICAgICApO1xuICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBEbyB0aGUgZW1pdCwgYnV0IGFkZCBpbiB0cmFuc2Zvcm1lcnMgd2hpY2ggYXJlIGdvaW5nIHRvIHJlcGxhY2UgcmVhbFxuICAgIC8vIGNvbW1lbnRzIHdpdGggc3ludGhldGljIG9uZXMuXG4gICAgY29uc3QgZW1pdCA9IHByb2dyYW0uZW1pdChcbiAgICAgIHVuZGVmaW5lZCwgLy8gdGFyZ2V0U291cmNlRmlsZVxuICAgICAgdW5kZWZpbmVkLCAvLyB3cml0ZUZpbGVcbiAgICAgIHVuZGVmaW5lZCwgLy8gY2FuY2VsbGF0aW9uVG9rZW5cbiAgICAgIHVuZGVmaW5lZCwgLy8gZW1pdE9ubHlEdHNGaWxlc1xuICAgICAgYXNzZW1ibGVyLmN1c3RvbVRyYW5zZm9ybWVycyxcbiAgICApO1xuICAgIGRpYWdub3N0aWNzLnB1c2goLi4uZW1pdC5kaWFnbm9zdGljcyk7XG5cbiAgICBpZiAoXG4gICAgICAhaGFzRXJyb3JzICYmXG4gICAgICAoZW1pdC5lbWl0U2tpcHBlZCB8fCB0aGlzLmRpYWdzSGF2ZUFib3J0YWJsZUVycm9ycyhlbWl0LmRpYWdub3N0aWNzKSlcbiAgICApIHtcbiAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICBMT0cuZXJyb3IoXG4gICAgICAgICdDb21waWxhdGlvbiBlcnJvcnMgcHJldmVudGVkIHRoZSBKU0lJIGFzc2VtYmx5IGZyb20gYmVpbmcgY3JlYXRlZCcsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbWl0U2tpcHBlZDogaGFzRXJyb3JzLFxuICAgICAgZGlhZ25vc3RpY3M6IHRzLnNvcnRBbmREZWR1cGxpY2F0ZURpYWdub3N0aWNzKGRpYWdub3N0aWNzKSxcbiAgICAgIGVtaXR0ZWRGaWxlczogZW1pdC5lbWl0dGVkRmlsZXMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCB0aGUgVHlwZVNjcmlwdCBjb25maWcgb2JqZWN0XG4gICAqXG4gICAqIFRoaXMgaXMgdGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgd3JpdHRlbiB0byBkaXNrLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBidWlsZFR5cGVTY3JpcHRDb25maWcoKSB7XG4gICAgbGV0IHJlZmVyZW5jZXM6IHN0cmluZ1tdIHwgdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLnByb2plY3RSZWZlcmVuY2VzKSB7XG4gICAgICByZWZlcmVuY2VzID0gYXdhaXQgdGhpcy5maW5kUHJvamVjdFJlZmVyZW5jZXMoKTtcbiAgICB9XG5cbiAgICBjb25zdCBwaSA9IHRoaXMub3B0aW9ucy5wcm9qZWN0SW5mbztcblxuICAgIHRoaXMudHlwZXNjcmlwdENvbmZpZyA9IHtcbiAgICAgIGNvbXBpbGVyT3B0aW9uczoge1xuICAgICAgICAuLi5waS50c2MsXG4gICAgICAgIC4uLkJBU0VfQ09NUElMRVJfT1BUSU9OUyxcbiAgICAgICAgLy8gRW5hYmxlIGNvbXBvc2l0ZSBtb2RlIGlmIHByb2plY3QgcmVmZXJlbmNlcyBhcmUgZW5hYmxlZFxuICAgICAgICBjb21wb3NpdGU6IHRoaXMucHJvamVjdFJlZmVyZW5jZXMsXG4gICAgICAgIC8vIFdoZW4gaW5jcmVtZW50YWwsIGNvbmZpZ3VyZSBhIHRzYnVpbGRpbmZvIGZpbGVcbiAgICAgICAgdHNCdWlsZEluZm9GaWxlOiBwYXRoLmpvaW4oXG4gICAgICAgICAgcGkudHNjPy5vdXREaXIgPz8gJy4nLFxuICAgICAgICAgICd0c2NvbmZpZy50c2J1aWxkaW5mbycsXG4gICAgICAgICksXG4gICAgICB9LFxuICAgICAgaW5jbHVkZTogW1xuICAgICAgICBwaS50c2M/LnJvb3REaXIgIT0gbnVsbFxuICAgICAgICAgID8gcGF0aC5qb2luKHBpLnRzYy5yb290RGlyLCAnKionLCAnKi50cycpXG4gICAgICAgICAgOiBwYXRoLmpvaW4oJyoqJywgJyoudHMnKSxcbiAgICAgIF0sXG4gICAgICBleGNsdWRlOiBbXG4gICAgICAgICdub2RlX21vZHVsZXMnLFxuICAgICAgICAuLi4ocGkuZXhjbHVkZVR5cGVzY3JpcHQgPz8gW10pLFxuICAgICAgICAuLi4ocGkudHNjPy5vdXREaXIgIT0gbnVsbCAmJlxuICAgICAgICAocGkudHNjPy5yb290RGlyID09IG51bGwgfHxcbiAgICAgICAgICBwYXRoXG4gICAgICAgICAgICAucmVzb2x2ZShwaS50c2Mub3V0RGlyKVxuICAgICAgICAgICAgLnN0YXJ0c1dpdGgocGF0aC5yZXNvbHZlKHBpLnRzYy5yb290RGlyKSArIHBhdGguc2VwKSlcbiAgICAgICAgICA/IFtwYXRoLmpvaW4ocGkudHNjLm91dERpciwgJyoqJywgJyoudHMnKV1cbiAgICAgICAgICA6IFtdKSxcbiAgICAgIF0sXG4gICAgICAvLyBDaGFuZ2UgdGhlIHJlZmVyZW5jZXMgYSBsaXR0bGUuIFdlIHdyaXRlICdvcmlnaW5hbHBhdGgnIHRvIHRoZVxuICAgICAgLy8gZmlsZSB1bmRlciB0aGUgJ3BhdGgnIGtleSwgd2hpY2ggaXMgdGhlIHNhbWUgYXMgd2hhdCB0aGVcbiAgICAgIC8vIFR5cGVTY3JpcHQgY29tcGlsZXIgZG9lcy4gTWFrZSBpdCByZWxhdGl2ZSBzbyB0aGF0IHRoZSBmaWxlcyBhcmVcbiAgICAgIC8vIG1vdmFibGUuIE5vdCBzdHJpY3RseSByZXF1aXJlZCBidXQgbG9va3MgYmV0dGVyLlxuICAgICAgcmVmZXJlbmNlczogcmVmZXJlbmNlcz8ubWFwKChwKSA9PiAoeyBwYXRoOiBwIH0pKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBgdHNjb25maWcuanNvbmAgZmlsZSB0byBpbXByb3ZlIHRoZSBJREUgZXhwZXJpZW5jZS5cbiAgICpcbiAgICogQHJldHVybiB0aGUgZnVsbHkgcXVhbGlmaWVkIHBhdGggdG8gdGhlIGB0c2NvbmZpZy5qc29uYCBmaWxlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHdyaXRlVHlwZVNjcmlwdENvbmZpZygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBjb21tZW50S2V5ID0gJ19nZW5lcmF0ZWRfYnlfanNpaV8nO1xuICAgIGNvbnN0IGNvbW1lbnRWYWx1ZSA9XG4gICAgICAnR2VuZXJhdGVkIGJ5IGpzaWkgLSBzYWZlIHRvIGRlbGV0ZSwgYW5kIGlkZWFsbHkgc2hvdWxkIGJlIGluIC5naXRpZ25vcmUnO1xuXG4gICAgKHRoaXMudHlwZXNjcmlwdENvbmZpZyBhcyBhbnkpW2NvbW1lbnRLZXldID0gY29tbWVudFZhbHVlO1xuXG4gICAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHModGhpcy5jb25maWdQYXRoKSkge1xuICAgICAgY29uc3QgY3VycmVudENvbmZpZyA9IGF3YWl0IGZzLnJlYWRKc29uKHRoaXMuY29uZmlnUGF0aCk7XG4gICAgICBpZiAoIShjb21tZW50S2V5IGluIGN1cnJlbnRDb25maWcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQSAnJHt0aGlzLmNvbmZpZ1BhdGh9JyBmaWxlIHRoYXQgd2FzIG5vdCBnZW5lcmF0ZWQgYnkganNpaSBpcyBpbiAke3RoaXMub3B0aW9ucy5wcm9qZWN0SW5mby5wcm9qZWN0Um9vdH0uIEFib3J0aW5nIGluc3RlYWQgb2Ygb3ZlcndyaXRpbmcuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvdXRwdXRDb25maWcgPSB7XG4gICAgICAuLi50aGlzLnR5cGVzY3JpcHRDb25maWcsXG4gICAgICBjb21waWxlck9wdGlvbnM6IHtcbiAgICAgICAgLi4udGhpcy50eXBlc2NyaXB0Q29uZmlnPy5jb21waWxlck9wdGlvbnMsXG4gICAgICAgIGxpYjogdGhpcy50eXBlc2NyaXB0Q29uZmlnPy5jb21waWxlck9wdGlvbnM/LmxpYj8ubWFwKChsaWIpID0+XG4gICAgICAgICAgLy8gRHJvcCB0aGUgXCJsaWIuXCIgcHJlZml4IGFuZCBcIi5kLnRzXCIgc3VmZml4IGJlZm9yZSB3cml0aW5nIHVwIHRoZSB0c2NvbmZpZy5qc29uIGZpbGVcbiAgICAgICAgICBsaWIuc2xpY2UoNCwgbGliLmxlbmd0aCAtIDUpLFxuICAgICAgICApLFxuICAgICAgICAvLyBSZS13cml0ZSB0aGUgbW9kdWxlLCB0YXJnZXRzICYganN4IHRvIGJlIHRoZSBKU09OIGZvcm1hdCBpbnN0ZWFkIG9mIFByb2dyYW1tYXRpYyBBUElcbiAgICAgICAgbW9kdWxlOiAodGhpcy50eXBlc2NyaXB0Q29uZmlnPy5jb21waWxlck9wdGlvbnM/Lm1vZHVsZSAmJlxuICAgICAgICAgIHRzLk1vZHVsZUtpbmRbdGhpcy50eXBlc2NyaXB0Q29uZmlnLmNvbXBpbGVyT3B0aW9ucy5tb2R1bGVdKSBhcyBhbnksXG4gICAgICAgIG5ld0xpbmU6IG5ld0xpbmVGb3JUc2NvbmZpZ0pzb24oXG4gICAgICAgICAgdGhpcy50eXBlc2NyaXB0Q29uZmlnPy5jb21waWxlck9wdGlvbnMubmV3TGluZSxcbiAgICAgICAgKSxcbiAgICAgICAgdGFyZ2V0OiAodGhpcy50eXBlc2NyaXB0Q29uZmlnPy5jb21waWxlck9wdGlvbnM/LnRhcmdldCAmJlxuICAgICAgICAgIHRzLlNjcmlwdFRhcmdldFt0aGlzLnR5cGVzY3JpcHRDb25maWcuY29tcGlsZXJPcHRpb25zLnRhcmdldF0pIGFzIGFueSxcbiAgICAgICAganN4OiAodGhpcy50eXBlc2NyaXB0Q29uZmlnPy5jb21waWxlck9wdGlvbnM/LmpzeCAmJlxuICAgICAgICAgIENhc2Uuc25ha2UoXG4gICAgICAgICAgICB0cy5Kc3hFbWl0W3RoaXMudHlwZXNjcmlwdENvbmZpZy5jb21waWxlck9wdGlvbnMuanN4XSxcbiAgICAgICAgICApKSBhcyBhbnksXG4gICAgICB9LFxuICAgIH07XG5cbiAgICBMT0cuZGVidWcoYENyZWF0aW5nIG9yIHVwZGF0aW5nICR7Y29sb3JzLmJsdWUodGhpcy5jb25maWdQYXRoKX1gKTtcbiAgICBhd2FpdCBmcy53cml0ZUpzb24odGhpcy5jb25maWdQYXRoLCBvdXRwdXRDb25maWcsIHtcbiAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICBzcGFjZXM6IDIsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGFubm95aW5nIC0gdGhlIHZhbHVlcyBleHBlY3RlZCBpbiB0aGUgdHNjb25maWcuanNvbiBmaWxlIGFyZSBub3RcbiAgICAgKiB0aGUgc2FtZSBhcyB0aGUgZW51bSBjb25zdGFudCBuYW1lcywgb3IgdGhlaXIgdmFsdWVzLiBTbyB3ZSBuZWVkIHRoaXNcbiAgICAgKiBmdW5jdGlvbiB0byBtYXAgdGhlIFwiY29tcGlsZXIgQVBJIHZlcnNpb25cIiB0byB0aGUgXCJ0c2NvbmZpZy5qc29uIHZlcnNpb25cIlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0xpbmUgdGhlIGNvbXBpbGVyIGZvcm0gb2YgdGhlIG5ldyBsaW5lIGNvbmZpZ3VyYXRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhlIHJlcXVpdmFsZW50IHZhbHVlIHRvIHB1dCBpbiB0c2NvbmZpZy5qc29uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmV3TGluZUZvclRzY29uZmlnSnNvbihuZXdMaW5lOiB0cy5OZXdMaW5lS2luZCB8IHVuZGVmaW5lZCkge1xuICAgICAgc3dpdGNoIChuZXdMaW5lKSB7XG4gICAgICAgIGNhc2UgdHMuTmV3TGluZUtpbmQuQ2FycmlhZ2VSZXR1cm5MaW5lRmVlZDpcbiAgICAgICAgICByZXR1cm4gJ2NybGYnO1xuICAgICAgICBjYXNlIHRzLk5ld0xpbmVLaW5kLkxpbmVGZWVkOlxuICAgICAgICAgIHJldHVybiAnbGYnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYWxsIGRlcGVuZGVuY2llcyB0aGF0IGxvb2sgbGlrZSBUeXBlU2NyaXB0IHByb2plY3RzLlxuICAgKlxuICAgKiBFbnVtZXJhdGUgYWxsIGRlcGVuZGVuY2llcywgaWYgdGhleSBoYXZlIGEgdHNjb25maWcuanNvbiBmaWxlIHdpdGhcbiAgICogXCJjb21wb3NpdGU6IHRydWVcIiB3ZSBjb25zaWRlciB0aGVtIHByb2plY3QgcmVmZXJlbmNlcy5cbiAgICpcbiAgICogKE5vdGU6IFR5cGVTY3JpcHQgc2VlbXMgdG8gb25seSBjb3JyZWN0bHkgZmluZCB0cmFuc2l0aXZlIHByb2plY3QgcmVmZXJlbmNlc1xuICAgKiBpZiB0aGVyZSdzIGFuIFwiaW5kZXhcIiB0c2NvbmZpZy5qc29uIG9mIGFsbCBwcm9qZWN0cyBzb21ld2hlcmUgdXAgdGhlIGRpcmVjdG9yeVxuICAgKiB0cmVlKVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBmaW5kUHJvamVjdFJlZmVyZW5jZXMoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IHBrZyA9IHRoaXMub3B0aW9ucy5wcm9qZWN0SW5mby5wYWNrYWdlSnNvbjtcblxuICAgIGNvbnN0IHJldCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG5cbiAgICBjb25zdCBkZXBlbmRlbmN5TmFtZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3lNYXAgb2YgW1xuICAgICAgcGtnLmRlcGVuZGVuY2llcyxcbiAgICAgIHBrZy5kZXZEZXBlbmRlbmNpZXMsXG4gICAgICBwa2cucGVlckRlcGVuZGVuY2llcyxcbiAgICBdKSB7XG4gICAgICBpZiAoZGVwZW5kZW5jeU1hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmtleXMoZGVwZW5kZW5jeU1hcCkuZm9yRWFjaChcbiAgICAgICAgZGVwZW5kZW5jeU5hbWVzLmFkZC5iaW5kKGRlcGVuZGVuY3lOYW1lcyksXG4gICAgICApO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgdHNjb25maWdGaWxlIG9mIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgQXJyYXkuZnJvbShkZXBlbmRlbmN5TmFtZXMpLm1hcCgoZGVwTmFtZSkgPT5cbiAgICAgICAgdGhpcy5maW5kTW9ub3JlcG9QZWVyVHNjb25maWcoZGVwTmFtZSksXG4gICAgICApLFxuICAgICkpIHtcbiAgICAgIGlmICghdHNjb25maWdGaWxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGNvbmZpZzogdHNjb25maWcgfSA9IHRzLnJlYWRDb25maWdGaWxlKFxuICAgICAgICB0c2NvbmZpZ0ZpbGUsXG4gICAgICAgIHRzLnN5cy5yZWFkRmlsZSxcbiAgICAgICk7XG5cbiAgICAgIC8vIEFkZCByZWZlcmVuY2VzIHRvIGFueSBUeXBlU2NyaXB0IHBhY2thZ2Ugd2UgZmluZCB0aGF0IGlzICdjb21wb3NpdGUnIGVuYWJsZWQuXG4gICAgICAvLyBNYWtlIGl0IHJlbGF0aXZlLlxuICAgICAgaWYgKHRzY29uZmlnLmNvbXBpbGVyT3B0aW9ucz8uY29tcG9zaXRlKSB7XG4gICAgICAgIHJldC5wdXNoKFxuICAgICAgICAgIHBhdGgucmVsYXRpdmUoXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucHJvamVjdEluZm8ucHJvamVjdFJvb3QsXG4gICAgICAgICAgICBwYXRoLmRpcm5hbWUodHNjb25maWdGaWxlKSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90IGEgY29tcG9zaXRlIHBhY2thZ2UtLWlmIHRoaXMgcGFja2FnZSBpcyBpbiBhIG5vZGVfbW9kdWxlcyBkaXJlY3RvcnksIHRoYXQgaXMgbW9zdFxuICAgICAgICAvLyBsaWtlbHkgY29ycmVjdCwgb3RoZXJ3aXNlIGl0IGlzIG1vc3QgbGlrZWx5IGFuIGVycm9yIChoZXVyaXN0aWMgaGVyZSwgSSBkb24ndCBrbm93IGhvdyB0b1xuICAgICAgICAvLyBwcm9wZXJseSBjaGVjayB0aGlzKS5cbiAgICAgICAgaWYgKHRzY29uZmlnRmlsZS5pbmNsdWRlcygnbm9kZV9tb2R1bGVzJykpIHtcbiAgICAgICAgICBMT0cud2FybihcbiAgICAgICAgICAgICclczogbm90IGEgY29tcG9zaXRlIFR5cGVTY3JpcHQgcGFja2FnZSwgYnV0IGl0IHByb2JhYmx5IHNob3VsZCBiZScsXG4gICAgICAgICAgICBwYXRoLmRpcm5hbWUodHNjb25maWdGaWxlKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHNvdXJjZSBmaWxlcyB1c2luZyB0aGUgc2FtZSBtZWNoYW5pc20gdGhhdCB0aGUgVHlwZVNjcmlwdCBjb21waWxlciBpdHNlbGYgdXNlcy5cbiAgICpcbiAgICogUmVzcGVjdHMgaW5jbHVkZXMvZXhjbHVkZXMvZXRjLlxuICAgKlxuICAgKiBUaGlzIG1ha2VzIGl0IHNvIHRoYXQgcnVubmluZyAndHNjJyBhbmQgcnVubmluZyAnanNpaScgaGFzIHRoZSBzYW1lIGJlaGF2aW9yLlxuICAgKi9cbiAgcHJpdmF0ZSBkZXRlcm1pbmVTb3VyY2VzKGZpbGVzOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCByZXQgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuXG4gICAgaWYgKGZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldC5wdXNoKC4uLmZpbGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGFyc2VDb25maWdIb3N0ID0gcGFyc2VDb25maWdIb3N0RnJvbUNvbXBpbGVySG9zdChcbiAgICAgICAgdGhpcy5jb21waWxlckhvc3QsXG4gICAgICApO1xuICAgICAgY29uc3QgcGFyc2VkID0gdHMucGFyc2VKc29uQ29uZmlnRmlsZUNvbnRlbnQoXG4gICAgICAgIHRoaXMudHlwZXNjcmlwdENvbmZpZyxcbiAgICAgICAgcGFyc2VDb25maWdIb3N0LFxuICAgICAgICB0aGlzLm9wdGlvbnMucHJvamVjdEluZm8ucHJvamVjdFJvb3QsXG4gICAgICApO1xuICAgICAgcmV0LnB1c2goLi4ucGFyc2VkLmZpbGVOYW1lcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIHRoZSBnaXZlbiBkZXBlbmRlbmN5IG5hbWUgZnJvbSB0aGUgY3VycmVudCBwYWNrYWdlLCBhbmQgZmluZCB0aGUgYXNzb2NpYXRlZCB0c2NvbmZpZy5qc29uIGxvY2F0aW9uXG4gICAqXG4gICAqIEJlY2F1c2Ugd2UgaGF2ZSB0aGUgZm9sbG93aW5nIHBvdGVudGlhbCBkaXJlY3RvcnkgbGF5b3V0OlxuICAgKlxuICAgKiAgIHBhY2thZ2Uvbm9kZV9tb2R1bGVzL3NvbWVfZGVwZW5kZW5jeVxuICAgKiAgIHBhY2thZ2UvdHNjb25maWcuanNvblxuICAgKlxuICAgKiBXZSByZXNvbHZlIHN5bWxpbmtzIGFuZCBvbmx5IGZpbmQgYSBcIlR5cGVTY3JpcHRcIiBkZXBlbmRlbmN5IGlmIGRvZXNuJ3QgaGF2ZSAnbm9kZV9tb2R1bGVzJyBpblxuICAgKiB0aGUgcGF0aCBhZnRlciByZXNvbHZpbmcgc3ltbGlua3MgKGkuZS4sIGlmIGl0J3MgYSBwZWVyIHBhY2thZ2UgaW4gdGhlIHNhbWUgbW9ub3JlcG8pLlxuICAgKlxuICAgKiBSZXR1cm5zIHVuZGVmaW5lZCBpZiBubyBzdWNoIHRzY29uZmlnIGNvdWxkIGJlIGZvdW5kLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBmaW5kTW9ub3JlcG9QZWVyVHNjb25maWcoXG4gICAgZGVwTmFtZTogc3RyaW5nLFxuICApOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIGNvbnN0IHBhdGhzID0gbm9kZUpzQ29tcGF0aWJsZVNlYXJjaFBhdGhzKFxuICAgICAgdGhpcy5vcHRpb25zLnByb2plY3RJbmZvLnByb2plY3RSb290LFxuICAgICk7XG5cbiAgICBsZXQgZGVwO1xuICAgIHRyeSB7XG4gICAgICBkZXAgPSByZXF1aXJlLnJlc29sdmUoYCR7ZGVwTmFtZX0vdHNjb25maWcuanNvbmAsIHsgcGF0aHMgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBQYWNrYWdlIGRvZXMgbm90IGhhdmUgYSB0c2NvbmZpZy5qc29uXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFJlc29sdmUgc3ltbGlua3MsIHRvIGNoZWNrIGlmIHRoaXMgaXMgYSBtb25vcmVwbyBwZWVyXG4gICAgY29uc3QgZGVwZW5kZW5jeVJlYWxQYXRoID0gYXdhaXQgZnMucmVhbHBhdGgoZGVwKTtcbiAgICBpZiAoZGVwZW5kZW5jeVJlYWxQYXRoLnNwbGl0KHBhdGguc2VwKS5pbmNsdWRlcygnbm9kZV9tb2R1bGVzJykpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlcGVuZGVuY3lSZWFsUGF0aDtcbiAgfVxuXG4gIHByaXZhdGUgZGlhZ3NIYXZlQWJvcnRhYmxlRXJyb3JzKGRpYWdzOiByZWFkb25seSB0cy5EaWFnbm9zdGljW10pIHtcbiAgICByZXR1cm4gZGlhZ3Muc29tZShcbiAgICAgIChkKSA9PlxuICAgICAgICBkLmNhdGVnb3J5ID09PSB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuRXJyb3IgfHxcbiAgICAgICAgKHRoaXMub3B0aW9ucy5mYWlsT25XYXJuaW5ncyAmJlxuICAgICAgICAgIGQuY2F0ZWdvcnkgPT09IHRzLkRpYWdub3N0aWNDYXRlZ29yeS5XYXJuaW5nKSxcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgV2F0Y2ggaW4gbm9uLWJsb2NraW5nIG1vZGUuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTm9uQmxvY2tpbmdXYXRjaE9wdGlvbnMge1xuICAvKipcbiAgICogU2lnbmFscyBub24tYmxvY2tpbmcgZXhlY3V0aW9uXG4gICAqL1xuICByZWFkb25seSBub25CbG9ja2luZzogdHJ1ZTtcblxuICAvKipcbiAgICogQ29uZmlndXJlcyB0aGUgZGlhZ25vc3RpY3MgcmVwb3J0ZXJcbiAgICovXG4gIHJlYWRvbmx5IHJlcG9ydERpYWdub3N0aWNzOiB0cy5EaWFnbm9zdGljUmVwb3J0ZXI7XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgdGhlIHdhdGNoIHN0YXR1cyByZXBvcnRlclxuICAgKi9cbiAgcmVhZG9ubHkgcmVwb3J0V2F0Y2hTdGF0dXM6IHRzLldhdGNoU3RhdHVzUmVwb3J0ZXI7XG5cbiAgLyoqXG4gICAqIFRoaXMgaG9vayBnZXRzIGludm9rZWQgd2hlbiBhIGNvbXBpbGF0aW9uIGN5Y2xlIChjb21wbGV0ZSB3aXRoIEFzc2VtYmxlciBleGVjdXRpb24pIGNvbXBsZXRlcy5cbiAgICovXG4gIHJlYWRvbmx5IGNvbXBpbGF0aW9uQ29tcGxldGU6IChcbiAgICBlbWl0UmVzdWx0OiB0cy5FbWl0UmVzdWx0LFxuICApID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+O1xufVxuXG5mdW5jdGlvbiBfcGF0aE9mTGlicmFyaWVzKFxuICBob3N0OiB0cy5Db21waWxlckhvc3QgfCB0cy5XYXRjaENvbXBpbGVySG9zdDxhbnk+LFxuKTogc3RyaW5nW10ge1xuICBpZiAoIUJBU0VfQ09NUElMRVJfT1BUSU9OUy5saWIgfHwgQkFTRV9DT01QSUxFUl9PUFRJT05TLmxpYi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgbGliID0gaG9zdC5nZXREZWZhdWx0TGliTG9jYXRpb24/LigpO1xuICBpZiAoIWxpYikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDb21waWxlciBob3N0IGRvZXNuJ3QgaGF2ZSBhIGRlZmF1bHQgbGlicmFyeSBkaXJlY3RvcnkgYXZhaWxhYmxlIGZvciAke0JBU0VfQ09NUElMRVJfT1BUSU9OUy5saWIuam9pbihcbiAgICAgICAgJywgJyxcbiAgICAgICl9YCxcbiAgICApO1xuICB9XG4gIHJldHVybiBCQVNFX0NPTVBJTEVSX09QVElPTlMubGliLm1hcCgobmFtZSkgPT4gcGF0aC5qb2luKGxpYiwgbmFtZSkpO1xufVxuXG4vKipcbiAqIFJldHVybiBhbGwgcG9zc2libGUgJ25vZGVfbW9kdWxlcycgZGlyZWN0b3JpZXMgZnJvbSBhIGdpdmVuIHN0YXJ0aW5nIGRpcmVjdG9yeS5cbiAqL1xuZnVuY3Rpb24gbm9kZUpzQ29tcGF0aWJsZVNlYXJjaFBhdGhzKGRpcjogc3RyaW5nKTogc3RyaW5nW10ge1xuICBjb25zdCByZXQgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuXG4gIGxldCBsYXN0RGlyO1xuICBkbyB7XG4gICAgcmV0LnB1c2gocGF0aC5qb2luKGRpciwgJ25vZGVfbW9kdWxlcycpKTtcbiAgICBsYXN0RGlyID0gZGlyO1xuICAgIGRpciA9IHBhdGguZGlybmFtZShkaXIpO1xuICB9IHdoaWxlIChkaXIgIT09IGxhc3REaXIpOyAvLyBwYXRoLmRpcm5hbWUoJy8nKSA9PT0gJy8nLCBhbHNvIHdvcmtzIG9uIFdpbmRvd3NcblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUNvbmZpZ0hvc3RGcm9tQ29tcGlsZXJIb3N0KFxuICBob3N0OiB0cy5Db21waWxlckhvc3QsXG4pOiB0cy5QYXJzZUNvbmZpZ0hvc3Qge1xuICAvLyBDb3BpZWQgZnJvbSB1cHN0cmVhbVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvYmxvYi85ZTA1YWJjZmQzZjhiYjNkNjc3NTE0NGVkZTgwN2RhY2VhYjJlMzIxL3NyYy9jb21waWxlci9wcm9ncmFtLnRzI0wzMTA1XG4gIHJldHVybiB7XG4gICAgZmlsZUV4aXN0czogKGYpID0+IGhvc3QuZmlsZUV4aXN0cyhmKSxcbiAgICByZWFkRGlyZWN0b3J5KHJvb3QsIGV4dGVuc2lvbnMsIGV4Y2x1ZGVzLCBpbmNsdWRlcywgZGVwdGgpIHtcbiAgICAgIGlmIChob3N0LnJlYWREaXJlY3RvcnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCInQ29tcGlsZXJIb3N0LnJlYWREaXJlY3RvcnknIG11c3QgYmUgaW1wbGVtZW50ZWQgdG8gY29ycmVjdGx5IHByb2Nlc3MgJ3Byb2plY3RSZWZlcmVuY2VzJ1wiLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhvc3QucmVhZERpcmVjdG9yeShyb290LCBleHRlbnNpb25zLCBleGNsdWRlcywgaW5jbHVkZXMsIGRlcHRoKTtcbiAgICB9LFxuICAgIHJlYWRGaWxlOiAoZikgPT4gaG9zdC5yZWFkRmlsZShmKSxcbiAgICB1c2VDYXNlU2Vuc2l0aXZlRmlsZU5hbWVzOiBob3N0LnVzZUNhc2VTZW5zaXRpdmVGaWxlTmFtZXMoKSxcbiAgICB0cmFjZTogaG9zdC50cmFjZSA/IChzKSA9PiBob3N0LnRyYWNlIShzKSA6IHVuZGVmaW5lZCxcbiAgfTtcbn1cbiJdfQ==