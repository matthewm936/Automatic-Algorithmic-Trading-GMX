"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Assembler = void 0;
const spec = require("@jsii/spec");
const Case = require("case");
const colors = require("colors/safe");
const crypto = require("crypto");
// eslint-disable-next-line @typescript-eslint/no-require-imports
const deepEqual = require("deep-equal");
const fs = require("fs-extra");
const log4js = require("log4js");
const path = require("path");
const ts = require("typescript");
const docs_1 = require("./docs");
const jsii_diagnostic_1 = require("./jsii-diagnostic");
const literate = require("./literate");
const bindings = require("./node-bindings");
const reserved_words_1 = require("./reserved-words");
const deprecated_remover_1 = require("./transforms/deprecated-remover");
const deprecation_warnings_1 = require("./transforms/deprecation-warnings");
const runtime_info_1 = require("./transforms/runtime-info");
const ts_comment_replacer_1 = require("./transforms/ts-comment-replacer");
const utils_1 = require("./transforms/utils");
const utils_2 = require("./utils");
const validator_1 = require("./validator");
const version_1 = require("./version");
const warnings_1 = require("./warnings");
// eslint-disable-next-line @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports
const sortJson = require('sort-json');
const LOG = log4js.getLogger('jsii/assembler');
/**
 * The JSII Assembler consumes a ``ts.Program`` instance and emits a JSII assembly.
 */
class Assembler {
    /**
     * @param projectInfo information about the package being assembled
     * @param program     the TypeScript program to be assembled from
     * @param stdlib      the directory where the TypeScript stdlib is rooted
     */
    constructor(projectInfo, program, stdlib, options = {}) {
        var _a;
        this.projectInfo = projectInfo;
        this.program = program;
        this.stdlib = stdlib;
        this.commentReplacer = new ts_comment_replacer_1.TsCommentReplacer();
        this._diagnostics = new Array();
        this._deferred = new Array();
        this._types = {};
        /** Map of Symbol to namespace export Symbol */
        this._submoduleMap = new Map();
        /**
         * Submodule information
         *
         * Contains submodule information for all namespaces that have been seen
         * across all assemblies (this and dependencies).
         *
         * Filtered to local submodules only at time of writing the assembly out to disk.
         */
        this._submodules = new Map();
        if (options.stripDeprecated) {
            let allowlistedDeprecations;
            if (options.stripDeprecatedAllowListFile) {
                if (!fs.existsSync(options.stripDeprecatedAllowListFile)) {
                    throw new Error(`--strip-deprecated file not found: ${options.stripDeprecatedAllowListFile}`);
                }
                allowlistedDeprecations = new Set(fs
                    .readFileSync(options.stripDeprecatedAllowListFile, 'utf8')
                    .split('\n'));
            }
            this.deprecatedRemover = new deprecated_remover_1.DeprecatedRemover(this._typeChecker, allowlistedDeprecations);
        }
        if (options.addDeprecationWarnings) {
            this.warningsInjector = new deprecation_warnings_1.DeprecationWarningsInjector(this._typeChecker);
        }
        const dts = projectInfo.types;
        let mainFile = dts.replace(/\.d\.ts(x?)$/, '.ts$1');
        // If out-of-source build was configured (tsc's outDir and rootDir), the
        // main file's path needs to be re-rooted from the outDir into the rootDir.
        const tscOutDir = program.getCompilerOptions().outDir;
        if (tscOutDir != null) {
            mainFile = path.relative(tscOutDir, mainFile);
            // rootDir may be set explicitly or not. If not, inferRootDir replicates
            // tsc's behavior of using the longest prefix of all built source files.
            const tscRootDir = (_a = program.getCompilerOptions().rootDir) !== null && _a !== void 0 ? _a : inferRootDir(program);
            if (tscRootDir != null) {
                mainFile = path.join(tscRootDir, mainFile);
            }
        }
        this.mainFile = path.resolve(projectInfo.projectRoot, mainFile);
        this.runtimeTypeInfoInjector = new runtime_info_1.RuntimeTypeInfoInjector(projectInfo.version);
    }
    get customTransformers() {
        var _a, _b, _c, _d;
        return utils_1.combinedTransformers((_b = (_a = this.deprecatedRemover) === null || _a === void 0 ? void 0 : _a.customTransformers) !== null && _b !== void 0 ? _b : {}, this.runtimeTypeInfoInjector.makeTransformers(), this.commentReplacer.makeTransformers(), (_d = (_c = this.warningsInjector) === null || _c === void 0 ? void 0 : _c.customTransformers) !== null && _d !== void 0 ? _d : {});
    }
    get _typeChecker() {
        return this.program.getTypeChecker();
    }
    /**
     * Attempt emitting the JSII assembly for the program.
     *
     * @return the result of the assembly emission.
     */
    async emit() {
        var _a, _b, _c, _d;
        this._diagnostics = [];
        if (!this.projectInfo.description) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_0001_PKG_MISSING_DESCRIPTION.createDetached());
        }
        if (!this.projectInfo.homepage) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_0002_PKG_MISSING_HOMEPAGE.createDetached());
        }
        const readme = await _loadReadme.call(this);
        if (readme == null) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_0003_MISSING_README.createDetached());
        }
        const docs = _loadDocs.call(this);
        this._types = {};
        this._deferred = [];
        const visitPromises = new Array();
        const sourceFile = this.program.getSourceFile(this.mainFile);
        if (sourceFile == null) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_0004_COULD_NOT_FIND_ENTRYPOINT.createDetached(this.mainFile));
        }
        else {
            await this._registerDependenciesNamespaces(sourceFile);
            if (LOG.isTraceEnabled()) {
                LOG.trace(`Processing source file: ${colors.blue(path.relative(this.projectInfo.projectRoot, sourceFile.fileName))}`);
            }
            const symbol = this._typeChecker.getSymbolAtLocation(sourceFile);
            if (symbol) {
                const moduleExports = this._typeChecker.getExportsOfModule(symbol);
                await Promise.all(moduleExports.map((item) => this._registerNamespaces(item, this.projectInfo.projectRoot)));
                for (const node of moduleExports) {
                    visitPromises.push(this._visitNode(node.declarations[0], new EmitContext([], this.projectInfo.stability)));
                }
            }
        }
        await Promise.all(visitPromises);
        this.callDeferredsInOrder();
        // Skip emitting if any diagnostic message is an error
        if (this._diagnostics.find((diag) => diag.category === ts.DiagnosticCategory.Error) != null) {
            LOG.debug('Skipping emit due to errors.');
            // Clearing ``this._types`` to allow contents to be garbage-collected.
            delete this._types;
            try {
                return { diagnostics: this._diagnostics, emitSkipped: true };
            }
            finally {
                // Clearing ``this._diagnostics`` to allow contents to be garbage-collected.
                delete this._diagnostics;
            }
        }
        const jsiiVersion = this.projectInfo.jsiiVersionFormat === 'short' ? version_1.SHORT_VERSION : version_1.VERSION;
        const assembly = {
            schema: spec.SchemaVersion.LATEST,
            name: this.projectInfo.name,
            version: this.projectInfo.version,
            description: (_a = this.projectInfo.description) !== null && _a !== void 0 ? _a : this.projectInfo.name,
            license: this.projectInfo.license,
            keywords: this.projectInfo.keywords,
            homepage: (_b = this.projectInfo.homepage) !== null && _b !== void 0 ? _b : this.projectInfo.repository.url,
            author: this.projectInfo.author,
            contributors: this.projectInfo.contributors && [
                ...this.projectInfo.contributors,
            ],
            repository: this.projectInfo.repository,
            dependencies: noEmptyDict({
                ...this.projectInfo.dependencies,
                ...this.projectInfo.peerDependencies,
            }),
            dependencyClosure: noEmptyDict(toDependencyClosure(this.projectInfo.dependencyClosure)),
            bundled: this.projectInfo.bundleDependencies,
            types: this._types,
            submodules: noEmptyDict(toSubmoduleDeclarations(this.mySubmodules())),
            targets: this.projectInfo.targets,
            metadata: this.projectInfo.metadata,
            docs,
            readme,
            jsiiVersion,
            bin: this.projectInfo.bin,
            fingerprint: '<TBD>',
        };
        if (this.deprecatedRemover) {
            this._diagnostics.push(...this.deprecatedRemover.removeFrom(assembly));
        }
        if (this.warningsInjector) {
            const jsiiMetadata = {
                ...((_d = (_c = assembly.metadata) === null || _c === void 0 ? void 0 : _c.jsii) !== null && _d !== void 0 ? _d : {}),
                ...{ compiledWithDeprecationWarnings: true },
            };
            if (assembly.metadata) {
                assembly.metadata.jsii = jsiiMetadata;
            }
            else {
                assembly.metadata = { jsii: jsiiMetadata };
            }
            this.warningsInjector.process(assembly, this.projectInfo);
        }
        const validator = new validator_1.Validator(this.projectInfo, assembly);
        const validationResult = await validator.emit();
        if (!validationResult.emitSkipped) {
            const assemblyPath = path.join(this.projectInfo.projectRoot, '.jsii');
            LOG.trace(`Emitting assembly: ${colors.blue(assemblyPath)}`);
            await fs.writeJson(assemblyPath, _fingerprint(assembly), {
                encoding: 'utf8',
                spaces: 2,
            });
        }
        try {
            return {
                diagnostics: [...this._diagnostics, ...validationResult.diagnostics],
                emitSkipped: validationResult.emitSkipped,
            };
        }
        finally {
            // Clearing ``this._types`` to allow contents to be garbage-collected.
            delete this._types;
            // Clearing ``this._diagnostics`` to allow contents to be garbage-collected.
            delete this._diagnostics;
        }
        async function _loadReadme() {
            // Search for `README.md` in a case-insensitive way
            const fileName = (await fs.readdir(this.projectInfo.projectRoot)).find((file) => file.toLocaleLowerCase() === 'readme.md');
            if (fileName == null) {
                return undefined;
            }
            const readmePath = path.join(this.projectInfo.projectRoot, fileName);
            const renderedLines = await literate.includeAndRenderExamples(await literate.loadFromFile(readmePath), literate.fileSystemLoader(this.projectInfo.projectRoot));
            return { markdown: renderedLines.join('\n') };
        }
        function _loadDocs() {
            if (!this.projectInfo.stability && !this.projectInfo.deprecated) {
                return undefined;
            }
            const deprecated = this.projectInfo.deprecated;
            const stability = this.projectInfo.stability;
            return { deprecated, stability };
        }
    }
    /**
     * Defer a callback until a (set of) types are available
     *
     * This is a helper function around _defer() which encapsulates the _dereference
     * action (which is basically the majority use case for _defer anyway).
     *
     * Will not invoke the function with any 'undefined's; an error will already have been emitted in
     * that case anyway.
     *
     * @param fqn FQN of the current type (the type that has a dependency on baseTypes)
     * @param baseTypes Array of type references to be looked up
     * @param referencingNode Node to report a diagnostic on if we fail to look up a t ype
     * @param cb Callback to be invoked with the Types corresponding to the TypeReferences in baseTypes
     */
    _deferUntilTypesAvailable(fqn, baseTypes, referencingNode, cb) {
        // We can do this one eagerly
        if (baseTypes.length === 0) {
            cb();
            return;
        }
        const baseFqns = baseTypes.map((bt) => typeof bt === 'string' ? bt : bt.fqn);
        this._defer(fqn, baseFqns, () => {
            const resolved = baseFqns
                .map((x) => this._dereference(x, referencingNode))
                .filter((x) => x !== undefined);
            if (resolved.length > 0) {
                cb(...resolved);
            }
        });
    }
    /**
     * Defer checks for after the program has been entirely processed; useful for verifying type references that may not
     * have been discovered yet, and verifying properties about them.
     *
     * The callback is guaranteed to be executed only after all deferreds for all types in 'dependedFqns' have
     * been executed.
     *
     * @param fqn FQN of the current type.
     * @param dependedFqns List of FQNs of types this callback depends on. All deferreds for all
     * @param cb the function to be called in a deferred way. It will be bound with ``this``, so it can depend on using
     *           ``this``.
     */
    _defer(fqn, dependedFqns, cb) {
        this._deferred.push({ fqn, dependedFqns, cb: cb.bind(this) });
    }
    /**
     * Obtains the ``spec.Type`` for a given ``spec.NamedTypeReference``.
     *
     * @param ref the type reference to be de-referenced
     *
     * @returns the de-referenced type, if it was found, otherwise ``undefined``.
     */
    _dereference(ref, referencingNode) {
        var _a;
        if (typeof ref !== 'string') {
            ref = ref.fqn;
        }
        const [assm] = ref.split('.');
        let type;
        if (assm === this.projectInfo.name) {
            type = this._types[ref];
        }
        else {
            const assembly = this.projectInfo.dependencyClosure.find((dep) => dep.name === assm);
            type = (_a = assembly === null || assembly === void 0 ? void 0 : assembly.types) === null || _a === void 0 ? void 0 : _a[ref];
            // since we are exposing a type of this assembly in this module's public API,
            // we expect it to appear as a peer dependency instead of a normal dependency.
            if (assembly) {
                if (!(assembly.name in this.projectInfo.peerDependencies)) {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_0005_MISSING_PEER_DEPENDENCY.create(referencingNode, // Cheating here for now, until the referencingNode can be made required
                    assembly.name, ref));
                }
            }
        }
        if (!type) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_9002_UNRESOLVEABLE_TYPE.create(referencingNode, // Cheating here for now, until the referencingNode can be made required
            ref));
        }
        return type;
    }
    /**
     * Compute the JSII fully qualified name corresponding to a ``ts.Type`` instance. If for any reason a name cannot be
     * computed for the type, a marker is returned instead, and an ``ts.DiagnosticCategory.Error`` diagnostic is
     * inserted in the assembler context.
     *
     * @param type the type for which a JSII fully qualified name is needed.
     * @param typeAnnotationNode the type annotation for which this FQN is generated. This is used for attaching the error
     *                           marker. When there is no explicit type annotation (e.g: inferred method return type), the
     *                           preferred substitute is the "type-inferred" element's name.
     * @param typeUse the reason why this type was resolved (e.g: "return type")
     * @param isThisType whether this type was specified or inferred as "this" or not
     *
     * @returns the FQN of the type, or some "unknown" marker.
     */
    async _getFQN(type, typeAnnotationNode, typeUse, isThisType) {
        const singleValuedEnum = isSingleValuedEnum(type, this._typeChecker);
        const tsFullName = this._typeChecker.getFullyQualifiedName(type.symbol);
        const tsName = singleValuedEnum
            ? // If it's a single-valued enum, we need to remove the last qualifier to get back to the enum.
                tsFullName.replace(/\.[^.]+$/, '')
            : tsFullName;
        let typeDeclaration = singleValuedEnum
            ? // If it's a single-valued enum, we need to move to the parent to have the enum declaration
                type.symbol.valueDeclaration.parent
            : type.symbol.valueDeclaration;
        if (!typeDeclaration && type.symbol.declarations.length > 0) {
            typeDeclaration = type.symbol.declarations[0];
        }
        // Set to true to prevent further adding of Error diagnostics for known-bad reference
        let hasError = false;
        if (this._isPrivateOrInternal(type.symbol)) {
            // Check if this type is "this" (explicit or inferred method return type).
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3001_EXPOSED_INTERNAL_TYPE.create(typeAnnotationNode, type.symbol, isThisType, typeUse).addRelatedInformation(typeDeclaration, `The referenced type is declared here`));
            hasError = true;
        }
        const groups = /^"([^"]+)"\.(.*)$/.exec(tsName);
        if (!groups) {
            if (!hasError) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3001_EXPOSED_INTERNAL_TYPE.create(typeAnnotationNode, type.symbol, isThisType, typeUse).addRelatedInformation(typeDeclaration, `The referenced type is declared here`));
                hasError = true;
            }
            return tsName;
        }
        const [, modulePath, typeName] = groups;
        const pkg = await findPackageInfo(modulePath);
        if (!pkg) {
            if (!hasError) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_9003_UNRESOLVEABLE_MODULE.create(typeAnnotationNode, modulePath).addRelatedInformation(typeDeclaration, `The referenced type is declared here`));
                hasError = true;
            }
            return `unknown.${typeName}`;
        }
        const submodule = this._submoduleMap.get(type.symbol);
        if (submodule != null) {
            const submoduleNs = this._submodules.get(submodule).fqnResolutionPrefix;
            return `${submoduleNs}.${typeName}`;
        }
        const fqn = `${pkg.name}.${typeName}`;
        if (pkg.name !== this.projectInfo.name &&
            !this._dereference({ fqn }, type.symbol.valueDeclaration)) {
            if (!hasError) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3002_USE_OF_UNEXPORTED_FOREIGN_TYPE.create(typeAnnotationNode, fqn, typeUse, pkg).addRelatedInformation(typeDeclaration, `The referenced type is declared here`));
                hasError = true;
            }
        }
        return fqn;
    }
    /**
     * For all modules in the dependency closure, crawl their exports to register
     * the submodules they contain.
     *
     * @param entryPoint the main source file for the currently compiled module.
     */
    async _registerDependenciesNamespaces(entryPoint) {
        for (const assm of this.projectInfo.dependencyClosure) {
            const resolved = ts.resolveModuleName(assm.name, entryPoint.fileName, this.program.getCompilerOptions(), ts.sys);
            // If we can't resolve the module name, simply ignore it (TypeScript compilation likely failed)
            if (resolved.resolvedModule == null) {
                continue;
            }
            const source = this.program.getSourceFile(resolved.resolvedModule.resolvedFileName);
            const depMod = source && this._typeChecker.getSymbolAtLocation(source);
            // It's unlikely, but if we can't get the SourceFile here, ignore it (TypeScript compilation probably failed)
            if (depMod == null) {
                continue;
            }
            const depRoot = packageRoot(resolved.resolvedModule.resolvedFileName);
            for (const symbol of this._typeChecker.getExportsOfModule(depMod)) {
                // eslint-disable-next-line no-await-in-loop
                await this._registerNamespaces(symbol, depRoot);
            }
        }
        function packageRoot(file) {
            const parent = path.dirname(file);
            if (path.basename(parent) === 'node_modules' || parent === file) {
                return file;
            }
            return packageRoot(parent);
        }
    }
    async _registerNamespaces(symbol, packageRoot) {
        var _a;
        const declaration = (_a = symbol.valueDeclaration) !== null && _a !== void 0 ? _a : symbol.declarations[0];
        if (declaration == null) {
            // Nothing to do here...
            return;
        }
        if (ts.isModuleDeclaration(declaration)) {
            // Looks like:
            //
            //    export some_namespace {
            //       ...
            //    }
            //
            // No way to configure targets
            const { fqn, fqnResolutionPrefix } = await qualifiedNameOf.call(this, symbol, true);
            this._submodules.set(symbol, {
                fqn,
                fqnResolutionPrefix,
                locationInModule: this.declarationLocation(declaration),
            });
            await this._addToSubmodule(symbol, symbol, packageRoot);
            return;
        }
        if (!ts.isNamespaceExport(declaration)) {
            // Nothing to do here...
            return;
        }
        const moduleSpecifier = declaration.parent.moduleSpecifier;
        if (moduleSpecifier == null || !ts.isStringLiteral(moduleSpecifier)) {
            // There is a grammar error here, so we'll let tsc report this for us.
            return;
        }
        const resolution = ts.resolveModuleName(moduleSpecifier.text, declaration.getSourceFile().fileName, this.program.getCompilerOptions(), ts.sys);
        if (resolution.resolvedModule == null) {
            // Unresolvable module... We'll let tsc report this for us.
            return;
        }
        // Normalize the path so the correct separator is in use (Looking at you, Windows)
        resolution.resolvedModule.resolvedFileName = path.normalize(resolution.resolvedModule.resolvedFileName);
        if (
        // We're not looking into a dependency's namespace exports, and the resolution says it's external
        (packageRoot === this.projectInfo.projectRoot &&
            resolution.resolvedModule.isExternalLibraryImport) ||
            // Or the module resolves outside of the current dependency's tree entirely
            !resolution.resolvedModule.resolvedFileName.startsWith(packageRoot) ||
            // Or the module is under one the current dependency's node_modules subtree
            resolution.resolvedModule.resolvedFileName
                .split(path.sep)
                .filter((entry) => entry === 'node_modules').length !==
                packageRoot.split(path.sep).filter((entry) => entry === 'node_modules')
                    .length) {
            // External re-exports are "pure-javascript" sugar; they need not be
            // represented in the jsii Assembly since the types in there will be
            // resolved through dependencies.
            return;
        }
        const sourceFile = this.program.getSourceFile(resolution.resolvedModule.resolvedFileName);
        const sourceModule = this._typeChecker.getSymbolAtLocation(sourceFile);
        // If there's no module, it's a syntax error, and tsc will have reported it for us.
        if (sourceModule) {
            if (symbol.name !== Case.camel(symbol.name) &&
                symbol.name !== Case.snake(symbol.name)) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_8004_SUBMOULE_NAME_CASING.create(declaration.name, symbol.name));
            }
            const { fqn, fqnResolutionPrefix } = await qualifiedNameOf.call(this, symbol);
            const targets = await loadSubmoduleTargetConfig(sourceFile.fileName);
            const readme = await loadSubmoduleReadMe(sourceFile.fileName);
            this._submodules.set(symbol, {
                fqn,
                fqnResolutionPrefix,
                targets,
                readme,
                locationInModule: this.declarationLocation(declaration),
            });
            await this._addToSubmodule(symbol, sourceModule, packageRoot);
        }
        async function qualifiedNameOf(sym, inlineNamespace = false) {
            var _a, _b, _c, _d;
            if (this._submoduleMap.has(sym)) {
                const parent = this._submodules.get(this._submoduleMap.get(sym));
                const fqn = `${parent.fqn}.${sym.name}`;
                return {
                    fqn,
                    fqnResolutionPrefix: inlineNamespace
                        ? parent.fqnResolutionPrefix
                        : fqn,
                };
            }
            const symbolLocation = (_c = (_b = (_a = sym
                .getDeclarations()) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.getSourceFile()) === null || _c === void 0 ? void 0 : _c.fileName;
            const pkgInfo = symbolLocation && (await findPackageInfo(symbolLocation));
            const assemblyName = (_d = pkgInfo === null || pkgInfo === void 0 ? void 0 : pkgInfo.name) !== null && _d !== void 0 ? _d : this.projectInfo.name;
            const fqn = `${assemblyName}.${sym.name}`;
            return {
                fqn,
                fqnResolutionPrefix: inlineNamespace ? this.projectInfo.name : fqn,
            };
        }
        async function loadSubmoduleTargetConfig(submoduleMain) {
            const jsiirc = path.resolve(submoduleMain, '..', '.jsiirc.json');
            if (!(await fs.pathExists(jsiirc))) {
                return undefined;
            }
            const data = await fs.readJson(jsiirc);
            return data.targets;
        }
        /**
         * Load the README for the given submodule
         *
         * If the submodule is loaded from a complete directory (determined by the 'main'
         * file ending in `index.[d.]ts`, then we load `README.md` in that same directory.
         *
         * If the submodule is loaded from a file, like `mymodule.[d.]ts`, we will load
         * `mymodule.README.md`.
         */
        async function loadSubmoduleReadMe(submoduleMain) {
            const fileBase = path.basename(submoduleMain).replace(/(\.d)?\.ts$/, '');
            const readMeName = fileBase === 'index' ? `README.md` : `${fileBase}.README.md`;
            const fullPath = path.join(path.dirname(submoduleMain), readMeName);
            if (!(await fs.pathExists(fullPath))) {
                return undefined;
            }
            return {
                markdown: await fs.readFile(fullPath, { encoding: 'utf-8' }),
            };
        }
    }
    /**
     * Registers Symbols to a particular submodule. This is used to associate
     * declarations exported by an `export * as ns from 'moduleLike';` statement
     * so that they can subsequently be correctly namespaced.
     *
     * @param ns          the symbol that identifies the submodule.
     * @param moduleLike  the module-like symbol bound to the submodule.
     * @param packageRoot the root of the package being traversed.
     */
    async _addToSubmodule(ns, moduleLike, packageRoot) {
        var _a, _b, _c;
        // For each symbol exported by the moduleLike, map it to the ns submodule.
        for (const symbol of this._typeChecker.getExportsOfModule(moduleLike)) {
            if (this._submoduleMap.has(symbol)) {
                const currNs = this._submoduleMap.get(symbol);
                // Checking if there's been two submodules exporting the same symbol,
                // which is illegal. We can tell if the currently registered symbol has
                // a different name than the one we're currently trying to register in.
                if (currNs.name !== ns.name) {
                    const currNsDecl = (_a = currNs.valueDeclaration) !== null && _a !== void 0 ? _a : currNs.declarations[0];
                    const nsDecl = (_b = ns.valueDeclaration) !== null && _b !== void 0 ? _b : ns.declarations[0];
                    // Make sure the error message always lists causes in the same order
                    const refs = [
                        { decl: currNsDecl, name: currNs.name },
                        { decl: nsDecl, name: ns.name },
                    ].sort(({ name: l }, { name: r }) => l.localeCompare(r));
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3003_SYMBOL_IS_EXPORTED_TWICE.create(_nameOrDeclarationNode(symbol), refs[0].name, refs[1].name)
                        .addRelatedInformation(refs[0].decl, `Symbol is exported under the "${refs[0].name}" submodule`)
                        .addRelatedInformation(refs[1].decl, `Symbol is exported under the "${refs[1].name}" submodule`));
                }
                // Found two re-exports, which is odd, but they use the same submodule,
                // so it's probably okay? That's likely a tsc error, which will have
                // been reported for us already anyway.
                continue;
            }
            this._submoduleMap.set(symbol, ns);
            // If the exported symbol has any declaration, and that delcaration is of
            // an entity that can have nested declarations of interest to jsii
            // (classes, interfaces, enums, modules), we need to also associate those
            // nested symbols to the submodule (or they won't be named correctly!)
            const decl = (_c = symbol.declarations) === null || _c === void 0 ? void 0 : _c[0];
            if (decl != null) {
                if (ts.isClassDeclaration(decl) ||
                    ts.isInterfaceDeclaration(decl) ||
                    ts.isEnumDeclaration(decl)) {
                    const type = this._typeChecker.getTypeAtLocation(decl);
                    if (isSingleValuedEnum(type, this._typeChecker)) {
                        // type.symbol !== symbol, because symbol is the enum itself, but
                        // since it's single-valued, the TypeChecker will only show us the
                        // value's symbol later on.
                        this._submoduleMap.set(type.symbol, ns);
                    }
                    if (type.symbol.exports) {
                        // eslint-disable-next-line no-await-in-loop
                        await this._addToSubmodule(ns, symbol, packageRoot);
                    }
                }
                else if (ts.isModuleDeclaration(decl)) {
                    // eslint-disable-next-line no-await-in-loop
                    await this._registerNamespaces(symbol, packageRoot);
                }
                else if (ts.isNamespaceExport(decl)) {
                    // eslint-disable-next-line no-await-in-loop
                    await this._registerNamespaces(symbol, packageRoot);
                }
            }
        }
    }
    /**
     * Register exported types in ``this.types``.
     *
     * @param node       a node found in a module
     * @param namePrefix the prefix for the types' namespaces
     */
    // eslint-disable-next-line complexity
    async _visitNode(node, context) {
        var _a, _b, _c, _d;
        if (ts.isNamespaceExport(node)) {
            // export * as ns from 'module';
            // Note: the "ts.NamespaceExport" refers to the "export * as ns" part of
            // the statement only. We must refer to `node.parent` in order to be able
            // to access the module specifier ("from 'module'") part.
            const symbol = this._typeChecker.getSymbolAtLocation(node.parent.moduleSpecifier);
            if (LOG.isTraceEnabled()) {
                LOG.trace(`Entering submodule: ${colors.cyan([...context.namespace, symbol.name].join('.'))}`);
            }
            const nsContext = context.appendNamespace(node.name.text);
            const promises = new Array();
            for (const child of this._typeChecker.getExportsOfModule(symbol)) {
                promises.push(this._visitNode(child.declarations[0], nsContext));
            }
            const allTypes = flattenPromises(promises);
            if (LOG.isTraceEnabled()) {
                LOG.trace(`Leaving submodule: ${colors.cyan([...context.namespace, symbol.name].join('.'))}`);
            }
            return allTypes;
        }
        if (ts.isExportSpecifier(node)) {
            // This is what happens when one does `export { Symbol } from "./location";`
            //                   ExportSpecifier:           ~~~~~~
            const resolvedSymbol = this._typeChecker.getExportSpecifierLocalTargetSymbol(node);
            if (!resolvedSymbol) {
                // A grammar error, compilation will already have failed
                return [];
            }
            return this._visitNode((_a = resolvedSymbol.valueDeclaration) !== null && _a !== void 0 ? _a : resolvedSymbol.declarations[0], context);
        }
        if ((ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) === 0) {
            return [];
        }
        let jsiiType;
        if (ts.isClassDeclaration(node) && _isExported(node)) {
            // export class Name { ... }
            this._validateHeritageClauses(node.heritageClauses);
            jsiiType = await this._visitClass(this._typeChecker.getTypeAtLocation(node), context);
            if (jsiiType) {
                this.registerExportedClassFqn(node, jsiiType.fqn);
            }
        }
        else if (ts.isInterfaceDeclaration(node) && _isExported(node)) {
            // export interface Name { ... }
            this._validateHeritageClauses(node.heritageClauses);
            jsiiType = await this._visitInterface(this._typeChecker.getTypeAtLocation(node), context);
        }
        else if (ts.isEnumDeclaration(node) && _isExported(node)) {
            // export enum Name { ... }
            jsiiType = await this._visitEnum(this._typeChecker.getTypeAtLocation(node), context);
        }
        else if (ts.isModuleDeclaration(node)) {
            // export namespace name { ... }
            const name = node.name.getText();
            const symbol = this._typeChecker.getSymbolAtLocation(node.name);
            if (LOG.isTraceEnabled()) {
                LOG.trace(`Entering namespace: ${colors.cyan([...context.namespace, name].join('.'))}`);
            }
            const allTypesPromises = new Array();
            for (const prop of this._typeChecker.getExportsOfModule(symbol)) {
                allTypesPromises.push(this._visitNode(prop.declarations[0], context.appendNamespace(node.name.getText())));
            }
            const allTypes = await flattenPromises(allTypesPromises);
            if (LOG.isTraceEnabled()) {
                LOG.trace(`Leaving namespace:  ${colors.cyan([...context.namespace, name].join('.'))}`);
            }
            return allTypes;
        }
        else {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_9998_UNSUPPORTED_NODE.create((_b = ts.getNameOfDeclaration(node)) !== null && _b !== void 0 ? _b : node, node.kind));
        }
        if (!jsiiType) {
            return [];
        }
        jsiiType.symbolId = this.getSymbolId(node);
        // Let's quickly verify the declaration does not collide with a submodule. Submodules get case-adjusted for each
        // target language separately, so names cannot collide with case-variations.
        for (const submodule of this._submodules.keys()) {
            const candidates = Array.from(new Set([
                submodule.name,
                Case.camel(submodule.name),
                Case.pascal(submodule.name),
                Case.snake(submodule.name),
            ]));
            const colliding = candidates.find((name) => `${this.projectInfo.name}.${name}` === jsiiType.fqn);
            if (colliding != null) {
                const submoduleDeclName = _nameOrDeclarationNode(submodule);
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5011_SUBMODULE_NAME_CONFLICT.create((_c = ts.getNameOfDeclaration(node)) !== null && _c !== void 0 ? _c : node, submodule.name, jsiiType.name, candidates).addRelatedInformation(submoduleDeclName, `This is the conflicting submodule declaration`));
            }
        }
        if (LOG.isInfoEnabled()) {
            LOG.info(`Registering JSII ${colors.magenta(jsiiType.kind)}: ${colors.green(jsiiType.fqn)}`);
        }
        this._types[jsiiType.fqn] = jsiiType;
        jsiiType.locationInModule = this.declarationLocation(node);
        const type = this._typeChecker.getTypeAtLocation(node);
        if (type.symbol.exports) {
            const nestedContext = context.appendNamespace(type.symbol.name);
            const visitedNodes = this._typeChecker
                .getExportsOfModule(type.symbol)
                .filter((s) => s.declarations)
                .map((exportedNode) => this._visitNode(exportedNode.declarations[0], nestedContext));
            for (const nestedTypes of await Promise.all(visitedNodes)) {
                for (const nestedType of nestedTypes) {
                    if (nestedType.namespace !== nestedContext.namespace.join('.')) {
                        this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5012_NAMESPACE_IN_TYPE.create((_d = ts.getNameOfDeclaration(node)) !== null && _d !== void 0 ? _d : node, jsiiType.fqn, nestedType.namespace));
                    }
                }
            }
        }
        return [jsiiType];
    }
    getSymbolId(node) {
        return utils_2.symbolIdentifier(this._typeChecker, this._typeChecker.getTypeAtLocation(node).symbol);
    }
    _validateHeritageClauses(clauses) {
        if (clauses == null || clauses.length === 0) {
            // Nothing to do.
            return;
        }
        for (const clause of clauses) {
            for (const node of clause.types) {
                const parentType = this._typeChecker.getTypeAtLocation(node);
                if (parentType.symbol == null) {
                    // The parent type won't have a symbol if it's an "error type" inserted by the type checker when the original
                    // code contains a compilation error. In such cases, the TypeScript compiler will already have reported about
                    // the incoherent declarations, so we'll just not re-validate it there (we'd fail anyway).
                    continue;
                }
                // For some reason, we cannot trust parentType.isClassOrInterface()
                const badDecl = parentType.symbol.declarations.find((decl) => !ts.isClassDeclaration(decl) && // <-- local classes
                    !ts.isInterfaceDeclaration(decl) && // <-- local interfaces
                    !ts.isModuleDeclaration(decl));
                if (badDecl != null) {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3004_INVALID_SUPERTYPE.create(node, clause, badDecl).addRelatedInformation(badDecl, `The invalid super type is declared here.`));
                }
            }
        }
    }
    declarationLocation(node) {
        const file = node.getSourceFile();
        const line = ts.getLineAndCharacterOfPosition(file, node.getStart()).line;
        const filename = path
            .normalize(path.relative(this.projectInfo.projectRoot, file.fileName))
            .replace(/\\/g, '/');
        return {
            filename,
            line: line + 1,
        };
    }
    async _processBaseInterfaces(fqn, baseTypes) {
        const erasedBases = new Array();
        if (!baseTypes) {
            return { erasedBases };
        }
        const result = new Array();
        const baseInterfaces = new Set();
        const processBaseTypes = (types) => {
            for (const iface of types) {
                // base is private/internal, so we continue recursively with it's own bases
                if (this._isPrivateOrInternal(iface.symbol)) {
                    erasedBases.push(iface);
                    const bases = iface.getBaseTypes();
                    if (bases) {
                        processBaseTypes(bases);
                    }
                    continue;
                }
                baseInterfaces.add(iface);
            }
        };
        processBaseTypes(baseTypes);
        const typeRefs = Array.from(baseInterfaces).map(async (iface) => {
            const decl = iface.symbol.valueDeclaration;
            const typeRef = await this._typeReference(iface, decl, 'base interface');
            return { decl, typeRef };
        });
        for (const { decl, typeRef } of await Promise.all(typeRefs)) {
            if (!spec.isNamedTypeReference(typeRef)) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3005_TYPE_USED_AS_INTERFACE.create(decl, typeRef));
                continue;
            }
            this._deferUntilTypesAvailable(fqn, [typeRef], decl, (deref) => {
                if (!spec.isInterfaceType(deref)) {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3005_TYPE_USED_AS_INTERFACE.create(decl, typeRef));
                }
            });
            result.push(typeRef);
        }
        return {
            interfaces: result.length === 0 ? undefined : result,
            erasedBases,
        };
    }
    // eslint-disable-next-line complexity
    async _visitClass(type, ctx) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        if (LOG.isTraceEnabled()) {
            LOG.trace(`Processing class: ${colors.gray(ctx.namespace.join('.'))}.${colors.cyan(type.symbol.name)}`);
        }
        if (_hasInternalJsDocTag(type.symbol)) {
            return undefined;
        }
        this._warnAboutReservedWords(type.symbol);
        const fqn = `${[this.projectInfo.name, ...ctx.namespace].join('.')}.${type.symbol.name}`;
        const jsiiType = bindings.setClassRelatedNode({
            assembly: this.projectInfo.name,
            fqn,
            kind: spec.TypeKind.Class,
            name: type.symbol.name,
            namespace: ctx.namespace.length > 0 ? ctx.namespace.join('.') : undefined,
            docs: this._visitDocumentation(type.symbol, ctx).docs,
        }, type.symbol.valueDeclaration);
        if (_isAbstract(type.symbol, jsiiType)) {
            jsiiType.abstract = true;
        }
        const erasedBases = new Array();
        for (let base of (_a = type.getBaseTypes()) !== null && _a !== void 0 ? _a : []) {
            if (jsiiType.base) {
                // Ignoring this - there has already been a compilation error generated by tsc here.
                continue;
            }
            //
            // base classes ("extends foo")
            // Crawl up the inheritance tree if the current base type is not exported, so we identify the type(s) to be
            // erased, and identify the closest exported base class, should there be one.
            while (base && this._isPrivateOrInternal(base.symbol)) {
                LOG.debug(`Base class of ${colors.green(jsiiType.fqn)} named ${colors.green(base.symbol.name)} is not exported, erasing it...`);
                erasedBases.push(base);
                base = ((_b = base.getBaseTypes()) !== null && _b !== void 0 ? _b : [])[0];
            }
            if (!base) {
                // There is no exported base class to be found, pretend this class has no base class.
                continue;
            }
            // eslint-disable-next-line no-await-in-loop
            const ref = await this._typeReference(base, type.symbol.valueDeclaration, 'base class');
            if (!spec.isNamedTypeReference(ref)) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3006_TYPE_USED_AS_CLASS.create((_c = base.symbol.valueDeclaration) !== null && _c !== void 0 ? _c : base.symbol.declarations[0], ref));
                continue;
            }
            this._deferUntilTypesAvailable(fqn, [ref], base.symbol.valueDeclaration, (deref) => {
                var _a;
                if (!spec.isClassType(deref)) {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3006_TYPE_USED_AS_CLASS.create((_a = base.symbol.valueDeclaration) !== null && _a !== void 0 ? _a : base.symbol.declarations[0], ref));
                }
            });
            jsiiType.base = ref.fqn;
        }
        //
        // base interfaces ("implements foo")
        // collect all "implements" declarations from the current type and all
        // erased base types (because otherwise we lose them, see jsii#487)
        const implementsClauses = new Array();
        for (const heritage of [type, ...erasedBases].map((t) => { var _a; return (_a = t.symbol.valueDeclaration.heritageClauses) !== null && _a !== void 0 ? _a : []; })) {
            for (const clause of heritage) {
                if (clause.token === ts.SyntaxKind.ExtendsKeyword) {
                    // Handled by `getBaseTypes`
                    continue;
                }
                else if (clause.token !== ts.SyntaxKind.ImplementsKeyword) {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_9998_UNSUPPORTED_NODE.create(clause, `Ignoring ${ts.SyntaxKind[clause.token]} heritage clause`));
                    continue;
                }
                implementsClauses.push(clause);
            }
        }
        // process all "implements" clauses
        const allInterfaces = new Set();
        const baseInterfaces = implementsClauses.map((clause) => this._processBaseInterfaces(fqn, clause.types.map((t) => this._getTypeFromTypeNode(t))));
        for (const { interfaces } of await Promise.all(baseInterfaces)) {
            for (const ifc of interfaces !== null && interfaces !== void 0 ? interfaces : []) {
                allInterfaces.add(ifc.fqn);
            }
            if (interfaces) {
                this._deferUntilTypesAvailable(jsiiType.fqn, interfaces, type.symbol.valueDeclaration, (...ifaces) => {
                    var _a;
                    for (const iface of ifaces) {
                        if (spec.isInterfaceType(iface) && iface.datatype) {
                            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3007_ILLEGAL_STRUCT_EXTENSION.create((_a = type.symbol.valueDeclaration) !== null && _a !== void 0 ? _a : type.symbol.declarations[0], jsiiType, iface));
                        }
                    }
                });
            }
        }
        if (allInterfaces.size > 0) {
            jsiiType.interfaces = Array.from(allInterfaces);
        }
        if (!type.isClass()) {
            throw new Error('Oh no');
        }
        const allDeclarations = type.symbol.declarations.map((decl) => ({ decl, type }));
        // Considering erased bases' declarations, too, so they are "blended in"
        for (const base of erasedBases) {
            allDeclarations.push(...base.symbol.declarations.map((decl) => ({ decl, type: base })));
        }
        for (const { decl, type: declaringType } of allDeclarations) {
            const classDecl = decl;
            if (!classDecl.members) {
                continue;
            }
            for (const memberDecl of classDecl.members) {
                if (ts.isSemicolonClassElement(memberDecl)) {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_9996_UNNECESSARY_TOKEN.create(memberDecl));
                    continue;
                }
                const member = ts.isConstructorDeclaration(memberDecl)
                    ? memberDecl.symbol
                    : this._typeChecker.getSymbolAtLocation(ts.getNameOfDeclaration(memberDecl));
                if (!((_d = declaringType.symbol.getDeclarations()) !== null && _d !== void 0 ? _d : []).find((d) => d === memberDecl.parent)) {
                    continue;
                }
                if (this._isPrivateOrInternal(member, memberDecl)) {
                    continue;
                }
                // constructors are handled later
                if (ts.isConstructorDeclaration(memberDecl)) {
                    continue;
                }
                // eslint-disable-next-line no-await-in-loop
                if (ts.isMethodDeclaration(memberDecl) ||
                    ts.isMethodSignature(memberDecl)) {
                    // eslint-disable-next-line no-await-in-loop
                    await this._visitMethod(member, jsiiType, ctx.replaceStability((_e = jsiiType.docs) === null || _e === void 0 ? void 0 : _e.stability), classDecl);
                }
                else if (ts.isPropertyDeclaration(memberDecl) ||
                    ts.isPropertySignature(memberDecl) ||
                    ts.isAccessor(memberDecl)) {
                    // eslint-disable-next-line no-await-in-loop
                    await this._visitProperty(member, jsiiType, ctx.replaceStability((_f = jsiiType.docs) === null || _f === void 0 ? void 0 : _f.stability), classDecl);
                }
                else {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_9998_UNSUPPORTED_NODE.create((_g = ts.getNameOfDeclaration(memberDecl)) !== null && _g !== void 0 ? _g : memberDecl, memberDecl.kind));
                }
                /* eslint-enable no-await-in-loop */
            }
        }
        const memberEmitContext = ctx.replaceStability(jsiiType.docs && jsiiType.docs.stability);
        // Find the first defined constructor in this class, or it's erased bases
        const constructor = [type, ...erasedBases]
            .map(getConstructor)
            .find((ctor) => ctor != null);
        const ctorDeclaration = constructor && constructor.declarations[0];
        if (constructor && ctorDeclaration) {
            const signature = this._typeChecker.getSignatureFromDeclaration(ctorDeclaration);
            if ((ts.getCombinedModifierFlags(ctorDeclaration) &
                ts.ModifierFlags.Private) ===
                0) {
                jsiiType.initializer = {
                    locationInModule: this.declarationLocation(ctorDeclaration),
                };
                if (signature) {
                    for (const param of signature.getParameters()) {
                        jsiiType.initializer.parameters = (_h = jsiiType.initializer.parameters) !== null && _h !== void 0 ? _h : [];
                        jsiiType.initializer.parameters.push(
                        // eslint-disable-next-line no-await-in-loop
                        await this._toParameter(param, ctx.replaceStability((_j = jsiiType.docs) === null || _j === void 0 ? void 0 : _j.stability)));
                        jsiiType.initializer.variadic =
                            ((_l = (_k = jsiiType.initializer) === null || _k === void 0 ? void 0 : _k.parameters) === null || _l === void 0 ? void 0 : _l.some((p) => !!p.variadic)) ||
                                undefined;
                        jsiiType.initializer.protected =
                            (ts.getCombinedModifierFlags(ctorDeclaration) &
                                ts.ModifierFlags.Protected) !==
                                0 || undefined;
                    }
                }
                this._verifyConsecutiveOptionals(ctorDeclaration, jsiiType.initializer.parameters);
                jsiiType.initializer.docs = this._visitDocumentation(constructor, memberEmitContext).docs;
                this.overrideDocComment(constructor, jsiiType.initializer.docs, paramDocs(jsiiType.initializer.parameters));
            }
            // Process constructor-based property declarations even if constructor is private
            if (signature) {
                for (const param of signature.getParameters()) {
                    if (ts.isParameterPropertyDeclaration(param.valueDeclaration, param.valueDeclaration.parent) &&
                        !this._isPrivateOrInternal(param)) {
                        // eslint-disable-next-line no-await-in-loop
                        await this._visitProperty(param, jsiiType, memberEmitContext, ctorDeclaration.parent);
                    }
                }
            }
        }
        else if (jsiiType.base) {
            this._deferUntilTypesAvailable(fqn, [jsiiType.base], type.symbol.valueDeclaration, (baseType) => {
                var _a;
                if (spec.isClassType(baseType)) {
                    jsiiType.initializer = baseType.initializer;
                }
                else {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3999_INCOHERENT_TYPE_MODEL.create((_a = type.symbol.valueDeclaration) !== null && _a !== void 0 ? _a : type.symbol.declarations[0], `Base type of ${jsiiType.fqn} (${jsiiType.base}) is not a class`));
                }
            });
        }
        else {
            jsiiType.initializer = {
                docs: ctx.stability && { stability: ctx.stability },
            };
        }
        this._verifyNoStaticMixing(jsiiType, type.symbol.valueDeclaration);
        this.overrideDocComment(type.getSymbol(), jsiiType === null || jsiiType === void 0 ? void 0 : jsiiType.docs);
        return _sortMembers(jsiiType);
    }
    /**
     * Use the TypeChecker's getTypeFromTypeNode, but throw a descriptive error if it fails
     */
    _getTypeFromTypeNode(t) {
        const type = this._typeChecker.getTypeFromTypeNode(t);
        if (isErrorType(type)) {
            throw new Error(`Unable to resolve type: ${t.getFullText()}. This typically happens if something is wrong with your dependency closure.`);
        }
        return type;
    }
    /**
     * Check that this class doesn't declare any members that are of different staticness in itself or any of its bases
     */
    _verifyNoStaticMixing(klass, decl) {
        var _a, _b, _c, _d;
        // Check class itself--may have two methods/props with the same name, so check the arrays
        const statics = new Set(((_a = klass.methods) !== null && _a !== void 0 ? _a : [])
            .concat((_b = klass.properties) !== null && _b !== void 0 ? _b : [])
            .filter((x) => x.static)
            .map((x) => x.name));
        const nonStatics = new Set(((_c = klass.methods) !== null && _c !== void 0 ? _c : [])
            .concat((_d = klass.properties) !== null && _d !== void 0 ? _d : [])
            .filter((x) => !x.static)
            .map((x) => x.name));
        // Intersect
        for (const member of intersect(statics, nonStatics)) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5013_STATIC_INSTANCE_CONFLICT.create(decl, member, klass));
        }
        // Check against base classes. They will not contain duplicate member names so we can load
        // the members into a map.
        const classMembers = typeMembers(klass);
        this._withBaseClass(klass, decl, (base, recurse) => {
            for (const [name, baseMember] of Object.entries(typeMembers(base))) {
                const member = classMembers[name];
                if (!member) {
                    continue;
                }
                if (!!baseMember.static !== !!member.static) {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5014_INHERITED_STATIC_CONFLICT.create(decl, member, klass, baseMember, base));
                }
            }
            recurse();
        });
    }
    /**
     * Wrapper around _deferUntilTypesAvailable, invoke the callback with the given classes' base type
     *
     * Does nothing if the given class doesn't have a base class.
     *
     * The second argument will be a `recurse` function for easy recursion up the inheritance tree
     * (no messing around with binding 'self' and 'this' and doing multiple calls to _withBaseClass.)
     */
    _withBaseClass(klass, decl, cb) {
        if (klass.base) {
            this._deferUntilTypesAvailable(klass.fqn, [klass.base], decl, (base) => {
                if (!spec.isClassType(base)) {
                    throw new Error('Oh no');
                }
                cb(base, () => this._withBaseClass(base, decl, cb));
            });
        }
    }
    /**
     * @returns true if this member is internal and should be omitted from the type manifest
     */
    _isPrivateOrInternal(symbol, validateDeclaration) {
        var _a, _b;
        const hasInternalJsDocTag = _hasInternalJsDocTag(symbol);
        const hasUnderscorePrefix = symbol.name !== '__constructor' && symbol.name.startsWith('_');
        if (_isPrivate(symbol)) {
            LOG.trace(`${colors.cyan(symbol.name)} is marked "private", or is an unexported type declaration`);
            return true;
        }
        if (!hasInternalJsDocTag && !hasUnderscorePrefix) {
            return false;
        }
        // we only validate if we have a declaration
        if (validateDeclaration) {
            if (!hasUnderscorePrefix) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_8005_INTERNAL_UNDERSCORE.create((_a = ts.getNameOfDeclaration(validateDeclaration)) !== null && _a !== void 0 ? _a : validateDeclaration, symbol.name));
            }
            if (!hasInternalJsDocTag) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_8006_UNDERSCORE_INTERNAL.create((_b = ts.getNameOfDeclaration(validateDeclaration)) !== null && _b !== void 0 ? _b : validateDeclaration, symbol.name));
            }
        }
        return true;
    }
    async _visitEnum(type, ctx) {
        var _a, _b;
        if (LOG.isTraceEnabled()) {
            LOG.trace(`Processing enum: ${colors.gray(ctx.namespace.join('.'))}.${colors.cyan(type.symbol.name)}`);
        }
        // Forcefully resolving to the EnumDeclaration symbol for single-valued enums
        const symbol = type.isLiteral()
            ? type.symbol.parent
            : type.symbol;
        if (!symbol) {
            throw new Error(`Unable to resolve enum declaration for ${type.symbol.name}!`);
        }
        if (_hasInternalJsDocTag(symbol)) {
            return Promise.resolve(undefined);
        }
        this._warnAboutReservedWords(type.symbol);
        const decl = symbol.valueDeclaration;
        const flags = ts.getCombinedModifierFlags(decl);
        if (flags & ts.ModifierFlags.Const) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_1000_NO_CONST_ENUM.create((_b = (_a = decl.modifiers) === null || _a === void 0 ? void 0 : _a.find((mod) => mod.kind === ts.SyntaxKind.ConstKeyword)) !== null && _b !== void 0 ? _b : decl));
        }
        const { docs } = this._visitDocumentation(symbol, ctx);
        const typeContext = ctx.replaceStability(docs === null || docs === void 0 ? void 0 : docs.stability);
        const members = type.isUnion() ? type.types : [type];
        const jsiiType = bindings.setEnumRelatedNode({
            assembly: this.projectInfo.name,
            fqn: `${[this.projectInfo.name, ...ctx.namespace].join('.')}.${symbol.name}`,
            kind: spec.TypeKind.Enum,
            members: members.map((m) => {
                const { docs } = this._visitDocumentation(m.symbol, typeContext);
                this.overrideDocComment(m.symbol, docs);
                return { name: m.symbol.name, docs };
            }),
            name: symbol.name,
            namespace: ctx.namespace.length > 0 ? ctx.namespace.join('.') : undefined,
            docs,
        }, decl);
        this.overrideDocComment(type.getSymbol(), jsiiType === null || jsiiType === void 0 ? void 0 : jsiiType.docs);
        return Promise.resolve(jsiiType);
    }
    /**
     * Return docs for a symbol
     */
    _visitDocumentation(sym, context) {
        var _a, _b, _c, _d;
        const result = docs_1.parseSymbolDocumentation(sym, this._typeChecker);
        for (const diag of (_a = result.diagnostics) !== null && _a !== void 0 ? _a : []) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_7999_DOCUMENTATION_ERROR.create((_b = sym.valueDeclaration) !== null && _b !== void 0 ? _b : sym.declarations[0], diag));
        }
        const decl = (_c = sym.valueDeclaration) !== null && _c !== void 0 ? _c : sym.declarations[0];
        // The @struct hint is only valid for interface declarations
        if (!ts.isInterfaceDeclaration(decl) && result.hints.struct) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_7001_ILLEGAL_HINT.create(_findHint(decl, 'struct'), 'struct', 'interfaces with only readonly properties')
                .addRelatedInformation((_d = ts.getNameOfDeclaration(decl)) !== null && _d !== void 0 ? _d : decl, 'The annotated declaration is here')
                .preformat(this.projectInfo.projectRoot));
            // Clean up the bad hint...
            delete result.hints.struct;
        }
        // Apply the current context's stability if none was specified locally.
        if (result.docs.stability == null) {
            result.docs.stability = context.stability;
        }
        const allUndefined = Object.values(result.docs).every((v) => v === undefined);
        return {
            docs: !allUndefined ? result.docs : undefined,
            hints: result.hints,
        };
    }
    /**
     * Check that all parameters the doc block refers to with a @param declaration actually exist
     */
    _validateReferencedDocParams(method, methodSym) {
        var _a, _b;
        const params = docs_1.getReferencedDocParams(methodSym);
        const actualNames = new Set(((_a = method.parameters) !== null && _a !== void 0 ? _a : []).map((p) => p.name));
        for (const param of params) {
            if (!actualNames.has(param)) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_7000_NON_EXISTENT_PARAMETER.create((_b = methodSym.valueDeclaration) !== null && _b !== void 0 ? _b : methodSym.declarations[0], method, param));
            }
        }
    }
    async _visitInterface(type, ctx) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (LOG.isTraceEnabled()) {
            LOG.trace(`Processing interface: ${colors.gray(ctx.namespace.join('.'))}.${colors.cyan(type.symbol.name)}`);
        }
        if (_hasInternalJsDocTag(type.symbol)) {
            return undefined;
        }
        this._warnAboutReservedWords(type.symbol);
        const fqn = `${[this.projectInfo.name, ...ctx.namespace].join('.')}.${type.symbol.name}`;
        const { docs, hints } = this._visitDocumentation(type.symbol, ctx);
        const jsiiType = bindings.setInterfaceRelatedNode({
            assembly: this.projectInfo.name,
            fqn,
            kind: spec.TypeKind.Interface,
            name: type.symbol.name,
            namespace: ctx.namespace.length > 0 ? ctx.namespace.join('.') : undefined,
            docs,
        }, type.symbol.declarations[0]);
        const { interfaces, erasedBases } = await this._processBaseInterfaces(fqn, type.getBaseTypes());
        jsiiType.interfaces = apply(interfaces, (arr) => arr.map((i) => i.fqn));
        for (const declaringType of [type, ...erasedBases]) {
            for (const member of declaringType.getProperties()) {
                if (!((_a = declaringType.symbol.getDeclarations()) !== null && _a !== void 0 ? _a : []).find((decl) => { var _a; return decl === ((_a = member.valueDeclaration) === null || _a === void 0 ? void 0 : _a.parent); })) {
                    continue;
                }
                if (this._isPrivateOrInternal(member, member.valueDeclaration)) {
                    continue;
                }
                if (ts.isMethodDeclaration(member.valueDeclaration) ||
                    ts.isMethodSignature(member.valueDeclaration)) {
                    // eslint-disable-next-line no-await-in-loop
                    await this._visitMethod(member, jsiiType, ctx.replaceStability((_b = jsiiType.docs) === null || _b === void 0 ? void 0 : _b.stability), ((_c = type.symbol.valueDeclaration) !== null && _c !== void 0 ? _c : type.symbol.declarations[0]));
                }
                else if (ts.isPropertyDeclaration(member.valueDeclaration) ||
                    ts.isPropertySignature(member.valueDeclaration) ||
                    ts.isAccessor(member.valueDeclaration)) {
                    // eslint-disable-next-line no-await-in-loop
                    await this._visitProperty(member, jsiiType, ctx.replaceStability((_d = jsiiType.docs) === null || _d === void 0 ? void 0 : _d.stability), ((_e = type.symbol.valueDeclaration) !== null && _e !== void 0 ? _e : type.symbol.declarations[0]));
                }
                else {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_9998_UNSUPPORTED_NODE.create(_nameOrDeclarationNode(member), ((_f = member.valueDeclaration) !== null && _f !== void 0 ? _f : member.declarations[0]).kind));
                }
            }
        }
        // Calculate datatype based on the datatypeness of this interface and all of its parents
        // To keep the spec minimal the actual values of the attribute are "true" or "undefined" (to represent "false").
        const declaration = (_g = type.symbol.valueDeclaration) !== null && _g !== void 0 ? _g : type.symbol.declarations[0];
        this._deferUntilTypesAvailable(fqn, (_h = jsiiType.interfaces) !== null && _h !== void 0 ? _h : [], declaration, (...bases) => {
            var _a, _b, _c, _d, _e;
            if (((_a = jsiiType.methods) !== null && _a !== void 0 ? _a : []).length === 0) {
                jsiiType.datatype = true;
            }
            else if (hints.struct) {
                this._diagnostics.push(jsiiType.methods.reduce((diag, mthod) => {
                    var _a;
                    const node = bindings.getMethodRelatedNode(mthod);
                    return node
                        ? diag.addRelatedInformation((_a = ts.getNameOfDeclaration(node)) !== null && _a !== void 0 ? _a : node, `A method is declared here`)
                        : diag;
                }, jsii_diagnostic_1.JsiiDiagnostic.JSII_7001_ILLEGAL_HINT.create(_findHint(declaration, 'struct'), 'struct', 'interfaces with only readonly properties')
                    .addRelatedInformation((_b = ts.getNameOfDeclaration(declaration)) !== null && _b !== void 0 ? _b : declaration, 'The annotated declartion is here')
                    .preformat(this.projectInfo.projectRoot)));
            }
            for (const base of bases) {
                if (spec.isInterfaceType(base) && !base.datatype) {
                    jsiiType.datatype = undefined;
                }
            }
            const interfaceName = isInterfaceName(jsiiType.name);
            // If it's not a datatype the name must start with an "I".
            if (!jsiiType.datatype && !interfaceName) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_8007_BEHAVIORAL_INTERFACE_NAME.create((_c = ts.getNameOfDeclaration(declaration)) !== null && _c !== void 0 ? _c : declaration, jsiiType.name));
            }
            // If the name starts with an "I" it is not intended as a datatype, so switch that off,
            // unless a TSDoc hint was set to force this to be considered a behavioral interface.
            if (jsiiType.datatype && interfaceName && !hints.struct) {
                delete jsiiType.datatype;
            }
            // Okay, this is a data type, check that all properties are readonly
            if (jsiiType.datatype) {
                for (const prop of (_d = jsiiType.properties) !== null && _d !== void 0 ? _d : []) {
                    if (!prop.immutable) {
                        const p = type.getProperty(prop.name);
                        this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3008_STRUCT_PROPS_MUST_BE_READONLY.create(_nameOrDeclarationNode(p), p.name, jsiiType));
                        // force property to be "readonly" since jsii languages will pass this by-value
                        prop.immutable = true;
                    }
                }
            }
            else {
                // This is *NOT* a data type, so it may not extend something that is one.
                for (const base of bases) {
                    if (!spec.isInterfaceType(base)) {
                        // Invalid type we already warned about earlier, just ignoring it here..
                        continue;
                    }
                    if (base.datatype) {
                        this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3007_ILLEGAL_STRUCT_EXTENSION.create((_e = type.symbol.valueDeclaration) !== null && _e !== void 0 ? _e : type.symbol.declarations[0], jsiiType, base));
                    }
                }
            }
        });
        // Check that no interface declares a member that's already declared
        // in a base type (not allowed in C#).
        const names = memberNames(jsiiType);
        const checkNoIntersection = (...bases) => {
            var _a, _b;
            for (const base of bases) {
                if (!spec.isInterfaceType(base)) {
                    continue;
                }
                const baseMembers = memberNames(base);
                for (const memberName of names) {
                    if (baseMembers.includes(memberName)) {
                        this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5015_REDECLARED_INTERFACE_MEMBER.create((_a = type.symbol.valueDeclaration) !== null && _a !== void 0 ? _a : type.symbol.declarations[0], memberName, jsiiType));
                    }
                }
                // Recurse upwards
                this._deferUntilTypesAvailable(fqn, (_b = base.interfaces) !== null && _b !== void 0 ? _b : [], type.symbol.valueDeclaration, checkNoIntersection);
            }
        };
        this._deferUntilTypesAvailable(fqn, (_j = jsiiType.interfaces) !== null && _j !== void 0 ? _j : [], type.symbol.valueDeclaration, checkNoIntersection);
        this.overrideDocComment(type.getSymbol(), jsiiType === null || jsiiType === void 0 ? void 0 : jsiiType.docs);
        return _sortMembers(jsiiType);
    }
    async _visitMethod(symbol, type, ctx, declaringTypeDecl) {
        var _a, _b, _c;
        if (LOG.isTraceEnabled()) {
            LOG.trace(`Processing method: ${colors.green(type.fqn)}#${colors.cyan(symbol.name)}`);
        }
        const declaration = symbol.valueDeclaration;
        const signature = this._typeChecker.getSignatureFromDeclaration(declaration);
        if (!signature) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_9004_UNABLE_TO_COMPUTE_SIGNATURE.create(declaration, symbol.name, type));
            return;
        }
        if (Case.pascal(type.name) === Case.pascal(symbol.name)) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5019_MEMBER_TYPE_NAME_CONFLICT.create(declaration.name, 'method', symbol, type).addRelatedInformation((_a = declaringTypeDecl.name) !== null && _a !== void 0 ? _a : declaringTypeDecl, `The declaring ${type.kind} is introduced here`));
        }
        if (isProhibitedMemberName(symbol.name)) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5016_PROHIBITED_MEMBER_NAME.create(declaration.name, symbol.name));
            return;
        }
        this._warnAboutReservedWords(symbol);
        const parameters = await Promise.all(signature.getParameters().map((p) => this._toParameter(p, ctx)));
        const returnType = signature.getReturnType();
        const method = bindings.setMethodRelatedNode({
            abstract: _isAbstract(symbol, type) || undefined,
            name: symbol.name,
            parameters: parameters.length > 0 ? parameters : undefined,
            protected: _isProtected(symbol) || undefined,
            returns: _isVoid(returnType)
                ? undefined
                : await this._optionalValue(returnType, declaration.name, 'return type'),
            async: _isPromise(returnType) || undefined,
            static: _isStatic(symbol) || undefined,
            locationInModule: this.declarationLocation(declaration),
        }, declaration);
        method.variadic =
            ((_b = method.parameters) === null || _b === void 0 ? void 0 : _b.some((p) => !!p.variadic)) === true ? true : undefined;
        this._verifyConsecutiveOptionals(declaration, method.parameters);
        method.docs = this._visitDocumentation(symbol, ctx).docs;
        // If the last parameter is a datatype, verify that it does not share any field names with
        // other function arguments, so that it can be turned into keyword arguments by jsii frontends
        // that support such.
        const lastParamTypeRef = apply(last(parameters), (x) => x.type);
        const lastParamSymbol = last(signature.getParameters());
        if (lastParamTypeRef && spec.isNamedTypeReference(lastParamTypeRef)) {
            this._deferUntilTypesAvailable(symbol.name, [lastParamTypeRef], lastParamSymbol.declarations[0], (lastParamType) => {
                if (!spec.isInterfaceType(lastParamType) || !lastParamType.datatype) {
                    return;
                }
                // Liftable datatype, make sure no parameter names match any of the properties in the datatype
                const propNames = this.allProperties(lastParamType);
                const paramNames = new Set(parameters.slice(0, parameters.length - 1).map((x) => x.name));
                const sharedNames = intersection(propNames, paramNames);
                for (const badName of sharedNames) {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5017_POSITIONAL_KEYWORD_CONFLICT.create(declaration, badName));
                }
            });
        }
        this._validateReferencedDocParams(method, symbol);
        type.methods = (_c = type.methods) !== null && _c !== void 0 ? _c : [];
        if (type.methods.find((m) => m.name === method.name && m.static === method.static) != null) {
            LOG.trace(`Dropping re-declaration of ${colors.green(type.fqn)}#${colors.cyan(method.name)}`);
            return;
        }
        type.methods.push(method);
        this.overrideDocComment(symbol, method.docs, paramDocs(method.parameters));
    }
    _warnAboutReservedWords(symbol) {
        if (!warnings_1.enabledWarnings['reserved-word']) {
            return;
        }
        const reservingLanguages = reserved_words_1.isReservedName(symbol.name);
        if (reservingLanguages) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5018_RESERVED_WORD.create(_nameOrDeclarationNode(symbol), symbol.name, reservingLanguages));
        }
    }
    async _visitProperty(symbol, type, ctx, declaringTypeDecl) {
        var _a, _b, _c, _d, _e, _f;
        if ((_a = type.properties) === null || _a === void 0 ? void 0 : _a.find((p) => p.name === symbol.name)) {
            /*
             * Second declaration of the same property. For example, if code specifies a getter & setter signature,
             * there will be one pass for each of the signatures, but we can process only the first encountered. The
             * typescript compiler will take care of making sure we don't have conflicting declarations, anyway.
             */
            return;
        }
        if (LOG.isTraceEnabled()) {
            LOG.trace(`Processing property: ${colors.green(type.fqn)}#${colors.cyan(symbol.name)}`);
        }
        const declaration = (_b = symbol.valueDeclaration) !== null && _b !== void 0 ? _b : symbol.declarations[0];
        const signature = declaration;
        if (Case.pascal(type.name) === Case.pascal(symbol.name)) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5019_MEMBER_TYPE_NAME_CONFLICT.create(signature.name, 'property', symbol, type).addRelatedInformation((_c = declaringTypeDecl.name) !== null && _c !== void 0 ? _c : declaringTypeDecl, `The declaring ${type.kind} is introduced here`));
        }
        if (isProhibitedMemberName(symbol.name)) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5016_PROHIBITED_MEMBER_NAME.create((_d = symbol.valueDeclaration) !== null && _d !== void 0 ? _d : symbol.declarations[0], symbol.name));
            return;
        }
        this._warnAboutReservedWords(symbol);
        const property = bindings.setPropertyRelatedNode({
            ...(await this._optionalValue(this._typeChecker.getTypeOfSymbolAtLocation(symbol, signature), signature.name, 'property type')),
            abstract: _isAbstract(symbol, type) || undefined,
            name: symbol.name,
            protected: _isProtected(symbol) || undefined,
            static: _isStatic(symbol) || undefined,
            locationInModule: this.declarationLocation(signature),
        }, signature);
        if (ts.isGetAccessor(signature)) {
            const decls = (_e = symbol.getDeclarations()) !== null && _e !== void 0 ? _e : [];
            property.immutable =
                !decls.some((decl) => ts.isSetAccessor(decl)) || undefined;
        }
        else {
            property.immutable =
                (ts.getCombinedModifierFlags(signature) & ts.ModifierFlags.Readonly) !==
                    0 || undefined;
        }
        if (signature.questionToken) {
            property.optional = true;
        }
        if (property.static &&
            property.immutable &&
            ts.isPropertyDeclaration(signature) &&
            signature.initializer) {
            property.const = true;
        }
        property.docs = this._visitDocumentation(symbol, ctx).docs;
        type.properties = (_f = type.properties) !== null && _f !== void 0 ? _f : [];
        if (type.properties.find((prop) => prop.name === property.name && prop.static === property.static) != null) {
            LOG.trace(`Dropping re-declaration of ${colors.green(type.fqn)}#${colors.cyan(property.name)}`);
            return;
        }
        type.properties.push(property);
        this.overrideDocComment(symbol, property.docs);
    }
    async _toParameter(paramSymbol, ctx) {
        if (LOG.isTraceEnabled()) {
            LOG.trace(`Processing parameter: ${colors.cyan(paramSymbol.name)}`);
        }
        const paramDeclaration = paramSymbol.valueDeclaration;
        this._warnAboutReservedWords(paramSymbol);
        const parameter = bindings.setParameterRelatedNode({
            ...(await this._optionalValue(this._typeChecker.getTypeAtLocation(paramDeclaration), paramDeclaration.name, 'parameter type')),
            name: paramSymbol.name,
            variadic: paramDeclaration.dotDotDotToken && true,
        }, paramDeclaration);
        if (parameter.variadic && spec.isCollectionTypeReference(parameter.type)) {
            // TypeScript types variadic parameters as an array, but JSII uses the item-type instead.
            parameter.type = parameter.type.collection.elementtype;
        }
        else if (paramDeclaration.initializer || paramDeclaration.questionToken) {
            // Optional parameters have an inherently null-able type.
            parameter.optional = true;
        }
        parameter.docs = this._visitDocumentation(paramSymbol, ctx.removeStability()).docs;
        // Don't rewrite doc comment here on purpose -- instead, we add them as '@param'
        // into the parent's doc comment.
        return parameter;
    }
    async _typeReference(type, declaration, purpose) {
        const optionalValue = await this._optionalValue(type, declaration, purpose);
        if (optionalValue.optional) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3999_INCOHERENT_TYPE_MODEL.create(declaration, 'Encountered optional value in location where a plain type reference is expected'));
        }
        return optionalValue.type;
    }
    async _optionalValue(type, declaration, purpose) {
        const isThisType = _isThisType(type, this._typeChecker);
        if (type.isLiteral() && _isEnumLike(type)) {
            type = this._typeChecker.getBaseTypeOfLiteralType(type);
        }
        else {
            type = this._typeChecker.getApparentType(type);
        }
        const primitiveType = _tryMakePrimitiveType.call(this);
        if (primitiveType) {
            return { type: primitiveType };
        }
        if (type.isUnion() && !_isEnumLike(type)) {
            return _unionType.call(this);
        }
        if (!type.symbol) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_1001_TYPE_HAS_NO_SYMBOL.create(declaration));
            return { type: spec.CANONICAL_ANY };
        }
        if (type.symbol.name === 'Array') {
            return { type: await _arrayType.call(this) };
        }
        if (type.symbol.name === '__type' && type.symbol.members) {
            return { type: await _mapType.call(this) };
        }
        if (type.symbol.escapedName === 'Promise') {
            const typeRef = type;
            if (!typeRef.typeArguments || typeRef.typeArguments.length !== 1) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_1002_UNSPECIFIED_PROMISE.create(declaration));
                return { type: spec.CANONICAL_ANY };
            }
            return {
                type: await this._typeReference(typeRef.typeArguments[0], declaration, purpose),
            };
        }
        return {
            type: { fqn: await this._getFQN(type, declaration, purpose, isThisType) },
        };
        async function _arrayType() {
            var _a;
            const typeRef = type;
            let elementtype;
            if (((_a = typeRef.typeArguments) === null || _a === void 0 ? void 0 : _a.length) === 1) {
                elementtype = await this._typeReference(typeRef.typeArguments[0], declaration, 'list element type');
            }
            else {
                const count = typeRef.typeArguments
                    ? typeRef.typeArguments.length
                    : 'none';
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_1003_UNSUPPORTED_TYPE.create(declaration, `Array references must have exactly one type argument (found ${count})`));
                elementtype = spec.CANONICAL_ANY;
            }
            return {
                collection: {
                    elementtype,
                    kind: spec.CollectionKind.Array,
                },
            };
        }
        async function _mapType() {
            let elementtype;
            const objectType = type.getStringIndexType();
            if (objectType) {
                elementtype = await this._typeReference(objectType, declaration, 'map element type');
            }
            else {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_1003_UNSUPPORTED_TYPE.create(declaration, 'Only string-indexed map types are supported'));
                elementtype = spec.CANONICAL_ANY;
            }
            return {
                collection: {
                    elementtype,
                    kind: spec.CollectionKind.Map,
                },
            };
        }
        function _tryMakePrimitiveType() {
            if (!type.symbol) {
                if (type.flags & ts.TypeFlags.Object) {
                    return { primitive: spec.PrimitiveType.Json };
                }
                if (type.flags & (ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {
                    return spec.CANONICAL_ANY;
                }
            }
            else if (type.symbol.valueDeclaration &&
                isUnder(type.symbol.valueDeclaration.getSourceFile().fileName, this.stdlib)) {
                switch (type.symbol.name) {
                    case 'Boolean':
                        return { primitive: spec.PrimitiveType.Boolean };
                    case 'Date':
                        return { primitive: spec.PrimitiveType.Date };
                    case 'Number':
                        return { primitive: spec.PrimitiveType.Number };
                    case 'String':
                        return { primitive: spec.PrimitiveType.String };
                }
            }
            // Not a primitive type!
            return undefined;
            function isUnder(file, dir) {
                const relative = path.relative(dir, file);
                return !relative.startsWith(path.sep) && !relative.startsWith('..');
            }
        }
        async function _unionType() {
            const types = new Array();
            let optional;
            for (const subType of type.types) {
                if (subType.flags & ts.TypeFlags.Undefined) {
                    optional = true;
                    continue;
                }
                // eslint-disable-next-line no-await-in-loop
                const resolvedType = await this._typeReference(subType, declaration, purpose);
                if (types.find((ref) => deepEqual(ref, resolvedType)) != null) {
                    continue;
                }
                types.push(resolvedType);
            }
            return types.length === 1
                ? { optional, type: types[0] }
                : { optional, type: { union: { types } } };
        }
    }
    callDeferredsInOrder() {
        // Do a topological call order of all deferreds.
        while (this._deferred.length > 0) {
            // All fqns in dependency lists that don't have any pending
            // deferreds themselves can be executed now, so are removed from
            // dependency lists.
            const pendingFqns = new Set(this._deferred.map((x) => x.fqn));
            for (const deferred of this._deferred) {
                restrictDependenciesTo(deferred, pendingFqns);
            }
            // Invoke all deferreds with no more dependencies and remove them from the list.
            let invoked = false;
            for (let i = 0; i < this._deferred.length; i++) {
                if (this._deferred[i].dependedFqns.length === 0) {
                    const deferred = this._deferred.splice(i, 1)[0];
                    deferred.cb();
                    invoked = true;
                }
            }
            if (!invoked) {
                // Apparently we're stuck. Complain loudly.
                throw new Error(`Could not invoke any more deferreds, cyclic dependency? Remaining: ${JSON.stringify(this._deferred, undefined, 2)}`);
            }
        }
        /**
         * Retain only elements in the dependencyfqn that are also in the set
         */
        function restrictDependenciesTo(def, fqns) {
            def.dependedFqns = def.dependedFqns.filter(fqns.has.bind(fqns));
        }
    }
    /**
     * Return the set of all (inherited) properties of an interface
     */
    allProperties(root) {
        const ret = new Set();
        recurse.call(this, root);
        return ret;
        function recurse(int) {
            var _a, _b;
            for (const property of (_a = int.properties) !== null && _a !== void 0 ? _a : []) {
                ret.add(property.name);
            }
            for (const baseRef of (_b = int.interfaces) !== null && _b !== void 0 ? _b : []) {
                const base = this._dereference(baseRef, undefined);
                if (!base) {
                    throw new Error('Impossible to have unresolvable base in allProperties()');
                }
                if (!spec.isInterfaceType(base)) {
                    throw new Error('Impossible to have non-interface base in allProperties()');
                }
                recurse.call(this, base);
            }
        }
    }
    _verifyConsecutiveOptionals(node, parameters) {
        if (!parameters) {
            return;
        }
        const remaining = [...parameters].reverse();
        while (remaining.length > 0) {
            const current = remaining.pop();
            if (current.optional) {
                const offender = remaining.find((p) => !p.optional && !p.variadic);
                if (offender == null) {
                    continue;
                }
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3009_OPTIONAL_PARAMETER_BEFORE_REQUIRED.create(node, current, offender));
                delete current.optional;
            }
        }
    }
    /**
     * Updates the runtime type info with the fully-qualified name for the current class definition.
     * Used by the runtime type info injector to add this information to the compiled file.
     */
    registerExportedClassFqn(clazz, fqn) {
        this.runtimeTypeInfoInjector.registerClassFqn(clazz, fqn);
    }
    /**
     * From the given JSIIDocs, re-render the TSDoc comment for the Node
     *
     * We may change the documentation a little, so that the doc comment that gets
     * written is not necessarily exactly the same as the docs that go into the
     * JSII manifest.
     *
     * This makes it possible for the code doc comments to highlight things
     * slighly differently from the API Reference, and makes sure we don't
     * duplicate information.
     *
     * Unless the docs got changed, this yields the same output back as the one that
     * we originally saw (modulo whitespace changes).
     */
    overrideDocComment(symbol, docs, parameters) {
        var _a;
        if (!docs || !symbol) {
            return;
        }
        docs = this.docCommentDocs(docs);
        // Some symbols have multiple declarations (for example, a class + interface
        // mixins, or a property declartaion + constructor argument).
        //
        // We DON'T wwant to put the doc comment on the constructor argument, because it
        // looks silly there.
        for (const decl of (_a = symbol.getDeclarations()) !== null && _a !== void 0 ? _a : []) {
            if (ts.isParameter(decl)) {
                continue;
            }
            this.commentReplacer.overrideNodeDocComment(decl, docs_1.renderSymbolDocumentation(docs, parameters));
        }
    }
    /**
     * Return a potentially new set of Docs, for rendering back to a TypeScript doc comment
     *
     * We put the "(experimental)"/"(deprecated)" status into the doc
     * comment summary, so that it's presented front and center.
     */
    docCommentDocs(docs) {
        // Modify the summary if this API element has a special stability
        if (docs.stability === spec.Stability.Experimental && docs.summary) {
            return {
                ...docs,
                summary: `(experimental) ${docs.summary}`,
            };
        }
        if (docs.stability === spec.Stability.Deprecated && docs.summary) {
            return {
                ...docs,
                summary: `(deprecated) ${docs.summary}`,
            };
        }
        return docs;
    }
    /**
     * Return only those submodules from the submodules list that are submodules inside this
     * assembly.
     */
    mySubmodules() {
        return Array.from(this._submodules.values()).filter((m) => m.fqn.startsWith(`${this.projectInfo.name}.`));
    }
}
exports.Assembler = Assembler;
function _fingerprint(assembly) {
    delete assembly.fingerprint;
    assembly = sortJson(assembly);
    const fingerprint = crypto
        .createHash('sha256')
        .update(JSON.stringify(assembly))
        .digest('base64');
    return { ...assembly, fingerprint };
}
function _isAbstract(symbol, declaringType) {
    // everything is abstract in interfaces
    if (declaringType.kind === spec.TypeKind.Interface) {
        return true;
    }
    return (!!symbol.valueDeclaration &&
        (ts.getCombinedModifierFlags(symbol.valueDeclaration) &
            ts.ModifierFlags.Abstract) !==
            0);
}
function _isEnumLike(type) {
    return (type.flags & ts.TypeFlags.EnumLike) !== 0;
}
function _isExported(node) {
    return (ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) !== 0;
}
/**
 * Members with names starting with `_` (and marked as @internal) and members
 * that are private are hidden.
 *
 * @param symbol the symbol which should be assessed
 *
 * @return `true` if the symbol should be hidden
 */
function _isPrivate(symbol) {
    const TYPE_DECLARATION_KINDS = new Set([
        ts.SyntaxKind.ClassDeclaration,
        ts.SyntaxKind.InterfaceDeclaration,
        ts.SyntaxKind.EnumDeclaration,
    ]);
    // if the symbol doesn't have a value declaration, we are assuming it's a type (enum/interface/class)
    // and check that it has an "export" modifier
    if (!symbol.valueDeclaration ||
        TYPE_DECLARATION_KINDS.has(symbol.valueDeclaration.kind)) {
        let hasExport = false;
        for (const decl of symbol.declarations) {
            if (ts.getCombinedModifierFlags(decl) & ts.ModifierFlags.Export) {
                hasExport = true;
                break;
            }
            // Handle nested classes from project references
            if (ts.isModuleBlock(decl.parent)) {
                const moduleDeclaration = decl.parent.parent;
                const modifiers = ts.getCombinedModifierFlags(moduleDeclaration);
                // The trick is the module is declared as ambient & exported
                if ((modifiers & ts.ModifierFlags.Ambient) !== 0 &&
                    (modifiers & ts.ModifierFlags.Export) !== 0) {
                    hasExport = true;
                    break;
                }
            }
        }
        return !hasExport;
    }
    return (symbol.valueDeclaration &&
        (ts.getCombinedModifierFlags(symbol.valueDeclaration) &
            ts.ModifierFlags.Private) !==
            0);
}
function _hasInternalJsDocTag(symbol) {
    return symbol.getJsDocTags().some((t) => t.name === 'internal');
}
function _isProtected(symbol) {
    return (!!symbol.valueDeclaration &&
        (ts.getCombinedModifierFlags(symbol.valueDeclaration) &
            ts.ModifierFlags.Protected) !==
            0);
}
function _isStatic(symbol) {
    return (!!symbol.valueDeclaration &&
        (ts.getCombinedModifierFlags(symbol.valueDeclaration) &
            ts.ModifierFlags.Static) !==
            0);
}
function _isVoid(type) {
    return (type.flags & ts.TypeFlags.Void) !== 0;
}
function _isPromise(type) {
    var _a;
    return ((_a = type.symbol) === null || _a === void 0 ? void 0 : _a.escapedName) === 'Promise';
}
function _sortMembers(type) {
    type.methods = type.methods && _sort(type.methods);
    type.properties = type.properties && _sort(type.properties);
    return type;
    /**
     * Sorts a member array such that:
     * 1. Static members appear first
     * 2. Immutable members appear first
     * 3. Non-optional members appear first
     * 4. Members appear in lexicographical order
     *
     * @param values the array of members to be sorted
     *
     * @return a sorted copy of ``values``
     */
    function _sort(values) {
        if (!values) {
            return values;
        }
        return values.sort(_comparator);
        function _comparator(lval, rval) {
            return _format(lval).localeCompare(_format(rval));
            function _format(val) {
                return [
                    val.static ? '0' : '1',
                    val.immutable ? '0' : '1',
                    !val.optional ? '0' : '1',
                    val.name,
                ].join('|');
            }
        }
    }
}
/**
 * Return the last element from a list
 */
function last(xs) {
    return xs.length > 0 ? xs[xs.length - 1] : undefined;
}
/**
 * Apply a function to a value if it's not equal to undefined
 */
function apply(x, fn) {
    return x !== undefined ? fn(x) : undefined;
}
/**
 * Return the intersection of two sets
 */
function intersection(xs, ys) {
    const ret = new Set();
    for (const x of xs) {
        if (ys.has(x)) {
            ret.add(x);
        }
    }
    return ret;
}
/**
 * Return all members names of a JSII interface type
 *
 * Returns empty string for a non-interface type.
 */
function memberNames(jsiiType) {
    return Object.keys(typeMembers(jsiiType)).filter((n) => n !== '');
}
function typeMembers(jsiiType) {
    var _a, _b, _c;
    const ret = {};
    for (const prop of (_a = jsiiType.properties) !== null && _a !== void 0 ? _a : []) {
        ret[prop.name] = prop;
    }
    for (const method of (_b = jsiiType.methods) !== null && _b !== void 0 ? _b : []) {
        ret[(_c = method.name) !== null && _c !== void 0 ? _c : ''] = method;
    }
    return ret;
}
/**
 * Whether or not the given name is conventionally an interface name
 *
 * It's an interface name if it starts with I and has another capital
 * (so we don't mark IonicColumnProps as an interface).
 */
function isInterfaceName(name) {
    return (name.length >= 2 &&
        name.startsWith('I') &&
        name.charAt(1).toUpperCase() === name.charAt(1));
}
function getConstructor(type) {
    var _a;
    return (_a = type.symbol.members) === null || _a === void 0 ? void 0 : _a.get(ts.InternalSymbolName.Constructor);
}
function* intersect(xs, ys) {
    for (const x of xs) {
        if (ys.has(x)) {
            yield x;
        }
    }
}
function noEmptyDict(xs) {
    if (xs == null || Object.keys(xs).length === 0) {
        return undefined;
    }
    return xs;
}
function toDependencyClosure(assemblies) {
    const result = {};
    for (const assembly of assemblies) {
        if (!assembly.targets) {
            continue;
        }
        result[assembly.name] = {
            submodules: assembly.submodules,
            targets: assembly.targets,
        };
    }
    return result;
}
function toSubmoduleDeclarations(submodules) {
    const result = {};
    for (const submodule of submodules) {
        result[submodule.fqn] = {
            locationInModule: submodule.locationInModule,
            targets: submodule.targets,
            readme: submodule.readme,
        };
    }
    return result;
}
/**
 * Check whether this type is the intrinsic TypeScript "error type"
 *
 * This type is returned if type lookup fails. Unfortunately no public
 * accessors for it are exposed.
 */
function isErrorType(t) {
    return t.intrinsicName === 'error';
}
/**
 * Those have specific semantics in certain languages that don't always translate cleanly in others
 * (like how equals/hashCode are not a thing in Javascript, but carry meaning in Java and C#). The
 * `build` name is reserved for generated code (Java builders use that).
 */
const PROHIBITED_MEMBER_NAMES = ['build', 'equals', 'hashcode'];
/**
 * Whether the given name is prohibited
 */
function isProhibitedMemberName(name) {
    return PROHIBITED_MEMBER_NAMES.includes(name.toLowerCase());
}
/**
 * Information about the context in which a declaration is emitted.
 */
class EmitContext {
    constructor(namespace, stability) {
        this.namespace = namespace;
        this.stability = stability;
    }
    /**
     * Create a new EmitContext by appending a namespace entry at the end.
     * @param element the new namespace entry.
     */
    appendNamespace(element) {
        return new EmitContext([...this.namespace, element], this.stability);
    }
    /**
     * Create a new EmitContext by replacing the stability.
     * @param stability the new stability, if available.
     */
    replaceStability(stability) {
        if (!stability) {
            return this;
        }
        return new EmitContext(this.namespace, stability);
    }
    /**
     * Create a new EmitContext without stability.
     */
    removeStability() {
        return new EmitContext(this.namespace, undefined);
    }
}
async function flattenPromises(promises) {
    const result = new Array();
    for (const subset of await Promise.all(promises)) {
        result.push(...subset);
    }
    return result;
}
function inferRootDir(program) {
    const directories = program
        .getRootFileNames()
        .filter((fileName) => {
        const sourceFile = program.getSourceFile(fileName);
        return (sourceFile != null &&
            !program.isSourceFileFromExternalLibrary(sourceFile) &&
            !program.isSourceFileDefaultLibrary(sourceFile));
    })
        .map((fileName) => path.relative(program.getCurrentDirectory(), path.dirname(fileName)))
        .map(segmentPath);
    const maxPrefix = Math.min(...directories.map((segments) => segments.length - 1));
    let commonIndex = -1;
    while (commonIndex < maxPrefix &&
        new Set(directories.map((segments) => segments[commonIndex + 1])).size === 1) {
        commonIndex++;
    }
    if (commonIndex < 0) {
        return undefined;
    }
    return directories[0][commonIndex];
    function segmentPath(fileName) {
        const result = new Array();
        for (let parent = fileName; parent !== path.dirname(parent); parent = path.dirname(parent)) {
            result.unshift(parent);
        }
        return result;
    }
}
/**
 * Determines whether the provided type is a single-valued enum. It is necessary
 * to check as enums are union-like in the type model, and single-valued enum
 * types are actually reduced to the only available literal, which can trip
 * the assembler.
 *
 * @param type        the type being checked.
 * @param typeChecker the type checker to use to get more information.
 *
 * @return `true` if `type` is a single-valued enum type.
 */
function isSingleValuedEnum(type, typeChecker) {
    if (type.isLiteral() && _isEnumLike(type)) {
        // Single-Valued enums are reduced to the only literal available.
        return type === typeChecker.getBaseTypeOfLiteralType(type);
    }
    return false;
}
async function findPackageInfo(fromDir) {
    const filePath = path.join(fromDir, 'package.json');
    if (await fs.pathExists(filePath)) {
        return fs.readJson(filePath);
    }
    const parent = path.dirname(fromDir);
    if (parent === fromDir) {
        return undefined;
    }
    return findPackageInfo(parent);
}
function paramDocs(params) {
    const ret = {};
    for (const param of params !== null && params !== void 0 ? params : []) {
        if (param.docs) {
            ret[param.name] = param.docs;
        }
    }
    return ret;
}
/**
 * Checks is the provided type is "this" (as a type annotation).
 *
 * @param type        the validated type.
 * @param typeChecker the type checker.
 *
 * @returns `true` iif the type is `this`
 */
function _isThisType(type, typeChecker) {
    var _a;
    return ((_a = typeChecker.typeToTypeNode(type)) === null || _a === void 0 ? void 0 : _a.kind) === ts.SyntaxKind.ThisKeyword;
}
/**
 * Gets the name node for a given symbol; or it's first declaration if no name can be found. This is
 * intended for use in placing problem markers on the right location.
 *
 * @param symbol the symbol for which the name node is needed.
 *
 * @returns the name node for the symbol, or the symbol's first declaration.
 */
function _nameOrDeclarationNode(symbol) {
    var _a, _b;
    const declaration = (_a = symbol.valueDeclaration) !== null && _a !== void 0 ? _a : symbol.declarations[0];
    return (_b = ts.getNameOfDeclaration(declaration)) !== null && _b !== void 0 ? _b : declaration;
}
function _findHint(decl, hint) {
    const [node] = ts.getAllJSDocTags(decl, (tag) => tag.tagName.text === hint);
    return node;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNzZW1ibGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYXNzZW1ibGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLG1DQUFtQztBQUNuQyw2QkFBNkI7QUFDN0Isc0NBQXNDO0FBQ3RDLGlDQUFpQztBQUNqQyxpRUFBaUU7QUFDakUsd0NBQXlDO0FBQ3pDLCtCQUErQjtBQUMvQixpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCLGlDQUFpQztBQUVqQyxpQ0FLZ0I7QUFFaEIsdURBQW1EO0FBQ25ELHVDQUF1QztBQUN2Qyw0Q0FBNEM7QUFFNUMscURBQWtEO0FBQ2xELHdFQUFvRTtBQUNwRSw0RUFBZ0Y7QUFDaEYsNERBQW9FO0FBQ3BFLDBFQUFxRTtBQUNyRSw4Q0FBMEQ7QUFDMUQsbUNBQTJDO0FBQzNDLDJDQUF3QztBQUN4Qyx1Q0FBbUQ7QUFDbkQseUNBQTZDO0FBRTdDLHFHQUFxRztBQUNyRyxNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7QUFFdEMsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0FBRS9DOztHQUVHO0FBQ0gsTUFBYSxTQUFTO0lBeUJwQjs7OztPQUlHO0lBQ0gsWUFDa0IsV0FBd0IsRUFDeEIsT0FBbUIsRUFDbkIsTUFBYyxFQUM5QixVQUE0QixFQUFFOztRQUhkLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBQ3hCLFlBQU8sR0FBUCxPQUFPLENBQVk7UUFDbkIsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQWhDZixvQkFBZSxHQUFHLElBQUksdUNBQWlCLEVBQUUsQ0FBQztRQU9uRCxpQkFBWSxHQUFHLElBQUksS0FBSyxFQUFrQixDQUFDO1FBQzNDLGNBQVMsR0FBRyxJQUFJLEtBQUssRUFBa0IsQ0FBQztRQUN4QyxXQUFNLEdBQWlDLEVBQUUsQ0FBQztRQUVsRCwrQ0FBK0M7UUFDOUIsa0JBQWEsR0FBRyxJQUFJLEdBQUcsRUFBd0IsQ0FB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QUFDLEdBQUcsRUFBRSxDQUFDLGVBQWUsQ0FDL0IsSUFBSSxFQUNKLENBQUMsR0FBRyxFQUFzQixFQUFFLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUN2RCxDQUFDO0lBQ0YsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgc3BlYyBmcm9tICdAanNpaS9zcGVjJztcbmltcG9ydCAqIGFzIENhc2UgZnJvbSAnY2FzZSc7XG5pbXBvcnQgKiBhcyBjb2xvcnMgZnJvbSAnY29sb3JzL3NhZmUnO1xuaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuaW1wb3J0IGRlZXBFcXVhbCA9IHJlcXVpcmUoJ2RlZXAtZXF1YWwnKTtcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIGxvZzRqcyBmcm9tICdsb2c0anMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5pbXBvcnQge1xuICBnZXRSZWZlcmVuY2VkRG9jUGFyYW1zLFxuICBwYXJzZVN5bWJvbERvY3VtZW50YXRpb24sXG4gIHJlbmRlclN5bWJvbERvY3VtZW50YXRpb24sXG4gIFR5cGVTeXN0ZW1IaW50cyxcbn0gZnJvbSAnLi9kb2NzJztcbmltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tICcuL2VtaXR0ZXInO1xuaW1wb3J0IHsgSnNpaURpYWdub3N0aWMgfSBmcm9tICcuL2pzaWktZGlhZ25vc3RpYyc7XG5pbXBvcnQgKiBhcyBsaXRlcmF0ZSBmcm9tICcuL2xpdGVyYXRlJztcbmltcG9ydCAqIGFzIGJpbmRpbmdzIGZyb20gJy4vbm9kZS1iaW5kaW5ncyc7XG5pbXBvcnQgeyBQcm9qZWN0SW5mbyB9IGZyb20gJy4vcHJvamVjdC1pbmZvJztcbmltcG9ydCB7IGlzUmVzZXJ2ZWROYW1lIH0gZnJvbSAnLi9yZXNlcnZlZC13b3Jkcyc7XG5pbXBvcnQgeyBEZXByZWNhdGVkUmVtb3ZlciB9IGZyb20gJy4vdHJhbnNmb3Jtcy9kZXByZWNhdGVkLXJlbW92ZXInO1xuaW1wb3J0IHsgRGVwcmVjYXRpb25XYXJuaW5nc0luamVjdG9yIH0gZnJvbSAnLi90cmFuc2Zvcm1zL2RlcHJlY2F0aW9uLXdhcm5pbmdzJztcbmltcG9ydCB7IFJ1bnRpbWVUeXBlSW5mb0luamVjdG9yIH0gZnJvbSAnLi90cmFuc2Zvcm1zL3J1bnRpbWUtaW5mbyc7XG5pbXBvcnQgeyBUc0NvbW1lbnRSZXBsYWNlciB9IGZyb20gJy4vdHJhbnNmb3Jtcy90cy1jb21tZW50LXJlcGxhY2VyJztcbmltcG9ydCB7IGNvbWJpbmVkVHJhbnNmb3JtZXJzIH0gZnJvbSAnLi90cmFuc2Zvcm1zL3V0aWxzJztcbmltcG9ydCB7IHN5bWJvbElkZW50aWZpZXIgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IFZhbGlkYXRvciB9IGZyb20gJy4vdmFsaWRhdG9yJztcbmltcG9ydCB7IFNIT1JUX1ZFUlNJT04sIFZFUlNJT04gfSBmcm9tICcuL3ZlcnNpb24nO1xuaW1wb3J0IHsgZW5hYmxlZFdhcm5pbmdzIH0gZnJvbSAnLi93YXJuaW5ncyc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzXG5jb25zdCBzb3J0SnNvbiA9IHJlcXVpcmUoJ3NvcnQtanNvbicpO1xuXG5jb25zdCBMT0cgPSBsb2c0anMuZ2V0TG9nZ2VyKCdqc2lpL2Fzc2VtYmxlcicpO1xuXG4vKipcbiAqIFRoZSBKU0lJIEFzc2VtYmxlciBjb25zdW1lcyBhIGBgdHMuUHJvZ3JhbWBgIGluc3RhbmNlIGFuZCBlbWl0cyBhIEpTSUkgYXNzZW1ibHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBBc3NlbWJsZXIgaW1wbGVtZW50cyBFbWl0dGVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBjb21tZW50UmVwbGFjZXIgPSBuZXcgVHNDb21tZW50UmVwbGFjZXIoKTtcbiAgcHJpdmF0ZSByZWFkb25seSBydW50aW1lVHlwZUluZm9JbmplY3RvcjogUnVudGltZVR5cGVJbmZvSW5qZWN0b3I7XG4gIHByaXZhdGUgcmVhZG9ubHkgZGVwcmVjYXRlZFJlbW92ZXI/OiBEZXByZWNhdGVkUmVtb3ZlcjtcbiAgcHJpdmF0ZSByZWFkb25seSB3YXJuaW5nc0luamVjdG9yPzogRGVwcmVjYXRpb25XYXJuaW5nc0luamVjdG9yO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgbWFpbkZpbGU6IHN0cmluZztcblxuICBwcml2YXRlIF9kaWFnbm9zdGljcyA9IG5ldyBBcnJheTxKc2lpRGlhZ25vc3RpYz4oKTtcbiAgcHJpdmF0ZSBfZGVmZXJyZWQgPSBuZXcgQXJyYXk8RGVmZXJyZWRSZWNvcmQ+KCk7XG4gIHByaXZhdGUgX3R5cGVzOiB7IFtmcW46IHN0cmluZ106IHNwZWMuVHlwZSB9ID0ge307XG5cbiAgLyoqIE1hcCBvZiBTeW1ib2wgdG8gbmFtZXNwYWNlIGV4cG9ydCBTeW1ib2wgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBfc3VibW9kdWxlTWFwID0gbmV3IE1hcDx0cy5TeW1ib2wsIHRzLlN5bWJvbD4oKTtcblxuICAvKipcbiAgICogU3VibW9kdWxlIGluZm9ybWF0aW9uXG4gICAqXG4gICAqIENvbnRhaW5zIHN1Ym1vZHVsZSBpbmZvcm1hdGlvbiBmb3IgYWxsIG5hbWVzcGFjZXMgdGhhdCBoYXZlIGJlZW4gc2VlblxuICAgKiBhY3Jvc3MgYWxsIGFzc2VtYmxpZXMgKHRoaXMgYW5kIGRlcGVuZGVuY2llcykuXG4gICAqXG4gICAqIEZpbHRlcmVkIHRvIGxvY2FsIHN1Ym1vZHVsZXMgb25seSBhdCB0aW1lIG9mIHdyaXRpbmcgdGhlIGFzc2VtYmx5IG91dCB0byBkaXNrLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBfc3VibW9kdWxlcyA9IG5ldyBNYXA8dHMuU3ltYm9sLCBTdWJtb2R1bGVTcGVjPigpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gcHJvamVjdEluZm8gaW5mb3JtYXRpb24gYWJvdXQgdGhlIHBhY2thZ2UgYmVpbmcgYXNzZW1ibGVkXG4gICAqIEBwYXJhbSBwcm9ncmFtICAgICB0aGUgVHlwZVNjcmlwdCBwcm9ncmFtIHRvIGJlIGFzc2VtYmxlZCBmcm9tXG4gICAqIEBwYXJhbSBzdGRsaWIgICAgICB0aGUgZGlyZWN0b3J5IHdoZXJlIHRoZSBUeXBlU2NyaXB0IHN0ZGxpYiBpcyByb290ZWRcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcmVhZG9ubHkgcHJvamVjdEluZm86IFByb2plY3RJbmZvLFxuICAgIHB1YmxpYyByZWFkb25seSBwcm9ncmFtOiB0cy5Qcm9ncmFtLFxuICAgIHB1YmxpYyByZWFkb25seSBzdGRsaWI6IHN0cmluZyxcbiAgICBvcHRpb25zOiBBc3NlbWJsZXJPcHRpb25zID0ge30sXG4gICkge1xuICAgIGlmIChvcHRpb25zLnN0cmlwRGVwcmVjYXRlZCkge1xuICAgICAgbGV0IGFsbG93bGlzdGVkRGVwcmVjYXRpb25zOiBTZXQ8c3RyaW5nPiB8IHVuZGVmaW5lZDtcbiAgICAgIGlmIChvcHRpb25zLnN0cmlwRGVwcmVjYXRlZEFsbG93TGlzdEZpbGUpIHtcbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKG9wdGlvbnMuc3RyaXBEZXByZWNhdGVkQWxsb3dMaXN0RmlsZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgLS1zdHJpcC1kZXByZWNhdGVkIGZpbGUgbm90IGZvdW5kOiAke29wdGlvbnMuc3RyaXBEZXByZWNhdGVkQWxsb3dMaXN0RmlsZX1gLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYWxsb3dsaXN0ZWREZXByZWNhdGlvbnMgPSBuZXcgU2V0PHN0cmluZz4oXG4gICAgICAgICAgZnNcbiAgICAgICAgICAgIC5yZWFkRmlsZVN5bmMob3B0aW9ucy5zdHJpcERlcHJlY2F0ZWRBbGxvd0xpc3RGaWxlLCAndXRmOCcpXG4gICAgICAgICAgICAuc3BsaXQoJ1xcbicpLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRlcHJlY2F0ZWRSZW1vdmVyID0gbmV3IERlcHJlY2F0ZWRSZW1vdmVyKFxuICAgICAgICB0aGlzLl90eXBlQ2hlY2tlcixcbiAgICAgICAgYWxsb3dsaXN0ZWREZXByZWNhdGlvbnMsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFkZERlcHJlY2F0aW9uV2FybmluZ3MpIHtcbiAgICAgIHRoaXMud2FybmluZ3NJbmplY3RvciA9IG5ldyBEZXByZWNhdGlvbldhcm5pbmdzSW5qZWN0b3IoXG4gICAgICAgIHRoaXMuX3R5cGVDaGVja2VyLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBkdHMgPSBwcm9qZWN0SW5mby50eXBlcztcbiAgICBsZXQgbWFpbkZpbGUgPSBkdHMucmVwbGFjZSgvXFwuZFxcLnRzKHg/KSQvLCAnLnRzJDEnKTtcblxuICAgIC8vIElmIG91dC1vZi1zb3VyY2UgYnVpbGQgd2FzIGNvbmZpZ3VyZWQgKHRzYydzIG91dERpciBhbmQgcm9vdERpciksIHRoZVxuICAgIC8vIG1haW4gZmlsZSdzIHBhdGggbmVlZHMgdG8gYmUgcmUtcm9vdGVkIGZyb20gdGhlIG91dERpciBpbnRvIHRoZSByb290RGlyLlxuICAgIGNvbnN0IHRzY091dERpciA9IHByb2dyYW0uZ2V0Q29tcGlsZXJPcHRpb25zKCkub3V0RGlyO1xuICAgIGlmICh0c2NPdXREaXIgIT0gbnVsbCkge1xuICAgICAgbWFpbkZpbGUgPSBwYXRoLnJlbGF0aXZlKHRzY091dERpciwgbWFpbkZpbGUpO1xuXG4gICAgICAvLyByb290RGlyIG1heSBiZSBzZXQgZXhwbGljaXRseSBvciBub3QuIElmIG5vdCwgaW5mZXJSb290RGlyIHJlcGxpY2F0ZXNcbiAgICAgIC8vIHRzYydzIGJlaGF2aW9yIG9mIHVzaW5nIHRoZSBsb25nZXN0IHByZWZpeCBvZiBhbGwgYnVpbHQgc291cmNlIGZpbGVzLlxuICAgICAgY29uc3QgdHNjUm9vdERpciA9XG4gICAgICAgIHByb2dyYW0uZ2V0Q29tcGlsZXJPcHRpb25zKCkucm9vdERpciA/PyBpbmZlclJvb3REaXIocHJvZ3JhbSk7XG4gICAgICBpZiAodHNjUm9vdERpciAhPSBudWxsKSB7XG4gICAgICAgIG1haW5GaWxlID0gcGF0aC5qb2luKHRzY1Jvb3REaXIsIG1haW5GaWxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1haW5GaWxlID0gcGF0aC5yZXNvbHZlKHByb2plY3RJbmZvLnByb2plY3RSb290LCBtYWluRmlsZSk7XG4gICAgdGhpcy5ydW50aW1lVHlwZUluZm9JbmplY3RvciA9IG5ldyBSdW50aW1lVHlwZUluZm9JbmplY3RvcihcbiAgICAgIHByb2plY3RJbmZvLnZlcnNpb24sXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgY3VzdG9tVHJhbnNmb3JtZXJzKCk6IHRzLkN1c3RvbVRyYW5zZm9ybWVycyB7XG4gICAgcmV0dXJuIGNvbWJpbmVkVHJhbnNmb3JtZXJzKFxuICAgICAgdGhpcy5kZXByZWNhdGVkUmVtb3Zlcj8uY3VzdG9tVHJhbnNmb3JtZXJzID8/IHt9LFxuICAgICAgdGhpcy5ydW50aW1lVHlwZUluZm9JbmplY3Rvci5tYWtlVHJhbnNmb3JtZXJzKCksXG4gICAgICB0aGlzLmNvbW1lbnRSZXBsYWNlci5tYWtlVHJhbnNmb3JtZXJzKCksXG4gICAgICB0aGlzLndhcm5pbmdzSW5qZWN0b3I/LmN1c3RvbVRyYW5zZm9ybWVycyA/PyB7fSxcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgX3R5cGVDaGVja2VyKCk6IHRzLlR5cGVDaGVja2VyIHtcbiAgICByZXR1cm4gdGhpcy5wcm9ncmFtLmdldFR5cGVDaGVja2VyKCk7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdCBlbWl0dGluZyB0aGUgSlNJSSBhc3NlbWJseSBmb3IgdGhlIHByb2dyYW0uXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgYXNzZW1ibHkgZW1pc3Npb24uXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZW1pdCgpOiBQcm9taXNlPHRzLkVtaXRSZXN1bHQ+IHtcbiAgICB0aGlzLl9kaWFnbm9zdGljcyA9IFtdO1xuICAgIGlmICghdGhpcy5wcm9qZWN0SW5mby5kZXNjcmlwdGlvbikge1xuICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8wMDAxX1BLR19NSVNTSU5HX0RFU0NSSVBUSU9OLmNyZWF0ZURldGFjaGVkKCksXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucHJvamVjdEluZm8uaG9tZXBhZ2UpIHtcbiAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfMDAwMl9QS0dfTUlTU0lOR19IT01FUEFHRS5jcmVhdGVEZXRhY2hlZCgpLFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVhZG1lID0gYXdhaXQgX2xvYWRSZWFkbWUuY2FsbCh0aGlzKTtcbiAgICBpZiAocmVhZG1lID09IG51bGwpIHtcbiAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfMDAwM19NSVNTSU5HX1JFQURNRS5jcmVhdGVEZXRhY2hlZCgpLFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZG9jcyA9IF9sb2FkRG9jcy5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fdHlwZXMgPSB7fTtcbiAgICB0aGlzLl9kZWZlcnJlZCA9IFtdO1xuICAgIGNvbnN0IHZpc2l0UHJvbWlzZXMgPSBuZXcgQXJyYXk8UHJvbWlzZTxhbnk+PigpO1xuXG4gICAgY29uc3Qgc291cmNlRmlsZSA9IHRoaXMucHJvZ3JhbS5nZXRTb3VyY2VGaWxlKHRoaXMubWFpbkZpbGUpO1xuXG4gICAgaWYgKHNvdXJjZUZpbGUgPT0gbnVsbCkge1xuICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8wMDA0X0NPVUxEX05PVF9GSU5EX0VOVFJZUE9JTlQuY3JlYXRlRGV0YWNoZWQoXG4gICAgICAgICAgdGhpcy5tYWluRmlsZSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHRoaXMuX3JlZ2lzdGVyRGVwZW5kZW5jaWVzTmFtZXNwYWNlcyhzb3VyY2VGaWxlKTtcblxuICAgICAgaWYgKExPRy5pc1RyYWNlRW5hYmxlZCgpKSB7XG4gICAgICAgIExPRy50cmFjZShcbiAgICAgICAgICBgUHJvY2Vzc2luZyBzb3VyY2UgZmlsZTogJHtjb2xvcnMuYmx1ZShcbiAgICAgICAgICAgIHBhdGgucmVsYXRpdmUodGhpcy5wcm9qZWN0SW5mby5wcm9qZWN0Um9vdCwgc291cmNlRmlsZS5maWxlTmFtZSksXG4gICAgICAgICAgKX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3ltYm9sID0gdGhpcy5fdHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChzeW1ib2wpIHtcbiAgICAgICAgY29uc3QgbW9kdWxlRXhwb3J0cyA9IHRoaXMuX3R5cGVDaGVja2VyLmdldEV4cG9ydHNPZk1vZHVsZShzeW1ib2wpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBtb2R1bGVFeHBvcnRzLm1hcCgoaXRlbSkgPT5cbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyTmFtZXNwYWNlcyhpdGVtLCB0aGlzLnByb2plY3RJbmZvLnByb2plY3RSb290KSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgbW9kdWxlRXhwb3J0cykge1xuICAgICAgICAgIHZpc2l0UHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0Tm9kZShcbiAgICAgICAgICAgICAgbm9kZS5kZWNsYXJhdGlvbnNbMF0sXG4gICAgICAgICAgICAgIG5ldyBFbWl0Q29udGV4dChbXSwgdGhpcy5wcm9qZWN0SW5mby5zdGFiaWxpdHkpLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwodmlzaXRQcm9taXNlcyk7XG5cbiAgICB0aGlzLmNhbGxEZWZlcnJlZHNJbk9yZGVyKCk7XG5cbiAgICAvLyBTa2lwIGVtaXR0aW5nIGlmIGFueSBkaWFnbm9zdGljIG1lc3NhZ2UgaXMgYW4gZXJyb3JcbiAgICBpZiAoXG4gICAgICB0aGlzLl9kaWFnbm9zdGljcy5maW5kKFxuICAgICAgICAoZGlhZykgPT4gZGlhZy5jYXRlZ29yeSA9PT0gdHMuRGlhZ25vc3RpY0NhdGVnb3J5LkVycm9yLFxuICAgICAgKSAhPSBudWxsXG4gICAgKSB7XG4gICAgICBMT0cuZGVidWcoJ1NraXBwaW5nIGVtaXQgZHVlIHRvIGVycm9ycy4nKTtcbiAgICAgIC8vIENsZWFyaW5nIGBgdGhpcy5fdHlwZXNgYCB0byBhbGxvdyBjb250ZW50cyB0byBiZSBnYXJiYWdlLWNvbGxlY3RlZC5cbiAgICAgIGRlbGV0ZSB0aGlzLl90eXBlcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7IGRpYWdub3N0aWNzOiB0aGlzLl9kaWFnbm9zdGljcywgZW1pdFNraXBwZWQ6IHRydWUgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIC8vIENsZWFyaW5nIGBgdGhpcy5fZGlhZ25vc3RpY3NgYCB0byBhbGxvdyBjb250ZW50cyB0byBiZSBnYXJiYWdlLWNvbGxlY3RlZC5cbiAgICAgICAgZGVsZXRlIHRoaXMuX2RpYWdub3N0aWNzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGpzaWlWZXJzaW9uID1cbiAgICAgIHRoaXMucHJvamVjdEluZm8uanNpaVZlcnNpb25Gb3JtYXQgPT09ICdzaG9ydCcgPyBTSE9SVF9WRVJTSU9OIDogVkVSU0lPTjtcblxuICAgIGNvbnN0IGFzc2VtYmx5OiBzcGVjLkFzc2VtYmx5ID0ge1xuICAgICAgc2NoZW1hOiBzcGVjLlNjaGVtYVZlcnNpb24uTEFURVNULFxuICAgICAgbmFtZTogdGhpcy5wcm9qZWN0SW5mby5uYW1lLFxuICAgICAgdmVyc2lvbjogdGhpcy5wcm9qZWN0SW5mby52ZXJzaW9uLFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMucHJvamVjdEluZm8uZGVzY3JpcHRpb24gPz8gdGhpcy5wcm9qZWN0SW5mby5uYW1lLFxuICAgICAgbGljZW5zZTogdGhpcy5wcm9qZWN0SW5mby5saWNlbnNlLFxuICAgICAga2V5d29yZHM6IHRoaXMucHJvamVjdEluZm8ua2V5d29yZHMsXG4gICAgICBob21lcGFnZTogdGhpcy5wcm9qZWN0SW5mby5ob21lcGFnZSA/PyB0aGlzLnByb2plY3RJbmZvLnJlcG9zaXRvcnkudXJsLFxuICAgICAgYXV0aG9yOiB0aGlzLnByb2plY3RJbmZvLmF1dGhvcixcbiAgICAgIGNvbnRyaWJ1dG9yczogdGhpcy5wcm9qZWN0SW5mby5jb250cmlidXRvcnMgJiYgW1xuICAgICAgICAuLi50aGlzLnByb2plY3RJbmZvLmNvbnRyaWJ1dG9ycyxcbiAgICAgIF0sXG4gICAgICByZXBvc2l0b3J5OiB0aGlzLnByb2plY3RJbmZvLnJlcG9zaXRvcnksXG4gICAgICBkZXBlbmRlbmNpZXM6IG5vRW1wdHlEaWN0KHtcbiAgICAgICAgLi4udGhpcy5wcm9qZWN0SW5mby5kZXBlbmRlbmNpZXMsXG4gICAgICAgIC4uLnRoaXMucHJvamVjdEluZm8ucGVlckRlcGVuZGVuY2llcyxcbiAgICAgIH0pLFxuICAgICAgZGVwZW5kZW5jeUNsb3N1cmU6IG5vRW1wdHlEaWN0KFxuICAgICAgICB0b0RlcGVuZGVuY3lDbG9zdXJlKHRoaXMucHJvamVjdEluZm8uZGVwZW5kZW5jeUNsb3N1cmUpLFxuICAgICAgKSxcbiAgICAgIGJ1bmRsZWQ6IHRoaXMucHJvamVjdEluZm8uYnVuZGxlRGVwZW5kZW5jaWVzLFxuICAgICAgdHlwZXM6IHRoaXMuX3R5cGVzLFxuICAgICAgc3VibW9kdWxlczogbm9FbXB0eURpY3QodG9TdWJtb2R1bGVEZWNsYXJhdGlvbnModGhpcy5teVN1Ym1vZHVsZXMoKSkpLFxuICAgICAgdGFyZ2V0czogdGhpcy5wcm9qZWN0SW5mby50YXJnZXRzLFxuICAgICAgbWV0YWRhdGE6IHRoaXMucHJvamVjdEluZm8ubWV0YWRhdGEsXG4gICAgICBkb2NzLFxuICAgICAgcmVhZG1lLFxuICAgICAganNpaVZlcnNpb24sXG4gICAgICBiaW46IHRoaXMucHJvamVjdEluZm8uYmluLFxuICAgICAgZmluZ2VycHJpbnQ6ICc8VEJEPicsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLmRlcHJlY2F0ZWRSZW1vdmVyKSB7XG4gICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKC4uLnRoaXMuZGVwcmVjYXRlZFJlbW92ZXIucmVtb3ZlRnJvbShhc3NlbWJseSkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLndhcm5pbmdzSW5qZWN0b3IpIHtcbiAgICAgIGNvbnN0IGpzaWlNZXRhZGF0YSA9IHtcbiAgICAgICAgLi4uKGFzc2VtYmx5Lm1ldGFkYXRhPy5qc2lpID8/IHt9KSxcbiAgICAgICAgLi4ueyBjb21waWxlZFdpdGhEZXByZWNhdGlvbldhcm5pbmdzOiB0cnVlIH0sXG4gICAgICB9O1xuXG4gICAgICBpZiAoYXNzZW1ibHkubWV0YWRhdGEpIHtcbiAgICAgICAgYXNzZW1ibHkubWV0YWRhdGEuanNpaSA9IGpzaWlNZXRhZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2VtYmx5Lm1ldGFkYXRhID0geyBqc2lpOiBqc2lpTWV0YWRhdGEgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMud2FybmluZ3NJbmplY3Rvci5wcm9jZXNzKGFzc2VtYmx5LCB0aGlzLnByb2plY3RJbmZvKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKHRoaXMucHJvamVjdEluZm8sIGFzc2VtYmx5KTtcbiAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgdmFsaWRhdG9yLmVtaXQoKTtcbiAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHQuZW1pdFNraXBwZWQpIHtcbiAgICAgIGNvbnN0IGFzc2VtYmx5UGF0aCA9IHBhdGguam9pbih0aGlzLnByb2plY3RJbmZvLnByb2plY3RSb290LCAnLmpzaWknKTtcbiAgICAgIExPRy50cmFjZShgRW1pdHRpbmcgYXNzZW1ibHk6ICR7Y29sb3JzLmJsdWUoYXNzZW1ibHlQYXRoKX1gKTtcbiAgICAgIGF3YWl0IGZzLndyaXRlSnNvbihhc3NlbWJseVBhdGgsIF9maW5nZXJwcmludChhc3NlbWJseSksIHtcbiAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgc3BhY2VzOiAyLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpYWdub3N0aWNzOiBbLi4udGhpcy5fZGlhZ25vc3RpY3MsIC4uLnZhbGlkYXRpb25SZXN1bHQuZGlhZ25vc3RpY3NdLFxuICAgICAgICBlbWl0U2tpcHBlZDogdmFsaWRhdGlvblJlc3VsdC5lbWl0U2tpcHBlZCxcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIENsZWFyaW5nIGBgdGhpcy5fdHlwZXNgYCB0byBhbGxvdyBjb250ZW50cyB0byBiZSBnYXJiYWdlLWNvbGxlY3RlZC5cbiAgICAgIGRlbGV0ZSB0aGlzLl90eXBlcztcblxuICAgICAgLy8gQ2xlYXJpbmcgYGB0aGlzLl9kaWFnbm9zdGljc2BgIHRvIGFsbG93IGNvbnRlbnRzIHRvIGJlIGdhcmJhZ2UtY29sbGVjdGVkLlxuICAgICAgZGVsZXRlIHRoaXMuX2RpYWdub3N0aWNzO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIF9sb2FkUmVhZG1lKHRoaXM6IEFzc2VtYmxlcikge1xuICAgICAgLy8gU2VhcmNoIGZvciBgUkVBRE1FLm1kYCBpbiBhIGNhc2UtaW5zZW5zaXRpdmUgd2F5XG4gICAgICBjb25zdCBmaWxlTmFtZSA9IChhd2FpdCBmcy5yZWFkZGlyKHRoaXMucHJvamVjdEluZm8ucHJvamVjdFJvb3QpKS5maW5kKFxuICAgICAgICAoZmlsZSkgPT4gZmlsZS50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSAncmVhZG1lLm1kJyxcbiAgICAgICk7XG4gICAgICBpZiAoZmlsZU5hbWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVhZG1lUGF0aCA9IHBhdGguam9pbih0aGlzLnByb2plY3RJbmZvLnByb2plY3RSb290LCBmaWxlTmFtZSk7XG4gICAgICBjb25zdCByZW5kZXJlZExpbmVzID0gYXdhaXQgbGl0ZXJhdGUuaW5jbHVkZUFuZFJlbmRlckV4YW1wbGVzKFxuICAgICAgICBhd2FpdCBsaXRlcmF0ZS5sb2FkRnJvbUZpbGUocmVhZG1lUGF0aCksXG4gICAgICAgIGxpdGVyYXRlLmZpbGVTeXN0ZW1Mb2FkZXIodGhpcy5wcm9qZWN0SW5mby5wcm9qZWN0Um9vdCksXG4gICAgICApO1xuICAgICAgcmV0dXJuIHsgbWFya2Rvd246IHJlbmRlcmVkTGluZXMuam9pbignXFxuJykgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfbG9hZERvY3ModGhpczogQXNzZW1ibGVyKTogc3BlYy5Eb2NzIHwgdW5kZWZpbmVkIHtcbiAgICAgIGlmICghdGhpcy5wcm9qZWN0SW5mby5zdGFiaWxpdHkgJiYgIXRoaXMucHJvamVjdEluZm8uZGVwcmVjYXRlZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVwcmVjYXRlZCA9IHRoaXMucHJvamVjdEluZm8uZGVwcmVjYXRlZDtcbiAgICAgIGNvbnN0IHN0YWJpbGl0eSA9IHRoaXMucHJvamVjdEluZm8uc3RhYmlsaXR5O1xuICAgICAgcmV0dXJuIHsgZGVwcmVjYXRlZCwgc3RhYmlsaXR5IH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlZmVyIGEgY2FsbGJhY2sgdW50aWwgYSAoc2V0IG9mKSB0eXBlcyBhcmUgYXZhaWxhYmxlXG4gICAqXG4gICAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gYXJvdW5kIF9kZWZlcigpIHdoaWNoIGVuY2Fwc3VsYXRlcyB0aGUgX2RlcmVmZXJlbmNlXG4gICAqIGFjdGlvbiAod2hpY2ggaXMgYmFzaWNhbGx5IHRoZSBtYWpvcml0eSB1c2UgY2FzZSBmb3IgX2RlZmVyIGFueXdheSkuXG4gICAqXG4gICAqIFdpbGwgbm90IGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCBhbnkgJ3VuZGVmaW5lZCdzOyBhbiBlcnJvciB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuIGVtaXR0ZWQgaW5cbiAgICogdGhhdCBjYXNlIGFueXdheS5cbiAgICpcbiAgICogQHBhcmFtIGZxbiBGUU4gb2YgdGhlIGN1cnJlbnQgdHlwZSAodGhlIHR5cGUgdGhhdCBoYXMgYSBkZXBlbmRlbmN5IG9uIGJhc2VUeXBlcylcbiAgICogQHBhcmFtIGJhc2VUeXBlcyBBcnJheSBvZiB0eXBlIHJlZmVyZW5jZXMgdG8gYmUgbG9va2VkIHVwXG4gICAqIEBwYXJhbSByZWZlcmVuY2luZ05vZGUgTm9kZSB0byByZXBvcnQgYSBkaWFnbm9zdGljIG9uIGlmIHdlIGZhaWwgdG8gbG9vayB1cCBhIHQgeXBlXG4gICAqIEBwYXJhbSBjYiBDYWxsYmFjayB0byBiZSBpbnZva2VkIHdpdGggdGhlIFR5cGVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIFR5cGVSZWZlcmVuY2VzIGluIGJhc2VUeXBlc1xuICAgKi9cbiAgcHJpdmF0ZSBfZGVmZXJVbnRpbFR5cGVzQXZhaWxhYmxlKFxuICAgIGZxbjogc3RyaW5nLFxuICAgIGJhc2VUeXBlczogQXJyYXk8c3RyaW5nIHwgc3BlYy5OYW1lZFR5cGVSZWZlcmVuY2U+LFxuICAgIHJlZmVyZW5jaW5nTm9kZTogdHMuTm9kZSxcbiAgICBjYjogKC4uLnhzOiBzcGVjLlR5cGVbXSkgPT4gdm9pZCxcbiAgKSB7XG4gICAgLy8gV2UgY2FuIGRvIHRoaXMgb25lIGVhZ2VybHlcbiAgICBpZiAoYmFzZVR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2IoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYmFzZUZxbnMgPSBiYXNlVHlwZXMubWFwKChidCkgPT5cbiAgICAgIHR5cGVvZiBidCA9PT0gJ3N0cmluZycgPyBidCA6IGJ0LmZxbixcbiAgICApO1xuXG4gICAgdGhpcy5fZGVmZXIoZnFuLCBiYXNlRnFucywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzb2x2ZWQgPSBiYXNlRnFuc1xuICAgICAgICAubWFwKCh4KSA9PiB0aGlzLl9kZXJlZmVyZW5jZSh4LCByZWZlcmVuY2luZ05vZGUpKVxuICAgICAgICAuZmlsdGVyKCh4KSA9PiB4ICE9PSB1bmRlZmluZWQpO1xuICAgICAgaWYgKHJlc29sdmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2IoLi4uKHJlc29sdmVkIGFzIHNwZWMuVHlwZVtdKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVmZXIgY2hlY2tzIGZvciBhZnRlciB0aGUgcHJvZ3JhbSBoYXMgYmVlbiBlbnRpcmVseSBwcm9jZXNzZWQ7IHVzZWZ1bCBmb3IgdmVyaWZ5aW5nIHR5cGUgcmVmZXJlbmNlcyB0aGF0IG1heSBub3RcbiAgICogaGF2ZSBiZWVuIGRpc2NvdmVyZWQgeWV0LCBhbmQgdmVyaWZ5aW5nIHByb3BlcnRpZXMgYWJvdXQgdGhlbS5cbiAgICpcbiAgICogVGhlIGNhbGxiYWNrIGlzIGd1YXJhbnRlZWQgdG8gYmUgZXhlY3V0ZWQgb25seSBhZnRlciBhbGwgZGVmZXJyZWRzIGZvciBhbGwgdHlwZXMgaW4gJ2RlcGVuZGVkRnFucycgaGF2ZVxuICAgKiBiZWVuIGV4ZWN1dGVkLlxuICAgKlxuICAgKiBAcGFyYW0gZnFuIEZRTiBvZiB0aGUgY3VycmVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGVwZW5kZWRGcW5zIExpc3Qgb2YgRlFOcyBvZiB0eXBlcyB0aGlzIGNhbGxiYWNrIGRlcGVuZHMgb24uIEFsbCBkZWZlcnJlZHMgZm9yIGFsbFxuICAgKiBAcGFyYW0gY2IgdGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpbiBhIGRlZmVycmVkIHdheS4gSXQgd2lsbCBiZSBib3VuZCB3aXRoIGBgdGhpc2BgLCBzbyBpdCBjYW4gZGVwZW5kIG9uIHVzaW5nXG4gICAqICAgICAgICAgICBgYHRoaXNgYC5cbiAgICovXG4gIHByaXZhdGUgX2RlZmVyKGZxbjogc3RyaW5nLCBkZXBlbmRlZEZxbnM6IHN0cmluZ1tdLCBjYjogKCkgPT4gdm9pZCkge1xuICAgIHRoaXMuX2RlZmVycmVkLnB1c2goeyBmcW4sIGRlcGVuZGVkRnFucywgY2I6IGNiLmJpbmQodGhpcykgfSk7XG4gIH1cblxuICAvKipcbiAgICogT2J0YWlucyB0aGUgYGBzcGVjLlR5cGVgYCBmb3IgYSBnaXZlbiBgYHNwZWMuTmFtZWRUeXBlUmVmZXJlbmNlYGAuXG4gICAqXG4gICAqIEBwYXJhbSByZWYgdGhlIHR5cGUgcmVmZXJlbmNlIHRvIGJlIGRlLXJlZmVyZW5jZWRcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGRlLXJlZmVyZW5jZWQgdHlwZSwgaWYgaXQgd2FzIGZvdW5kLCBvdGhlcndpc2UgYGB1bmRlZmluZWRgYC5cbiAgICovXG4gIHByaXZhdGUgX2RlcmVmZXJlbmNlKFxuICAgIHJlZjogc3RyaW5nIHwgc3BlYy5OYW1lZFR5cGVSZWZlcmVuY2UsXG4gICAgcmVmZXJlbmNpbmdOb2RlOiB0cy5Ob2RlIHwgdW5kZWZpbmVkLFxuICApOiBzcGVjLlR5cGUgfCB1bmRlZmluZWQge1xuICAgIGlmICh0eXBlb2YgcmVmICE9PSAnc3RyaW5nJykge1xuICAgICAgcmVmID0gcmVmLmZxbjtcbiAgICB9XG5cbiAgICBjb25zdCBbYXNzbV0gPSByZWYuc3BsaXQoJy4nKTtcbiAgICBsZXQgdHlwZTtcbiAgICBpZiAoYXNzbSA9PT0gdGhpcy5wcm9qZWN0SW5mby5uYW1lKSB7XG4gICAgICB0eXBlID0gdGhpcy5fdHlwZXNbcmVmXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYXNzZW1ibHkgPSB0aGlzLnByb2plY3RJbmZvLmRlcGVuZGVuY3lDbG9zdXJlLmZpbmQoXG4gICAgICAgIChkZXApID0+IGRlcC5uYW1lID09PSBhc3NtLFxuICAgICAgKTtcbiAgICAgIHR5cGUgPSBhc3NlbWJseT8udHlwZXM/LltyZWZdO1xuXG4gICAgICAvLyBzaW5jZSB3ZSBhcmUgZXhwb3NpbmcgYSB0eXBlIG9mIHRoaXMgYXNzZW1ibHkgaW4gdGhpcyBtb2R1bGUncyBwdWJsaWMgQVBJLFxuICAgICAgLy8gd2UgZXhwZWN0IGl0IHRvIGFwcGVhciBhcyBhIHBlZXIgZGVwZW5kZW5jeSBpbnN0ZWFkIG9mIGEgbm9ybWFsIGRlcGVuZGVuY3kuXG4gICAgICBpZiAoYXNzZW1ibHkpIHtcbiAgICAgICAgaWYgKCEoYXNzZW1ibHkubmFtZSBpbiB0aGlzLnByb2plY3RJbmZvLnBlZXJEZXBlbmRlbmNpZXMpKSB7XG4gICAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfMDAwNV9NSVNTSU5HX1BFRVJfREVQRU5ERU5DWS5jcmVhdGUoXG4gICAgICAgICAgICAgIHJlZmVyZW5jaW5nTm9kZSEsIC8vIENoZWF0aW5nIGhlcmUgZm9yIG5vdywgdW50aWwgdGhlIHJlZmVyZW5jaW5nTm9kZSBjYW4gYmUgbWFkZSByZXF1aXJlZFxuICAgICAgICAgICAgICBhc3NlbWJseS5uYW1lLFxuICAgICAgICAgICAgICByZWYsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfOTAwMl9VTlJFU09MVkVBQkxFX1RZUEUuY3JlYXRlKFxuICAgICAgICAgIHJlZmVyZW5jaW5nTm9kZSEsIC8vIENoZWF0aW5nIGhlcmUgZm9yIG5vdywgdW50aWwgdGhlIHJlZmVyZW5jaW5nTm9kZSBjYW4gYmUgbWFkZSByZXF1aXJlZFxuICAgICAgICAgIHJlZixcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgSlNJSSBmdWxseSBxdWFsaWZpZWQgbmFtZSBjb3JyZXNwb25kaW5nIHRvIGEgYGB0cy5UeXBlYGAgaW5zdGFuY2UuIElmIGZvciBhbnkgcmVhc29uIGEgbmFtZSBjYW5ub3QgYmVcbiAgICogY29tcHV0ZWQgZm9yIHRoZSB0eXBlLCBhIG1hcmtlciBpcyByZXR1cm5lZCBpbnN0ZWFkLCBhbmQgYW4gYGB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuRXJyb3JgYCBkaWFnbm9zdGljIGlzXG4gICAqIGluc2VydGVkIGluIHRoZSBhc3NlbWJsZXIgY29udGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgZm9yIHdoaWNoIGEgSlNJSSBmdWxseSBxdWFsaWZpZWQgbmFtZSBpcyBuZWVkZWQuXG4gICAqIEBwYXJhbSB0eXBlQW5ub3RhdGlvbk5vZGUgdGhlIHR5cGUgYW5ub3RhdGlvbiBmb3Igd2hpY2ggdGhpcyBGUU4gaXMgZ2VuZXJhdGVkLiBUaGlzIGlzIHVzZWQgZm9yIGF0dGFjaGluZyB0aGUgZXJyb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXIuIFdoZW4gdGhlcmUgaXMgbm8gZXhwbGljaXQgdHlwZSBhbm5vdGF0aW9uIChlLmc6IGluZmVycmVkIG1ldGhvZCByZXR1cm4gdHlwZSksIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcnJlZCBzdWJzdGl0dXRlIGlzIHRoZSBcInR5cGUtaW5mZXJyZWRcIiBlbGVtZW50J3MgbmFtZS5cbiAgICogQHBhcmFtIHR5cGVVc2UgdGhlIHJlYXNvbiB3aHkgdGhpcyB0eXBlIHdhcyByZXNvbHZlZCAoZS5nOiBcInJldHVybiB0eXBlXCIpXG4gICAqIEBwYXJhbSBpc1RoaXNUeXBlIHdoZXRoZXIgdGhpcyB0eXBlIHdhcyBzcGVjaWZpZWQgb3IgaW5mZXJyZWQgYXMgXCJ0aGlzXCIgb3Igbm90XG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBGUU4gb2YgdGhlIHR5cGUsIG9yIHNvbWUgXCJ1bmtub3duXCIgbWFya2VyLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfZ2V0RlFOKFxuICAgIHR5cGU6IHRzLlR5cGUsXG4gICAgdHlwZUFubm90YXRpb25Ob2RlOiB0cy5Ob2RlLFxuICAgIHR5cGVVc2U6IFR5cGVVc2VLaW5kLFxuICAgIGlzVGhpc1R5cGU6IGJvb2xlYW4sXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3Qgc2luZ2xlVmFsdWVkRW51bSA9IGlzU2luZ2xlVmFsdWVkRW51bSh0eXBlLCB0aGlzLl90eXBlQ2hlY2tlcik7XG5cbiAgICBjb25zdCB0c0Z1bGxOYW1lID0gdGhpcy5fdHlwZUNoZWNrZXIuZ2V0RnVsbHlRdWFsaWZpZWROYW1lKHR5cGUuc3ltYm9sKTtcbiAgICBjb25zdCB0c05hbWUgPSBzaW5nbGVWYWx1ZWRFbnVtXG4gICAgICA/IC8vIElmIGl0J3MgYSBzaW5nbGUtdmFsdWVkIGVudW0sIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBsYXN0IHF1YWxpZmllciB0byBnZXQgYmFjayB0byB0aGUgZW51bS5cbiAgICAgICAgdHNGdWxsTmFtZS5yZXBsYWNlKC9cXC5bXi5dKyQvLCAnJylcbiAgICAgIDogdHNGdWxsTmFtZTtcblxuICAgIGxldCB0eXBlRGVjbGFyYXRpb24gPSBzaW5nbGVWYWx1ZWRFbnVtXG4gICAgICA/IC8vIElmIGl0J3MgYSBzaW5nbGUtdmFsdWVkIGVudW0sIHdlIG5lZWQgdG8gbW92ZSB0byB0aGUgcGFyZW50IHRvIGhhdmUgdGhlIGVudW0gZGVjbGFyYXRpb25cbiAgICAgICAgdHlwZS5zeW1ib2wudmFsdWVEZWNsYXJhdGlvbi5wYXJlbnRcbiAgICAgIDogdHlwZS5zeW1ib2wudmFsdWVEZWNsYXJhdGlvbjtcbiAgICBpZiAoIXR5cGVEZWNsYXJhdGlvbiAmJiB0eXBlLnN5bWJvbC5kZWNsYXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgdHlwZURlY2xhcmF0aW9uID0gdHlwZS5zeW1ib2wuZGVjbGFyYXRpb25zWzBdO1xuICAgIH1cblxuICAgIC8vIFNldCB0byB0cnVlIHRvIHByZXZlbnQgZnVydGhlciBhZGRpbmcgb2YgRXJyb3IgZGlhZ25vc3RpY3MgZm9yIGtub3duLWJhZCByZWZlcmVuY2VcbiAgICBsZXQgaGFzRXJyb3IgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLl9pc1ByaXZhdGVPckludGVybmFsKHR5cGUuc3ltYm9sKSkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyB0eXBlIGlzIFwidGhpc1wiIChleHBsaWNpdCBvciBpbmZlcnJlZCBtZXRob2QgcmV0dXJuIHR5cGUpLlxuICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8zMDAxX0VYUE9TRURfSU5URVJOQUxfVFlQRS5jcmVhdGUoXG4gICAgICAgICAgdHlwZUFubm90YXRpb25Ob2RlLFxuICAgICAgICAgIHR5cGUuc3ltYm9sLFxuICAgICAgICAgIGlzVGhpc1R5cGUsXG4gICAgICAgICAgdHlwZVVzZSxcbiAgICAgICAgKS5hZGRSZWxhdGVkSW5mb3JtYXRpb24oXG4gICAgICAgICAgdHlwZURlY2xhcmF0aW9uLFxuICAgICAgICAgIGBUaGUgcmVmZXJlbmNlZCB0eXBlIGlzIGRlY2xhcmVkIGhlcmVgLFxuICAgICAgICApLFxuICAgICAgKTtcblxuICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGdyb3VwcyA9IC9eXCIoW15cIl0rKVwiXFwuKC4qKSQvLmV4ZWModHNOYW1lKTtcbiAgICBpZiAoIWdyb3Vwcykge1xuICAgICAgaWYgKCFoYXNFcnJvcikge1xuICAgICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfMzAwMV9FWFBPU0VEX0lOVEVSTkFMX1RZUEUuY3JlYXRlKFxuICAgICAgICAgICAgdHlwZUFubm90YXRpb25Ob2RlLFxuICAgICAgICAgICAgdHlwZS5zeW1ib2wsXG4gICAgICAgICAgICBpc1RoaXNUeXBlLFxuICAgICAgICAgICAgdHlwZVVzZSxcbiAgICAgICAgICApLmFkZFJlbGF0ZWRJbmZvcm1hdGlvbihcbiAgICAgICAgICAgIHR5cGVEZWNsYXJhdGlvbixcbiAgICAgICAgICAgIGBUaGUgcmVmZXJlbmNlZCB0eXBlIGlzIGRlY2xhcmVkIGhlcmVgLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0c05hbWU7XG4gICAgfVxuICAgIGNvbnN0IFssIG1vZHVsZVBhdGgsIHR5cGVOYW1lXSA9IGdyb3VwcztcbiAgICBjb25zdCBwa2cgPSBhd2FpdCBmaW5kUGFja2FnZUluZm8obW9kdWxlUGF0aCk7XG4gICAgaWYgKCFwa2cpIHtcbiAgICAgIGlmICghaGFzRXJyb3IpIHtcbiAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzkwMDNfVU5SRVNPTFZFQUJMRV9NT0RVTEUuY3JlYXRlKFxuICAgICAgICAgICAgdHlwZUFubm90YXRpb25Ob2RlLFxuICAgICAgICAgICAgbW9kdWxlUGF0aCxcbiAgICAgICAgICApLmFkZFJlbGF0ZWRJbmZvcm1hdGlvbihcbiAgICAgICAgICAgIHR5cGVEZWNsYXJhdGlvbixcbiAgICAgICAgICAgIGBUaGUgcmVmZXJlbmNlZCB0eXBlIGlzIGRlY2xhcmVkIGhlcmVgLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgdW5rbm93bi4ke3R5cGVOYW1lfWA7XG4gICAgfVxuXG4gICAgY29uc3Qgc3VibW9kdWxlID0gdGhpcy5fc3VibW9kdWxlTWFwLmdldCh0eXBlLnN5bWJvbCk7XG4gICAgaWYgKHN1Ym1vZHVsZSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBzdWJtb2R1bGVOcyA9IHRoaXMuX3N1Ym1vZHVsZXMuZ2V0KHN1Ym1vZHVsZSkhLmZxblJlc29sdXRpb25QcmVmaXg7XG4gICAgICByZXR1cm4gYCR7c3VibW9kdWxlTnN9LiR7dHlwZU5hbWV9YDtcbiAgICB9XG5cbiAgICBjb25zdCBmcW4gPSBgJHtwa2cubmFtZX0uJHt0eXBlTmFtZX1gO1xuICAgIGlmIChcbiAgICAgIHBrZy5uYW1lICE9PSB0aGlzLnByb2plY3RJbmZvLm5hbWUgJiZcbiAgICAgICF0aGlzLl9kZXJlZmVyZW5jZSh7IGZxbiB9LCB0eXBlLnN5bWJvbC52YWx1ZURlY2xhcmF0aW9uKVxuICAgICkge1xuICAgICAgaWYgKCFoYXNFcnJvcikge1xuICAgICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfMzAwMl9VU0VfT0ZfVU5FWFBPUlRFRF9GT1JFSUdOX1RZUEUuY3JlYXRlKFxuICAgICAgICAgICAgdHlwZUFubm90YXRpb25Ob2RlLFxuICAgICAgICAgICAgZnFuLFxuICAgICAgICAgICAgdHlwZVVzZSxcbiAgICAgICAgICAgIHBrZyxcbiAgICAgICAgICApLmFkZFJlbGF0ZWRJbmZvcm1hdGlvbihcbiAgICAgICAgICAgIHR5cGVEZWNsYXJhdGlvbixcbiAgICAgICAgICAgIGBUaGUgcmVmZXJlbmNlZCB0eXBlIGlzIGRlY2xhcmVkIGhlcmVgLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZxbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgYWxsIG1vZHVsZXMgaW4gdGhlIGRlcGVuZGVuY3kgY2xvc3VyZSwgY3Jhd2wgdGhlaXIgZXhwb3J0cyB0byByZWdpc3RlclxuICAgKiB0aGUgc3VibW9kdWxlcyB0aGV5IGNvbnRhaW4uXG4gICAqXG4gICAqIEBwYXJhbSBlbnRyeVBvaW50IHRoZSBtYWluIHNvdXJjZSBmaWxlIGZvciB0aGUgY3VycmVudGx5IGNvbXBpbGVkIG1vZHVsZS5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX3JlZ2lzdGVyRGVwZW5kZW5jaWVzTmFtZXNwYWNlcyhlbnRyeVBvaW50OiB0cy5Tb3VyY2VGaWxlKSB7XG4gICAgZm9yIChjb25zdCBhc3NtIG9mIHRoaXMucHJvamVjdEluZm8uZGVwZW5kZW5jeUNsb3N1cmUpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVkID0gdHMucmVzb2x2ZU1vZHVsZU5hbWUoXG4gICAgICAgIGFzc20ubmFtZSxcbiAgICAgICAgZW50cnlQb2ludC5maWxlTmFtZSxcbiAgICAgICAgdGhpcy5wcm9ncmFtLmdldENvbXBpbGVyT3B0aW9ucygpLFxuICAgICAgICB0cy5zeXMsXG4gICAgICApO1xuICAgICAgLy8gSWYgd2UgY2FuJ3QgcmVzb2x2ZSB0aGUgbW9kdWxlIG5hbWUsIHNpbXBseSBpZ25vcmUgaXQgKFR5cGVTY3JpcHQgY29tcGlsYXRpb24gbGlrZWx5IGZhaWxlZClcbiAgICAgIGlmIChyZXNvbHZlZC5yZXNvbHZlZE1vZHVsZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5wcm9ncmFtLmdldFNvdXJjZUZpbGUoXG4gICAgICAgIHJlc29sdmVkLnJlc29sdmVkTW9kdWxlLnJlc29sdmVkRmlsZU5hbWUsXG4gICAgICApO1xuICAgICAgY29uc3QgZGVwTW9kID0gc291cmNlICYmIHRoaXMuX3R5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24oc291cmNlKTtcbiAgICAgIC8vIEl0J3MgdW5saWtlbHksIGJ1dCBpZiB3ZSBjYW4ndCBnZXQgdGhlIFNvdXJjZUZpbGUgaGVyZSwgaWdub3JlIGl0IChUeXBlU2NyaXB0IGNvbXBpbGF0aW9uIHByb2JhYmx5IGZhaWxlZClcbiAgICAgIGlmIChkZXBNb2QgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVwUm9vdCA9IHBhY2thZ2VSb290KHJlc29sdmVkLnJlc29sdmVkTW9kdWxlLnJlc29sdmVkRmlsZU5hbWUpO1xuXG4gICAgICBmb3IgKGNvbnN0IHN5bWJvbCBvZiB0aGlzLl90eXBlQ2hlY2tlci5nZXRFeHBvcnRzT2ZNb2R1bGUoZGVwTW9kKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgICBhd2FpdCB0aGlzLl9yZWdpc3Rlck5hbWVzcGFjZXMoc3ltYm9sLCBkZXBSb290KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYWNrYWdlUm9vdChmaWxlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgY29uc3QgcGFyZW50ID0gcGF0aC5kaXJuYW1lKGZpbGUpO1xuICAgICAgaWYgKHBhdGguYmFzZW5hbWUocGFyZW50KSA9PT0gJ25vZGVfbW9kdWxlcycgfHwgcGFyZW50ID09PSBmaWxlKSB7XG4gICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhY2thZ2VSb290KHBhcmVudCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfcmVnaXN0ZXJOYW1lc3BhY2VzKFxuICAgIHN5bWJvbDogdHMuU3ltYm9sLFxuICAgIHBhY2thZ2VSb290OiBzdHJpbmcsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24gPz8gc3ltYm9sLmRlY2xhcmF0aW9uc1swXTtcbiAgICBpZiAoZGVjbGFyYXRpb24gPT0gbnVsbCkge1xuICAgICAgLy8gTm90aGluZyB0byBkbyBoZXJlLi4uXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0cy5pc01vZHVsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSkge1xuICAgICAgLy8gTG9va3MgbGlrZTpcbiAgICAgIC8vXG4gICAgICAvLyAgICBleHBvcnQgc29tZV9uYW1lc3BhY2Uge1xuICAgICAgLy8gICAgICAgLi4uXG4gICAgICAvLyAgICB9XG4gICAgICAvL1xuICAgICAgLy8gTm8gd2F5IHRvIGNvbmZpZ3VyZSB0YXJnZXRzXG5cbiAgICAgIGNvbnN0IHsgZnFuLCBmcW5SZXNvbHV0aW9uUHJlZml4IH0gPSBhd2FpdCBxdWFsaWZpZWROYW1lT2YuY2FsbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgc3ltYm9sLFxuICAgICAgICB0cnVlLFxuICAgICAgKTtcblxuICAgICAgdGhpcy5fc3VibW9kdWxlcy5zZXQoc3ltYm9sLCB7XG4gICAgICAgIGZxbixcbiAgICAgICAgZnFuUmVzb2x1dGlvblByZWZpeCxcbiAgICAgICAgbG9jYXRpb25Jbk1vZHVsZTogdGhpcy5kZWNsYXJhdGlvbkxvY2F0aW9uKGRlY2xhcmF0aW9uKSxcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgdGhpcy5fYWRkVG9TdWJtb2R1bGUoc3ltYm9sLCBzeW1ib2wsIHBhY2thZ2VSb290KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0cy5pc05hbWVzcGFjZUV4cG9ydChkZWNsYXJhdGlvbikpIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8gaGVyZS4uLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1vZHVsZVNwZWNpZmllciA9IGRlY2xhcmF0aW9uLnBhcmVudC5tb2R1bGVTcGVjaWZpZXI7XG4gICAgaWYgKG1vZHVsZVNwZWNpZmllciA9PSBudWxsIHx8ICF0cy5pc1N0cmluZ0xpdGVyYWwobW9kdWxlU3BlY2lmaWVyKSkge1xuICAgICAgLy8gVGhlcmUgaXMgYSBncmFtbWFyIGVycm9yIGhlcmUsIHNvIHdlJ2xsIGxldCB0c2MgcmVwb3J0IHRoaXMgZm9yIHVzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHV0aW9uID0gdHMucmVzb2x2ZU1vZHVsZU5hbWUoXG4gICAgICBtb2R1bGVTcGVjaWZpZXIudGV4dCxcbiAgICAgIGRlY2xhcmF0aW9uLmdldFNvdXJjZUZpbGUoKS5maWxlTmFtZSxcbiAgICAgIHRoaXMucHJvZ3JhbS5nZXRDb21waWxlck9wdGlvbnMoKSxcbiAgICAgIHRzLnN5cyxcbiAgICApO1xuICAgIGlmIChyZXNvbHV0aW9uLnJlc29sdmVkTW9kdWxlID09IG51bGwpIHtcbiAgICAgIC8vIFVucmVzb2x2YWJsZSBtb2R1bGUuLi4gV2UnbGwgbGV0IHRzYyByZXBvcnQgdGhpcyBmb3IgdXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsaXplIHRoZSBwYXRoIHNvIHRoZSBjb3JyZWN0IHNlcGFyYXRvciBpcyBpbiB1c2UgKExvb2tpbmcgYXQgeW91LCBXaW5kb3dzKVxuICAgIHJlc29sdXRpb24ucmVzb2x2ZWRNb2R1bGUucmVzb2x2ZWRGaWxlTmFtZSA9IHBhdGgubm9ybWFsaXplKFxuICAgICAgcmVzb2x1dGlvbi5yZXNvbHZlZE1vZHVsZS5yZXNvbHZlZEZpbGVOYW1lLFxuICAgICk7XG4gICAgaWYgKFxuICAgICAgLy8gV2UncmUgbm90IGxvb2tpbmcgaW50byBhIGRlcGVuZGVuY3kncyBuYW1lc3BhY2UgZXhwb3J0cywgYW5kIHRoZSByZXNvbHV0aW9uIHNheXMgaXQncyBleHRlcm5hbFxuICAgICAgKHBhY2thZ2VSb290ID09PSB0aGlzLnByb2plY3RJbmZvLnByb2plY3RSb290ICYmXG4gICAgICAgIHJlc29sdXRpb24ucmVzb2x2ZWRNb2R1bGUuaXNFeHRlcm5hbExpYnJhcnlJbXBvcnQpIHx8XG4gICAgICAvLyBPciB0aGUgbW9kdWxlIHJlc29sdmVzIG91dHNpZGUgb2YgdGhlIGN1cnJlbnQgZGVwZW5kZW5jeSdzIHRyZWUgZW50aXJlbHlcbiAgICAgICFyZXNvbHV0aW9uLnJlc29sdmVkTW9kdWxlLnJlc29sdmVkRmlsZU5hbWUuc3RhcnRzV2l0aChwYWNrYWdlUm9vdCkgfHxcbiAgICAgIC8vIE9yIHRoZSBtb2R1bGUgaXMgdW5kZXIgb25lIHRoZSBjdXJyZW50IGRlcGVuZGVuY3kncyBub2RlX21vZHVsZXMgc3VidHJlZVxuICAgICAgcmVzb2x1dGlvbi5yZXNvbHZlZE1vZHVsZS5yZXNvbHZlZEZpbGVOYW1lXG4gICAgICAgIC5zcGxpdChwYXRoLnNlcClcbiAgICAgICAgLmZpbHRlcigoZW50cnkpID0+IGVudHJ5ID09PSAnbm9kZV9tb2R1bGVzJykubGVuZ3RoICE9PVxuICAgICAgICBwYWNrYWdlUm9vdC5zcGxpdChwYXRoLnNlcCkuZmlsdGVyKChlbnRyeSkgPT4gZW50cnkgPT09ICdub2RlX21vZHVsZXMnKVxuICAgICAgICAgIC5sZW5ndGhcbiAgICApIHtcbiAgICAgIC8vIEV4dGVybmFsIHJlLWV4cG9ydHMgYXJlIFwicHVyZS1qYXZhc2NyaXB0XCIgc3VnYXI7IHRoZXkgbmVlZCBub3QgYmVcbiAgICAgIC8vIHJlcHJlc2VudGVkIGluIHRoZSBqc2lpIEFzc2VtYmx5IHNpbmNlIHRoZSB0eXBlcyBpbiB0aGVyZSB3aWxsIGJlXG4gICAgICAvLyByZXNvbHZlZCB0aHJvdWdoIGRlcGVuZGVuY2llcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2VGaWxlID0gdGhpcy5wcm9ncmFtLmdldFNvdXJjZUZpbGUoXG4gICAgICByZXNvbHV0aW9uLnJlc29sdmVkTW9kdWxlLnJlc29sdmVkRmlsZU5hbWUsXG4gICAgKSE7XG4gICAgY29uc3Qgc291cmNlTW9kdWxlID0gdGhpcy5fdHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihzb3VyY2VGaWxlKTtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIG1vZHVsZSwgaXQncyBhIHN5bnRheCBlcnJvciwgYW5kIHRzYyB3aWxsIGhhdmUgcmVwb3J0ZWQgaXQgZm9yIHVzLlxuICAgIGlmIChzb3VyY2VNb2R1bGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgc3ltYm9sLm5hbWUgIT09IENhc2UuY2FtZWwoc3ltYm9sLm5hbWUpICYmXG4gICAgICAgIHN5bWJvbC5uYW1lICE9PSBDYXNlLnNuYWtlKHN5bWJvbC5uYW1lKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV84MDA0X1NVQk1PVUxFX05BTUVfQ0FTSU5HLmNyZWF0ZShcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uLm5hbWUsXG4gICAgICAgICAgICBzeW1ib2wubmFtZSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGZxbiwgZnFuUmVzb2x1dGlvblByZWZpeCB9ID0gYXdhaXQgcXVhbGlmaWVkTmFtZU9mLmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHN5bWJvbCxcbiAgICAgICk7XG4gICAgICBjb25zdCB0YXJnZXRzID0gYXdhaXQgbG9hZFN1Ym1vZHVsZVRhcmdldENvbmZpZyhzb3VyY2VGaWxlLmZpbGVOYW1lKTtcbiAgICAgIGNvbnN0IHJlYWRtZSA9IGF3YWl0IGxvYWRTdWJtb2R1bGVSZWFkTWUoc291cmNlRmlsZS5maWxlTmFtZSk7XG5cbiAgICAgIHRoaXMuX3N1Ym1vZHVsZXMuc2V0KHN5bWJvbCwge1xuICAgICAgICBmcW4sXG4gICAgICAgIGZxblJlc29sdXRpb25QcmVmaXgsXG4gICAgICAgIHRhcmdldHMsXG4gICAgICAgIHJlYWRtZSxcbiAgICAgICAgbG9jYXRpb25Jbk1vZHVsZTogdGhpcy5kZWNsYXJhdGlvbkxvY2F0aW9uKGRlY2xhcmF0aW9uKSxcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgdGhpcy5fYWRkVG9TdWJtb2R1bGUoc3ltYm9sLCBzb3VyY2VNb2R1bGUsIHBhY2thZ2VSb290KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBxdWFsaWZpZWROYW1lT2YoXG4gICAgICB0aGlzOiBBc3NlbWJsZXIsXG4gICAgICBzeW06IHRzLlN5bWJvbCxcbiAgICAgIGlubGluZU5hbWVzcGFjZSA9IGZhbHNlLFxuICAgICk6IFByb21pc2U8eyBmcW46IHN0cmluZzsgZnFuUmVzb2x1dGlvblByZWZpeDogc3RyaW5nIH0+IHtcbiAgICAgIGlmICh0aGlzLl9zdWJtb2R1bGVNYXAuaGFzKHN5bSkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fc3VibW9kdWxlcy5nZXQodGhpcy5fc3VibW9kdWxlTWFwLmdldChzeW0pISkhO1xuICAgICAgICBjb25zdCBmcW4gPSBgJHtwYXJlbnQuZnFufS4ke3N5bS5uYW1lfWA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZnFuLFxuICAgICAgICAgIGZxblJlc29sdXRpb25QcmVmaXg6IGlubGluZU5hbWVzcGFjZVxuICAgICAgICAgICAgPyBwYXJlbnQuZnFuUmVzb2x1dGlvblByZWZpeFxuICAgICAgICAgICAgOiBmcW4sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBzeW1ib2xMb2NhdGlvbiA9IHN5bVxuICAgICAgICAuZ2V0RGVjbGFyYXRpb25zKCk/LlswXVxuICAgICAgICA/LmdldFNvdXJjZUZpbGUoKT8uZmlsZU5hbWU7XG4gICAgICBjb25zdCBwa2dJbmZvID0gc3ltYm9sTG9jYXRpb24gJiYgKGF3YWl0IGZpbmRQYWNrYWdlSW5mbyhzeW1ib2xMb2NhdGlvbikpO1xuICAgICAgY29uc3QgYXNzZW1ibHlOYW1lOiBzdHJpbmcgPSBwa2dJbmZvPy5uYW1lID8/IHRoaXMucHJvamVjdEluZm8ubmFtZTtcbiAgICAgIGNvbnN0IGZxbiA9IGAke2Fzc2VtYmx5TmFtZX0uJHtzeW0ubmFtZX1gO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZnFuLFxuICAgICAgICBmcW5SZXNvbHV0aW9uUHJlZml4OiBpbmxpbmVOYW1lc3BhY2UgPyB0aGlzLnByb2plY3RJbmZvLm5hbWUgOiBmcW4sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRTdWJtb2R1bGVUYXJnZXRDb25maWcoXG4gICAgICBzdWJtb2R1bGVNYWluOiBzdHJpbmcsXG4gICAgKTogUHJvbWlzZTxTdWJtb2R1bGVTcGVjWyd0YXJnZXRzJ10+IHtcbiAgICAgIGNvbnN0IGpzaWlyYyA9IHBhdGgucmVzb2x2ZShzdWJtb2R1bGVNYWluLCAnLi4nLCAnLmpzaWlyYy5qc29uJyk7XG4gICAgICBpZiAoIShhd2FpdCBmcy5wYXRoRXhpc3RzKGpzaWlyYykpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZnMucmVhZEpzb24oanNpaXJjKTtcbiAgICAgIHJldHVybiBkYXRhLnRhcmdldHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCB0aGUgUkVBRE1FIGZvciB0aGUgZ2l2ZW4gc3VibW9kdWxlXG4gICAgICpcbiAgICAgKiBJZiB0aGUgc3VibW9kdWxlIGlzIGxvYWRlZCBmcm9tIGEgY29tcGxldGUgZGlyZWN0b3J5IChkZXRlcm1pbmVkIGJ5IHRoZSAnbWFpbidcbiAgICAgKiBmaWxlIGVuZGluZyBpbiBgaW5kZXguW2QuXXRzYCwgdGhlbiB3ZSBsb2FkIGBSRUFETUUubWRgIGluIHRoYXQgc2FtZSBkaXJlY3RvcnkuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgc3VibW9kdWxlIGlzIGxvYWRlZCBmcm9tIGEgZmlsZSwgbGlrZSBgbXltb2R1bGUuW2QuXXRzYCwgd2Ugd2lsbCBsb2FkXG4gICAgICogYG15bW9kdWxlLlJFQURNRS5tZGAuXG4gICAgICovXG4gICAgYXN5bmMgZnVuY3Rpb24gbG9hZFN1Ym1vZHVsZVJlYWRNZShcbiAgICAgIHN1Ym1vZHVsZU1haW46IHN0cmluZyxcbiAgICApOiBQcm9taXNlPFN1Ym1vZHVsZVNwZWNbJ3JlYWRtZSddPiB7XG4gICAgICBjb25zdCBmaWxlQmFzZSA9IHBhdGguYmFzZW5hbWUoc3VibW9kdWxlTWFpbikucmVwbGFjZSgvKFxcLmQpP1xcLnRzJC8sICcnKTtcbiAgICAgIGNvbnN0IHJlYWRNZU5hbWUgPVxuICAgICAgICBmaWxlQmFzZSA9PT0gJ2luZGV4JyA/IGBSRUFETUUubWRgIDogYCR7ZmlsZUJhc2V9LlJFQURNRS5tZGA7XG4gICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihwYXRoLmRpcm5hbWUoc3VibW9kdWxlTWFpbiksIHJlYWRNZU5hbWUpO1xuXG4gICAgICBpZiAoIShhd2FpdCBmcy5wYXRoRXhpc3RzKGZ1bGxQYXRoKSkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hcmtkb3duOiBhd2FpdCBmcy5yZWFkRmlsZShmdWxsUGF0aCwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KSxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBTeW1ib2xzIHRvIGEgcGFydGljdWxhciBzdWJtb2R1bGUuIFRoaXMgaXMgdXNlZCB0byBhc3NvY2lhdGVcbiAgICogZGVjbGFyYXRpb25zIGV4cG9ydGVkIGJ5IGFuIGBleHBvcnQgKiBhcyBucyBmcm9tICdtb2R1bGVMaWtlJztgIHN0YXRlbWVudFxuICAgKiBzbyB0aGF0IHRoZXkgY2FuIHN1YnNlcXVlbnRseSBiZSBjb3JyZWN0bHkgbmFtZXNwYWNlZC5cbiAgICpcbiAgICogQHBhcmFtIG5zICAgICAgICAgIHRoZSBzeW1ib2wgdGhhdCBpZGVudGlmaWVzIHRoZSBzdWJtb2R1bGUuXG4gICAqIEBwYXJhbSBtb2R1bGVMaWtlICB0aGUgbW9kdWxlLWxpa2Ugc3ltYm9sIGJvdW5kIHRvIHRoZSBzdWJtb2R1bGUuXG4gICAqIEBwYXJhbSBwYWNrYWdlUm9vdCB0aGUgcm9vdCBvZiB0aGUgcGFja2FnZSBiZWluZyB0cmF2ZXJzZWQuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9hZGRUb1N1Ym1vZHVsZShcbiAgICBuczogdHMuU3ltYm9sLFxuICAgIG1vZHVsZUxpa2U6IHRzLlN5bWJvbCxcbiAgICBwYWNrYWdlUm9vdDogc3RyaW5nLFxuICApIHtcbiAgICAvLyBGb3IgZWFjaCBzeW1ib2wgZXhwb3J0ZWQgYnkgdGhlIG1vZHVsZUxpa2UsIG1hcCBpdCB0byB0aGUgbnMgc3VibW9kdWxlLlxuICAgIGZvciAoY29uc3Qgc3ltYm9sIG9mIHRoaXMuX3R5cGVDaGVja2VyLmdldEV4cG9ydHNPZk1vZHVsZShtb2R1bGVMaWtlKSkge1xuICAgICAgaWYgKHRoaXMuX3N1Ym1vZHVsZU1hcC5oYXMoc3ltYm9sKSkge1xuICAgICAgICBjb25zdCBjdXJyTnMgPSB0aGlzLl9zdWJtb2R1bGVNYXAuZ2V0KHN5bWJvbCkhO1xuICAgICAgICAvLyBDaGVja2luZyBpZiB0aGVyZSdzIGJlZW4gdHdvIHN1Ym1vZHVsZXMgZXhwb3J0aW5nIHRoZSBzYW1lIHN5bWJvbCxcbiAgICAgICAgLy8gd2hpY2ggaXMgaWxsZWdhbC4gV2UgY2FuIHRlbGwgaWYgdGhlIGN1cnJlbnRseSByZWdpc3RlcmVkIHN5bWJvbCBoYXNcbiAgICAgICAgLy8gYSBkaWZmZXJlbnQgbmFtZSB0aGFuIHRoZSBvbmUgd2UncmUgY3VycmVudGx5IHRyeWluZyB0byByZWdpc3RlciBpbi5cbiAgICAgICAgaWYgKGN1cnJOcy5uYW1lICE9PSBucy5uYW1lKSB7XG4gICAgICAgICAgY29uc3QgY3Vyck5zRGVjbCA9IGN1cnJOcy52YWx1ZURlY2xhcmF0aW9uID8/IGN1cnJOcy5kZWNsYXJhdGlvbnNbMF07XG4gICAgICAgICAgY29uc3QgbnNEZWNsID0gbnMudmFsdWVEZWNsYXJhdGlvbiA/PyBucy5kZWNsYXJhdGlvbnNbMF07XG5cbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGVycm9yIG1lc3NhZ2UgYWx3YXlzIGxpc3RzIGNhdXNlcyBpbiB0aGUgc2FtZSBvcmRlclxuICAgICAgICAgIGNvbnN0IHJlZnMgPSBbXG4gICAgICAgICAgICB7IGRlY2w6IGN1cnJOc0RlY2wsIG5hbWU6IGN1cnJOcy5uYW1lIH0gYXMgY29uc3QsXG4gICAgICAgICAgICB7IGRlY2w6IG5zRGVjbCwgbmFtZTogbnMubmFtZSB9IGFzIGNvbnN0LFxuICAgICAgICAgIF0uc29ydCgoeyBuYW1lOiBsIH0sIHsgbmFtZTogciB9KSA9PiBsLmxvY2FsZUNvbXBhcmUocikpO1xuXG4gICAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfMzAwM19TWU1CT0xfSVNfRVhQT1JURURfVFdJQ0UuY3JlYXRlKFxuICAgICAgICAgICAgICBfbmFtZU9yRGVjbGFyYXRpb25Ob2RlKHN5bWJvbCksXG4gICAgICAgICAgICAgIHJlZnNbMF0ubmFtZSxcbiAgICAgICAgICAgICAgcmVmc1sxXS5uYW1lLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAuYWRkUmVsYXRlZEluZm9ybWF0aW9uKFxuICAgICAgICAgICAgICAgIHJlZnNbMF0uZGVjbCxcbiAgICAgICAgICAgICAgICBgU3ltYm9sIGlzIGV4cG9ydGVkIHVuZGVyIHRoZSBcIiR7cmVmc1swXS5uYW1lfVwiIHN1Ym1vZHVsZWAsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLmFkZFJlbGF0ZWRJbmZvcm1hdGlvbihcbiAgICAgICAgICAgICAgICByZWZzWzFdLmRlY2wsXG4gICAgICAgICAgICAgICAgYFN5bWJvbCBpcyBleHBvcnRlZCB1bmRlciB0aGUgXCIke3JlZnNbMV0ubmFtZX1cIiBzdWJtb2R1bGVgLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm91bmQgdHdvIHJlLWV4cG9ydHMsIHdoaWNoIGlzIG9kZCwgYnV0IHRoZXkgdXNlIHRoZSBzYW1lIHN1Ym1vZHVsZSxcbiAgICAgICAgLy8gc28gaXQncyBwcm9iYWJseSBva2F5PyBUaGF0J3MgbGlrZWx5IGEgdHNjIGVycm9yLCB3aGljaCB3aWxsIGhhdmVcbiAgICAgICAgLy8gYmVlbiByZXBvcnRlZCBmb3IgdXMgYWxyZWFkeSBhbnl3YXkuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3VibW9kdWxlTWFwLnNldChzeW1ib2wsIG5zKTtcblxuICAgICAgLy8gSWYgdGhlIGV4cG9ydGVkIHN5bWJvbCBoYXMgYW55IGRlY2xhcmF0aW9uLCBhbmQgdGhhdCBkZWxjYXJhdGlvbiBpcyBvZlxuICAgICAgLy8gYW4gZW50aXR5IHRoYXQgY2FuIGhhdmUgbmVzdGVkIGRlY2xhcmF0aW9ucyBvZiBpbnRlcmVzdCB0byBqc2lpXG4gICAgICAvLyAoY2xhc3NlcywgaW50ZXJmYWNlcywgZW51bXMsIG1vZHVsZXMpLCB3ZSBuZWVkIHRvIGFsc28gYXNzb2NpYXRlIHRob3NlXG4gICAgICAvLyBuZXN0ZWQgc3ltYm9scyB0byB0aGUgc3VibW9kdWxlIChvciB0aGV5IHdvbid0IGJlIG5hbWVkIGNvcnJlY3RseSEpXG4gICAgICBjb25zdCBkZWNsID0gc3ltYm9sLmRlY2xhcmF0aW9ucz8uWzBdO1xuICAgICAgaWYgKGRlY2wgIT0gbnVsbCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdHMuaXNDbGFzc0RlY2xhcmF0aW9uKGRlY2wpIHx8XG4gICAgICAgICAgdHMuaXNJbnRlcmZhY2VEZWNsYXJhdGlvbihkZWNsKSB8fFxuICAgICAgICAgIHRzLmlzRW51bURlY2xhcmF0aW9uKGRlY2wpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLl90eXBlQ2hlY2tlci5nZXRUeXBlQXRMb2NhdGlvbihkZWNsKTtcbiAgICAgICAgICBpZiAoaXNTaW5nbGVWYWx1ZWRFbnVtKHR5cGUsIHRoaXMuX3R5cGVDaGVja2VyKSkge1xuICAgICAgICAgICAgLy8gdHlwZS5zeW1ib2wgIT09IHN5bWJvbCwgYmVjYXVzZSBzeW1ib2wgaXMgdGhlIGVudW0gaXRzZWxmLCBidXRcbiAgICAgICAgICAgIC8vIHNpbmNlIGl0J3Mgc2luZ2xlLXZhbHVlZCwgdGhlIFR5cGVDaGVja2VyIHdpbGwgb25seSBzaG93IHVzIHRoZVxuICAgICAgICAgICAgLy8gdmFsdWUncyBzeW1ib2wgbGF0ZXIgb24uXG4gICAgICAgICAgICB0aGlzLl9zdWJtb2R1bGVNYXAuc2V0KHR5cGUuc3ltYm9sLCBucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlLnN5bWJvbC5leHBvcnRzKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYWRkVG9TdWJtb2R1bGUobnMsIHN5bWJvbCwgcGFja2FnZVJvb3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0cy5pc01vZHVsZURlY2xhcmF0aW9uKGRlY2wpKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICBhd2FpdCB0aGlzLl9yZWdpc3Rlck5hbWVzcGFjZXMoc3ltYm9sLCBwYWNrYWdlUm9vdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHMuaXNOYW1lc3BhY2VFeHBvcnQoZGVjbCkpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgICAgIGF3YWl0IHRoaXMuX3JlZ2lzdGVyTmFtZXNwYWNlcyhzeW1ib2wsIHBhY2thZ2VSb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBleHBvcnRlZCB0eXBlcyBpbiBgYHRoaXMudHlwZXNgYC5cbiAgICpcbiAgICogQHBhcmFtIG5vZGUgICAgICAgYSBub2RlIGZvdW5kIGluIGEgbW9kdWxlXG4gICAqIEBwYXJhbSBuYW1lUHJlZml4IHRoZSBwcmVmaXggZm9yIHRoZSB0eXBlcycgbmFtZXNwYWNlc1xuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgcHJpdmF0ZSBhc3luYyBfdmlzaXROb2RlKFxuICAgIG5vZGU6IHRzLkRlY2xhcmF0aW9uLFxuICAgIGNvbnRleHQ6IEVtaXRDb250ZXh0LFxuICApOiBQcm9taXNlPHNwZWMuVHlwZVtdPiB7XG4gICAgaWYgKHRzLmlzTmFtZXNwYWNlRXhwb3J0KG5vZGUpKSB7XG4gICAgICAvLyBleHBvcnQgKiBhcyBucyBmcm9tICdtb2R1bGUnO1xuICAgICAgLy8gTm90ZTogdGhlIFwidHMuTmFtZXNwYWNlRXhwb3J0XCIgcmVmZXJzIHRvIHRoZSBcImV4cG9ydCAqIGFzIG5zXCIgcGFydCBvZlxuICAgICAgLy8gdGhlIHN0YXRlbWVudCBvbmx5LiBXZSBtdXN0IHJlZmVyIHRvIGBub2RlLnBhcmVudGAgaW4gb3JkZXIgdG8gYmUgYWJsZVxuICAgICAgLy8gdG8gYWNjZXNzIHRoZSBtb2R1bGUgc3BlY2lmaWVyIChcImZyb20gJ21vZHVsZSdcIikgcGFydC5cbiAgICAgIGNvbnN0IHN5bWJvbCA9IHRoaXMuX3R5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24oXG4gICAgICAgIG5vZGUucGFyZW50Lm1vZHVsZVNwZWNpZmllciEsXG4gICAgICApITtcblxuICAgICAgaWYgKExPRy5pc1RyYWNlRW5hYmxlZCgpKSB7XG4gICAgICAgIExPRy50cmFjZShcbiAgICAgICAgICBgRW50ZXJpbmcgc3VibW9kdWxlOiAke2NvbG9ycy5jeWFuKFxuICAgICAgICAgICAgWy4uLmNvbnRleHQubmFtZXNwYWNlLCBzeW1ib2wubmFtZV0uam9pbignLicpLFxuICAgICAgICAgICl9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbnNDb250ZXh0ID0gY29udGV4dC5hcHBlbmROYW1lc3BhY2Uobm9kZS5uYW1lLnRleHQpO1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBuZXcgQXJyYXk8UHJvbWlzZTxzcGVjLlR5cGVbXT4+KCk7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuX3R5cGVDaGVja2VyLmdldEV4cG9ydHNPZk1vZHVsZShzeW1ib2wpKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fdmlzaXROb2RlKGNoaWxkLmRlY2xhcmF0aW9uc1swXSwgbnNDb250ZXh0KSk7XG4gICAgICB9XG4gICAgICBjb25zdCBhbGxUeXBlcyA9IGZsYXR0ZW5Qcm9taXNlcyhwcm9taXNlcyk7XG5cbiAgICAgIGlmIChMT0cuaXNUcmFjZUVuYWJsZWQoKSkge1xuICAgICAgICBMT0cudHJhY2UoXG4gICAgICAgICAgYExlYXZpbmcgc3VibW9kdWxlOiAke2NvbG9ycy5jeWFuKFxuICAgICAgICAgICAgWy4uLmNvbnRleHQubmFtZXNwYWNlLCBzeW1ib2wubmFtZV0uam9pbignLicpLFxuICAgICAgICAgICl9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFsbFR5cGVzO1xuICAgIH1cblxuICAgIGlmICh0cy5pc0V4cG9ydFNwZWNpZmllcihub2RlKSkge1xuICAgICAgLy8gVGhpcyBpcyB3aGF0IGhhcHBlbnMgd2hlbiBvbmUgZG9lcyBgZXhwb3J0IHsgU3ltYm9sIH0gZnJvbSBcIi4vbG9jYXRpb25cIjtgXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICBFeHBvcnRTcGVjaWZpZXI6ICAgICAgICAgICB+fn5+fn5cblxuICAgICAgY29uc3QgcmVzb2x2ZWRTeW1ib2wgPVxuICAgICAgICB0aGlzLl90eXBlQ2hlY2tlci5nZXRFeHBvcnRTcGVjaWZpZXJMb2NhbFRhcmdldFN5bWJvbChub2RlKTtcbiAgICAgIGlmICghcmVzb2x2ZWRTeW1ib2wpIHtcbiAgICAgICAgLy8gQSBncmFtbWFyIGVycm9yLCBjb21waWxhdGlvbiB3aWxsIGFscmVhZHkgaGF2ZSBmYWlsZWRcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0Tm9kZShcbiAgICAgICAgcmVzb2x2ZWRTeW1ib2wudmFsdWVEZWNsYXJhdGlvbiA/PyByZXNvbHZlZFN5bWJvbC5kZWNsYXJhdGlvbnNbMF0sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICgodHMuZ2V0Q29tYmluZWRNb2RpZmllckZsYWdzKG5vZGUpICYgdHMuTW9kaWZpZXJGbGFncy5FeHBvcnQpID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgbGV0IGpzaWlUeXBlOiBzcGVjLlR5cGUgfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHMuaXNDbGFzc0RlY2xhcmF0aW9uKG5vZGUpICYmIF9pc0V4cG9ydGVkKG5vZGUpKSB7XG4gICAgICAvLyBleHBvcnQgY2xhc3MgTmFtZSB7IC4uLiB9XG4gICAgICB0aGlzLl92YWxpZGF0ZUhlcml0YWdlQ2xhdXNlcyhub2RlLmhlcml0YWdlQ2xhdXNlcyk7XG5cbiAgICAgIGpzaWlUeXBlID0gYXdhaXQgdGhpcy5fdmlzaXRDbGFzcyhcbiAgICAgICAgdGhpcy5fdHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24obm9kZSksXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApO1xuICAgICAgaWYgKGpzaWlUeXBlKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJFeHBvcnRlZENsYXNzRnFuKG5vZGUsIGpzaWlUeXBlLmZxbik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0cy5pc0ludGVyZmFjZURlY2xhcmF0aW9uKG5vZGUpICYmIF9pc0V4cG9ydGVkKG5vZGUpKSB7XG4gICAgICAvLyBleHBvcnQgaW50ZXJmYWNlIE5hbWUgeyAuLi4gfVxuICAgICAgdGhpcy5fdmFsaWRhdGVIZXJpdGFnZUNsYXVzZXMobm9kZS5oZXJpdGFnZUNsYXVzZXMpO1xuICAgICAganNpaVR5cGUgPSBhd2FpdCB0aGlzLl92aXNpdEludGVyZmFjZShcbiAgICAgICAgdGhpcy5fdHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24obm9kZSksXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodHMuaXNFbnVtRGVjbGFyYXRpb24obm9kZSkgJiYgX2lzRXhwb3J0ZWQobm9kZSkpIHtcbiAgICAgIC8vIGV4cG9ydCBlbnVtIE5hbWUgeyAuLi4gfVxuICAgICAganNpaVR5cGUgPSBhd2FpdCB0aGlzLl92aXNpdEVudW0oXG4gICAgICAgIHRoaXMuX3R5cGVDaGVja2VyLmdldFR5cGVBdExvY2F0aW9uKG5vZGUpLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHRzLmlzTW9kdWxlRGVjbGFyYXRpb24obm9kZSkpIHtcbiAgICAgIC8vIGV4cG9ydCBuYW1lc3BhY2UgbmFtZSB7IC4uLiB9XG4gICAgICBjb25zdCBuYW1lID0gbm9kZS5uYW1lLmdldFRleHQoKTtcbiAgICAgIGNvbnN0IHN5bWJvbCA9IHRoaXMuX3R5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24obm9kZS5uYW1lKSE7XG5cbiAgICAgIGlmIChMT0cuaXNUcmFjZUVuYWJsZWQoKSkge1xuICAgICAgICBMT0cudHJhY2UoXG4gICAgICAgICAgYEVudGVyaW5nIG5hbWVzcGFjZTogJHtjb2xvcnMuY3lhbihcbiAgICAgICAgICAgIFsuLi5jb250ZXh0Lm5hbWVzcGFjZSwgbmFtZV0uam9pbignLicpLFxuICAgICAgICAgICl9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWxsVHlwZXNQcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPHNwZWMuVHlwZVtdPj4oKTtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBvZiB0aGlzLl90eXBlQ2hlY2tlci5nZXRFeHBvcnRzT2ZNb2R1bGUoc3ltYm9sKSkge1xuICAgICAgICBhbGxUeXBlc1Byb21pc2VzLnB1c2goXG4gICAgICAgICAgdGhpcy5fdmlzaXROb2RlKFxuICAgICAgICAgICAgcHJvcC5kZWNsYXJhdGlvbnNbMF0sXG4gICAgICAgICAgICBjb250ZXh0LmFwcGVuZE5hbWVzcGFjZShub2RlLm5hbWUuZ2V0VGV4dCgpKSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgYWxsVHlwZXMgPSBhd2FpdCBmbGF0dGVuUHJvbWlzZXMoYWxsVHlwZXNQcm9taXNlcyk7XG5cbiAgICAgIGlmIChMT0cuaXNUcmFjZUVuYWJsZWQoKSkge1xuICAgICAgICBMT0cudHJhY2UoXG4gICAgICAgICAgYExlYXZpbmcgbmFtZXNwYWNlOiAgJHtjb2xvcnMuY3lhbihcbiAgICAgICAgICAgIFsuLi5jb250ZXh0Lm5hbWVzcGFjZSwgbmFtZV0uam9pbignLicpLFxuICAgICAgICAgICl9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGxUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV85OTk4X1VOU1VQUE9SVEVEX05PREUuY3JlYXRlKFxuICAgICAgICAgIHRzLmdldE5hbWVPZkRlY2xhcmF0aW9uKG5vZGUpID8/IG5vZGUsXG4gICAgICAgICAgbm9kZS5raW5kLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWpzaWlUeXBlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAganNpaVR5cGUuc3ltYm9sSWQgPSB0aGlzLmdldFN5bWJvbElkKG5vZGUpO1xuXG4gICAgLy8gTGV0J3MgcXVpY2tseSB2ZXJpZnkgdGhlIGRlY2xhcmF0aW9uIGRvZXMgbm90IGNvbGxpZGUgd2l0aCBhIHN1Ym1vZHVsZS4gU3VibW9kdWxlcyBnZXQgY2FzZS1hZGp1c3RlZCBmb3IgZWFjaFxuICAgIC8vIHRhcmdldCBsYW5ndWFnZSBzZXBhcmF0ZWx5LCBzbyBuYW1lcyBjYW5ub3QgY29sbGlkZSB3aXRoIGNhc2UtdmFyaWF0aW9ucy5cbiAgICBmb3IgKGNvbnN0IHN1Ym1vZHVsZSBvZiB0aGlzLl9zdWJtb2R1bGVzLmtleXMoKSkge1xuICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IEFycmF5LmZyb20oXG4gICAgICAgIG5ldyBTZXQoW1xuICAgICAgICAgIHN1Ym1vZHVsZS5uYW1lLFxuICAgICAgICAgIENhc2UuY2FtZWwoc3VibW9kdWxlLm5hbWUpLFxuICAgICAgICAgIENhc2UucGFzY2FsKHN1Ym1vZHVsZS5uYW1lKSxcbiAgICAgICAgICBDYXNlLnNuYWtlKHN1Ym1vZHVsZS5uYW1lKSxcbiAgICAgICAgXSksXG4gICAgICApO1xuICAgICAgY29uc3QgY29sbGlkaW5nID0gY2FuZGlkYXRlcy5maW5kKFxuICAgICAgICAobmFtZSkgPT4gYCR7dGhpcy5wcm9qZWN0SW5mby5uYW1lfS4ke25hbWV9YCA9PT0ganNpaVR5cGUhLmZxbixcbiAgICAgICk7XG4gICAgICBpZiAoY29sbGlkaW5nICE9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc3VibW9kdWxlRGVjbE5hbWUgPSBfbmFtZU9yRGVjbGFyYXRpb25Ob2RlKHN1Ym1vZHVsZSk7XG4gICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV81MDExX1NVQk1PRFVMRV9OQU1FX0NPTkZMSUNULmNyZWF0ZShcbiAgICAgICAgICAgIHRzLmdldE5hbWVPZkRlY2xhcmF0aW9uKG5vZGUpID8/IG5vZGUsXG4gICAgICAgICAgICBzdWJtb2R1bGUubmFtZSxcbiAgICAgICAgICAgIGpzaWlUeXBlLm5hbWUsXG4gICAgICAgICAgICBjYW5kaWRhdGVzLFxuICAgICAgICAgICkuYWRkUmVsYXRlZEluZm9ybWF0aW9uKFxuICAgICAgICAgICAgc3VibW9kdWxlRGVjbE5hbWUsXG4gICAgICAgICAgICBgVGhpcyBpcyB0aGUgY29uZmxpY3Rpbmcgc3VibW9kdWxlIGRlY2xhcmF0aW9uYCxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChMT0cuaXNJbmZvRW5hYmxlZCgpKSB7XG4gICAgICBMT0cuaW5mbyhcbiAgICAgICAgYFJlZ2lzdGVyaW5nIEpTSUkgJHtjb2xvcnMubWFnZW50YShqc2lpVHlwZS5raW5kKX06ICR7Y29sb3JzLmdyZWVuKFxuICAgICAgICAgIGpzaWlUeXBlLmZxbixcbiAgICAgICAgKX1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5fdHlwZXNbanNpaVR5cGUuZnFuXSA9IGpzaWlUeXBlO1xuICAgIGpzaWlUeXBlLmxvY2F0aW9uSW5Nb2R1bGUgPSB0aGlzLmRlY2xhcmF0aW9uTG9jYXRpb24obm9kZSk7XG5cbiAgICBjb25zdCB0eXBlID0gdGhpcy5fdHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24obm9kZSk7XG4gICAgaWYgKHR5cGUuc3ltYm9sLmV4cG9ydHMpIHtcbiAgICAgIGNvbnN0IG5lc3RlZENvbnRleHQgPSBjb250ZXh0LmFwcGVuZE5hbWVzcGFjZSh0eXBlLnN5bWJvbC5uYW1lKTtcbiAgICAgIGNvbnN0IHZpc2l0ZWROb2RlcyA9IHRoaXMuX3R5cGVDaGVja2VyXG4gICAgICAgIC5nZXRFeHBvcnRzT2ZNb2R1bGUodHlwZS5zeW1ib2wpXG4gICAgICAgIC5maWx0ZXIoKHMpID0+IHMuZGVjbGFyYXRpb25zKVxuICAgICAgICAubWFwKChleHBvcnRlZE5vZGUpID0+XG4gICAgICAgICAgdGhpcy5fdmlzaXROb2RlKGV4cG9ydGVkTm9kZS5kZWNsYXJhdGlvbnNbMF0sIG5lc3RlZENvbnRleHQpLFxuICAgICAgICApO1xuICAgICAgZm9yIChjb25zdCBuZXN0ZWRUeXBlcyBvZiBhd2FpdCBQcm9taXNlLmFsbCh2aXNpdGVkTm9kZXMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmVzdGVkVHlwZSBvZiBuZXN0ZWRUeXBlcykge1xuICAgICAgICAgIGlmIChuZXN0ZWRUeXBlLm5hbWVzcGFjZSAhPT0gbmVzdGVkQ29udGV4dC5uYW1lc3BhY2Uuam9pbignLicpKSB7XG4gICAgICAgICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzUwMTJfTkFNRVNQQUNFX0lOX1RZUEUuY3JlYXRlKFxuICAgICAgICAgICAgICAgIHRzLmdldE5hbWVPZkRlY2xhcmF0aW9uKG5vZGUpID8/IG5vZGUsXG4gICAgICAgICAgICAgICAganNpaVR5cGUuZnFuLFxuICAgICAgICAgICAgICAgIG5lc3RlZFR5cGUubmFtZXNwYWNlISxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtqc2lpVHlwZV07XG4gIH1cblxuICBwcml2YXRlIGdldFN5bWJvbElkKG5vZGU6IHRzLk5vZGUpIHtcbiAgICByZXR1cm4gc3ltYm9sSWRlbnRpZmllcihcbiAgICAgIHRoaXMuX3R5cGVDaGVja2VyLFxuICAgICAgdGhpcy5fdHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24obm9kZSkuc3ltYm9sLFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIF92YWxpZGF0ZUhlcml0YWdlQ2xhdXNlcyhjbGF1c2VzPzogdHMuTm9kZUFycmF5PHRzLkhlcml0YWdlQ2xhdXNlPikge1xuICAgIGlmIChjbGF1c2VzID09IG51bGwgfHwgY2xhdXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8uXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2xhdXNlIG9mIGNsYXVzZXMpIHtcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBjbGF1c2UudHlwZXMpIHtcbiAgICAgICAgY29uc3QgcGFyZW50VHlwZSA9IHRoaXMuX3R5cGVDaGVja2VyLmdldFR5cGVBdExvY2F0aW9uKG5vZGUpO1xuICAgICAgICBpZiAocGFyZW50VHlwZS5zeW1ib2wgPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRoZSBwYXJlbnQgdHlwZSB3b24ndCBoYXZlIGEgc3ltYm9sIGlmIGl0J3MgYW4gXCJlcnJvciB0eXBlXCIgaW5zZXJ0ZWQgYnkgdGhlIHR5cGUgY2hlY2tlciB3aGVuIHRoZSBvcmlnaW5hbFxuICAgICAgICAgIC8vIGNvZGUgY29udGFpbnMgYSBjb21waWxhdGlvbiBlcnJvci4gSW4gc3VjaCBjYXNlcywgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXIgd2lsbCBhbHJlYWR5IGhhdmUgcmVwb3J0ZWQgYWJvdXRcbiAgICAgICAgICAvLyB0aGUgaW5jb2hlcmVudCBkZWNsYXJhdGlvbnMsIHNvIHdlJ2xsIGp1c3Qgbm90IHJlLXZhbGlkYXRlIGl0IHRoZXJlICh3ZSdkIGZhaWwgYW55d2F5KS5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3Igc29tZSByZWFzb24sIHdlIGNhbm5vdCB0cnVzdCBwYXJlbnRUeXBlLmlzQ2xhc3NPckludGVyZmFjZSgpXG4gICAgICAgIGNvbnN0IGJhZERlY2wgPSBwYXJlbnRUeXBlLnN5bWJvbC5kZWNsYXJhdGlvbnMuZmluZChcbiAgICAgICAgICAoZGVjbCkgPT5cbiAgICAgICAgICAgICF0cy5pc0NsYXNzRGVjbGFyYXRpb24oZGVjbCkgJiYgLy8gPC0tIGxvY2FsIGNsYXNzZXNcbiAgICAgICAgICAgICF0cy5pc0ludGVyZmFjZURlY2xhcmF0aW9uKGRlY2wpICYmIC8vIDwtLSBsb2NhbCBpbnRlcmZhY2VzXG4gICAgICAgICAgICAhdHMuaXNNb2R1bGVEZWNsYXJhdGlvbihkZWNsKSwgLy8gPC0tIGltcG9ydGVkIHR5cGVzXG4gICAgICAgICk7XG4gICAgICAgIGlmIChiYWREZWNsICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8zMDA0X0lOVkFMSURfU1VQRVJUWVBFLmNyZWF0ZShcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgY2xhdXNlLFxuICAgICAgICAgICAgICBiYWREZWNsLFxuICAgICAgICAgICAgKS5hZGRSZWxhdGVkSW5mb3JtYXRpb24oXG4gICAgICAgICAgICAgIGJhZERlY2wsXG4gICAgICAgICAgICAgIGBUaGUgaW52YWxpZCBzdXBlciB0eXBlIGlzIGRlY2xhcmVkIGhlcmUuYCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZGVjbGFyYXRpb25Mb2NhdGlvbihub2RlOiB0cy5EZWNsYXJhdGlvbik6IHNwZWMuU291cmNlTG9jYXRpb24ge1xuICAgIGNvbnN0IGZpbGUgPSBub2RlLmdldFNvdXJjZUZpbGUoKTtcbiAgICBjb25zdCBsaW5lID0gdHMuZ2V0TGluZUFuZENoYXJhY3Rlck9mUG9zaXRpb24oZmlsZSwgbm9kZS5nZXRTdGFydCgpKS5saW5lO1xuICAgIGNvbnN0IGZpbGVuYW1lID0gcGF0aFxuICAgICAgLm5vcm1hbGl6ZShwYXRoLnJlbGF0aXZlKHRoaXMucHJvamVjdEluZm8ucHJvamVjdFJvb3QsIGZpbGUuZmlsZU5hbWUpKVxuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsZW5hbWUsXG4gICAgICBsaW5lOiBsaW5lICsgMSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfcHJvY2Vzc0Jhc2VJbnRlcmZhY2VzKGZxbjogc3RyaW5nLCBiYXNlVHlwZXM/OiB0cy5UeXBlW10pIHtcbiAgICBjb25zdCBlcmFzZWRCYXNlcyA9IG5ldyBBcnJheTx0cy5UeXBlPigpO1xuICAgIGlmICghYmFzZVR5cGVzKSB7XG4gICAgICByZXR1cm4geyBlcmFzZWRCYXNlcyB9O1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheTxzcGVjLk5hbWVkVHlwZVJlZmVyZW5jZT4oKTtcbiAgICBjb25zdCBiYXNlSW50ZXJmYWNlcyA9IG5ldyBTZXQ8dHMuVHlwZT4oKTtcblxuICAgIGNvbnN0IHByb2Nlc3NCYXNlVHlwZXMgPSAodHlwZXM6IHRzLlR5cGVbXSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBpZmFjZSBvZiB0eXBlcykge1xuICAgICAgICAvLyBiYXNlIGlzIHByaXZhdGUvaW50ZXJuYWwsIHNvIHdlIGNvbnRpbnVlIHJlY3Vyc2l2ZWx5IHdpdGggaXQncyBvd24gYmFzZXNcbiAgICAgICAgaWYgKHRoaXMuX2lzUHJpdmF0ZU9ySW50ZXJuYWwoaWZhY2Uuc3ltYm9sKSkge1xuICAgICAgICAgIGVyYXNlZEJhc2VzLnB1c2goaWZhY2UpO1xuICAgICAgICAgIGNvbnN0IGJhc2VzID0gaWZhY2UuZ2V0QmFzZVR5cGVzKCk7XG4gICAgICAgICAgaWYgKGJhc2VzKSB7XG4gICAgICAgICAgICBwcm9jZXNzQmFzZVR5cGVzKGJhc2VzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBiYXNlSW50ZXJmYWNlcy5hZGQoaWZhY2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBwcm9jZXNzQmFzZVR5cGVzKGJhc2VUeXBlcyk7XG5cbiAgICBjb25zdCB0eXBlUmVmcyA9IEFycmF5LmZyb20oYmFzZUludGVyZmFjZXMpLm1hcChhc3luYyAoaWZhY2UpID0+IHtcbiAgICAgIGNvbnN0IGRlY2wgPSBpZmFjZS5zeW1ib2wudmFsdWVEZWNsYXJhdGlvbjtcbiAgICAgIGNvbnN0IHR5cGVSZWYgPSBhd2FpdCB0aGlzLl90eXBlUmVmZXJlbmNlKGlmYWNlLCBkZWNsLCAnYmFzZSBpbnRlcmZhY2UnKTtcbiAgICAgIHJldHVybiB7IGRlY2wsIHR5cGVSZWYgfTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IHsgZGVjbCwgdHlwZVJlZiB9IG9mIGF3YWl0IFByb21pc2UuYWxsKHR5cGVSZWZzKSkge1xuICAgICAgaWYgKCFzcGVjLmlzTmFtZWRUeXBlUmVmZXJlbmNlKHR5cGVSZWYpKSB7XG4gICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8zMDA1X1RZUEVfVVNFRF9BU19JTlRFUkZBQ0UuY3JlYXRlKGRlY2wsIHR5cGVSZWYpLFxuICAgICAgICApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZGVmZXJVbnRpbFR5cGVzQXZhaWxhYmxlKGZxbiwgW3R5cGVSZWZdLCBkZWNsLCAoZGVyZWYpID0+IHtcbiAgICAgICAgaWYgKCFzcGVjLmlzSW50ZXJmYWNlVHlwZShkZXJlZikpIHtcbiAgICAgICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8zMDA1X1RZUEVfVVNFRF9BU19JTlRFUkZBQ0UuY3JlYXRlKFxuICAgICAgICAgICAgICBkZWNsLFxuICAgICAgICAgICAgICB0eXBlUmVmLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVzdWx0LnB1c2godHlwZVJlZik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGludGVyZmFjZXM6IHJlc3VsdC5sZW5ndGggPT09IDAgPyB1bmRlZmluZWQgOiByZXN1bHQsXG4gICAgICBlcmFzZWRCYXNlcyxcbiAgICB9O1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgcHJpdmF0ZSBhc3luYyBfdmlzaXRDbGFzcyhcbiAgICB0eXBlOiB0cy5UeXBlLFxuICAgIGN0eDogRW1pdENvbnRleHQsXG4gICk6IFByb21pc2U8c3BlYy5DbGFzc1R5cGUgfCB1bmRlZmluZWQ+IHtcbiAgICBpZiAoTE9HLmlzVHJhY2VFbmFibGVkKCkpIHtcbiAgICAgIExPRy50cmFjZShcbiAgICAgICAgYFByb2Nlc3NpbmcgY2xhc3M6ICR7Y29sb3JzLmdyYXkoXG4gICAgICAgICAgY3R4Lm5hbWVzcGFjZS5qb2luKCcuJyksXG4gICAgICAgICl9LiR7Y29sb3JzLmN5YW4odHlwZS5zeW1ib2wubmFtZSl9YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKF9oYXNJbnRlcm5hbEpzRG9jVGFnKHR5cGUuc3ltYm9sKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0aGlzLl93YXJuQWJvdXRSZXNlcnZlZFdvcmRzKHR5cGUuc3ltYm9sKTtcblxuICAgIGNvbnN0IGZxbiA9IGAke1t0aGlzLnByb2plY3RJbmZvLm5hbWUsIC4uLmN0eC5uYW1lc3BhY2VdLmpvaW4oJy4nKX0uJHtcbiAgICAgIHR5cGUuc3ltYm9sLm5hbWVcbiAgICB9YDtcblxuICAgIGNvbnN0IGpzaWlUeXBlOiBzcGVjLkNsYXNzVHlwZSA9IGJpbmRpbmdzLnNldENsYXNzUmVsYXRlZE5vZGUoXG4gICAgICB7XG4gICAgICAgIGFzc2VtYmx5OiB0aGlzLnByb2plY3RJbmZvLm5hbWUsXG4gICAgICAgIGZxbixcbiAgICAgICAga2luZDogc3BlYy5UeXBlS2luZC5DbGFzcyxcbiAgICAgICAgbmFtZTogdHlwZS5zeW1ib2wubmFtZSxcbiAgICAgICAgbmFtZXNwYWNlOlxuICAgICAgICAgIGN0eC5uYW1lc3BhY2UubGVuZ3RoID4gMCA/IGN0eC5uYW1lc3BhY2Uuam9pbignLicpIDogdW5kZWZpbmVkLFxuICAgICAgICBkb2NzOiB0aGlzLl92aXNpdERvY3VtZW50YXRpb24odHlwZS5zeW1ib2wsIGN0eCkuZG9jcyxcbiAgICAgIH0sXG4gICAgICB0eXBlLnN5bWJvbC52YWx1ZURlY2xhcmF0aW9uIGFzIHRzLkNsYXNzRGVjbGFyYXRpb24sXG4gICAgKTtcblxuICAgIGlmIChfaXNBYnN0cmFjdCh0eXBlLnN5bWJvbCwganNpaVR5cGUpKSB7XG4gICAgICBqc2lpVHlwZS5hYnN0cmFjdCA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgZXJhc2VkQmFzZXMgPSBuZXcgQXJyYXk8dHMuQmFzZVR5cGU+KCk7XG4gICAgZm9yIChsZXQgYmFzZSBvZiB0eXBlLmdldEJhc2VUeXBlcygpID8/IFtdKSB7XG4gICAgICBpZiAoanNpaVR5cGUuYmFzZSkge1xuICAgICAgICAvLyBJZ25vcmluZyB0aGlzIC0gdGhlcmUgaGFzIGFscmVhZHkgYmVlbiBhIGNvbXBpbGF0aW9uIGVycm9yIGdlbmVyYXRlZCBieSB0c2MgaGVyZS5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vXG4gICAgICAvLyBiYXNlIGNsYXNzZXMgKFwiZXh0ZW5kcyBmb29cIilcblxuICAgICAgLy8gQ3Jhd2wgdXAgdGhlIGluaGVyaXRhbmNlIHRyZWUgaWYgdGhlIGN1cnJlbnQgYmFzZSB0eXBlIGlzIG5vdCBleHBvcnRlZCwgc28gd2UgaWRlbnRpZnkgdGhlIHR5cGUocykgdG8gYmVcbiAgICAgIC8vIGVyYXNlZCwgYW5kIGlkZW50aWZ5IHRoZSBjbG9zZXN0IGV4cG9ydGVkIGJhc2UgY2xhc3MsIHNob3VsZCB0aGVyZSBiZSBvbmUuXG4gICAgICB3aGlsZSAoYmFzZSAmJiB0aGlzLl9pc1ByaXZhdGVPckludGVybmFsKGJhc2Uuc3ltYm9sKSkge1xuICAgICAgICBMT0cuZGVidWcoXG4gICAgICAgICAgYEJhc2UgY2xhc3Mgb2YgJHtjb2xvcnMuZ3JlZW4oanNpaVR5cGUuZnFuKX0gbmFtZWQgJHtjb2xvcnMuZ3JlZW4oXG4gICAgICAgICAgICBiYXNlLnN5bWJvbC5uYW1lLFxuICAgICAgICAgICl9IGlzIG5vdCBleHBvcnRlZCwgZXJhc2luZyBpdC4uLmAsXG4gICAgICAgICk7XG4gICAgICAgIGVyYXNlZEJhc2VzLnB1c2goYmFzZSk7XG4gICAgICAgIGJhc2UgPSAoYmFzZS5nZXRCYXNlVHlwZXMoKSA/PyBbXSlbMF07XG4gICAgICB9XG4gICAgICBpZiAoIWJhc2UpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gZXhwb3J0ZWQgYmFzZSBjbGFzcyB0byBiZSBmb3VuZCwgcHJldGVuZCB0aGlzIGNsYXNzIGhhcyBubyBiYXNlIGNsYXNzLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgIGNvbnN0IHJlZiA9IGF3YWl0IHRoaXMuX3R5cGVSZWZlcmVuY2UoXG4gICAgICAgIGJhc2UsXG4gICAgICAgIHR5cGUuc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24sXG4gICAgICAgICdiYXNlIGNsYXNzJyxcbiAgICAgICk7XG5cbiAgICAgIGlmICghc3BlYy5pc05hbWVkVHlwZVJlZmVyZW5jZShyZWYpKSB7XG4gICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8zMDA2X1RZUEVfVVNFRF9BU19DTEFTUy5jcmVhdGUoXG4gICAgICAgICAgICBiYXNlLnN5bWJvbC52YWx1ZURlY2xhcmF0aW9uID8/IGJhc2Uuc3ltYm9sLmRlY2xhcmF0aW9uc1swXSxcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2RlZmVyVW50aWxUeXBlc0F2YWlsYWJsZShcbiAgICAgICAgZnFuLFxuICAgICAgICBbcmVmXSxcbiAgICAgICAgYmFzZS5zeW1ib2wudmFsdWVEZWNsYXJhdGlvbixcbiAgICAgICAgKGRlcmVmKSA9PiB7XG4gICAgICAgICAgaWYgKCFzcGVjLmlzQ2xhc3NUeXBlKGRlcmVmKSkge1xuICAgICAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8zMDA2X1RZUEVfVVNFRF9BU19DTEFTUy5jcmVhdGUoXG4gICAgICAgICAgICAgICAgYmFzZS5zeW1ib2wudmFsdWVEZWNsYXJhdGlvbiA/PyBiYXNlLnN5bWJvbC5kZWNsYXJhdGlvbnNbMF0sXG4gICAgICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAganNpaVR5cGUuYmFzZSA9IHJlZi5mcW47XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBiYXNlIGludGVyZmFjZXMgKFwiaW1wbGVtZW50cyBmb29cIilcblxuICAgIC8vIGNvbGxlY3QgYWxsIFwiaW1wbGVtZW50c1wiIGRlY2xhcmF0aW9ucyBmcm9tIHRoZSBjdXJyZW50IHR5cGUgYW5kIGFsbFxuICAgIC8vIGVyYXNlZCBiYXNlIHR5cGVzIChiZWNhdXNlIG90aGVyd2lzZSB3ZSBsb3NlIHRoZW0sIHNlZSBqc2lpIzQ4NylcbiAgICBjb25zdCBpbXBsZW1lbnRzQ2xhdXNlcyA9IG5ldyBBcnJheTx0cy5IZXJpdGFnZUNsYXVzZT4oKTtcbiAgICBmb3IgKGNvbnN0IGhlcml0YWdlIG9mIFt0eXBlLCAuLi5lcmFzZWRCYXNlc10ubWFwKFxuICAgICAgKHQpID0+XG4gICAgICAgICh0LnN5bWJvbC52YWx1ZURlY2xhcmF0aW9uIGFzIHRzLkNsYXNzRGVjbGFyYXRpb24pLmhlcml0YWdlQ2xhdXNlcyA/P1xuICAgICAgICBbXSxcbiAgICApKSB7XG4gICAgICBmb3IgKGNvbnN0IGNsYXVzZSBvZiBoZXJpdGFnZSkge1xuICAgICAgICBpZiAoY2xhdXNlLnRva2VuID09PSB0cy5TeW50YXhLaW5kLkV4dGVuZHNLZXl3b3JkKSB7XG4gICAgICAgICAgLy8gSGFuZGxlZCBieSBgZ2V0QmFzZVR5cGVzYFxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGNsYXVzZS50b2tlbiAhPT0gdHMuU3ludGF4S2luZC5JbXBsZW1lbnRzS2V5d29yZCkge1xuICAgICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzk5OThfVU5TVVBQT1JURURfTk9ERS5jcmVhdGUoXG4gICAgICAgICAgICAgIGNsYXVzZSxcbiAgICAgICAgICAgICAgYElnbm9yaW5nICR7dHMuU3ludGF4S2luZFtjbGF1c2UudG9rZW5dfSBoZXJpdGFnZSBjbGF1c2VgLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1wbGVtZW50c0NsYXVzZXMucHVzaChjbGF1c2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHByb2Nlc3MgYWxsIFwiaW1wbGVtZW50c1wiIGNsYXVzZXNcbiAgICBjb25zdCBhbGxJbnRlcmZhY2VzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgY29uc3QgYmFzZUludGVyZmFjZXMgPSBpbXBsZW1lbnRzQ2xhdXNlcy5tYXAoKGNsYXVzZSkgPT5cbiAgICAgIHRoaXMuX3Byb2Nlc3NCYXNlSW50ZXJmYWNlcyhcbiAgICAgICAgZnFuLFxuICAgICAgICBjbGF1c2UudHlwZXMubWFwKCh0KSA9PiB0aGlzLl9nZXRUeXBlRnJvbVR5cGVOb2RlKHQpKSxcbiAgICAgICksXG4gICAgKTtcbiAgICBmb3IgKGNvbnN0IHsgaW50ZXJmYWNlcyB9IG9mIGF3YWl0IFByb21pc2UuYWxsKGJhc2VJbnRlcmZhY2VzKSkge1xuICAgICAgZm9yIChjb25zdCBpZmMgb2YgaW50ZXJmYWNlcyA/PyBbXSkge1xuICAgICAgICBhbGxJbnRlcmZhY2VzLmFkZChpZmMuZnFuKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnRlcmZhY2VzKSB7XG4gICAgICAgIHRoaXMuX2RlZmVyVW50aWxUeXBlc0F2YWlsYWJsZShcbiAgICAgICAgICBqc2lpVHlwZS5mcW4sXG4gICAgICAgICAgaW50ZXJmYWNlcyxcbiAgICAgICAgICB0eXBlLnN5bWJvbC52YWx1ZURlY2xhcmF0aW9uLFxuICAgICAgICAgICguLi5pZmFjZXMpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWZhY2Ugb2YgaWZhY2VzKSB7XG4gICAgICAgICAgICAgIGlmIChzcGVjLmlzSW50ZXJmYWNlVHlwZShpZmFjZSkgJiYgaWZhY2UuZGF0YXR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8zMDA3X0lMTEVHQUxfU1RSVUNUX0VYVEVOU0lPTi5jcmVhdGUoXG4gICAgICAgICAgICAgICAgICAgIHR5cGUuc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24gPz8gdHlwZS5zeW1ib2wuZGVjbGFyYXRpb25zWzBdLFxuICAgICAgICAgICAgICAgICAgICBqc2lpVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgaWZhY2UsXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhbGxJbnRlcmZhY2VzLnNpemUgPiAwKSB7XG4gICAgICBqc2lpVHlwZS5pbnRlcmZhY2VzID0gQXJyYXkuZnJvbShhbGxJbnRlcmZhY2VzKTtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGUuaXNDbGFzcygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09oIG5vJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYWxsRGVjbGFyYXRpb25zOiBBcnJheTx7XG4gICAgICBkZWNsOiB0cy5EZWNsYXJhdGlvbjtcbiAgICAgIHR5cGU6IHRzLkludGVyZmFjZVR5cGUgfCB0cy5CYXNlVHlwZTtcbiAgICB9PiA9IHR5cGUuc3ltYm9sLmRlY2xhcmF0aW9ucy5tYXAoKGRlY2wpID0+ICh7IGRlY2wsIHR5cGUgfSkpO1xuXG4gICAgLy8gQ29uc2lkZXJpbmcgZXJhc2VkIGJhc2VzJyBkZWNsYXJhdGlvbnMsIHRvbywgc28gdGhleSBhcmUgXCJibGVuZGVkIGluXCJcbiAgICBmb3IgKGNvbnN0IGJhc2Ugb2YgZXJhc2VkQmFzZXMpIHtcbiAgICAgIGFsbERlY2xhcmF0aW9ucy5wdXNoKFxuICAgICAgICAuLi5iYXNlLnN5bWJvbC5kZWNsYXJhdGlvbnMubWFwKChkZWNsKSA9PiAoeyBkZWNsLCB0eXBlOiBiYXNlIH0pKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB7IGRlY2wsIHR5cGU6IGRlY2xhcmluZ1R5cGUgfSBvZiBhbGxEZWNsYXJhdGlvbnMpIHtcbiAgICAgIGNvbnN0IGNsYXNzRGVjbCA9IGRlY2wgYXMgdHMuQ2xhc3NEZWNsYXJhdGlvbiB8IHRzLkludGVyZmFjZURlY2xhcmF0aW9uO1xuICAgICAgaWYgKCFjbGFzc0RlY2wubWVtYmVycykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBtZW1iZXJEZWNsIG9mIGNsYXNzRGVjbC5tZW1iZXJzKSB7XG4gICAgICAgIGlmICh0cy5pc1NlbWljb2xvbkNsYXNzRWxlbWVudChtZW1iZXJEZWNsKSkge1xuICAgICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzk5OTZfVU5ORUNFU1NBUllfVE9LRU4uY3JlYXRlKG1lbWJlckRlY2wpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtZW1iZXI6IHRzLlN5bWJvbCA9IHRzLmlzQ29uc3RydWN0b3JEZWNsYXJhdGlvbihtZW1iZXJEZWNsKVxuICAgICAgICAgID8gKG1lbWJlckRlY2wgYXMgYW55KS5zeW1ib2xcbiAgICAgICAgICA6IHRoaXMuX3R5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24oXG4gICAgICAgICAgICAgIHRzLmdldE5hbWVPZkRlY2xhcmF0aW9uKG1lbWJlckRlY2wpISxcbiAgICAgICAgICAgICkhO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAhKGRlY2xhcmluZ1R5cGUuc3ltYm9sLmdldERlY2xhcmF0aW9ucygpID8/IFtdKS5maW5kKFxuICAgICAgICAgICAgKGQpID0+IGQgPT09IG1lbWJlckRlY2wucGFyZW50LFxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faXNQcml2YXRlT3JJbnRlcm5hbChtZW1iZXIsIG1lbWJlckRlY2wgYXMgdHMuQ2xhc3NFbGVtZW50KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc3RydWN0b3JzIGFyZSBoYW5kbGVkIGxhdGVyXG4gICAgICAgIGlmICh0cy5pc0NvbnN0cnVjdG9yRGVjbGFyYXRpb24obWVtYmVyRGVjbCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0cy5pc01ldGhvZERlY2xhcmF0aW9uKG1lbWJlckRlY2wpIHx8XG4gICAgICAgICAgdHMuaXNNZXRob2RTaWduYXR1cmUobWVtYmVyRGVjbClcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICBhd2FpdCB0aGlzLl92aXNpdE1ldGhvZChcbiAgICAgICAgICAgIG1lbWJlcixcbiAgICAgICAgICAgIGpzaWlUeXBlLFxuICAgICAgICAgICAgY3R4LnJlcGxhY2VTdGFiaWxpdHkoanNpaVR5cGUuZG9jcz8uc3RhYmlsaXR5KSxcbiAgICAgICAgICAgIGNsYXNzRGVjbCxcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHRzLmlzUHJvcGVydHlEZWNsYXJhdGlvbihtZW1iZXJEZWNsKSB8fFxuICAgICAgICAgIHRzLmlzUHJvcGVydHlTaWduYXR1cmUobWVtYmVyRGVjbCkgfHxcbiAgICAgICAgICB0cy5pc0FjY2Vzc29yKG1lbWJlckRlY2wpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgICAgYXdhaXQgdGhpcy5fdmlzaXRQcm9wZXJ0eShcbiAgICAgICAgICAgIG1lbWJlcixcbiAgICAgICAgICAgIGpzaWlUeXBlLFxuICAgICAgICAgICAgY3R4LnJlcGxhY2VTdGFiaWxpdHkoanNpaVR5cGUuZG9jcz8uc3RhYmlsaXR5KSxcbiAgICAgICAgICAgIGNsYXNzRGVjbCxcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzk5OThfVU5TVVBQT1JURURfTk9ERS5jcmVhdGUoXG4gICAgICAgICAgICAgIHRzLmdldE5hbWVPZkRlY2xhcmF0aW9uKG1lbWJlckRlY2wpID8/IG1lbWJlckRlY2wsXG4gICAgICAgICAgICAgIG1lbWJlckRlY2wua2luZCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWF3YWl0LWluLWxvb3AgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtZW1iZXJFbWl0Q29udGV4dCA9IGN0eC5yZXBsYWNlU3RhYmlsaXR5KFxuICAgICAganNpaVR5cGUuZG9jcyAmJiBqc2lpVHlwZS5kb2NzLnN0YWJpbGl0eSxcbiAgICApO1xuXG4gICAgLy8gRmluZCB0aGUgZmlyc3QgZGVmaW5lZCBjb25zdHJ1Y3RvciBpbiB0aGlzIGNsYXNzLCBvciBpdCdzIGVyYXNlZCBiYXNlc1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gW3R5cGUsIC4uLmVyYXNlZEJhc2VzXVxuICAgICAgLm1hcChnZXRDb25zdHJ1Y3RvcilcbiAgICAgIC5maW5kKChjdG9yKSA9PiBjdG9yICE9IG51bGwpO1xuICAgIGNvbnN0IGN0b3JEZWNsYXJhdGlvbiA9XG4gICAgICBjb25zdHJ1Y3RvciAmJiAoY29uc3RydWN0b3IuZGVjbGFyYXRpb25zWzBdIGFzIHRzLkNvbnN0cnVjdG9yRGVjbGFyYXRpb24pO1xuICAgIGlmIChjb25zdHJ1Y3RvciAmJiBjdG9yRGVjbGFyYXRpb24pIHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9XG4gICAgICAgIHRoaXMuX3R5cGVDaGVja2VyLmdldFNpZ25hdHVyZUZyb21EZWNsYXJhdGlvbihjdG9yRGVjbGFyYXRpb24pO1xuXG4gICAgICBpZiAoXG4gICAgICAgICh0cy5nZXRDb21iaW5lZE1vZGlmaWVyRmxhZ3MoY3RvckRlY2xhcmF0aW9uKSAmXG4gICAgICAgICAgdHMuTW9kaWZpZXJGbGFncy5Qcml2YXRlKSA9PT1cbiAgICAgICAgMFxuICAgICAgKSB7XG4gICAgICAgIGpzaWlUeXBlLmluaXRpYWxpemVyID0ge1xuICAgICAgICAgIGxvY2F0aW9uSW5Nb2R1bGU6IHRoaXMuZGVjbGFyYXRpb25Mb2NhdGlvbihjdG9yRGVjbGFyYXRpb24pLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBwYXJhbSBvZiBzaWduYXR1cmUuZ2V0UGFyYW1ldGVycygpKSB7XG4gICAgICAgICAgICBqc2lpVHlwZS5pbml0aWFsaXplci5wYXJhbWV0ZXJzID1cbiAgICAgICAgICAgICAganNpaVR5cGUuaW5pdGlhbGl6ZXIucGFyYW1ldGVycyA/PyBbXTtcbiAgICAgICAgICAgIGpzaWlUeXBlLmluaXRpYWxpemVyLnBhcmFtZXRlcnMucHVzaChcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdG9QYXJhbWV0ZXIoXG4gICAgICAgICAgICAgICAgcGFyYW0sXG4gICAgICAgICAgICAgICAgY3R4LnJlcGxhY2VTdGFiaWxpdHkoanNpaVR5cGUuZG9jcz8uc3RhYmlsaXR5KSxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBqc2lpVHlwZS5pbml0aWFsaXplci52YXJpYWRpYyA9XG4gICAgICAgICAgICAgIGpzaWlUeXBlLmluaXRpYWxpemVyPy5wYXJhbWV0ZXJzPy5zb21lKChwKSA9PiAhIXAudmFyaWFkaWMpIHx8XG4gICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGpzaWlUeXBlLmluaXRpYWxpemVyLnByb3RlY3RlZCA9XG4gICAgICAgICAgICAgICh0cy5nZXRDb21iaW5lZE1vZGlmaWVyRmxhZ3MoY3RvckRlY2xhcmF0aW9uKSAmXG4gICAgICAgICAgICAgICAgdHMuTW9kaWZpZXJGbGFncy5Qcm90ZWN0ZWQpICE9PVxuICAgICAgICAgICAgICAgIDAgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92ZXJpZnlDb25zZWN1dGl2ZU9wdGlvbmFscyhcbiAgICAgICAgICBjdG9yRGVjbGFyYXRpb24sXG4gICAgICAgICAganNpaVR5cGUuaW5pdGlhbGl6ZXIucGFyYW1ldGVycyxcbiAgICAgICAgKTtcbiAgICAgICAganNpaVR5cGUuaW5pdGlhbGl6ZXIuZG9jcyA9IHRoaXMuX3Zpc2l0RG9jdW1lbnRhdGlvbihcbiAgICAgICAgICBjb25zdHJ1Y3RvcixcbiAgICAgICAgICBtZW1iZXJFbWl0Q29udGV4dCxcbiAgICAgICAgKS5kb2NzO1xuICAgICAgICB0aGlzLm92ZXJyaWRlRG9jQ29tbWVudChcbiAgICAgICAgICBjb25zdHJ1Y3RvcixcbiAgICAgICAgICBqc2lpVHlwZS5pbml0aWFsaXplci5kb2NzLFxuICAgICAgICAgIHBhcmFtRG9jcyhqc2lpVHlwZS5pbml0aWFsaXplci5wYXJhbWV0ZXJzKSxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gUHJvY2VzcyBjb25zdHJ1Y3Rvci1iYXNlZCBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgZXZlbiBpZiBjb25zdHJ1Y3RvciBpcyBwcml2YXRlXG4gICAgICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgICAgIGZvciAoY29uc3QgcGFyYW0gb2Ygc2lnbmF0dXJlLmdldFBhcmFtZXRlcnMoKSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRzLmlzUGFyYW1ldGVyUHJvcGVydHlEZWNsYXJhdGlvbihcbiAgICAgICAgICAgICAgcGFyYW0udmFsdWVEZWNsYXJhdGlvbixcbiAgICAgICAgICAgICAgcGFyYW0udmFsdWVEZWNsYXJhdGlvbi5wYXJlbnQsXG4gICAgICAgICAgICApICYmXG4gICAgICAgICAgICAhdGhpcy5faXNQcml2YXRlT3JJbnRlcm5hbChwYXJhbSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl92aXNpdFByb3BlcnR5KFxuICAgICAgICAgICAgICBwYXJhbSxcbiAgICAgICAgICAgICAganNpaVR5cGUsXG4gICAgICAgICAgICAgIG1lbWJlckVtaXRDb250ZXh0LFxuICAgICAgICAgICAgICBjdG9yRGVjbGFyYXRpb24ucGFyZW50LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGpzaWlUeXBlLmJhc2UpIHtcbiAgICAgIHRoaXMuX2RlZmVyVW50aWxUeXBlc0F2YWlsYWJsZShcbiAgICAgICAgZnFuLFxuICAgICAgICBbanNpaVR5cGUuYmFzZV0sXG4gICAgICAgIHR5cGUuc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24sXG4gICAgICAgIChiYXNlVHlwZSkgPT4ge1xuICAgICAgICAgIGlmIChzcGVjLmlzQ2xhc3NUeXBlKGJhc2VUeXBlKSkge1xuICAgICAgICAgICAganNpaVR5cGUuaW5pdGlhbGl6ZXIgPSBiYXNlVHlwZS5pbml0aWFsaXplcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8zOTk5X0lOQ09IRVJFTlRfVFlQRV9NT0RFTC5jcmVhdGUoXG4gICAgICAgICAgICAgICAgdHlwZS5zeW1ib2wudmFsdWVEZWNsYXJhdGlvbiA/PyB0eXBlLnN5bWJvbC5kZWNsYXJhdGlvbnNbMF0sXG4gICAgICAgICAgICAgICAgYEJhc2UgdHlwZSBvZiAke2pzaWlUeXBlLmZxbn0gKCR7anNpaVR5cGUuYmFzZX0pIGlzIG5vdCBhIGNsYXNzYCxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAganNpaVR5cGUuaW5pdGlhbGl6ZXIgPSB7XG4gICAgICAgIGRvY3M6IGN0eC5zdGFiaWxpdHkgJiYgeyBzdGFiaWxpdHk6IGN0eC5zdGFiaWxpdHkgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5fdmVyaWZ5Tm9TdGF0aWNNaXhpbmcoanNpaVR5cGUsIHR5cGUuc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24pO1xuXG4gICAgdGhpcy5vdmVycmlkZURvY0NvbW1lbnQodHlwZS5nZXRTeW1ib2woKSwganNpaVR5cGU/LmRvY3MpO1xuXG4gICAgcmV0dXJuIF9zb3J0TWVtYmVycyhqc2lpVHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoZSBUeXBlQ2hlY2tlcidzIGdldFR5cGVGcm9tVHlwZU5vZGUsIGJ1dCB0aHJvdyBhIGRlc2NyaXB0aXZlIGVycm9yIGlmIGl0IGZhaWxzXG4gICAqL1xuICBwcml2YXRlIF9nZXRUeXBlRnJvbVR5cGVOb2RlKHQ6IHRzLlR5cGVOb2RlKSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuX3R5cGVDaGVja2VyLmdldFR5cGVGcm9tVHlwZU5vZGUodCk7XG4gICAgaWYgKGlzRXJyb3JUeXBlKHR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBVbmFibGUgdG8gcmVzb2x2ZSB0eXBlOiAke3QuZ2V0RnVsbFRleHQoKX0uIFRoaXMgdHlwaWNhbGx5IGhhcHBlbnMgaWYgc29tZXRoaW5nIGlzIHdyb25nIHdpdGggeW91ciBkZXBlbmRlbmN5IGNsb3N1cmUuYCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoYXQgdGhpcyBjbGFzcyBkb2Vzbid0IGRlY2xhcmUgYW55IG1lbWJlcnMgdGhhdCBhcmUgb2YgZGlmZmVyZW50IHN0YXRpY25lc3MgaW4gaXRzZWxmIG9yIGFueSBvZiBpdHMgYmFzZXNcbiAgICovXG4gIHByaXZhdGUgX3ZlcmlmeU5vU3RhdGljTWl4aW5nKGtsYXNzOiBzcGVjLkNsYXNzVHlwZSwgZGVjbDogdHMuRGVjbGFyYXRpb24pIHtcbiAgICAvLyBDaGVjayBjbGFzcyBpdHNlbGYtLW1heSBoYXZlIHR3byBtZXRob2RzL3Byb3BzIHdpdGggdGhlIHNhbWUgbmFtZSwgc28gY2hlY2sgdGhlIGFycmF5c1xuICAgIGNvbnN0IHN0YXRpY3MgPSBuZXcgU2V0KFxuICAgICAgKGtsYXNzLm1ldGhvZHMgPz8gW10pXG4gICAgICAgIC5jb25jYXQoa2xhc3MucHJvcGVydGllcyA/PyBbXSlcbiAgICAgICAgLmZpbHRlcigoeCkgPT4geC5zdGF0aWMpXG4gICAgICAgIC5tYXAoKHgpID0+IHgubmFtZSksXG4gICAgKTtcbiAgICBjb25zdCBub25TdGF0aWNzID0gbmV3IFNldChcbiAgICAgIChrbGFzcy5tZXRob2RzID8/IFtdKVxuICAgICAgICAuY29uY2F0KGtsYXNzLnByb3BlcnRpZXMgPz8gW10pXG4gICAgICAgIC5maWx0ZXIoKHgpID0+ICF4LnN0YXRpYylcbiAgICAgICAgLm1hcCgoeCkgPT4geC5uYW1lKSxcbiAgICApO1xuICAgIC8vIEludGVyc2VjdFxuICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIGludGVyc2VjdChzdGF0aWNzLCBub25TdGF0aWNzKSkge1xuICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV81MDEzX1NUQVRJQ19JTlNUQU5DRV9DT05GTElDVC5jcmVhdGUoXG4gICAgICAgICAgZGVjbCxcbiAgICAgICAgICBtZW1iZXIsXG4gICAgICAgICAga2xhc3MsXG4gICAgICAgICksXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGFnYWluc3QgYmFzZSBjbGFzc2VzLiBUaGV5IHdpbGwgbm90IGNvbnRhaW4gZHVwbGljYXRlIG1lbWJlciBuYW1lcyBzbyB3ZSBjYW4gbG9hZFxuICAgIC8vIHRoZSBtZW1iZXJzIGludG8gYSBtYXAuXG4gICAgY29uc3QgY2xhc3NNZW1iZXJzID0gdHlwZU1lbWJlcnMoa2xhc3MpO1xuICAgIHRoaXMuX3dpdGhCYXNlQ2xhc3Moa2xhc3MsIGRlY2wsIChiYXNlLCByZWN1cnNlKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IFtuYW1lLCBiYXNlTWVtYmVyXSBvZiBPYmplY3QuZW50cmllcyh0eXBlTWVtYmVycyhiYXNlKSkpIHtcbiAgICAgICAgY29uc3QgbWVtYmVyID0gY2xhc3NNZW1iZXJzW25hbWVdO1xuICAgICAgICBpZiAoIW1lbWJlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEhYmFzZU1lbWJlci5zdGF0aWMgIT09ICEhbWVtYmVyLnN0YXRpYykge1xuICAgICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzUwMTRfSU5IRVJJVEVEX1NUQVRJQ19DT05GTElDVC5jcmVhdGUoXG4gICAgICAgICAgICAgIGRlY2wsXG4gICAgICAgICAgICAgIG1lbWJlcixcbiAgICAgICAgICAgICAga2xhc3MsXG4gICAgICAgICAgICAgIGJhc2VNZW1iZXIsXG4gICAgICAgICAgICAgIGJhc2UsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVjdXJzZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBwZXIgYXJvdW5kIF9kZWZlclVudGlsVHlwZXNBdmFpbGFibGUsIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgZ2l2ZW4gY2xhc3NlcycgYmFzZSB0eXBlXG4gICAqXG4gICAqIERvZXMgbm90aGluZyBpZiB0aGUgZ2l2ZW4gY2xhc3MgZG9lc24ndCBoYXZlIGEgYmFzZSBjbGFzcy5cbiAgICpcbiAgICogVGhlIHNlY29uZCBhcmd1bWVudCB3aWxsIGJlIGEgYHJlY3Vyc2VgIGZ1bmN0aW9uIGZvciBlYXN5IHJlY3Vyc2lvbiB1cCB0aGUgaW5oZXJpdGFuY2UgdHJlZVxuICAgKiAobm8gbWVzc2luZyBhcm91bmQgd2l0aCBiaW5kaW5nICdzZWxmJyBhbmQgJ3RoaXMnIGFuZCBkb2luZyBtdWx0aXBsZSBjYWxscyB0byBfd2l0aEJhc2VDbGFzcy4pXG4gICAqL1xuICBwcml2YXRlIF93aXRoQmFzZUNsYXNzKFxuICAgIGtsYXNzOiBzcGVjLkNsYXNzVHlwZSxcbiAgICBkZWNsOiB0cy5EZWNsYXJhdGlvbixcbiAgICBjYjogKGJhc2U6IHNwZWMuQ2xhc3NUeXBlLCByZWN1cnNlOiAoKSA9PiB2b2lkKSA9PiB2b2lkLFxuICApIHtcbiAgICBpZiAoa2xhc3MuYmFzZSkge1xuICAgICAgdGhpcy5fZGVmZXJVbnRpbFR5cGVzQXZhaWxhYmxlKGtsYXNzLmZxbiwgW2tsYXNzLmJhc2VdLCBkZWNsLCAoYmFzZSkgPT4ge1xuICAgICAgICBpZiAoIXNwZWMuaXNDbGFzc1R5cGUoYmFzZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09oIG5vJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2IoYmFzZSwgKCkgPT4gdGhpcy5fd2l0aEJhc2VDbGFzcyhiYXNlLCBkZWNsLCBjYikpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhpcyBtZW1iZXIgaXMgaW50ZXJuYWwgYW5kIHNob3VsZCBiZSBvbWl0dGVkIGZyb20gdGhlIHR5cGUgbWFuaWZlc3RcbiAgICovXG4gIHByaXZhdGUgX2lzUHJpdmF0ZU9ySW50ZXJuYWwoXG4gICAgc3ltYm9sOiB0cy5TeW1ib2wsXG4gICAgdmFsaWRhdGVEZWNsYXJhdGlvbj86IHRzLkRlY2xhcmF0aW9uLFxuICApOiBib29sZWFuIHtcbiAgICBjb25zdCBoYXNJbnRlcm5hbEpzRG9jVGFnID0gX2hhc0ludGVybmFsSnNEb2NUYWcoc3ltYm9sKTtcbiAgICBjb25zdCBoYXNVbmRlcnNjb3JlUHJlZml4ID1cbiAgICAgIHN5bWJvbC5uYW1lICE9PSAnX19jb25zdHJ1Y3RvcicgJiYgc3ltYm9sLm5hbWUuc3RhcnRzV2l0aCgnXycpO1xuXG4gICAgaWYgKF9pc1ByaXZhdGUoc3ltYm9sKSkge1xuICAgICAgTE9HLnRyYWNlKFxuICAgICAgICBgJHtjb2xvcnMuY3lhbihcbiAgICAgICAgICBzeW1ib2wubmFtZSxcbiAgICAgICAgKX0gaXMgbWFya2VkIFwicHJpdmF0ZVwiLCBvciBpcyBhbiB1bmV4cG9ydGVkIHR5cGUgZGVjbGFyYXRpb25gLFxuICAgICAgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghaGFzSW50ZXJuYWxKc0RvY1RhZyAmJiAhaGFzVW5kZXJzY29yZVByZWZpeCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHdlIG9ubHkgdmFsaWRhdGUgaWYgd2UgaGF2ZSBhIGRlY2xhcmF0aW9uXG4gICAgaWYgKHZhbGlkYXRlRGVjbGFyYXRpb24pIHtcbiAgICAgIGlmICghaGFzVW5kZXJzY29yZVByZWZpeCkge1xuICAgICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfODAwNV9JTlRFUk5BTF9VTkRFUlNDT1JFLmNyZWF0ZShcbiAgICAgICAgICAgIHRzLmdldE5hbWVPZkRlY2xhcmF0aW9uKHZhbGlkYXRlRGVjbGFyYXRpb24pID8/IHZhbGlkYXRlRGVjbGFyYXRpb24sXG4gICAgICAgICAgICBzeW1ib2wubmFtZSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhhc0ludGVybmFsSnNEb2NUYWcpIHtcbiAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzgwMDZfVU5ERVJTQ09SRV9JTlRFUk5BTC5jcmVhdGUoXG4gICAgICAgICAgICB0cy5nZXROYW1lT2ZEZWNsYXJhdGlvbih2YWxpZGF0ZURlY2xhcmF0aW9uKSA/PyB2YWxpZGF0ZURlY2xhcmF0aW9uLFxuICAgICAgICAgICAgc3ltYm9sLm5hbWUsXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX3Zpc2l0RW51bShcbiAgICB0eXBlOiB0cy5UeXBlLFxuICAgIGN0eDogRW1pdENvbnRleHQsXG4gICk6IFByb21pc2U8c3BlYy5FbnVtVHlwZSB8IHVuZGVmaW5lZD4ge1xuICAgIGlmIChMT0cuaXNUcmFjZUVuYWJsZWQoKSkge1xuICAgICAgTE9HLnRyYWNlKFxuICAgICAgICBgUHJvY2Vzc2luZyBlbnVtOiAke2NvbG9ycy5ncmF5KGN0eC5uYW1lc3BhY2Uuam9pbignLicpKX0uJHtjb2xvcnMuY3lhbihcbiAgICAgICAgICB0eXBlLnN5bWJvbC5uYW1lLFxuICAgICAgICApfWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEZvcmNlZnVsbHkgcmVzb2x2aW5nIHRvIHRoZSBFbnVtRGVjbGFyYXRpb24gc3ltYm9sIGZvciBzaW5nbGUtdmFsdWVkIGVudW1zXG4gICAgY29uc3Qgc3ltYm9sOiB0cy5TeW1ib2wgPSB0eXBlLmlzTGl0ZXJhbCgpXG4gICAgICA/ICh0eXBlLnN5bWJvbCBhcyBhbnkpLnBhcmVudFxuICAgICAgOiB0eXBlLnN5bWJvbDtcbiAgICBpZiAoIXN5bWJvbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVW5hYmxlIHRvIHJlc29sdmUgZW51bSBkZWNsYXJhdGlvbiBmb3IgJHt0eXBlLnN5bWJvbC5uYW1lfSFgLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoX2hhc0ludGVybmFsSnNEb2NUYWcoc3ltYm9sKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHRoaXMuX3dhcm5BYm91dFJlc2VydmVkV29yZHModHlwZS5zeW1ib2wpO1xuXG4gICAgY29uc3QgZGVjbCA9IHN5bWJvbC52YWx1ZURlY2xhcmF0aW9uO1xuICAgIGNvbnN0IGZsYWdzID0gdHMuZ2V0Q29tYmluZWRNb2RpZmllckZsYWdzKGRlY2wpO1xuICAgIGlmIChmbGFncyAmIHRzLk1vZGlmaWVyRmxhZ3MuQ29uc3QpIHtcbiAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfMTAwMF9OT19DT05TVF9FTlVNLmNyZWF0ZShcbiAgICAgICAgICAoZGVjbCBhcyB0cy5FbnVtRGVjbGFyYXRpb24pLm1vZGlmaWVycz8uZmluZChcbiAgICAgICAgICAgIChtb2QpID0+IG1vZC5raW5kID09PSB0cy5TeW50YXhLaW5kLkNvbnN0S2V5d29yZCxcbiAgICAgICAgICApID8/IGRlY2wsXG4gICAgICAgICksXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHsgZG9jcyB9ID0gdGhpcy5fdmlzaXREb2N1bWVudGF0aW9uKHN5bWJvbCwgY3R4KTtcblxuICAgIGNvbnN0IHR5cGVDb250ZXh0ID0gY3R4LnJlcGxhY2VTdGFiaWxpdHkoZG9jcz8uc3RhYmlsaXR5KTtcbiAgICBjb25zdCBtZW1iZXJzID0gdHlwZS5pc1VuaW9uKCkgPyB0eXBlLnR5cGVzIDogW3R5cGVdO1xuXG4gICAgY29uc3QganNpaVR5cGU6IHNwZWMuRW51bVR5cGUgPSBiaW5kaW5ncy5zZXRFbnVtUmVsYXRlZE5vZGUoXG4gICAgICB7XG4gICAgICAgIGFzc2VtYmx5OiB0aGlzLnByb2plY3RJbmZvLm5hbWUsXG4gICAgICAgIGZxbjogYCR7W3RoaXMucHJvamVjdEluZm8ubmFtZSwgLi4uY3R4Lm5hbWVzcGFjZV0uam9pbignLicpfS4ke1xuICAgICAgICAgIHN5bWJvbC5uYW1lXG4gICAgICAgIH1gLFxuICAgICAgICBraW5kOiBzcGVjLlR5cGVLaW5kLkVudW0sXG4gICAgICAgIG1lbWJlcnM6IG1lbWJlcnMubWFwKChtKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBkb2NzIH0gPSB0aGlzLl92aXNpdERvY3VtZW50YXRpb24obS5zeW1ib2wsIHR5cGVDb250ZXh0KTtcbiAgICAgICAgICB0aGlzLm92ZXJyaWRlRG9jQ29tbWVudChtLnN5bWJvbCwgZG9jcyk7XG4gICAgICAgICAgcmV0dXJuIHsgbmFtZTogbS5zeW1ib2wubmFtZSwgZG9jcyB9O1xuICAgICAgICB9KSxcbiAgICAgICAgbmFtZTogc3ltYm9sLm5hbWUsXG4gICAgICAgIG5hbWVzcGFjZTpcbiAgICAgICAgICBjdHgubmFtZXNwYWNlLmxlbmd0aCA+IDAgPyBjdHgubmFtZXNwYWNlLmpvaW4oJy4nKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9jcyxcbiAgICAgIH0sXG4gICAgICBkZWNsIGFzIHRzLkVudW1EZWNsYXJhdGlvbixcbiAgICApO1xuXG4gICAgdGhpcy5vdmVycmlkZURvY0NvbW1lbnQodHlwZS5nZXRTeW1ib2woKSwganNpaVR5cGU/LmRvY3MpO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShqc2lpVHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGRvY3MgZm9yIGEgc3ltYm9sXG4gICAqL1xuICBwcml2YXRlIF92aXNpdERvY3VtZW50YXRpb24oXG4gICAgc3ltOiB0cy5TeW1ib2wsXG4gICAgY29udGV4dDogRW1pdENvbnRleHQsXG4gICk6IHsgcmVhZG9ubHkgZG9jcz86IHNwZWMuRG9jczsgcmVhZG9ubHkgaGludHM6IFR5cGVTeXN0ZW1IaW50cyB9IHtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZVN5bWJvbERvY3VtZW50YXRpb24oc3ltLCB0aGlzLl90eXBlQ2hlY2tlcik7XG5cbiAgICBmb3IgKGNvbnN0IGRpYWcgb2YgcmVzdWx0LmRpYWdub3N0aWNzID8/IFtdKSB7XG4gICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzc5OTlfRE9DVU1FTlRBVElPTl9FUlJPUi5jcmVhdGUoXG4gICAgICAgICAgc3ltLnZhbHVlRGVjbGFyYXRpb24gPz8gc3ltLmRlY2xhcmF0aW9uc1swXSxcbiAgICAgICAgICBkaWFnLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWNsID0gc3ltLnZhbHVlRGVjbGFyYXRpb24gPz8gc3ltLmRlY2xhcmF0aW9uc1swXTtcbiAgICAvLyBUaGUgQHN0cnVjdCBoaW50IGlzIG9ubHkgdmFsaWQgZm9yIGludGVyZmFjZSBkZWNsYXJhdGlvbnNcbiAgICBpZiAoIXRzLmlzSW50ZXJmYWNlRGVjbGFyYXRpb24oZGVjbCkgJiYgcmVzdWx0LmhpbnRzLnN0cnVjdCkge1xuICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV83MDAxX0lMTEVHQUxfSElOVC5jcmVhdGUoXG4gICAgICAgICAgX2ZpbmRIaW50KGRlY2wsICdzdHJ1Y3QnKSEsXG4gICAgICAgICAgJ3N0cnVjdCcsXG4gICAgICAgICAgJ2ludGVyZmFjZXMgd2l0aCBvbmx5IHJlYWRvbmx5IHByb3BlcnRpZXMnLFxuICAgICAgICApXG4gICAgICAgICAgLmFkZFJlbGF0ZWRJbmZvcm1hdGlvbihcbiAgICAgICAgICAgIHRzLmdldE5hbWVPZkRlY2xhcmF0aW9uKGRlY2wpID8/IGRlY2wsXG4gICAgICAgICAgICAnVGhlIGFubm90YXRlZCBkZWNsYXJhdGlvbiBpcyBoZXJlJyxcbiAgICAgICAgICApXG4gICAgICAgICAgLnByZWZvcm1hdCh0aGlzLnByb2plY3RJbmZvLnByb2plY3RSb290KSxcbiAgICAgICk7XG4gICAgICAvLyBDbGVhbiB1cCB0aGUgYmFkIGhpbnQuLi5cbiAgICAgIGRlbGV0ZSAocmVzdWx0LmhpbnRzIGFzIGFueSkuc3RydWN0O1xuICAgIH1cblxuICAgIC8vIEFwcGx5IHRoZSBjdXJyZW50IGNvbnRleHQncyBzdGFiaWxpdHkgaWYgbm9uZSB3YXMgc3BlY2lmaWVkIGxvY2FsbHkuXG4gICAgaWYgKHJlc3VsdC5kb2NzLnN0YWJpbGl0eSA9PSBudWxsKSB7XG4gICAgICByZXN1bHQuZG9jcy5zdGFiaWxpdHkgPSBjb250ZXh0LnN0YWJpbGl0eTtcbiAgICB9XG5cbiAgICBjb25zdCBhbGxVbmRlZmluZWQgPSBPYmplY3QudmFsdWVzKHJlc3VsdC5kb2NzKS5ldmVyeShcbiAgICAgICh2KSA9PiB2ID09PSB1bmRlZmluZWQsXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgZG9jczogIWFsbFVuZGVmaW5lZCA/IHJlc3VsdC5kb2NzIDogdW5kZWZpbmVkLFxuICAgICAgaGludHM6IHJlc3VsdC5oaW50cyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoYXQgYWxsIHBhcmFtZXRlcnMgdGhlIGRvYyBibG9jayByZWZlcnMgdG8gd2l0aCBhIEBwYXJhbSBkZWNsYXJhdGlvbiBhY3R1YWxseSBleGlzdFxuICAgKi9cbiAgcHJpdmF0ZSBfdmFsaWRhdGVSZWZlcmVuY2VkRG9jUGFyYW1zKFxuICAgIG1ldGhvZDogc3BlYy5NZXRob2QsXG4gICAgbWV0aG9kU3ltOiB0cy5TeW1ib2wsXG4gICkge1xuICAgIGNvbnN0IHBhcmFtcyA9IGdldFJlZmVyZW5jZWREb2NQYXJhbXMobWV0aG9kU3ltKTtcbiAgICBjb25zdCBhY3R1YWxOYW1lcyA9IG5ldyBTZXQoKG1ldGhvZC5wYXJhbWV0ZXJzID8/IFtdKS5tYXAoKHApID0+IHAubmFtZSkpO1xuICAgIGZvciAoY29uc3QgcGFyYW0gb2YgcGFyYW1zKSB7XG4gICAgICBpZiAoIWFjdHVhbE5hbWVzLmhhcyhwYXJhbSkpIHtcbiAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzcwMDBfTk9OX0VYSVNURU5UX1BBUkFNRVRFUi5jcmVhdGUoXG4gICAgICAgICAgICBtZXRob2RTeW0udmFsdWVEZWNsYXJhdGlvbiA/PyBtZXRob2RTeW0uZGVjbGFyYXRpb25zWzBdLFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgcGFyYW0sXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF92aXNpdEludGVyZmFjZShcbiAgICB0eXBlOiB0cy5UeXBlLFxuICAgIGN0eDogRW1pdENvbnRleHQsXG4gICk6IFByb21pc2U8c3BlYy5JbnRlcmZhY2VUeXBlIHwgdW5kZWZpbmVkPiB7XG4gICAgaWYgKExPRy5pc1RyYWNlRW5hYmxlZCgpKSB7XG4gICAgICBMT0cudHJhY2UoXG4gICAgICAgIGBQcm9jZXNzaW5nIGludGVyZmFjZTogJHtjb2xvcnMuZ3JheShcbiAgICAgICAgICBjdHgubmFtZXNwYWNlLmpvaW4oJy4nKSxcbiAgICAgICAgKX0uJHtjb2xvcnMuY3lhbih0eXBlLnN5bWJvbC5uYW1lKX1gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoX2hhc0ludGVybmFsSnNEb2NUYWcodHlwZS5zeW1ib2wpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRoaXMuX3dhcm5BYm91dFJlc2VydmVkV29yZHModHlwZS5zeW1ib2wpO1xuXG4gICAgY29uc3QgZnFuID0gYCR7W3RoaXMucHJvamVjdEluZm8ubmFtZSwgLi4uY3R4Lm5hbWVzcGFjZV0uam9pbignLicpfS4ke1xuICAgICAgdHlwZS5zeW1ib2wubmFtZVxuICAgIH1gO1xuXG4gICAgY29uc3QgeyBkb2NzLCBoaW50cyB9ID0gdGhpcy5fdmlzaXREb2N1bWVudGF0aW9uKHR5cGUuc3ltYm9sLCBjdHgpO1xuICAgIGNvbnN0IGpzaWlUeXBlOiBzcGVjLkludGVyZmFjZVR5cGUgPSBiaW5kaW5ncy5zZXRJbnRlcmZhY2VSZWxhdGVkTm9kZShcbiAgICAgIHtcbiAgICAgICAgYXNzZW1ibHk6IHRoaXMucHJvamVjdEluZm8ubmFtZSxcbiAgICAgICAgZnFuLFxuICAgICAgICBraW5kOiBzcGVjLlR5cGVLaW5kLkludGVyZmFjZSxcbiAgICAgICAgbmFtZTogdHlwZS5zeW1ib2wubmFtZSxcbiAgICAgICAgbmFtZXNwYWNlOlxuICAgICAgICAgIGN0eC5uYW1lc3BhY2UubGVuZ3RoID4gMCA/IGN0eC5uYW1lc3BhY2Uuam9pbignLicpIDogdW5kZWZpbmVkLFxuICAgICAgICBkb2NzLFxuICAgICAgfSxcbiAgICAgIHR5cGUuc3ltYm9sLmRlY2xhcmF0aW9uc1swXSBhcyB0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbixcbiAgICApO1xuXG4gICAgY29uc3QgeyBpbnRlcmZhY2VzLCBlcmFzZWRCYXNlcyB9ID0gYXdhaXQgdGhpcy5fcHJvY2Vzc0Jhc2VJbnRlcmZhY2VzKFxuICAgICAgZnFuLFxuICAgICAgdHlwZS5nZXRCYXNlVHlwZXMoKSxcbiAgICApO1xuICAgIGpzaWlUeXBlLmludGVyZmFjZXMgPSBhcHBseShpbnRlcmZhY2VzLCAoYXJyKSA9PiBhcnIubWFwKChpKSA9PiBpLmZxbikpO1xuXG4gICAgZm9yIChjb25zdCBkZWNsYXJpbmdUeXBlIG9mIFt0eXBlLCAuLi5lcmFzZWRCYXNlc10pIHtcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIGRlY2xhcmluZ1R5cGUuZ2V0UHJvcGVydGllcygpKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhKGRlY2xhcmluZ1R5cGUuc3ltYm9sLmdldERlY2xhcmF0aW9ucygpID8/IFtdKS5maW5kKFxuICAgICAgICAgICAgKGRlY2wpID0+IGRlY2wgPT09IG1lbWJlci52YWx1ZURlY2xhcmF0aW9uPy5wYXJlbnQsXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLl9pc1ByaXZhdGVPckludGVybmFsKFxuICAgICAgICAgICAgbWVtYmVyLFxuICAgICAgICAgICAgbWVtYmVyLnZhbHVlRGVjbGFyYXRpb24gYXMgdHMuUHJvcGVydHlEZWNsYXJhdGlvbixcbiAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRzLmlzTWV0aG9kRGVjbGFyYXRpb24obWVtYmVyLnZhbHVlRGVjbGFyYXRpb24pIHx8XG4gICAgICAgICAgdHMuaXNNZXRob2RTaWduYXR1cmUobWVtYmVyLnZhbHVlRGVjbGFyYXRpb24pXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgICAgYXdhaXQgdGhpcy5fdmlzaXRNZXRob2QoXG4gICAgICAgICAgICBtZW1iZXIsXG4gICAgICAgICAgICBqc2lpVHlwZSxcbiAgICAgICAgICAgIGN0eC5yZXBsYWNlU3RhYmlsaXR5KGpzaWlUeXBlLmRvY3M/LnN0YWJpbGl0eSksXG4gICAgICAgICAgICAodHlwZS5zeW1ib2wudmFsdWVEZWNsYXJhdGlvbiA/P1xuICAgICAgICAgICAgICB0eXBlLnN5bWJvbC5kZWNsYXJhdGlvbnNbMF0pIGFzIHRzLkludGVyZmFjZURlY2xhcmF0aW9uLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgdHMuaXNQcm9wZXJ0eURlY2xhcmF0aW9uKG1lbWJlci52YWx1ZURlY2xhcmF0aW9uKSB8fFxuICAgICAgICAgIHRzLmlzUHJvcGVydHlTaWduYXR1cmUobWVtYmVyLnZhbHVlRGVjbGFyYXRpb24pIHx8XG4gICAgICAgICAgdHMuaXNBY2Nlc3NvcihtZW1iZXIudmFsdWVEZWNsYXJhdGlvbilcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICBhd2FpdCB0aGlzLl92aXNpdFByb3BlcnR5KFxuICAgICAgICAgICAgbWVtYmVyLFxuICAgICAgICAgICAganNpaVR5cGUsXG4gICAgICAgICAgICBjdHgucmVwbGFjZVN0YWJpbGl0eShqc2lpVHlwZS5kb2NzPy5zdGFiaWxpdHkpLFxuICAgICAgICAgICAgKHR5cGUuc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24gPz9cbiAgICAgICAgICAgICAgdHlwZS5zeW1ib2wuZGVjbGFyYXRpb25zWzBdKSBhcyB0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbixcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzk5OThfVU5TVVBQT1JURURfTk9ERS5jcmVhdGUoXG4gICAgICAgICAgICAgIF9uYW1lT3JEZWNsYXJhdGlvbk5vZGUobWVtYmVyKSxcbiAgICAgICAgICAgICAgKG1lbWJlci52YWx1ZURlY2xhcmF0aW9uID8/IG1lbWJlci5kZWNsYXJhdGlvbnNbMF0pLmtpbmQsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgZGF0YXR5cGUgYmFzZWQgb24gdGhlIGRhdGF0eXBlbmVzcyBvZiB0aGlzIGludGVyZmFjZSBhbmQgYWxsIG9mIGl0cyBwYXJlbnRzXG4gICAgLy8gVG8ga2VlcCB0aGUgc3BlYyBtaW5pbWFsIHRoZSBhY3R1YWwgdmFsdWVzIG9mIHRoZSBhdHRyaWJ1dGUgYXJlIFwidHJ1ZVwiIG9yIFwidW5kZWZpbmVkXCIgKHRvIHJlcHJlc2VudCBcImZhbHNlXCIpLlxuICAgIGNvbnN0IGRlY2xhcmF0aW9uID1cbiAgICAgIHR5cGUuc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24gPz8gdHlwZS5zeW1ib2wuZGVjbGFyYXRpb25zWzBdO1xuICAgIHRoaXMuX2RlZmVyVW50aWxUeXBlc0F2YWlsYWJsZShcbiAgICAgIGZxbixcbiAgICAgIGpzaWlUeXBlLmludGVyZmFjZXMgPz8gW10sXG4gICAgICBkZWNsYXJhdGlvbixcbiAgICAgICguLi5iYXNlczogc3BlYy5UeXBlW10pID0+IHtcbiAgICAgICAgaWYgKChqc2lpVHlwZS5tZXRob2RzID8/IFtdKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBqc2lpVHlwZS5kYXRhdHlwZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaGludHMuc3RydWN0KSB7XG4gICAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICAgIGpzaWlUeXBlLm1ldGhvZHMhLnJlZHVjZShcbiAgICAgICAgICAgICAgKGRpYWcsIG10aG9kKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGJpbmRpbmdzLmdldE1ldGhvZFJlbGF0ZWROb2RlKG10aG9kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZVxuICAgICAgICAgICAgICAgICAgPyBkaWFnLmFkZFJlbGF0ZWRJbmZvcm1hdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICB0cy5nZXROYW1lT2ZEZWNsYXJhdGlvbihub2RlKSA/PyBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgIGBBIG1ldGhvZCBpcyBkZWNsYXJlZCBoZXJlYCxcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgOiBkaWFnO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzcwMDFfSUxMRUdBTF9ISU5ULmNyZWF0ZShcbiAgICAgICAgICAgICAgICBfZmluZEhpbnQoZGVjbGFyYXRpb24sICdzdHJ1Y3QnKSEsXG4gICAgICAgICAgICAgICAgJ3N0cnVjdCcsXG4gICAgICAgICAgICAgICAgJ2ludGVyZmFjZXMgd2l0aCBvbmx5IHJlYWRvbmx5IHByb3BlcnRpZXMnLFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLmFkZFJlbGF0ZWRJbmZvcm1hdGlvbihcbiAgICAgICAgICAgICAgICAgIHRzLmdldE5hbWVPZkRlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSA/PyBkZWNsYXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICdUaGUgYW5ub3RhdGVkIGRlY2xhcnRpb24gaXMgaGVyZScsXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC5wcmVmb3JtYXQodGhpcy5wcm9qZWN0SW5mby5wcm9qZWN0Um9vdCksXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGJhc2Ugb2YgYmFzZXMpIHtcbiAgICAgICAgICBpZiAoc3BlYy5pc0ludGVyZmFjZVR5cGUoYmFzZSkgJiYgIWJhc2UuZGF0YXR5cGUpIHtcbiAgICAgICAgICAgIGpzaWlUeXBlLmRhdGF0eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGludGVyZmFjZU5hbWUgPSBpc0ludGVyZmFjZU5hbWUoanNpaVR5cGUubmFtZSk7XG5cbiAgICAgICAgLy8gSWYgaXQncyBub3QgYSBkYXRhdHlwZSB0aGUgbmFtZSBtdXN0IHN0YXJ0IHdpdGggYW4gXCJJXCIuXG4gICAgICAgIGlmICghanNpaVR5cGUuZGF0YXR5cGUgJiYgIWludGVyZmFjZU5hbWUpIHtcbiAgICAgICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV84MDA3X0JFSEFWSU9SQUxfSU5URVJGQUNFX05BTUUuY3JlYXRlKFxuICAgICAgICAgICAgICB0cy5nZXROYW1lT2ZEZWNsYXJhdGlvbihkZWNsYXJhdGlvbikgPz8gZGVjbGFyYXRpb24sXG4gICAgICAgICAgICAgIGpzaWlUeXBlLm5hbWUsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgbmFtZSBzdGFydHMgd2l0aCBhbiBcIklcIiBpdCBpcyBub3QgaW50ZW5kZWQgYXMgYSBkYXRhdHlwZSwgc28gc3dpdGNoIHRoYXQgb2ZmLFxuICAgICAgICAvLyB1bmxlc3MgYSBUU0RvYyBoaW50IHdhcyBzZXQgdG8gZm9yY2UgdGhpcyB0byBiZSBjb25zaWRlcmVkIGEgYmVoYXZpb3JhbCBpbnRlcmZhY2UuXG4gICAgICAgIGlmIChqc2lpVHlwZS5kYXRhdHlwZSAmJiBpbnRlcmZhY2VOYW1lICYmICFoaW50cy5zdHJ1Y3QpIHtcbiAgICAgICAgICBkZWxldGUganNpaVR5cGUuZGF0YXR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPa2F5LCB0aGlzIGlzIGEgZGF0YSB0eXBlLCBjaGVjayB0aGF0IGFsbCBwcm9wZXJ0aWVzIGFyZSByZWFkb25seVxuICAgICAgICBpZiAoanNpaVR5cGUuZGF0YXR5cGUpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YganNpaVR5cGUucHJvcGVydGllcyA/PyBbXSkge1xuICAgICAgICAgICAgaWYgKCFwcm9wLmltbXV0YWJsZSkge1xuICAgICAgICAgICAgICBjb25zdCBwID0gdHlwZS5nZXRQcm9wZXJ0eShwcm9wLm5hbWUpITtcbiAgICAgICAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzMwMDhfU1RSVUNUX1BST1BTX01VU1RfQkVfUkVBRE9OTFkuY3JlYXRlKFxuICAgICAgICAgICAgICAgICAgX25hbWVPckRlY2xhcmF0aW9uTm9kZShwKSxcbiAgICAgICAgICAgICAgICAgIHAubmFtZSxcbiAgICAgICAgICAgICAgICAgIGpzaWlUeXBlLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgLy8gZm9yY2UgcHJvcGVydHkgdG8gYmUgXCJyZWFkb25seVwiIHNpbmNlIGpzaWkgbGFuZ3VhZ2VzIHdpbGwgcGFzcyB0aGlzIGJ5LXZhbHVlXG4gICAgICAgICAgICAgIHByb3AuaW1tdXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyAqTk9UKiBhIGRhdGEgdHlwZSwgc28gaXQgbWF5IG5vdCBleHRlbmQgc29tZXRoaW5nIHRoYXQgaXMgb25lLlxuICAgICAgICAgIGZvciAoY29uc3QgYmFzZSBvZiBiYXNlcykge1xuICAgICAgICAgICAgaWYgKCFzcGVjLmlzSW50ZXJmYWNlVHlwZShiYXNlKSkge1xuICAgICAgICAgICAgICAvLyBJbnZhbGlkIHR5cGUgd2UgYWxyZWFkeSB3YXJuZWQgYWJvdXQgZWFybGllciwganVzdCBpZ25vcmluZyBpdCBoZXJlLi5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmFzZS5kYXRhdHlwZSkge1xuICAgICAgICAgICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICAgICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfMzAwN19JTExFR0FMX1NUUlVDVF9FWFRFTlNJT04uY3JlYXRlKFxuICAgICAgICAgICAgICAgICAgdHlwZS5zeW1ib2wudmFsdWVEZWNsYXJhdGlvbiA/PyB0eXBlLnN5bWJvbC5kZWNsYXJhdGlvbnNbMF0sXG4gICAgICAgICAgICAgICAgICBqc2lpVHlwZSxcbiAgICAgICAgICAgICAgICAgIGJhc2UsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgKTtcblxuICAgIC8vIENoZWNrIHRoYXQgbm8gaW50ZXJmYWNlIGRlY2xhcmVzIGEgbWVtYmVyIHRoYXQncyBhbHJlYWR5IGRlY2xhcmVkXG4gICAgLy8gaW4gYSBiYXNlIHR5cGUgKG5vdCBhbGxvd2VkIGluIEMjKS5cbiAgICBjb25zdCBuYW1lcyA9IG1lbWJlck5hbWVzKGpzaWlUeXBlKTtcbiAgICBjb25zdCBjaGVja05vSW50ZXJzZWN0aW9uID0gKC4uLmJhc2VzOiBzcGVjLlR5cGVbXSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBiYXNlIG9mIGJhc2VzKSB7XG4gICAgICAgIGlmICghc3BlYy5pc0ludGVyZmFjZVR5cGUoYmFzZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJhc2VNZW1iZXJzID0gbWVtYmVyTmFtZXMoYmFzZSk7XG4gICAgICAgIGZvciAoY29uc3QgbWVtYmVyTmFtZSBvZiBuYW1lcykge1xuICAgICAgICAgIGlmIChiYXNlTWVtYmVycy5pbmNsdWRlcyhtZW1iZXJOYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV81MDE1X1JFREVDTEFSRURfSU5URVJGQUNFX01FTUJFUi5jcmVhdGUoXG4gICAgICAgICAgICAgICAgdHlwZS5zeW1ib2wudmFsdWVEZWNsYXJhdGlvbiA/PyB0eXBlLnN5bWJvbC5kZWNsYXJhdGlvbnNbMF0sXG4gICAgICAgICAgICAgICAgbWVtYmVyTmFtZSxcbiAgICAgICAgICAgICAgICBqc2lpVHlwZSxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2UgdXB3YXJkc1xuICAgICAgICB0aGlzLl9kZWZlclVudGlsVHlwZXNBdmFpbGFibGUoXG4gICAgICAgICAgZnFuLFxuICAgICAgICAgIGJhc2UuaW50ZXJmYWNlcyA/PyBbXSxcbiAgICAgICAgICB0eXBlLnN5bWJvbC52YWx1ZURlY2xhcmF0aW9uLFxuICAgICAgICAgIGNoZWNrTm9JbnRlcnNlY3Rpb24sXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9kZWZlclVudGlsVHlwZXNBdmFpbGFibGUoXG4gICAgICBmcW4sXG4gICAgICBqc2lpVHlwZS5pbnRlcmZhY2VzID8/IFtdLFxuICAgICAgdHlwZS5zeW1ib2wudmFsdWVEZWNsYXJhdGlvbixcbiAgICAgIGNoZWNrTm9JbnRlcnNlY3Rpb24sXG4gICAgKTtcblxuICAgIHRoaXMub3ZlcnJpZGVEb2NDb21tZW50KHR5cGUuZ2V0U3ltYm9sKCksIGpzaWlUeXBlPy5kb2NzKTtcblxuICAgIHJldHVybiBfc29ydE1lbWJlcnMoanNpaVR5cGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfdmlzaXRNZXRob2QoXG4gICAgc3ltYm9sOiB0cy5TeW1ib2wsXG4gICAgdHlwZTogc3BlYy5DbGFzc1R5cGUgfCBzcGVjLkludGVyZmFjZVR5cGUsXG4gICAgY3R4OiBFbWl0Q29udGV4dCxcbiAgICBkZWNsYXJpbmdUeXBlRGVjbDogdHMuQ2xhc3NMaWtlRGVjbGFyYXRpb24gfCB0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbixcbiAgKSB7XG4gICAgaWYgKExPRy5pc1RyYWNlRW5hYmxlZCgpKSB7XG4gICAgICBMT0cudHJhY2UoXG4gICAgICAgIGBQcm9jZXNzaW5nIG1ldGhvZDogJHtjb2xvcnMuZ3JlZW4odHlwZS5mcW4pfSMke2NvbG9ycy5jeWFuKFxuICAgICAgICAgIHN5bWJvbC5uYW1lLFxuICAgICAgICApfWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24gYXNcbiAgICAgIHwgdHMuTWV0aG9kRGVjbGFyYXRpb25cbiAgICAgIHwgdHMuTWV0aG9kU2lnbmF0dXJlO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9XG4gICAgICB0aGlzLl90eXBlQ2hlY2tlci5nZXRTaWduYXR1cmVGcm9tRGVjbGFyYXRpb24oZGVjbGFyYXRpb24pO1xuICAgIGlmICghc2lnbmF0dXJlKSB7XG4gICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzkwMDRfVU5BQkxFX1RPX0NPTVBVVEVfU0lHTkFUVVJFLmNyZWF0ZShcbiAgICAgICAgICBkZWNsYXJhdGlvbixcbiAgICAgICAgICBzeW1ib2wubmFtZSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoQ2FzZS5wYXNjYWwodHlwZS5uYW1lKSA9PT0gQ2FzZS5wYXNjYWwoc3ltYm9sLm5hbWUpKSB7XG4gICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzUwMTlfTUVNQkVSX1RZUEVfTkFNRV9DT05GTElDVC5jcmVhdGUoXG4gICAgICAgICAgZGVjbGFyYXRpb24ubmFtZSxcbiAgICAgICAgICAnbWV0aG9kJyxcbiAgICAgICAgICBzeW1ib2wsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgKS5hZGRSZWxhdGVkSW5mb3JtYXRpb24oXG4gICAgICAgICAgZGVjbGFyaW5nVHlwZURlY2wubmFtZSA/PyBkZWNsYXJpbmdUeXBlRGVjbCxcbiAgICAgICAgICBgVGhlIGRlY2xhcmluZyAke3R5cGUua2luZH0gaXMgaW50cm9kdWNlZCBoZXJlYCxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGlzUHJvaGliaXRlZE1lbWJlck5hbWUoc3ltYm9sLm5hbWUpKSB7XG4gICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzUwMTZfUFJPSElCSVRFRF9NRU1CRVJfTkFNRS5jcmVhdGUoXG4gICAgICAgICAgZGVjbGFyYXRpb24ubmFtZSxcbiAgICAgICAgICBzeW1ib2wubmFtZSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3dhcm5BYm91dFJlc2VydmVkV29yZHMoc3ltYm9sKTtcblxuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHNpZ25hdHVyZS5nZXRQYXJhbWV0ZXJzKCkubWFwKChwKSA9PiB0aGlzLl90b1BhcmFtZXRlcihwLCBjdHgpKSxcbiAgICApO1xuXG4gICAgY29uc3QgcmV0dXJuVHlwZSA9IHNpZ25hdHVyZS5nZXRSZXR1cm5UeXBlKCk7XG4gICAgY29uc3QgbWV0aG9kOiBzcGVjLk1ldGhvZCA9IGJpbmRpbmdzLnNldE1ldGhvZFJlbGF0ZWROb2RlKFxuICAgICAge1xuICAgICAgICBhYnN0cmFjdDogX2lzQWJzdHJhY3Qoc3ltYm9sLCB0eXBlKSB8fCB1bmRlZmluZWQsXG4gICAgICAgIG5hbWU6IHN5bWJvbC5uYW1lLFxuICAgICAgICBwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzLmxlbmd0aCA+IDAgPyBwYXJhbWV0ZXJzIDogdW5kZWZpbmVkLFxuICAgICAgICBwcm90ZWN0ZWQ6IF9pc1Byb3RlY3RlZChzeW1ib2wpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgcmV0dXJuczogX2lzVm9pZChyZXR1cm5UeXBlKVxuICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgOiBhd2FpdCB0aGlzLl9vcHRpb25hbFZhbHVlKFxuICAgICAgICAgICAgICByZXR1cm5UeXBlLFxuICAgICAgICAgICAgICBkZWNsYXJhdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAncmV0dXJuIHR5cGUnLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgYXN5bmM6IF9pc1Byb21pc2UocmV0dXJuVHlwZSkgfHwgdW5kZWZpbmVkLFxuICAgICAgICBzdGF0aWM6IF9pc1N0YXRpYyhzeW1ib2wpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgbG9jYXRpb25Jbk1vZHVsZTogdGhpcy5kZWNsYXJhdGlvbkxvY2F0aW9uKGRlY2xhcmF0aW9uKSxcbiAgICAgIH0sXG4gICAgICBkZWNsYXJhdGlvbixcbiAgICApO1xuICAgIG1ldGhvZC52YXJpYWRpYyA9XG4gICAgICBtZXRob2QucGFyYW1ldGVycz8uc29tZSgocCkgPT4gISFwLnZhcmlhZGljKSA9PT0gdHJ1ZSA/IHRydWUgOiB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLl92ZXJpZnlDb25zZWN1dGl2ZU9wdGlvbmFscyhkZWNsYXJhdGlvbiwgbWV0aG9kLnBhcmFtZXRlcnMpO1xuXG4gICAgbWV0aG9kLmRvY3MgPSB0aGlzLl92aXNpdERvY3VtZW50YXRpb24oc3ltYm9sLCBjdHgpLmRvY3M7XG5cbiAgICAvLyBJZiB0aGUgbGFzdCBwYXJhbWV0ZXIgaXMgYSBkYXRhdHlwZSwgdmVyaWZ5IHRoYXQgaXQgZG9lcyBub3Qgc2hhcmUgYW55IGZpZWxkIG5hbWVzIHdpdGhcbiAgICAvLyBvdGhlciBmdW5jdGlvbiBhcmd1bWVudHMsIHNvIHRoYXQgaXQgY2FuIGJlIHR1cm5lZCBpbnRvIGtleXdvcmQgYXJndW1lbnRzIGJ5IGpzaWkgZnJvbnRlbmRzXG4gICAgLy8gdGhhdCBzdXBwb3J0IHN1Y2guXG4gICAgY29uc3QgbGFzdFBhcmFtVHlwZVJlZiA9IGFwcGx5KGxhc3QocGFyYW1ldGVycyksICh4KSA9PiB4LnR5cGUpO1xuICAgIGNvbnN0IGxhc3RQYXJhbVN5bWJvbCA9IGxhc3Qoc2lnbmF0dXJlLmdldFBhcmFtZXRlcnMoKSk7XG4gICAgaWYgKGxhc3RQYXJhbVR5cGVSZWYgJiYgc3BlYy5pc05hbWVkVHlwZVJlZmVyZW5jZShsYXN0UGFyYW1UeXBlUmVmKSkge1xuICAgICAgdGhpcy5fZGVmZXJVbnRpbFR5cGVzQXZhaWxhYmxlKFxuICAgICAgICBzeW1ib2wubmFtZSxcbiAgICAgICAgW2xhc3RQYXJhbVR5cGVSZWZdLFxuICAgICAgICBsYXN0UGFyYW1TeW1ib2whLmRlY2xhcmF0aW9uc1swXSxcbiAgICAgICAgKGxhc3RQYXJhbVR5cGUpID0+IHtcbiAgICAgICAgICBpZiAoIXNwZWMuaXNJbnRlcmZhY2VUeXBlKGxhc3RQYXJhbVR5cGUpIHx8ICFsYXN0UGFyYW1UeXBlLmRhdGF0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTGlmdGFibGUgZGF0YXR5cGUsIG1ha2Ugc3VyZSBubyBwYXJhbWV0ZXIgbmFtZXMgbWF0Y2ggYW55IG9mIHRoZSBwcm9wZXJ0aWVzIGluIHRoZSBkYXRhdHlwZVxuICAgICAgICAgIGNvbnN0IHByb3BOYW1lcyA9IHRoaXMuYWxsUHJvcGVydGllcyhsYXN0UGFyYW1UeXBlKTtcbiAgICAgICAgICBjb25zdCBwYXJhbU5hbWVzID0gbmV3IFNldChcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuc2xpY2UoMCwgcGFyYW1ldGVycy5sZW5ndGggLSAxKS5tYXAoKHgpID0+IHgubmFtZSksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBzaGFyZWROYW1lcyA9IGludGVyc2VjdGlvbihwcm9wTmFtZXMsIHBhcmFtTmFtZXMpO1xuXG4gICAgICAgICAgZm9yIChjb25zdCBiYWROYW1lIG9mIHNoYXJlZE5hbWVzKSB7XG4gICAgICAgICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzUwMTdfUE9TSVRJT05BTF9LRVlXT1JEX0NPTkZMSUNULmNyZWF0ZShcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbixcbiAgICAgICAgICAgICAgICBiYWROYW1lLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuX3ZhbGlkYXRlUmVmZXJlbmNlZERvY1BhcmFtcyhtZXRob2QsIHN5bWJvbCk7XG5cbiAgICB0eXBlLm1ldGhvZHMgPSB0eXBlLm1ldGhvZHMgPz8gW107XG4gICAgaWYgKFxuICAgICAgdHlwZS5tZXRob2RzLmZpbmQoXG4gICAgICAgIChtKSA9PiBtLm5hbWUgPT09IG1ldGhvZC5uYW1lICYmIG0uc3RhdGljID09PSBtZXRob2Quc3RhdGljLFxuICAgICAgKSAhPSBudWxsXG4gICAgKSB7XG4gICAgICBMT0cudHJhY2UoXG4gICAgICAgIGBEcm9wcGluZyByZS1kZWNsYXJhdGlvbiBvZiAke2NvbG9ycy5ncmVlbih0eXBlLmZxbil9IyR7Y29sb3JzLmN5YW4oXG4gICAgICAgICAgbWV0aG9kLm5hbWUsXG4gICAgICAgICl9YCxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHR5cGUubWV0aG9kcy5wdXNoKG1ldGhvZCk7XG4gICAgdGhpcy5vdmVycmlkZURvY0NvbW1lbnQoc3ltYm9sLCBtZXRob2QuZG9jcywgcGFyYW1Eb2NzKG1ldGhvZC5wYXJhbWV0ZXJzKSk7XG4gIH1cblxuICBwcml2YXRlIF93YXJuQWJvdXRSZXNlcnZlZFdvcmRzKHN5bWJvbDogdHMuU3ltYm9sKSB7XG4gICAgaWYgKCFlbmFibGVkV2FybmluZ3NbJ3Jlc2VydmVkLXdvcmQnXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc2VydmluZ0xhbmd1YWdlcyA9IGlzUmVzZXJ2ZWROYW1lKHN5bWJvbC5uYW1lKTtcbiAgICBpZiAocmVzZXJ2aW5nTGFuZ3VhZ2VzKSB7XG4gICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzUwMThfUkVTRVJWRURfV09SRC5jcmVhdGUoXG4gICAgICAgICAgX25hbWVPckRlY2xhcmF0aW9uTm9kZShzeW1ib2wpLFxuICAgICAgICAgIHN5bWJvbC5uYW1lLFxuICAgICAgICAgIHJlc2VydmluZ0xhbmd1YWdlcyxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfdmlzaXRQcm9wZXJ0eShcbiAgICBzeW1ib2w6IHRzLlN5bWJvbCxcbiAgICB0eXBlOiBzcGVjLkNsYXNzVHlwZSB8IHNwZWMuSW50ZXJmYWNlVHlwZSxcbiAgICBjdHg6IEVtaXRDb250ZXh0LFxuICAgIGRlY2xhcmluZ1R5cGVEZWNsOiB0cy5DbGFzc0xpa2VEZWNsYXJhdGlvbiB8IHRzLkludGVyZmFjZURlY2xhcmF0aW9uLFxuICApIHtcbiAgICBpZiAodHlwZS5wcm9wZXJ0aWVzPy5maW5kKChwKSA9PiBwLm5hbWUgPT09IHN5bWJvbC5uYW1lKSkge1xuICAgICAgLypcbiAgICAgICAqIFNlY29uZCBkZWNsYXJhdGlvbiBvZiB0aGUgc2FtZSBwcm9wZXJ0eS4gRm9yIGV4YW1wbGUsIGlmIGNvZGUgc3BlY2lmaWVzIGEgZ2V0dGVyICYgc2V0dGVyIHNpZ25hdHVyZSxcbiAgICAgICAqIHRoZXJlIHdpbGwgYmUgb25lIHBhc3MgZm9yIGVhY2ggb2YgdGhlIHNpZ25hdHVyZXMsIGJ1dCB3ZSBjYW4gcHJvY2VzcyBvbmx5IHRoZSBmaXJzdCBlbmNvdW50ZXJlZC4gVGhlXG4gICAgICAgKiB0eXBlc2NyaXB0IGNvbXBpbGVyIHdpbGwgdGFrZSBjYXJlIG9mIG1ha2luZyBzdXJlIHdlIGRvbid0IGhhdmUgY29uZmxpY3RpbmcgZGVjbGFyYXRpb25zLCBhbnl3YXkuXG4gICAgICAgKi9cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoTE9HLmlzVHJhY2VFbmFibGVkKCkpIHtcbiAgICAgIExPRy50cmFjZShcbiAgICAgICAgYFByb2Nlc3NpbmcgcHJvcGVydHk6ICR7Y29sb3JzLmdyZWVuKHR5cGUuZnFuKX0jJHtjb2xvcnMuY3lhbihcbiAgICAgICAgICBzeW1ib2wubmFtZSxcbiAgICAgICAgKX1gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWNsYXJhdGlvbiA9IHN5bWJvbC52YWx1ZURlY2xhcmF0aW9uID8/IHN5bWJvbC5kZWNsYXJhdGlvbnNbMF07XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gZGVjbGFyYXRpb24gYXNcbiAgICAgIHwgdHMuUHJvcGVydHlTaWduYXR1cmVcbiAgICAgIHwgdHMuUHJvcGVydHlEZWNsYXJhdGlvblxuICAgICAgfCB0cy5BY2Nlc3NvckRlY2xhcmF0aW9uXG4gICAgICB8IHRzLlBhcmFtZXRlclByb3BlcnR5RGVjbGFyYXRpb247XG5cbiAgICBpZiAoQ2FzZS5wYXNjYWwodHlwZS5uYW1lKSA9PT0gQ2FzZS5wYXNjYWwoc3ltYm9sLm5hbWUpKSB7XG4gICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzUwMTlfTUVNQkVSX1RZUEVfTkFNRV9DT05GTElDVC5jcmVhdGUoXG4gICAgICAgICAgc2lnbmF0dXJlLm5hbWUsXG4gICAgICAgICAgJ3Byb3BlcnR5JyxcbiAgICAgICAgICBzeW1ib2wsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgKS5hZGRSZWxhdGVkSW5mb3JtYXRpb24oXG4gICAgICAgICAgZGVjbGFyaW5nVHlwZURlY2wubmFtZSA/PyBkZWNsYXJpbmdUeXBlRGVjbCxcbiAgICAgICAgICBgVGhlIGRlY2xhcmluZyAke3R5cGUua2luZH0gaXMgaW50cm9kdWNlZCBoZXJlYCxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGlzUHJvaGliaXRlZE1lbWJlck5hbWUoc3ltYm9sLm5hbWUpKSB7XG4gICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzUwMTZfUFJPSElCSVRFRF9NRU1CRVJfTkFNRS5jcmVhdGUoXG4gICAgICAgICAgc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24gPz8gc3ltYm9sLmRlY2xhcmF0aW9uc1swXSxcbiAgICAgICAgICBzeW1ib2wubmFtZSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fd2FybkFib3V0UmVzZXJ2ZWRXb3JkcyhzeW1ib2wpO1xuXG4gICAgY29uc3QgcHJvcGVydHk6IHNwZWMuUHJvcGVydHkgPSBiaW5kaW5ncy5zZXRQcm9wZXJ0eVJlbGF0ZWROb2RlKFxuICAgICAge1xuICAgICAgICAuLi4oYXdhaXQgdGhpcy5fb3B0aW9uYWxWYWx1ZShcbiAgICAgICAgICB0aGlzLl90eXBlQ2hlY2tlci5nZXRUeXBlT2ZTeW1ib2xBdExvY2F0aW9uKHN5bWJvbCwgc2lnbmF0dXJlKSxcbiAgICAgICAgICBzaWduYXR1cmUubmFtZSxcbiAgICAgICAgICAncHJvcGVydHkgdHlwZScsXG4gICAgICAgICkpLFxuICAgICAgICBhYnN0cmFjdDogX2lzQWJzdHJhY3Qoc3ltYm9sLCB0eXBlKSB8fCB1bmRlZmluZWQsXG4gICAgICAgIG5hbWU6IHN5bWJvbC5uYW1lLFxuICAgICAgICBwcm90ZWN0ZWQ6IF9pc1Byb3RlY3RlZChzeW1ib2wpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhdGljOiBfaXNTdGF0aWMoc3ltYm9sKSB8fCB1bmRlZmluZWQsXG4gICAgICAgIGxvY2F0aW9uSW5Nb2R1bGU6IHRoaXMuZGVjbGFyYXRpb25Mb2NhdGlvbihzaWduYXR1cmUpLFxuICAgICAgfSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICApO1xuXG4gICAgaWYgKHRzLmlzR2V0QWNjZXNzb3Ioc2lnbmF0dXJlKSkge1xuICAgICAgY29uc3QgZGVjbHMgPSBzeW1ib2wuZ2V0RGVjbGFyYXRpb25zKCkgPz8gW107XG4gICAgICBwcm9wZXJ0eS5pbW11dGFibGUgPVxuICAgICAgICAhZGVjbHMuc29tZSgoZGVjbCkgPT4gdHMuaXNTZXRBY2Nlc3NvcihkZWNsKSkgfHwgdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wZXJ0eS5pbW11dGFibGUgPVxuICAgICAgICAodHMuZ2V0Q29tYmluZWRNb2RpZmllckZsYWdzKHNpZ25hdHVyZSkgJiB0cy5Nb2RpZmllckZsYWdzLlJlYWRvbmx5KSAhPT1cbiAgICAgICAgICAwIHx8IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoc2lnbmF0dXJlLnF1ZXN0aW9uVG9rZW4pIHtcbiAgICAgIHByb3BlcnR5Lm9wdGlvbmFsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBwcm9wZXJ0eS5zdGF0aWMgJiZcbiAgICAgIHByb3BlcnR5LmltbXV0YWJsZSAmJlxuICAgICAgdHMuaXNQcm9wZXJ0eURlY2xhcmF0aW9uKHNpZ25hdHVyZSkgJiZcbiAgICAgIHNpZ25hdHVyZS5pbml0aWFsaXplclxuICAgICkge1xuICAgICAgcHJvcGVydHkuY29uc3QgPSB0cnVlO1xuICAgIH1cblxuICAgIHByb3BlcnR5LmRvY3MgPSB0aGlzLl92aXNpdERvY3VtZW50YXRpb24oc3ltYm9sLCBjdHgpLmRvY3M7XG5cbiAgICB0eXBlLnByb3BlcnRpZXMgPSB0eXBlLnByb3BlcnRpZXMgPz8gW107XG4gICAgaWYgKFxuICAgICAgdHlwZS5wcm9wZXJ0aWVzLmZpbmQoXG4gICAgICAgIChwcm9wKSA9PlxuICAgICAgICAgIHByb3AubmFtZSA9PT0gcHJvcGVydHkubmFtZSAmJiBwcm9wLnN0YXRpYyA9PT0gcHJvcGVydHkuc3RhdGljLFxuICAgICAgKSAhPSBudWxsXG4gICAgKSB7XG4gICAgICBMT0cudHJhY2UoXG4gICAgICAgIGBEcm9wcGluZyByZS1kZWNsYXJhdGlvbiBvZiAke2NvbG9ycy5ncmVlbih0eXBlLmZxbil9IyR7Y29sb3JzLmN5YW4oXG4gICAgICAgICAgcHJvcGVydHkubmFtZSxcbiAgICAgICAgKX1gLFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHlwZS5wcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuICAgIHRoaXMub3ZlcnJpZGVEb2NDb21tZW50KHN5bWJvbCwgcHJvcGVydHkuZG9jcyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF90b1BhcmFtZXRlcihcbiAgICBwYXJhbVN5bWJvbDogdHMuU3ltYm9sLFxuICAgIGN0eDogRW1pdENvbnRleHQsXG4gICk6IFByb21pc2U8c3BlYy5QYXJhbWV0ZXI+IHtcbiAgICBpZiAoTE9HLmlzVHJhY2VFbmFibGVkKCkpIHtcbiAgICAgIExPRy50cmFjZShgUHJvY2Vzc2luZyBwYXJhbWV0ZXI6ICR7Y29sb3JzLmN5YW4ocGFyYW1TeW1ib2wubmFtZSl9YCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtRGVjbGFyYXRpb24gPVxuICAgICAgcGFyYW1TeW1ib2wudmFsdWVEZWNsYXJhdGlvbiBhcyB0cy5QYXJhbWV0ZXJEZWNsYXJhdGlvbjtcblxuICAgIHRoaXMuX3dhcm5BYm91dFJlc2VydmVkV29yZHMocGFyYW1TeW1ib2wpO1xuXG4gICAgY29uc3QgcGFyYW1ldGVyOiBzcGVjLlBhcmFtZXRlciA9IGJpbmRpbmdzLnNldFBhcmFtZXRlclJlbGF0ZWROb2RlKFxuICAgICAge1xuICAgICAgICAuLi4oYXdhaXQgdGhpcy5fb3B0aW9uYWxWYWx1ZShcbiAgICAgICAgICB0aGlzLl90eXBlQ2hlY2tlci5nZXRUeXBlQXRMb2NhdGlvbihwYXJhbURlY2xhcmF0aW9uKSxcbiAgICAgICAgICBwYXJhbURlY2xhcmF0aW9uLm5hbWUsXG4gICAgICAgICAgJ3BhcmFtZXRlciB0eXBlJyxcbiAgICAgICAgKSksXG4gICAgICAgIG5hbWU6IHBhcmFtU3ltYm9sLm5hbWUsXG4gICAgICAgIHZhcmlhZGljOiBwYXJhbURlY2xhcmF0aW9uLmRvdERvdERvdFRva2VuICYmIHRydWUsXG4gICAgICB9LFxuICAgICAgcGFyYW1EZWNsYXJhdGlvbixcbiAgICApO1xuXG4gICAgaWYgKHBhcmFtZXRlci52YXJpYWRpYyAmJiBzcGVjLmlzQ29sbGVjdGlvblR5cGVSZWZlcmVuY2UocGFyYW1ldGVyLnR5cGUpKSB7XG4gICAgICAvLyBUeXBlU2NyaXB0IHR5cGVzIHZhcmlhZGljIHBhcmFtZXRlcnMgYXMgYW4gYXJyYXksIGJ1dCBKU0lJIHVzZXMgdGhlIGl0ZW0tdHlwZSBpbnN0ZWFkLlxuICAgICAgcGFyYW1ldGVyLnR5cGUgPSBwYXJhbWV0ZXIudHlwZS5jb2xsZWN0aW9uLmVsZW1lbnR0eXBlO1xuICAgIH0gZWxzZSBpZiAocGFyYW1EZWNsYXJhdGlvbi5pbml0aWFsaXplciB8fCBwYXJhbURlY2xhcmF0aW9uLnF1ZXN0aW9uVG9rZW4pIHtcbiAgICAgIC8vIE9wdGlvbmFsIHBhcmFtZXRlcnMgaGF2ZSBhbiBpbmhlcmVudGx5IG51bGwtYWJsZSB0eXBlLlxuICAgICAgcGFyYW1ldGVyLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBwYXJhbWV0ZXIuZG9jcyA9IHRoaXMuX3Zpc2l0RG9jdW1lbnRhdGlvbihcbiAgICAgIHBhcmFtU3ltYm9sLFxuICAgICAgY3R4LnJlbW92ZVN0YWJpbGl0eSgpLCAvLyBObyBpbmhlcml0YW5jZSBvbiBwdXJwb3NlXG4gICAgKS5kb2NzO1xuXG4gICAgLy8gRG9uJ3QgcmV3cml0ZSBkb2MgY29tbWVudCBoZXJlIG9uIHB1cnBvc2UgLS0gaW5zdGVhZCwgd2UgYWRkIHRoZW0gYXMgJ0BwYXJhbSdcbiAgICAvLyBpbnRvIHRoZSBwYXJlbnQncyBkb2MgY29tbWVudC5cblxuICAgIHJldHVybiBwYXJhbWV0ZXI7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF90eXBlUmVmZXJlbmNlKFxuICAgIHR5cGU6IHRzLlR5cGUsXG4gICAgZGVjbGFyYXRpb246IHRzLk5vZGUsXG4gICAgcHVycG9zZTogVHlwZVVzZUtpbmQsXG4gICk6IFByb21pc2U8c3BlYy5UeXBlUmVmZXJlbmNlPiB7XG4gICAgY29uc3Qgb3B0aW9uYWxWYWx1ZSA9IGF3YWl0IHRoaXMuX29wdGlvbmFsVmFsdWUodHlwZSwgZGVjbGFyYXRpb24sIHB1cnBvc2UpO1xuICAgIGlmIChvcHRpb25hbFZhbHVlLm9wdGlvbmFsKSB7XG4gICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzM5OTlfSU5DT0hFUkVOVF9UWVBFX01PREVMLmNyZWF0ZShcbiAgICAgICAgICBkZWNsYXJhdGlvbixcbiAgICAgICAgICAnRW5jb3VudGVyZWQgb3B0aW9uYWwgdmFsdWUgaW4gbG9jYXRpb24gd2hlcmUgYSBwbGFpbiB0eXBlIHJlZmVyZW5jZSBpcyBleHBlY3RlZCcsXG4gICAgICAgICksXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uYWxWYWx1ZS50eXBlO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfb3B0aW9uYWxWYWx1ZShcbiAgICB0eXBlOiB0cy5UeXBlLFxuICAgIGRlY2xhcmF0aW9uOiB0cy5Ob2RlLFxuICAgIHB1cnBvc2U6IFR5cGVVc2VLaW5kLFxuICApOiBQcm9taXNlPHNwZWMuT3B0aW9uYWxWYWx1ZT4ge1xuICAgIGNvbnN0IGlzVGhpc1R5cGUgPSBfaXNUaGlzVHlwZSh0eXBlLCB0aGlzLl90eXBlQ2hlY2tlcik7XG5cbiAgICBpZiAodHlwZS5pc0xpdGVyYWwoKSAmJiBfaXNFbnVtTGlrZSh0eXBlKSkge1xuICAgICAgdHlwZSA9IHRoaXMuX3R5cGVDaGVja2VyLmdldEJhc2VUeXBlT2ZMaXRlcmFsVHlwZSh0eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IHRoaXMuX3R5cGVDaGVja2VyLmdldEFwcGFyZW50VHlwZSh0eXBlKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcmltaXRpdmVUeXBlID0gX3RyeU1ha2VQcmltaXRpdmVUeXBlLmNhbGwodGhpcyk7XG4gICAgaWYgKHByaW1pdGl2ZVR5cGUpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHByaW1pdGl2ZVR5cGUgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZS5pc1VuaW9uKCkgJiYgIV9pc0VudW1MaWtlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gX3VuaW9uVHlwZS5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGlmICghdHlwZS5zeW1ib2wpIHtcbiAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfMTAwMV9UWVBFX0hBU19OT19TWU1CT0wuY3JlYXRlKGRlY2xhcmF0aW9uKSxcbiAgICAgICk7XG4gICAgICByZXR1cm4geyB0eXBlOiBzcGVjLkNBTk9OSUNBTF9BTlkgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZS5zeW1ib2wubmFtZSA9PT0gJ0FycmF5Jykge1xuICAgICAgcmV0dXJuIHsgdHlwZTogYXdhaXQgX2FycmF5VHlwZS5jYWxsKHRoaXMpIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGUuc3ltYm9sLm5hbWUgPT09ICdfX3R5cGUnICYmIHR5cGUuc3ltYm9sLm1lbWJlcnMpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IGF3YWl0IF9tYXBUeXBlLmNhbGwodGhpcykgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZS5zeW1ib2wuZXNjYXBlZE5hbWUgPT09ICdQcm9taXNlJykge1xuICAgICAgY29uc3QgdHlwZVJlZiA9IHR5cGUgYXMgdHMuVHlwZVJlZmVyZW5jZTtcbiAgICAgIGlmICghdHlwZVJlZi50eXBlQXJndW1lbnRzIHx8IHR5cGVSZWYudHlwZUFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzEwMDJfVU5TUEVDSUZJRURfUFJPTUlTRS5jcmVhdGUoZGVjbGFyYXRpb24pLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBzcGVjLkNBTk9OSUNBTF9BTlkgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGF3YWl0IHRoaXMuX3R5cGVSZWZlcmVuY2UoXG4gICAgICAgICAgdHlwZVJlZi50eXBlQXJndW1lbnRzWzBdLFxuICAgICAgICAgIGRlY2xhcmF0aW9uLFxuICAgICAgICAgIHB1cnBvc2UsXG4gICAgICAgICksXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB7IGZxbjogYXdhaXQgdGhpcy5fZ2V0RlFOKHR5cGUsIGRlY2xhcmF0aW9uLCBwdXJwb3NlLCBpc1RoaXNUeXBlKSB9LFxuICAgIH07XG5cbiAgICBhc3luYyBmdW5jdGlvbiBfYXJyYXlUeXBlKFxuICAgICAgdGhpczogQXNzZW1ibGVyLFxuICAgICk6IFByb21pc2U8c3BlYy5Db2xsZWN0aW9uVHlwZVJlZmVyZW5jZT4ge1xuICAgICAgY29uc3QgdHlwZVJlZiA9IHR5cGUgYXMgdHMuVHlwZVJlZmVyZW5jZTtcbiAgICAgIGxldCBlbGVtZW50dHlwZTogc3BlYy5UeXBlUmVmZXJlbmNlO1xuXG4gICAgICBpZiAodHlwZVJlZi50eXBlQXJndW1lbnRzPy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZWxlbWVudHR5cGUgPSBhd2FpdCB0aGlzLl90eXBlUmVmZXJlbmNlKFxuICAgICAgICAgIHR5cGVSZWYudHlwZUFyZ3VtZW50c1swXSxcbiAgICAgICAgICBkZWNsYXJhdGlvbixcbiAgICAgICAgICAnbGlzdCBlbGVtZW50IHR5cGUnLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY291bnQgPSB0eXBlUmVmLnR5cGVBcmd1bWVudHNcbiAgICAgICAgICA/IHR5cGVSZWYudHlwZUFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgICA6ICdub25lJztcbiAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzEwMDNfVU5TVVBQT1JURURfVFlQRS5jcmVhdGUoXG4gICAgICAgICAgICBkZWNsYXJhdGlvbixcbiAgICAgICAgICAgIGBBcnJheSByZWZlcmVuY2VzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSB0eXBlIGFyZ3VtZW50IChmb3VuZCAke2NvdW50fSlgLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICAgIGVsZW1lbnR0eXBlID0gc3BlYy5DQU5PTklDQUxfQU5ZO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2xsZWN0aW9uOiB7XG4gICAgICAgICAgZWxlbWVudHR5cGUsXG4gICAgICAgICAga2luZDogc3BlYy5Db2xsZWN0aW9uS2luZC5BcnJheSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gX21hcFR5cGUoXG4gICAgICB0aGlzOiBBc3NlbWJsZXIsXG4gICAgKTogUHJvbWlzZTxzcGVjLkNvbGxlY3Rpb25UeXBlUmVmZXJlbmNlPiB7XG4gICAgICBsZXQgZWxlbWVudHR5cGU6IHNwZWMuVHlwZVJlZmVyZW5jZTtcbiAgICAgIGNvbnN0IG9iamVjdFR5cGUgPSB0eXBlLmdldFN0cmluZ0luZGV4VHlwZSgpO1xuICAgICAgaWYgKG9iamVjdFR5cGUpIHtcbiAgICAgICAgZWxlbWVudHR5cGUgPSBhd2FpdCB0aGlzLl90eXBlUmVmZXJlbmNlKFxuICAgICAgICAgIG9iamVjdFR5cGUsXG4gICAgICAgICAgZGVjbGFyYXRpb24sXG4gICAgICAgICAgJ21hcCBlbGVtZW50IHR5cGUnLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzEwMDNfVU5TVVBQT1JURURfVFlQRS5jcmVhdGUoXG4gICAgICAgICAgICBkZWNsYXJhdGlvbixcbiAgICAgICAgICAgICdPbmx5IHN0cmluZy1pbmRleGVkIG1hcCB0eXBlcyBhcmUgc3VwcG9ydGVkJyxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgICBlbGVtZW50dHlwZSA9IHNwZWMuQ0FOT05JQ0FMX0FOWTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbGxlY3Rpb246IHtcbiAgICAgICAgICBlbGVtZW50dHlwZSxcbiAgICAgICAgICBraW5kOiBzcGVjLkNvbGxlY3Rpb25LaW5kLk1hcCxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3RyeU1ha2VQcmltaXRpdmVUeXBlKFxuICAgICAgdGhpczogQXNzZW1ibGVyLFxuICAgICk6IHNwZWMuUHJpbWl0aXZlVHlwZVJlZmVyZW5jZSB8IHVuZGVmaW5lZCB7XG4gICAgICBpZiAoIXR5cGUuc3ltYm9sKSB7XG4gICAgICAgIGlmICh0eXBlLmZsYWdzICYgdHMuVHlwZUZsYWdzLk9iamVjdCkge1xuICAgICAgICAgIHJldHVybiB7IHByaW1pdGl2ZTogc3BlYy5QcmltaXRpdmVUeXBlLkpzb24gfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZS5mbGFncyAmICh0cy5UeXBlRmxhZ3MuQW55IHwgdHMuVHlwZUZsYWdzLlVua25vd24pKSB7XG4gICAgICAgICAgcmV0dXJuIHNwZWMuQ0FOT05JQ0FMX0FOWTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgdHlwZS5zeW1ib2wudmFsdWVEZWNsYXJhdGlvbiAmJlxuICAgICAgICBpc1VuZGVyKFxuICAgICAgICAgIHR5cGUuc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24uZ2V0U291cmNlRmlsZSgpLmZpbGVOYW1lLFxuICAgICAgICAgIHRoaXMuc3RkbGliLFxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgc3dpdGNoICh0eXBlLnN5bWJvbC5uYW1lKSB7XG4gICAgICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICAgICAgICByZXR1cm4geyBwcmltaXRpdmU6IHNwZWMuUHJpbWl0aXZlVHlwZS5Cb29sZWFuIH07XG4gICAgICAgICAgY2FzZSAnRGF0ZSc6XG4gICAgICAgICAgICByZXR1cm4geyBwcmltaXRpdmU6IHNwZWMuUHJpbWl0aXZlVHlwZS5EYXRlIH07XG4gICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICAgIHJldHVybiB7IHByaW1pdGl2ZTogc3BlYy5QcmltaXRpdmVUeXBlLk51bWJlciB9O1xuICAgICAgICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgICAgICAgICByZXR1cm4geyBwcmltaXRpdmU6IHNwZWMuUHJpbWl0aXZlVHlwZS5TdHJpbmcgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTm90IGEgcHJpbWl0aXZlIHR5cGUhXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICBmdW5jdGlvbiBpc1VuZGVyKGZpbGU6IHN0cmluZywgZGlyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgcmVsYXRpdmUgPSBwYXRoLnJlbGF0aXZlKGRpciwgZmlsZSk7XG4gICAgICAgIHJldHVybiAhcmVsYXRpdmUuc3RhcnRzV2l0aChwYXRoLnNlcCkgJiYgIXJlbGF0aXZlLnN0YXJ0c1dpdGgoJy4uJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gX3VuaW9uVHlwZSh0aGlzOiBBc3NlbWJsZXIpOiBQcm9taXNlPHNwZWMuT3B0aW9uYWxWYWx1ZT4ge1xuICAgICAgY29uc3QgdHlwZXMgPSBuZXcgQXJyYXk8c3BlYy5UeXBlUmVmZXJlbmNlPigpO1xuICAgICAgbGV0IG9wdGlvbmFsOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuXG4gICAgICBmb3IgKGNvbnN0IHN1YlR5cGUgb2YgKHR5cGUgYXMgdHMuVW5pb25UeXBlKS50eXBlcykge1xuICAgICAgICBpZiAoc3ViVHlwZS5mbGFncyAmIHRzLlR5cGVGbGFncy5VbmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25hbCA9IHRydWU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRUeXBlID0gYXdhaXQgdGhpcy5fdHlwZVJlZmVyZW5jZShcbiAgICAgICAgICBzdWJUeXBlLFxuICAgICAgICAgIGRlY2xhcmF0aW9uLFxuICAgICAgICAgIHB1cnBvc2UsXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0eXBlcy5maW5kKChyZWYpID0+IGRlZXBFcXVhbChyZWYsIHJlc29sdmVkVHlwZSkpICE9IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlcy5wdXNoKHJlc29sdmVkVHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlcy5sZW5ndGggPT09IDFcbiAgICAgICAgPyB7IG9wdGlvbmFsLCB0eXBlOiB0eXBlc1swXSB9XG4gICAgICAgIDogeyBvcHRpb25hbCwgdHlwZTogeyB1bmlvbjogeyB0eXBlcyB9IH0gfTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNhbGxEZWZlcnJlZHNJbk9yZGVyKCkge1xuICAgIC8vIERvIGEgdG9wb2xvZ2ljYWwgY2FsbCBvcmRlciBvZiBhbGwgZGVmZXJyZWRzLlxuICAgIHdoaWxlICh0aGlzLl9kZWZlcnJlZC5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBBbGwgZnFucyBpbiBkZXBlbmRlbmN5IGxpc3RzIHRoYXQgZG9uJ3QgaGF2ZSBhbnkgcGVuZGluZ1xuICAgICAgLy8gZGVmZXJyZWRzIHRoZW1zZWx2ZXMgY2FuIGJlIGV4ZWN1dGVkIG5vdywgc28gYXJlIHJlbW92ZWQgZnJvbVxuICAgICAgLy8gZGVwZW5kZW5jeSBsaXN0cy5cbiAgICAgIGNvbnN0IHBlbmRpbmdGcW5zID0gbmV3IFNldDxzdHJpbmc+KHRoaXMuX2RlZmVycmVkLm1hcCgoeCkgPT4geC5mcW4pKTtcbiAgICAgIGZvciAoY29uc3QgZGVmZXJyZWQgb2YgdGhpcy5fZGVmZXJyZWQpIHtcbiAgICAgICAgcmVzdHJpY3REZXBlbmRlbmNpZXNUbyhkZWZlcnJlZCwgcGVuZGluZ0ZxbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBJbnZva2UgYWxsIGRlZmVycmVkcyB3aXRoIG5vIG1vcmUgZGVwZW5kZW5jaWVzIGFuZCByZW1vdmUgdGhlbSBmcm9tIHRoZSBsaXN0LlxuICAgICAgbGV0IGludm9rZWQgPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZGVmZXJyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZmVycmVkW2ldLmRlcGVuZGVkRnFucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IHRoaXMuX2RlZmVycmVkLnNwbGljZShpLCAxKVswXTtcbiAgICAgICAgICBkZWZlcnJlZC5jYigpO1xuICAgICAgICAgIGludm9rZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaW52b2tlZCkge1xuICAgICAgICAvLyBBcHBhcmVudGx5IHdlJ3JlIHN0dWNrLiBDb21wbGFpbiBsb3VkbHkuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ291bGQgbm90IGludm9rZSBhbnkgbW9yZSBkZWZlcnJlZHMsIGN5Y2xpYyBkZXBlbmRlbmN5PyBSZW1haW5pbmc6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICB0aGlzLl9kZWZlcnJlZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIDIsXG4gICAgICAgICAgKX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldGFpbiBvbmx5IGVsZW1lbnRzIGluIHRoZSBkZXBlbmRlbmN5ZnFuIHRoYXQgYXJlIGFsc28gaW4gdGhlIHNldFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3RyaWN0RGVwZW5kZW5jaWVzVG8oZGVmOiBEZWZlcnJlZFJlY29yZCwgZnFuczogU2V0PHN0cmluZz4pIHtcbiAgICAgIGRlZi5kZXBlbmRlZEZxbnMgPSBkZWYuZGVwZW5kZWRGcW5zLmZpbHRlcihmcW5zLmhhcy5iaW5kKGZxbnMpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzZXQgb2YgYWxsIChpbmhlcml0ZWQpIHByb3BlcnRpZXMgb2YgYW4gaW50ZXJmYWNlXG4gICAqL1xuICBwcml2YXRlIGFsbFByb3BlcnRpZXMocm9vdDogc3BlYy5JbnRlcmZhY2VUeXBlKTogU2V0PHN0cmluZz4ge1xuICAgIGNvbnN0IHJldCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIHJlY3Vyc2UuY2FsbCh0aGlzLCByb290KTtcbiAgICByZXR1cm4gcmV0O1xuXG4gICAgZnVuY3Rpb24gcmVjdXJzZSh0aGlzOiBBc3NlbWJsZXIsIGludDogc3BlYy5JbnRlcmZhY2VUeXBlKSB7XG4gICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIGludC5wcm9wZXJ0aWVzID8/IFtdKSB7XG4gICAgICAgIHJldC5hZGQocHJvcGVydHkubmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgYmFzZVJlZiBvZiBpbnQuaW50ZXJmYWNlcyA/PyBbXSkge1xuICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fZGVyZWZlcmVuY2UoYmFzZVJlZiwgdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKCFiYXNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0ltcG9zc2libGUgdG8gaGF2ZSB1bnJlc29sdmFibGUgYmFzZSBpbiBhbGxQcm9wZXJ0aWVzKCknLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzcGVjLmlzSW50ZXJmYWNlVHlwZShiYXNlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdJbXBvc3NpYmxlIHRvIGhhdmUgbm9uLWludGVyZmFjZSBiYXNlIGluIGFsbFByb3BlcnRpZXMoKScsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2UuY2FsbCh0aGlzLCBiYXNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF92ZXJpZnlDb25zZWN1dGl2ZU9wdGlvbmFscyhcbiAgICBub2RlOiB0cy5Ob2RlLFxuICAgIHBhcmFtZXRlcnM/OiBzcGVjLlBhcmFtZXRlcltdLFxuICApIHtcbiAgICBpZiAoIXBhcmFtZXRlcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZW1haW5pbmcgPSBbLi4ucGFyYW1ldGVyc10ucmV2ZXJzZSgpO1xuICAgIHdoaWxlIChyZW1haW5pbmcubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY3VycmVudCA9IHJlbWFpbmluZy5wb3AoKSE7XG4gICAgICBpZiAoY3VycmVudC5vcHRpb25hbCkge1xuICAgICAgICBjb25zdCBvZmZlbmRlciA9IHJlbWFpbmluZy5maW5kKChwKSA9PiAhcC5vcHRpb25hbCAmJiAhcC52YXJpYWRpYyk7XG4gICAgICAgIGlmIChvZmZlbmRlciA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzMwMDlfT1BUSU9OQUxfUEFSQU1FVEVSX0JFRk9SRV9SRVFVSVJFRC5jcmVhdGUoXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIG9mZmVuZGVyLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICAgIGRlbGV0ZSBjdXJyZW50Lm9wdGlvbmFsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBydW50aW1lIHR5cGUgaW5mbyB3aXRoIHRoZSBmdWxseS1xdWFsaWZpZWQgbmFtZSBmb3IgdGhlIGN1cnJlbnQgY2xhc3MgZGVmaW5pdGlvbi5cbiAgICogVXNlZCBieSB0aGUgcnVudGltZSB0eXBlIGluZm8gaW5qZWN0b3IgdG8gYWRkIHRoaXMgaW5mb3JtYXRpb24gdG8gdGhlIGNvbXBpbGVkIGZpbGUuXG4gICAqL1xuICBwcml2YXRlIHJlZ2lzdGVyRXhwb3J0ZWRDbGFzc0ZxbihjbGF6ejogdHMuQ2xhc3NEZWNsYXJhdGlvbiwgZnFuOiBzdHJpbmcpIHtcbiAgICB0aGlzLnJ1bnRpbWVUeXBlSW5mb0luamVjdG9yLnJlZ2lzdGVyQ2xhc3NGcW4oY2xhenosIGZxbik7XG4gIH1cblxuICAvKipcbiAgICogRnJvbSB0aGUgZ2l2ZW4gSlNJSURvY3MsIHJlLXJlbmRlciB0aGUgVFNEb2MgY29tbWVudCBmb3IgdGhlIE5vZGVcbiAgICpcbiAgICogV2UgbWF5IGNoYW5nZSB0aGUgZG9jdW1lbnRhdGlvbiBhIGxpdHRsZSwgc28gdGhhdCB0aGUgZG9jIGNvbW1lbnQgdGhhdCBnZXRzXG4gICAqIHdyaXR0ZW4gaXMgbm90IG5lY2Vzc2FyaWx5IGV4YWN0bHkgdGhlIHNhbWUgYXMgdGhlIGRvY3MgdGhhdCBnbyBpbnRvIHRoZVxuICAgKiBKU0lJIG1hbmlmZXN0LlxuICAgKlxuICAgKiBUaGlzIG1ha2VzIGl0IHBvc3NpYmxlIGZvciB0aGUgY29kZSBkb2MgY29tbWVudHMgdG8gaGlnaGxpZ2h0IHRoaW5nc1xuICAgKiBzbGlnaGx5IGRpZmZlcmVudGx5IGZyb20gdGhlIEFQSSBSZWZlcmVuY2UsIGFuZCBtYWtlcyBzdXJlIHdlIGRvbid0XG4gICAqIGR1cGxpY2F0ZSBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogVW5sZXNzIHRoZSBkb2NzIGdvdCBjaGFuZ2VkLCB0aGlzIHlpZWxkcyB0aGUgc2FtZSBvdXRwdXQgYmFjayBhcyB0aGUgb25lIHRoYXRcbiAgICogd2Ugb3JpZ2luYWxseSBzYXcgKG1vZHVsbyB3aGl0ZXNwYWNlIGNoYW5nZXMpLlxuICAgKi9cbiAgcHJpdmF0ZSBvdmVycmlkZURvY0NvbW1lbnQoXG4gICAgc3ltYm9sPzogdHMuU3ltYm9sLFxuICAgIGRvY3M/OiBzcGVjLkRvY3MsXG4gICAgcGFyYW1ldGVycz86IFJlY29yZDxzdHJpbmcsIHNwZWMuRG9jcz4sXG4gICkge1xuICAgIGlmICghZG9jcyB8fCAhc3ltYm9sKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZG9jcyA9IHRoaXMuZG9jQ29tbWVudERvY3MoZG9jcyk7XG5cbiAgICAvLyBTb21lIHN5bWJvbHMgaGF2ZSBtdWx0aXBsZSBkZWNsYXJhdGlvbnMgKGZvciBleGFtcGxlLCBhIGNsYXNzICsgaW50ZXJmYWNlXG4gICAgLy8gbWl4aW5zLCBvciBhIHByb3BlcnR5IGRlY2xhcnRhaW9uICsgY29uc3RydWN0b3IgYXJndW1lbnQpLlxuICAgIC8vXG4gICAgLy8gV2UgRE9OJ1Qgd3dhbnQgdG8gcHV0IHRoZSBkb2MgY29tbWVudCBvbiB0aGUgY29uc3RydWN0b3IgYXJndW1lbnQsIGJlY2F1c2UgaXRcbiAgICAvLyBsb29rcyBzaWxseSB0aGVyZS5cbiAgICBmb3IgKGNvbnN0IGRlY2wgb2Ygc3ltYm9sLmdldERlY2xhcmF0aW9ucygpID8/IFtdKSB7XG4gICAgICBpZiAodHMuaXNQYXJhbWV0ZXIoZGVjbCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29tbWVudFJlcGxhY2VyLm92ZXJyaWRlTm9kZURvY0NvbW1lbnQoXG4gICAgICAgIGRlY2wsXG4gICAgICAgIHJlbmRlclN5bWJvbERvY3VtZW50YXRpb24oZG9jcywgcGFyYW1ldGVycyksXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBwb3RlbnRpYWxseSBuZXcgc2V0IG9mIERvY3MsIGZvciByZW5kZXJpbmcgYmFjayB0byBhIFR5cGVTY3JpcHQgZG9jIGNvbW1lbnRcbiAgICpcbiAgICogV2UgcHV0IHRoZSBcIihleHBlcmltZW50YWwpXCIvXCIoZGVwcmVjYXRlZClcIiBzdGF0dXMgaW50byB0aGUgZG9jXG4gICAqIGNvbW1lbnQgc3VtbWFyeSwgc28gdGhhdCBpdCdzIHByZXNlbnRlZCBmcm9udCBhbmQgY2VudGVyLlxuICAgKi9cbiAgcHJpdmF0ZSBkb2NDb21tZW50RG9jcyhkb2NzOiBSZWFkb25seTxzcGVjLkRvY3M+KTogc3BlYy5Eb2NzIHtcbiAgICAvLyBNb2RpZnkgdGhlIHN1bW1hcnkgaWYgdGhpcyBBUEkgZWxlbWVudCBoYXMgYSBzcGVjaWFsIHN0YWJpbGl0eVxuICAgIGlmIChkb2NzLnN0YWJpbGl0eSA9PT0gc3BlYy5TdGFiaWxpdHkuRXhwZXJpbWVudGFsICYmIGRvY3Muc3VtbWFyeSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZG9jcyxcbiAgICAgICAgc3VtbWFyeTogYChleHBlcmltZW50YWwpICR7ZG9jcy5zdW1tYXJ5fWAsXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoZG9jcy5zdGFiaWxpdHkgPT09IHNwZWMuU3RhYmlsaXR5LkRlcHJlY2F0ZWQgJiYgZG9jcy5zdW1tYXJ5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5kb2NzLFxuICAgICAgICBzdW1tYXJ5OiBgKGRlcHJlY2F0ZWQpICR7ZG9jcy5zdW1tYXJ5fWAsXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZG9jcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gb25seSB0aG9zZSBzdWJtb2R1bGVzIGZyb20gdGhlIHN1Ym1vZHVsZXMgbGlzdCB0aGF0IGFyZSBzdWJtb2R1bGVzIGluc2lkZSB0aGlzXG4gICAqIGFzc2VtYmx5LlxuICAgKi9cbiAgcHJpdmF0ZSBteVN1Ym1vZHVsZXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fc3VibW9kdWxlcy52YWx1ZXMoKSkuZmlsdGVyKChtKSA9PlxuICAgICAgbS5mcW4uc3RhcnRzV2l0aChgJHt0aGlzLnByb2plY3RJbmZvLm5hbWV9LmApLFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBc3NlbWJsZXJPcHRpb25zIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVtb3ZlIGBAZGVwcmVjYXRlZGAgbWVtYmVycyBmcm9tIHRoZSBnZW5lcmF0ZWQgYXNzZW1ibHkuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBzdHJpcERlcHJlY2F0ZWQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJZiBgc3RyaXBEZXByZWNhdGVkYCBpcyB0cnVlLCBhbmQgYSBmaWxlIGlzIHByb3ZpZGVkIGhlcmUsIG9ubHkgdGhlIEZRTnNcbiAgICogcHJlc2VudCBpbiB0aGUgZmlsZSB3aWxsIGFjdHVhbGx5IGJlIHJlbW92ZWQuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuXG4gICAqIHlvdSB3aXNoIHRvIGRlcHJlY2F0ZSBzb21lIGVsZW1lbnRzIHdpdGhvdXQgYWN0dWFsbHkgcmVtb3ZpbmcgdGhlbS5cbiAgICpcbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqL1xuICByZWFkb25seSBzdHJpcERlcHJlY2F0ZWRBbGxvd0xpc3RGaWxlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGluamVjdCBjb2RlIHRoYXQgd2FybnMgd2hlbiBhIGRlcHJlY2F0ZWQgZWxlbWVudCBpcyB1c2VkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgYWRkRGVwcmVjYXRpb25XYXJuaW5ncz86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBTdWJtb2R1bGVTcGVjIHtcbiAgLyoqXG4gICAqIFRoZSBzdWJtb2R1bGUncyBmdWxseSBxdWFsaWZpZWQgbmFtZS5cbiAgICovXG4gIHJlYWRvbmx5IGZxbjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgc3VibW9kdWxlJ3MgZnVsbHkgcXVhbGlmaWVkIG5hbWUgcHJlZml4IHRvIHVzZSB3aGVuIHJlc29sdmluZyB0eXBlIEZRTnMuIFRoaXMgZG9lcyBub3RcbiAgICogaW5jbHVkZSBcImlubGluZSBuYW1lc3BhY2VcIiBuYW1lcyBhcyB0aG9zZSBhcmUgYWxyZWFkeSByZXByZXNlbnRlZCBpbiB0aGUgVHlwZUNoZWNrZXJzJyB2aWV3IG9mXG4gICAqIHRoZSB0eXBlIG5hbWVzLlxuICAgKi9cbiAgcmVhZG9ubHkgZnFuUmVzb2x1dGlvblByZWZpeDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbG9jYXRpb24gb2YgdGhlIHN1Ym1vZHVsZSBkZWZpbml0aW9uIGluIHRoZSBzb3VyY2UuXG4gICAqL1xuICByZWFkb25seSBsb2NhdGlvbkluTW9kdWxlOiBzcGVjLlNvdXJjZUxvY2F0aW9uO1xuXG4gIC8qKlxuICAgKiBBbnkgY3VzdG9taXplZCBjb25maWd1cmF0aW9uIGZvciB0aGUgY3VycmVudGwgc3VibW9kdWxlLlxuICAgKi9cbiAgcmVhZG9ubHkgdGFyZ2V0cz86IHNwZWMuQXNzZW1ibHlUYXJnZXRzO1xuXG4gIC8qKlxuICAgKiBSZWFkbWUgZm9yIHRoaXMgc3VibW9kdWxlIChpZiBmb3VuZClcbiAgICovXG4gIHJlYWRvbmx5IHJlYWRtZT86IHNwZWMuUmVhZE1lO1xufVxuXG5mdW5jdGlvbiBfZmluZ2VycHJpbnQoYXNzZW1ibHk6IHNwZWMuQXNzZW1ibHkpOiBzcGVjLkFzc2VtYmx5IHtcbiAgZGVsZXRlIGFzc2VtYmx5LmZpbmdlcnByaW50O1xuICBhc3NlbWJseSA9IHNvcnRKc29uKGFzc2VtYmx5KTtcbiAgY29uc3QgZmluZ2VycHJpbnQgPSBjcnlwdG9cbiAgICAuY3JlYXRlSGFzaCgnc2hhMjU2JylcbiAgICAudXBkYXRlKEpTT04uc3RyaW5naWZ5KGFzc2VtYmx5KSlcbiAgICAuZGlnZXN0KCdiYXNlNjQnKTtcbiAgcmV0dXJuIHsgLi4uYXNzZW1ibHksIGZpbmdlcnByaW50IH07XG59XG5cbmZ1bmN0aW9uIF9pc0Fic3RyYWN0KFxuICBzeW1ib2w6IHRzLlN5bWJvbCxcbiAgZGVjbGFyaW5nVHlwZTogc3BlYy5DbGFzc1R5cGUgfCBzcGVjLkludGVyZmFjZVR5cGUsXG4pOiBib29sZWFuIHtcbiAgLy8gZXZlcnl0aGluZyBpcyBhYnN0cmFjdCBpbiBpbnRlcmZhY2VzXG4gIGlmIChkZWNsYXJpbmdUeXBlLmtpbmQgPT09IHNwZWMuVHlwZUtpbmQuSW50ZXJmYWNlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gKFxuICAgICEhc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24gJiZcbiAgICAodHMuZ2V0Q29tYmluZWRNb2RpZmllckZsYWdzKHN5bWJvbC52YWx1ZURlY2xhcmF0aW9uKSAmXG4gICAgICB0cy5Nb2RpZmllckZsYWdzLkFic3RyYWN0KSAhPT1cbiAgICAgIDBcbiAgKTtcbn1cblxuZnVuY3Rpb24gX2lzRW51bUxpa2UodHlwZTogdHMuVHlwZSk6IHR5cGUgaXMgdHMuRW51bVR5cGUge1xuICByZXR1cm4gKHR5cGUuZmxhZ3MgJiB0cy5UeXBlRmxhZ3MuRW51bUxpa2UpICE9PSAwO1xufVxuXG5mdW5jdGlvbiBfaXNFeHBvcnRlZChub2RlOiB0cy5EZWNsYXJhdGlvbik6IGJvb2xlYW4ge1xuICByZXR1cm4gKHRzLmdldENvbWJpbmVkTW9kaWZpZXJGbGFncyhub2RlKSAmIHRzLk1vZGlmaWVyRmxhZ3MuRXhwb3J0KSAhPT0gMDtcbn1cblxuLyoqXG4gKiBNZW1iZXJzIHdpdGggbmFtZXMgc3RhcnRpbmcgd2l0aCBgX2AgKGFuZCBtYXJrZWQgYXMgQGludGVybmFsKSBhbmQgbWVtYmVyc1xuICogdGhhdCBhcmUgcHJpdmF0ZSBhcmUgaGlkZGVuLlxuICpcbiAqIEBwYXJhbSBzeW1ib2wgdGhlIHN5bWJvbCB3aGljaCBzaG91bGQgYmUgYXNzZXNzZWRcbiAqXG4gKiBAcmV0dXJuIGB0cnVlYCBpZiB0aGUgc3ltYm9sIHNob3VsZCBiZSBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gX2lzUHJpdmF0ZShzeW1ib2w6IHRzLlN5bWJvbCk6IGJvb2xlYW4ge1xuICBjb25zdCBUWVBFX0RFQ0xBUkFUSU9OX0tJTkRTID0gbmV3IFNldChbXG4gICAgdHMuU3ludGF4S2luZC5DbGFzc0RlY2xhcmF0aW9uLFxuICAgIHRzLlN5bnRheEtpbmQuSW50ZXJmYWNlRGVjbGFyYXRpb24sXG4gICAgdHMuU3ludGF4S2luZC5FbnVtRGVjbGFyYXRpb24sXG4gIF0pO1xuXG4gIC8vIGlmIHRoZSBzeW1ib2wgZG9lc24ndCBoYXZlIGEgdmFsdWUgZGVjbGFyYXRpb24sIHdlIGFyZSBhc3N1bWluZyBpdCdzIGEgdHlwZSAoZW51bS9pbnRlcmZhY2UvY2xhc3MpXG4gIC8vIGFuZCBjaGVjayB0aGF0IGl0IGhhcyBhbiBcImV4cG9ydFwiIG1vZGlmaWVyXG4gIGlmIChcbiAgICAhc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24gfHxcbiAgICBUWVBFX0RFQ0xBUkFUSU9OX0tJTkRTLmhhcyhzeW1ib2wudmFsdWVEZWNsYXJhdGlvbi5raW5kKVxuICApIHtcbiAgICBsZXQgaGFzRXhwb3J0ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBkZWNsIG9mIHN5bWJvbC5kZWNsYXJhdGlvbnMpIHtcbiAgICAgIGlmICh0cy5nZXRDb21iaW5lZE1vZGlmaWVyRmxhZ3MoZGVjbCkgJiB0cy5Nb2RpZmllckZsYWdzLkV4cG9ydCkge1xuICAgICAgICBoYXNFeHBvcnQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIEhhbmRsZSBuZXN0ZWQgY2xhc3NlcyBmcm9tIHByb2plY3QgcmVmZXJlbmNlc1xuICAgICAgaWYgKHRzLmlzTW9kdWxlQmxvY2soZGVjbC5wYXJlbnQpKSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZURlY2xhcmF0aW9uID0gZGVjbC5wYXJlbnQucGFyZW50O1xuICAgICAgICBjb25zdCBtb2RpZmllcnMgPSB0cy5nZXRDb21iaW5lZE1vZGlmaWVyRmxhZ3MobW9kdWxlRGVjbGFyYXRpb24pO1xuICAgICAgICAvLyBUaGUgdHJpY2sgaXMgdGhlIG1vZHVsZSBpcyBkZWNsYXJlZCBhcyBhbWJpZW50ICYgZXhwb3J0ZWRcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChtb2RpZmllcnMgJiB0cy5Nb2RpZmllckZsYWdzLkFtYmllbnQpICE9PSAwICYmXG4gICAgICAgICAgKG1vZGlmaWVycyAmIHRzLk1vZGlmaWVyRmxhZ3MuRXhwb3J0KSAhPT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNFeHBvcnQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhaGFzRXhwb3J0O1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBzeW1ib2wudmFsdWVEZWNsYXJhdGlvbiAmJlxuICAgICh0cy5nZXRDb21iaW5lZE1vZGlmaWVyRmxhZ3Moc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24pICZcbiAgICAgIHRzLk1vZGlmaWVyRmxhZ3MuUHJpdmF0ZSkgIT09XG4gICAgICAwXG4gICk7XG59XG5cbmZ1bmN0aW9uIF9oYXNJbnRlcm5hbEpzRG9jVGFnKHN5bWJvbDogdHMuU3ltYm9sKSB7XG4gIHJldHVybiBzeW1ib2wuZ2V0SnNEb2NUYWdzKCkuc29tZSgodDogYW55KSA9PiB0Lm5hbWUgPT09ICdpbnRlcm5hbCcpO1xufVxuXG5mdW5jdGlvbiBfaXNQcm90ZWN0ZWQoc3ltYm9sOiB0cy5TeW1ib2wpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICAhIXN5bWJvbC52YWx1ZURlY2xhcmF0aW9uICYmXG4gICAgKHRzLmdldENvbWJpbmVkTW9kaWZpZXJGbGFncyhzeW1ib2wudmFsdWVEZWNsYXJhdGlvbikgJlxuICAgICAgdHMuTW9kaWZpZXJGbGFncy5Qcm90ZWN0ZWQpICE9PVxuICAgICAgMFxuICApO1xufVxuXG5mdW5jdGlvbiBfaXNTdGF0aWMoc3ltYm9sOiB0cy5TeW1ib2wpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICAhIXN5bWJvbC52YWx1ZURlY2xhcmF0aW9uICYmXG4gICAgKHRzLmdldENvbWJpbmVkTW9kaWZpZXJGbGFncyhzeW1ib2wudmFsdWVEZWNsYXJhdGlvbikgJlxuICAgICAgdHMuTW9kaWZpZXJGbGFncy5TdGF0aWMpICE9PVxuICAgICAgMFxuICApO1xufVxuXG5mdW5jdGlvbiBfaXNWb2lkKHR5cGU6IHRzLlR5cGUpOiBib29sZWFuIHtcbiAgcmV0dXJuICh0eXBlLmZsYWdzICYgdHMuVHlwZUZsYWdzLlZvaWQpICE9PSAwO1xufVxuXG5mdW5jdGlvbiBfaXNQcm9taXNlKHR5cGU6IHRzLlR5cGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGUuc3ltYm9sPy5lc2NhcGVkTmFtZSA9PT0gJ1Byb21pc2UnO1xufVxuXG5mdW5jdGlvbiBfc29ydE1lbWJlcnModHlwZTogc3BlYy5DbGFzc1R5cGUpOiBzcGVjLkNsYXNzVHlwZTtcbmZ1bmN0aW9uIF9zb3J0TWVtYmVycyh0eXBlOiBzcGVjLkludGVyZmFjZVR5cGUpOiBzcGVjLkludGVyZmFjZVR5cGU7XG5mdW5jdGlvbiBfc29ydE1lbWJlcnMoXG4gIHR5cGU6IHNwZWMuQ2xhc3NUeXBlIHwgc3BlYy5JbnRlcmZhY2VUeXBlLFxuKTogc3BlYy5DbGFzc1R5cGUgfCBzcGVjLkludGVyZmFjZVR5cGUge1xuICB0eXBlLm1ldGhvZHMgPSB0eXBlLm1ldGhvZHMgJiYgX3NvcnQodHlwZS5tZXRob2RzKTtcbiAgdHlwZS5wcm9wZXJ0aWVzID0gdHlwZS5wcm9wZXJ0aWVzICYmIF9zb3J0KHR5cGUucHJvcGVydGllcyk7XG4gIHJldHVybiB0eXBlO1xuXG4gIC8qKlxuICAgKiBTb3J0cyBhIG1lbWJlciBhcnJheSBzdWNoIHRoYXQ6XG4gICAqIDEuIFN0YXRpYyBtZW1iZXJzIGFwcGVhciBmaXJzdFxuICAgKiAyLiBJbW11dGFibGUgbWVtYmVycyBhcHBlYXIgZmlyc3RcbiAgICogMy4gTm9uLW9wdGlvbmFsIG1lbWJlcnMgYXBwZWFyIGZpcnN0XG4gICAqIDQuIE1lbWJlcnMgYXBwZWFyIGluIGxleGljb2dyYXBoaWNhbCBvcmRlclxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVzIHRoZSBhcnJheSBvZiBtZW1iZXJzIHRvIGJlIHNvcnRlZFxuICAgKlxuICAgKiBAcmV0dXJuIGEgc29ydGVkIGNvcHkgb2YgYGB2YWx1ZXNgYFxuICAgKi9cbiAgZnVuY3Rpb24gX3NvcnQ8VCBleHRlbmRzIFR5cGVNZW1iZXI+KHZhbHVlczogVFtdKTogVFtdIHtcbiAgICBpZiAoIXZhbHVlcykge1xuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcy5zb3J0KF9jb21wYXJhdG9yKTtcblxuICAgIGZ1bmN0aW9uIF9jb21wYXJhdG9yKGx2YWw6IFQsIHJ2YWw6IFQpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIF9mb3JtYXQobHZhbCkubG9jYWxlQ29tcGFyZShfZm9ybWF0KHJ2YWwpKTtcblxuICAgICAgZnVuY3Rpb24gX2Zvcm1hdCh2YWw6IFQpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHZhbC5zdGF0aWMgPyAnMCcgOiAnMScsXG4gICAgICAgICAgdmFsLmltbXV0YWJsZSA/ICcwJyA6ICcxJyxcbiAgICAgICAgICAhdmFsLm9wdGlvbmFsID8gJzAnIDogJzEnLFxuICAgICAgICAgIHZhbC5uYW1lLFxuICAgICAgICBdLmpvaW4oJ3wnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdHlwZSBUeXBlTWVtYmVyID0ge1xuICAgIG5hbWU/OiBzdHJpbmc7IC8vIE1ldGhvZHMgJiBQcm9wZXJ0aWVzXG4gICAgc3RhdGljPzogYm9vbGVhbjsgLy8gTWV0aG9kcyAmIFByb3BlcnRpZXNcbiAgICBpbW11dGFibGU/OiBib29sZWFuOyAvLyAgICAgICAgICAgUHJvcGVydGllc1xuICAgIG9wdGlvbmFsPzogYm9vbGVhbjsgLy8gICAgICAgICAgIFByb3BlcnRpZXNcbiAgfTtcbn1cblxuLyoqXG4gKiBEZWZlcnJlZCBwcm9jZXNzaW5nIHRoYXQgbmVlZHMgdG8gaGFwcGVuIGluIGEgc2Vjb25kLCBvcmRlcmVkIHBhc3NcbiAqL1xuaW50ZXJmYWNlIERlZmVycmVkUmVjb3JkIHtcbiAgLyoqXG4gICAqIFRoZSBGUU4gb2YgdGhlIHR5cGUgdGhlIGFjdGlvbiB3aWxsIGJlIGV4ZWN1dGVkIG9uXG4gICAqL1xuICBmcW46IHN0cmluZztcblxuICAvKipcbiAgICogRGVwZW5kZW5jeSBGUU5zIG9mIHRoZSB0eXBlcyB0aGF0IG5lZWQgdG8gYmUgcHJvY2Vzc2VkIGJlZm9yZSBhbmFseXNpcy5cbiAgICpcbiAgICogQWxsIGRlZmVycmVkIGFuYWx5c2lzIGFjdGlvbnMgZm9yIHRoZSB0eXBlcyBsaXN0ZWQgaGVyZSBtdXN0IGJlIGNvbXBsZXRlXG4gICAqIGJlZm9yZSB0aGlzIGFuYWx5c2lzIGFjdGlvbiBjYW4gcnVuLlxuICAgKi9cbiAgZGVwZW5kZWRGcW5zOiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogQ2FsbGJhY2sgcmVwcmVzZW50aW5nIHRoZSBhY3Rpb24gdG8gcnVuLlxuICAgKi9cbiAgY2I6ICgpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsYXN0IGVsZW1lbnQgZnJvbSBhIGxpc3RcbiAqL1xuZnVuY3Rpb24gbGFzdDxUPih4czogVFtdKTogVCB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiB4cy5sZW5ndGggPiAwID8geHNbeHMubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQXBwbHkgYSBmdW5jdGlvbiB0byBhIHZhbHVlIGlmIGl0J3Mgbm90IGVxdWFsIHRvIHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBhcHBseTxULCBVPihcbiAgeDogVCB8IHVuZGVmaW5lZCxcbiAgZm46ICh4OiBUKSA9PiBVIHwgdW5kZWZpbmVkLFxuKTogVSB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiB4ICE9PSB1bmRlZmluZWQgPyBmbih4KSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGludGVyc2VjdGlvbiBvZiB0d28gc2V0c1xuICovXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb248VD4oeHM6IFNldDxUPiwgeXM6IFNldDxUPik6IFNldDxUPiB7XG4gIGNvbnN0IHJldCA9IG5ldyBTZXQ8VD4oKTtcbiAgZm9yIChjb25zdCB4IG9mIHhzKSB7XG4gICAgaWYgKHlzLmhhcyh4KSkge1xuICAgICAgcmV0LmFkZCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYWxsIG1lbWJlcnMgbmFtZXMgb2YgYSBKU0lJIGludGVyZmFjZSB0eXBlXG4gKlxuICogUmV0dXJucyBlbXB0eSBzdHJpbmcgZm9yIGEgbm9uLWludGVyZmFjZSB0eXBlLlxuICovXG5mdW5jdGlvbiBtZW1iZXJOYW1lcyhqc2lpVHlwZTogc3BlYy5JbnRlcmZhY2VUeXBlIHwgc3BlYy5DbGFzc1R5cGUpOiBzdHJpbmdbXSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0eXBlTWVtYmVycyhqc2lpVHlwZSkpLmZpbHRlcigobikgPT4gbiAhPT0gJycpO1xufVxuXG5mdW5jdGlvbiB0eXBlTWVtYmVycyhqc2lpVHlwZTogc3BlYy5JbnRlcmZhY2VUeXBlIHwgc3BlYy5DbGFzc1R5cGUpOiB7XG4gIFtrZXk6IHN0cmluZ106IHNwZWMuUHJvcGVydHkgfCBzcGVjLk1ldGhvZDtcbn0ge1xuICBjb25zdCByZXQ6IHsgW2tleTogc3RyaW5nXTogc3BlYy5Qcm9wZXJ0eSB8IHNwZWMuTWV0aG9kIH0gPSB7fTtcblxuICBmb3IgKGNvbnN0IHByb3Agb2YganNpaVR5cGUucHJvcGVydGllcyA/PyBbXSkge1xuICAgIHJldFtwcm9wLm5hbWVdID0gcHJvcDtcbiAgfVxuXG4gIGZvciAoY29uc3QgbWV0aG9kIG9mIGpzaWlUeXBlLm1ldGhvZHMgPz8gW10pIHtcbiAgICByZXRbbWV0aG9kLm5hbWUgPz8gJyddID0gbWV0aG9kO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gbmFtZSBpcyBjb252ZW50aW9uYWxseSBhbiBpbnRlcmZhY2UgbmFtZVxuICpcbiAqIEl0J3MgYW4gaW50ZXJmYWNlIG5hbWUgaWYgaXQgc3RhcnRzIHdpdGggSSBhbmQgaGFzIGFub3RoZXIgY2FwaXRhbFxuICogKHNvIHdlIGRvbid0IG1hcmsgSW9uaWNDb2x1bW5Qcm9wcyBhcyBhbiBpbnRlcmZhY2UpLlxuICovXG5mdW5jdGlvbiBpc0ludGVyZmFjZU5hbWUobmFtZTogc3RyaW5nKSB7XG4gIHJldHVybiAoXG4gICAgbmFtZS5sZW5ndGggPj0gMiAmJlxuICAgIG5hbWUuc3RhcnRzV2l0aCgnSScpICYmXG4gICAgbmFtZS5jaGFyQXQoMSkudG9VcHBlckNhc2UoKSA9PT0gbmFtZS5jaGFyQXQoMSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3IodHlwZTogdHMuVHlwZSk6IHRzLlN5bWJvbCB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiB0eXBlLnN5bWJvbC5tZW1iZXJzPy5nZXQodHMuSW50ZXJuYWxTeW1ib2xOYW1lLkNvbnN0cnVjdG9yKTtcbn1cblxuZnVuY3Rpb24qIGludGVyc2VjdDxUPih4czogU2V0PFQ+LCB5czogU2V0PFQ+KSB7XG4gIGZvciAoY29uc3QgeCBvZiB4cykge1xuICAgIGlmICh5cy5oYXMoeCkpIHtcbiAgICAgIHlpZWxkIHg7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vRW1wdHlEaWN0PFQ+KFxuICB4czogUmVjb3JkPHN0cmluZywgVD4gfCB1bmRlZmluZWQsXG4pOiBSZWNvcmQ8c3RyaW5nLCBUPiB8IHVuZGVmaW5lZCB7XG4gIGlmICh4cyA9PSBudWxsIHx8IE9iamVjdC5rZXlzKHhzKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB4cztcbn1cblxuZnVuY3Rpb24gdG9EZXBlbmRlbmN5Q2xvc3VyZShhc3NlbWJsaWVzOiByZWFkb25seSBzcGVjLkFzc2VtYmx5W10pOiB7XG4gIFtuYW1lOiBzdHJpbmddOiBzcGVjLkFzc2VtYmx5Q29uZmlndXJhdGlvbjtcbn0ge1xuICBjb25zdCByZXN1bHQ6IHsgW25hbWU6IHN0cmluZ106IHNwZWMuQXNzZW1ibHlUYXJnZXRzIH0gPSB7fTtcbiAgZm9yIChjb25zdCBhc3NlbWJseSBvZiBhc3NlbWJsaWVzKSB7XG4gICAgaWYgKCFhc3NlbWJseS50YXJnZXRzKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmVzdWx0W2Fzc2VtYmx5Lm5hbWVdID0ge1xuICAgICAgc3VibW9kdWxlczogYXNzZW1ibHkuc3VibW9kdWxlcyxcbiAgICAgIHRhcmdldHM6IGFzc2VtYmx5LnRhcmdldHMsXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB0b1N1Ym1vZHVsZURlY2xhcmF0aW9ucyhcbiAgc3VibW9kdWxlczogSXRlcmFibGU8U3VibW9kdWxlU3BlYz4sXG4pOiBzcGVjLkFzc2VtYmx5WydzdWJtb2R1bGVzJ10ge1xuICBjb25zdCByZXN1bHQ6IHNwZWMuQXNzZW1ibHlbJ3N1Ym1vZHVsZXMnXSA9IHt9O1xuXG4gIGZvciAoY29uc3Qgc3VibW9kdWxlIG9mIHN1Ym1vZHVsZXMpIHtcbiAgICByZXN1bHRbc3VibW9kdWxlLmZxbl0gPSB7XG4gICAgICBsb2NhdGlvbkluTW9kdWxlOiBzdWJtb2R1bGUubG9jYXRpb25Jbk1vZHVsZSxcbiAgICAgIHRhcmdldHM6IHN1Ym1vZHVsZS50YXJnZXRzLFxuICAgICAgcmVhZG1lOiBzdWJtb2R1bGUucmVhZG1lLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhpcyB0eXBlIGlzIHRoZSBpbnRyaW5zaWMgVHlwZVNjcmlwdCBcImVycm9yIHR5cGVcIlxuICpcbiAqIFRoaXMgdHlwZSBpcyByZXR1cm5lZCBpZiB0eXBlIGxvb2t1cCBmYWlscy4gVW5mb3J0dW5hdGVseSBubyBwdWJsaWNcbiAqIGFjY2Vzc29ycyBmb3IgaXQgYXJlIGV4cG9zZWQuXG4gKi9cbmZ1bmN0aW9uIGlzRXJyb3JUeXBlKHQ6IHRzLlR5cGUpIHtcbiAgcmV0dXJuICh0IGFzIGFueSkuaW50cmluc2ljTmFtZSA9PT0gJ2Vycm9yJztcbn1cblxuLyoqXG4gKiBUaG9zZSBoYXZlIHNwZWNpZmljIHNlbWFudGljcyBpbiBjZXJ0YWluIGxhbmd1YWdlcyB0aGF0IGRvbid0IGFsd2F5cyB0cmFuc2xhdGUgY2xlYW5seSBpbiBvdGhlcnNcbiAqIChsaWtlIGhvdyBlcXVhbHMvaGFzaENvZGUgYXJlIG5vdCBhIHRoaW5nIGluIEphdmFzY3JpcHQsIGJ1dCBjYXJyeSBtZWFuaW5nIGluIEphdmEgYW5kIEMjKS4gVGhlXG4gKiBgYnVpbGRgIG5hbWUgaXMgcmVzZXJ2ZWQgZm9yIGdlbmVyYXRlZCBjb2RlIChKYXZhIGJ1aWxkZXJzIHVzZSB0aGF0KS5cbiAqL1xuY29uc3QgUFJPSElCSVRFRF9NRU1CRVJfTkFNRVMgPSBbJ2J1aWxkJywgJ2VxdWFscycsICdoYXNoY29kZSddO1xuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGdpdmVuIG5hbWUgaXMgcHJvaGliaXRlZFxuICovXG5mdW5jdGlvbiBpc1Byb2hpYml0ZWRNZW1iZXJOYW1lKG5hbWU6IHN0cmluZykge1xuICByZXR1cm4gUFJPSElCSVRFRF9NRU1CRVJfTkFNRVMuaW5jbHVkZXMobmFtZS50b0xvd2VyQ2FzZSgpKTtcbn1cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgY29udGV4dCBpbiB3aGljaCBhIGRlY2xhcmF0aW9uIGlzIGVtaXR0ZWQuXG4gKi9cbmNsYXNzIEVtaXRDb250ZXh0IHtcbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSBuYW1lc3BhY2U6IHJlYWRvbmx5IHN0cmluZ1tdLFxuICAgIHB1YmxpYyByZWFkb25seSBzdGFiaWxpdHk/OiBzcGVjLlN0YWJpbGl0eSxcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgRW1pdENvbnRleHQgYnkgYXBwZW5kaW5nIGEgbmFtZXNwYWNlIGVudHJ5IGF0IHRoZSBlbmQuXG4gICAqIEBwYXJhbSBlbGVtZW50IHRoZSBuZXcgbmFtZXNwYWNlIGVudHJ5LlxuICAgKi9cbiAgcHVibGljIGFwcGVuZE5hbWVzcGFjZShlbGVtZW50OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IEVtaXRDb250ZXh0KFsuLi50aGlzLm5hbWVzcGFjZSwgZWxlbWVudF0sIHRoaXMuc3RhYmlsaXR5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgRW1pdENvbnRleHQgYnkgcmVwbGFjaW5nIHRoZSBzdGFiaWxpdHkuXG4gICAqIEBwYXJhbSBzdGFiaWxpdHkgdGhlIG5ldyBzdGFiaWxpdHksIGlmIGF2YWlsYWJsZS5cbiAgICovXG4gIHB1YmxpYyByZXBsYWNlU3RhYmlsaXR5KHN0YWJpbGl0eT86IHNwZWMuU3RhYmlsaXR5KSB7XG4gICAgaWYgKCFzdGFiaWxpdHkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVtaXRDb250ZXh0KHRoaXMubmFtZXNwYWNlLCBzdGFiaWxpdHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBFbWl0Q29udGV4dCB3aXRob3V0IHN0YWJpbGl0eS5cbiAgICovXG4gIHB1YmxpYyByZW1vdmVTdGFiaWxpdHkoKSB7XG4gICAgcmV0dXJuIG5ldyBFbWl0Q29udGV4dCh0aGlzLm5hbWVzcGFjZSwgdW5kZWZpbmVkKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBmbGF0dGVuUHJvbWlzZXM8VD4ocHJvbWlzZXM6IEFycmF5PFByb21pc2U8VFtdPj4pOiBQcm9taXNlPFRbXT4ge1xuICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXk8VD4oKTtcbiAgZm9yIChjb25zdCBzdWJzZXQgb2YgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpKSB7XG4gICAgcmVzdWx0LnB1c2goLi4uc3Vic2V0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpbmZlclJvb3REaXIocHJvZ3JhbTogdHMuUHJvZ3JhbSk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IGRpcmVjdG9yaWVzID0gcHJvZ3JhbVxuICAgIC5nZXRSb290RmlsZU5hbWVzKClcbiAgICAuZmlsdGVyKChmaWxlTmFtZSkgPT4ge1xuICAgICAgY29uc3Qgc291cmNlRmlsZSA9IHByb2dyYW0uZ2V0U291cmNlRmlsZShmaWxlTmFtZSk7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBzb3VyY2VGaWxlICE9IG51bGwgJiZcbiAgICAgICAgIXByb2dyYW0uaXNTb3VyY2VGaWxlRnJvbUV4dGVybmFsTGlicmFyeShzb3VyY2VGaWxlKSAmJlxuICAgICAgICAhcHJvZ3JhbS5pc1NvdXJjZUZpbGVEZWZhdWx0TGlicmFyeShzb3VyY2VGaWxlKVxuICAgICAgKTtcbiAgICB9KVxuICAgIC5tYXAoKGZpbGVOYW1lKSA9PlxuICAgICAgcGF0aC5yZWxhdGl2ZShwcm9ncmFtLmdldEN1cnJlbnREaXJlY3RvcnkoKSwgcGF0aC5kaXJuYW1lKGZpbGVOYW1lKSksXG4gICAgKVxuICAgIC5tYXAoc2VnbWVudFBhdGgpO1xuXG4gIGNvbnN0IG1heFByZWZpeCA9IE1hdGgubWluKFxuICAgIC4uLmRpcmVjdG9yaWVzLm1hcCgoc2VnbWVudHMpID0+IHNlZ21lbnRzLmxlbmd0aCAtIDEpLFxuICApO1xuICBsZXQgY29tbW9uSW5kZXggPSAtMTtcbiAgd2hpbGUgKFxuICAgIGNvbW1vbkluZGV4IDwgbWF4UHJlZml4ICYmXG4gICAgbmV3IFNldChkaXJlY3Rvcmllcy5tYXAoKHNlZ21lbnRzKSA9PiBzZWdtZW50c1tjb21tb25JbmRleCArIDFdKSkuc2l6ZSA9PT0gMVxuICApIHtcbiAgICBjb21tb25JbmRleCsrO1xuICB9XG5cbiAgaWYgKGNvbW1vbkluZGV4IDwgMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gZGlyZWN0b3JpZXNbMF1bY29tbW9uSW5kZXhdO1xuXG4gIGZ1bmN0aW9uIHNlZ21lbnRQYXRoKGZpbGVOYW1lOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgICBmb3IgKFxuICAgICAgbGV0IHBhcmVudCA9IGZpbGVOYW1lO1xuICAgICAgcGFyZW50ICE9PSBwYXRoLmRpcm5hbWUocGFyZW50KTtcbiAgICAgIHBhcmVudCA9IHBhdGguZGlybmFtZShwYXJlbnQpXG4gICAgKSB7XG4gICAgICByZXN1bHQudW5zaGlmdChwYXJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwcm92aWRlZCB0eXBlIGlzIGEgc2luZ2xlLXZhbHVlZCBlbnVtLiBJdCBpcyBuZWNlc3NhcnlcbiAqIHRvIGNoZWNrIGFzIGVudW1zIGFyZSB1bmlvbi1saWtlIGluIHRoZSB0eXBlIG1vZGVsLCBhbmQgc2luZ2xlLXZhbHVlZCBlbnVtXG4gKiB0eXBlcyBhcmUgYWN0dWFsbHkgcmVkdWNlZCB0byB0aGUgb25seSBhdmFpbGFibGUgbGl0ZXJhbCwgd2hpY2ggY2FuIHRyaXBcbiAqIHRoZSBhc3NlbWJsZXIuXG4gKlxuICogQHBhcmFtIHR5cGUgICAgICAgIHRoZSB0eXBlIGJlaW5nIGNoZWNrZWQuXG4gKiBAcGFyYW0gdHlwZUNoZWNrZXIgdGhlIHR5cGUgY2hlY2tlciB0byB1c2UgdG8gZ2V0IG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJldHVybiBgdHJ1ZWAgaWYgYHR5cGVgIGlzIGEgc2luZ2xlLXZhbHVlZCBlbnVtIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzU2luZ2xlVmFsdWVkRW51bShcbiAgdHlwZTogdHMuVHlwZSxcbiAgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLFxuKTogdHlwZSBpcyB0cy5FbnVtVHlwZSB7XG4gIGlmICh0eXBlLmlzTGl0ZXJhbCgpICYmIF9pc0VudW1MaWtlKHR5cGUpKSB7XG4gICAgLy8gU2luZ2xlLVZhbHVlZCBlbnVtcyBhcmUgcmVkdWNlZCB0byB0aGUgb25seSBsaXRlcmFsIGF2YWlsYWJsZS5cbiAgICByZXR1cm4gdHlwZSA9PT0gdHlwZUNoZWNrZXIuZ2V0QmFzZVR5cGVPZkxpdGVyYWxUeXBlKHR5cGUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZmluZFBhY2thZ2VJbmZvKGZyb21EaXI6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKGZyb21EaXIsICdwYWNrYWdlLmpzb24nKTtcbiAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMoZmlsZVBhdGgpKSB7XG4gICAgcmV0dXJuIGZzLnJlYWRKc29uKGZpbGVQYXRoKTtcbiAgfVxuICBjb25zdCBwYXJlbnQgPSBwYXRoLmRpcm5hbWUoZnJvbURpcik7XG4gIGlmIChwYXJlbnQgPT09IGZyb21EaXIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBmaW5kUGFja2FnZUluZm8ocGFyZW50KTtcbn1cblxuZnVuY3Rpb24gcGFyYW1Eb2NzKFxuICBwYXJhbXM/OiByZWFkb25seSBzcGVjLlBhcmFtZXRlcltdLFxuKTogUmVjb3JkPHN0cmluZywgc3BlYy5Eb2NzPiB7XG4gIGNvbnN0IHJldDogUmVjb3JkPHN0cmluZywgc3BlYy5Eb2NzPiA9IHt9O1xuICBmb3IgKGNvbnN0IHBhcmFtIG9mIHBhcmFtcyA/PyBbXSkge1xuICAgIGlmIChwYXJhbS5kb2NzKSB7XG4gICAgICByZXRbcGFyYW0ubmFtZV0gPSBwYXJhbS5kb2NzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpcyB0aGUgcHJvdmlkZWQgdHlwZSBpcyBcInRoaXNcIiAoYXMgYSB0eXBlIGFubm90YXRpb24pLlxuICpcbiAqIEBwYXJhbSB0eXBlICAgICAgICB0aGUgdmFsaWRhdGVkIHR5cGUuXG4gKiBAcGFyYW0gdHlwZUNoZWNrZXIgdGhlIHR5cGUgY2hlY2tlci5cbiAqXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWlmIHRoZSB0eXBlIGlzIGB0aGlzYFxuICovXG5mdW5jdGlvbiBfaXNUaGlzVHlwZSh0eXBlOiB0cy5UeXBlLCB0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVDaGVja2VyLnR5cGVUb1R5cGVOb2RlKHR5cGUpPy5raW5kID09PSB0cy5TeW50YXhLaW5kLlRoaXNLZXl3b3JkO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hbWUgbm9kZSBmb3IgYSBnaXZlbiBzeW1ib2w7IG9yIGl0J3MgZmlyc3QgZGVjbGFyYXRpb24gaWYgbm8gbmFtZSBjYW4gYmUgZm91bmQuIFRoaXMgaXNcbiAqIGludGVuZGVkIGZvciB1c2UgaW4gcGxhY2luZyBwcm9ibGVtIG1hcmtlcnMgb24gdGhlIHJpZ2h0IGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSBzeW1ib2wgdGhlIHN5bWJvbCBmb3Igd2hpY2ggdGhlIG5hbWUgbm9kZSBpcyBuZWVkZWQuXG4gKlxuICogQHJldHVybnMgdGhlIG5hbWUgbm9kZSBmb3IgdGhlIHN5bWJvbCwgb3IgdGhlIHN5bWJvbCdzIGZpcnN0IGRlY2xhcmF0aW9uLlxuICovXG5mdW5jdGlvbiBfbmFtZU9yRGVjbGFyYXRpb25Ob2RlKHN5bWJvbDogdHMuU3ltYm9sKTogdHMuTm9kZSB7XG4gIGNvbnN0IGRlY2xhcmF0aW9uID0gc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24gPz8gc3ltYm9sLmRlY2xhcmF0aW9uc1swXTtcbiAgcmV0dXJuIHRzLmdldE5hbWVPZkRlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSA/PyBkZWNsYXJhdGlvbjtcbn1cblxuZnVuY3Rpb24gX2ZpbmRIaW50KFxuICBkZWNsOiB0cy5EZWNsYXJhdGlvbixcbiAgaGludDogc3RyaW5nLFxuKTogdHMuSlNEb2NUYWcgfCB1bmRlZmluZWQge1xuICBjb25zdCBbbm9kZV0gPSB0cy5nZXRBbGxKU0RvY1RhZ3MoXG4gICAgZGVjbCxcbiAgICAodGFnKTogdGFnIGlzIHRzLkpTRG9jVGFnID0+IHRhZy50YWdOYW1lLnRleHQgPT09IGhpbnQsXG4gICk7XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEEgbG9jYXRpb24gd2hlcmUgYSB0eXBlIGNhbiBiZSB1c2VkLlxuICovXG50eXBlIFR5cGVVc2VLaW5kID1cbiAgfCAnYmFzZSBjbGFzcydcbiAgfCAnYmFzZSBpbnRlcmZhY2UnXG4gIHwgJ2xpc3QgZWxlbWVudCB0eXBlJ1xuICB8ICdtYXAgZWxlbWVudCB0eXBlJ1xuICB8ICdwYXJhbWV0ZXIgdHlwZSdcbiAgfCAncHJvcGVydHkgdHlwZSdcbiAgfCAncmV0dXJuIHR5cGUnO1xuIl19