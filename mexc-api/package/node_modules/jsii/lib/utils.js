"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNamespace = exports.symbolIdentifier = exports.parseRepository = exports.parsePerson = exports.logDiagnostic = exports._formatDiagnostic = exports.formatDiagnostic = exports.diagnosticsLogger = exports.JSII_DIAGNOSTICS_CODE = exports.DIAGNOSTICS = void 0;
const fs = require("fs");
const log4js = require("log4js");
const path = require("path");
const ts = require("typescript");
const jsii_diagnostic_1 = require("./jsii-diagnostic");
/**
 * Name of the logger for diagnostics information
 */
exports.DIAGNOSTICS = 'diagnostics';
/**
 * Diagnostic code for JSII-generated messages.
 */
exports.JSII_DIAGNOSTICS_CODE = 9999;
/**
 * Obtains the relevant logger to be used for a given diagnostic message.
 *
 * @param logger     the ``log4js.Logger`` to use for emitting the message.
 * @param diagnostic the message for which a logger is requested.
 *
 * @returns a logger method of the ``logger`` for the appropriate level.
 */
function diagnosticsLogger(logger, diagnostic) {
    switch (diagnostic.category) {
        case ts.DiagnosticCategory.Error:
            if (!logger.isErrorEnabled()) {
                return undefined;
            }
            return logger.error.bind(logger);
        case ts.DiagnosticCategory.Warning:
            if (!logger.isWarnEnabled()) {
                return undefined;
            }
            return logger.warn.bind(logger);
        case ts.DiagnosticCategory.Message:
            if (!logger.isDebugEnabled()) {
                return undefined;
            }
            return logger.debug.bind(logger);
        case ts.DiagnosticCategory.Suggestion:
        default:
            if (!logger.isTraceEnabled()) {
                return undefined;
            }
            return logger.trace.bind(logger);
    }
}
exports.diagnosticsLogger = diagnosticsLogger;
/**
 * Formats a diagnostic message with color and context, if possible.
 *
 * @param diagnostic  the diagnostic message ot be formatted.
 * @param projectRoot the root of the TypeScript project.
 *
 * @returns a formatted string.
 */
function formatDiagnostic(diagnostic, projectRoot) {
    if (jsii_diagnostic_1.JsiiDiagnostic.isJsiiDiagnostic(diagnostic)) {
        // Ensure we leverage pre-rendered diagnostics where available.
        return diagnostic.format(projectRoot);
    }
    return _formatDiagnostic(diagnostic, projectRoot);
}
exports.formatDiagnostic = formatDiagnostic;
/**
 * Formats a diagnostic message with color and context, if possible. Users
 * should use `formatDiagnostic` instead, as this implementation is inteded for
 * internal usafe only.
 *
 * @param diagnostic  the diagnostic message ot be formatted.
 * @param projectRoot the root of the TypeScript project.
 *
 * @returns a formatted string.
 */
function _formatDiagnostic(diagnostic, projectRoot) {
    const formatDiagnosticsHost = {
        getCurrentDirectory: () => projectRoot,
        getCanonicalFileName: (fileName) => fileName,
        getNewLine: () => ts.sys.newLine,
    };
    const message = diagnostic.file != null
        ? ts.formatDiagnosticsWithColorAndContext([diagnostic], formatDiagnosticsHost)
        : ts.formatDiagnostic(diagnostic, formatDiagnosticsHost);
    if (!jsii_diagnostic_1.JsiiDiagnostic.isJsiiDiagnostic(diagnostic)) {
        return message;
    }
    // This is our own diagnostics, so we'll format appropriately (replacing TS#### with JSII####).
    return message.replace(` TS${exports.JSII_DIAGNOSTICS_CODE}: `, ` JSII${diagnostic.jsiiCode}: `);
}
exports._formatDiagnostic = _formatDiagnostic;
function logDiagnostic(diagnostic, projectRoot) {
    const logFunc = diagnosticsLogger(log4js.getLogger(exports.DIAGNOSTICS), diagnostic);
    if (!logFunc) {
        return;
    }
    logFunc(formatDiagnostic(diagnostic, projectRoot).trim());
}
exports.logDiagnostic = logDiagnostic;
const PERSON_REGEX = /^\s*(.+?)(?:\s*<([^>]+)>)?(?:\s*\(([^)]+)\))?\s*$/;
/**
 * Parses a string-formatted person entry from `package.json`.
 * @param value the string-formatted person entry.
 *
 * @example
 *  parsePerson("Barney Rubble <b@rubble.com> (http://barnyrubble.tumblr.com/)");
 *  // => { name: "Barney Rubble", email: "b@rubble.com", url: "http://barnyrubble.tumblr.com/" }
 */
function parsePerson(value) {
    const match = PERSON_REGEX.exec(value);
    if (!match) {
        throw new Error(`Invalid stringified "person" value: ${value}`);
    }
    const [, name, email, url] = match;
    const result = {
        name: name.trim(),
    };
    if (email) {
        result.email = email.trim();
    }
    if (url) {
        result.url = url.trim();
    }
    return result;
}
exports.parsePerson = parsePerson;
const REPOSITORY_REGEX = /^(?:(github|gist|bitbucket|gitlab):)?([A-Za-z\d_-]+\/[A-Za-z\d_-]+)$/;
function parseRepository(value) {
    const match = REPOSITORY_REGEX.exec(value);
    if (!match) {
        return { url: value };
    }
    const [, host, slug] = match;
    switch (host !== null && host !== void 0 ? host : 'github') {
        case 'github':
            return { url: `https://github.com/${slug}.git` };
        case 'gist':
            return { url: `https://gist.github.com/${slug}.git` };
        case 'bitbucket':
            return { url: `https://bitbucket.org/${slug}.git` };
        case 'gitlab':
            return { url: `https://gitlab.com/${slug}.git` };
        default:
            throw new Error(`Unknown host service: ${host}`);
    }
}
exports.parseRepository = parseRepository;
function symbolIdentifier(typeChecker, sym) {
    const inFileNameParts = [];
    let decl = sym.declarations[0];
    while (decl && !ts.isSourceFile(decl)) {
        if (ts.isClassDeclaration(decl) ||
            ts.isNamespaceExportDeclaration(decl) ||
            ts.isNamespaceExport(decl) ||
            ts.isEnumDeclaration(decl) ||
            ts.isEnumMember(decl) ||
            ts.isInterfaceDeclaration(decl) ||
            ts.isMethodDeclaration(decl) ||
            ts.isMethodSignature(decl) ||
            ts.isPropertyDeclaration(decl) ||
            ts.isPropertySignature(decl)) {
            const name = ts.getNameOfDeclaration(decl);
            const declSym = name ? typeChecker.getSymbolAtLocation(name) : undefined;
            if (declSym) {
                inFileNameParts.unshift(declSym.name);
            }
        }
        decl = decl.parent;
    }
    if (!decl) {
        return undefined;
    }
    const namespace = getNamespace(decl.getSourceFile().fileName);
    if (!namespace) {
        return undefined;
    }
    return `${namespace}:${inFileNameParts.join('.')}`;
}
exports.symbolIdentifier = symbolIdentifier;
function getNamespace(sourceFileName) {
    var _a, _b;
    const packageJsonLocation = findPackageJsonLocation(path.dirname(sourceFileName));
    if (!packageJsonLocation) {
        return undefined;
    }
    const packageJson = JSON.parse(fs.readFileSync(packageJsonLocation).toString());
    const sourcePath = removePrefix((_b = (_a = packageJson.jsii) === null || _a === void 0 ? void 0 : _a.outdir) !== null && _b !== void 0 ? _b : '', path.relative(path.dirname(packageJsonLocation), sourceFileName));
    return sourcePath.replace(/(\.d)?\.ts$/, '');
    function findPackageJsonLocation(currentPath) {
        const candidate = path.join(currentPath, 'package.json');
        if (fs.existsSync(candidate)) {
            return candidate;
        }
        const parentPath = path.resolve(currentPath, '..');
        return parentPath !== currentPath
            ? findPackageJsonLocation(parentPath)
            : undefined;
    }
    function removePrefix(prefix, filePath) {
        const prefixParts = prefix.split(/[/\\]/g);
        const pathParts = filePath.split(/[/\\]/g);
        let i = 0;
        while (prefixParts[i] === pathParts[i]) {
            i++;
        }
        return pathParts.slice(i).join('/');
    }
}
exports.getNamespace = getNamespace;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ1dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSx5QkFBeUI7QUFDekIsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFFakMsdURBQW1EO0FBRW5EOztHQUVHO0FBQ1UsUUFBQSxXQUFXLEdBQUcsYUFBYSxDQUFDO0FBQ3pDOztHQUVHO0FBQ1UsUUFBQSxxQkFBcUIsR0FBRyxJQUFJLENBQUM7QUFFMUM7Ozs7Ozs7R0FPRztBQUNILFNBQWdCLGlCQUFpQixDQUMvQixNQUFxQixFQUNyQixVQUF5QjtJQUV6QixRQUFRLFVBQVUsQ0FBQyxRQUFRLEVBQUU7UUFDM0IsS0FBSyxFQUFFLENBQUMsa0JBQWtCLENBQUMsS0FBSztZQUM5QixJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRSxFQUFFO2dCQUM1QixPQUFPLFNBQVMsQ0FBQzthQUNsQjtZQUNELE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbkMsS0FBSyxFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTztZQUNoQyxJQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRSxFQUFFO2dCQUMzQixPQUFPLFNBQVMsQ0FBQzthQUNsQjtZQUNELE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbEMsS0FBSyxFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTztZQUNoQyxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRSxFQUFFO2dCQUM1QixPQUFPLFNBQVMsQ0FBQzthQUNsQjtZQUNELE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbkMsS0FBSyxFQUFFLENBQUMsa0JBQWtCLENBQUMsVUFBVSxDQUFDO1FBQ3RDO1lBQ0UsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFj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QUFRLENBQUMsQ0FBQztRQUMzQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDVixPQUFPLFdBQVcsQ0FBQyxDQUFDLENBQUMsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDdEMsQ0FBQyxFQUFFLENBQUM7U0FDTDtRQUNELE9BQU8sU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdEMsQ0FBQztBQUNILENBQUM7QUF4Q0Qsb0NBd0NDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgbG9nNGpzIGZyb20gJ2xvZzRqcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7IEpzaWlEaWFnbm9zdGljIH0gZnJvbSAnLi9qc2lpLWRpYWdub3N0aWMnO1xuXG4vKipcbiAqIE5hbWUgb2YgdGhlIGxvZ2dlciBmb3IgZGlhZ25vc3RpY3MgaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IERJQUdOT1NUSUNTID0gJ2RpYWdub3N0aWNzJztcbi8qKlxuICogRGlhZ25vc3RpYyBjb2RlIGZvciBKU0lJLWdlbmVyYXRlZCBtZXNzYWdlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IEpTSUlfRElBR05PU1RJQ1NfQ09ERSA9IDk5OTk7XG5cbi8qKlxuICogT2J0YWlucyB0aGUgcmVsZXZhbnQgbG9nZ2VyIHRvIGJlIHVzZWQgZm9yIGEgZ2l2ZW4gZGlhZ25vc3RpYyBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBsb2dnZXIgICAgIHRoZSBgYGxvZzRqcy5Mb2dnZXJgYCB0byB1c2UgZm9yIGVtaXR0aW5nIHRoZSBtZXNzYWdlLlxuICogQHBhcmFtIGRpYWdub3N0aWMgdGhlIG1lc3NhZ2UgZm9yIHdoaWNoIGEgbG9nZ2VyIGlzIHJlcXVlc3RlZC5cbiAqXG4gKiBAcmV0dXJucyBhIGxvZ2dlciBtZXRob2Qgb2YgdGhlIGBgbG9nZ2VyYGAgZm9yIHRoZSBhcHByb3ByaWF0ZSBsZXZlbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpYWdub3N0aWNzTG9nZ2VyKFxuICBsb2dnZXI6IGxvZzRqcy5Mb2dnZXIsXG4gIGRpYWdub3N0aWM6IHRzLkRpYWdub3N0aWMsXG4pOiAoKG1lc3NhZ2U6IGFueSwgLi4uYXJnczogYW55W10pID0+IHZvaWQpIHwgdW5kZWZpbmVkIHtcbiAgc3dpdGNoIChkaWFnbm9zdGljLmNhdGVnb3J5KSB7XG4gICAgY2FzZSB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuRXJyb3I6XG4gICAgICBpZiAoIWxvZ2dlci5pc0Vycm9yRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9nZ2VyLmVycm9yLmJpbmQobG9nZ2VyKTtcbiAgICBjYXNlIHRzLkRpYWdub3N0aWNDYXRlZ29yeS5XYXJuaW5nOlxuICAgICAgaWYgKCFsb2dnZXIuaXNXYXJuRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9nZ2VyLndhcm4uYmluZChsb2dnZXIpO1xuICAgIGNhc2UgdHMuRGlhZ25vc3RpY0NhdGVnb3J5Lk1lc3NhZ2U6XG4gICAgICBpZiAoIWxvZ2dlci5pc0RlYnVnRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9nZ2VyLmRlYnVnLmJpbmQobG9nZ2VyKTtcbiAgICBjYXNlIHRzLkRpYWdub3N0aWNDYXRlZ29yeS5TdWdnZXN0aW9uOlxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoIWxvZ2dlci5pc1RyYWNlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9nZ2VyLnRyYWNlLmJpbmQobG9nZ2VyKTtcbiAgfVxufVxuXG4vKipcbiAqIEZvcm1hdHMgYSBkaWFnbm9zdGljIG1lc3NhZ2Ugd2l0aCBjb2xvciBhbmQgY29udGV4dCwgaWYgcG9zc2libGUuXG4gKlxuICogQHBhcmFtIGRpYWdub3N0aWMgIHRoZSBkaWFnbm9zdGljIG1lc3NhZ2Ugb3QgYmUgZm9ybWF0dGVkLlxuICogQHBhcmFtIHByb2plY3RSb290IHRoZSByb290IG9mIHRoZSBUeXBlU2NyaXB0IHByb2plY3QuXG4gKlxuICogQHJldHVybnMgYSBmb3JtYXR0ZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGlhZ25vc3RpYyhcbiAgZGlhZ25vc3RpYzogdHMuRGlhZ25vc3RpYyxcbiAgcHJvamVjdFJvb3Q6IHN0cmluZyxcbikge1xuICBpZiAoSnNpaURpYWdub3N0aWMuaXNKc2lpRGlhZ25vc3RpYyhkaWFnbm9zdGljKSkge1xuICAgIC8vIEVuc3VyZSB3ZSBsZXZlcmFnZSBwcmUtcmVuZGVyZWQgZGlhZ25vc3RpY3Mgd2hlcmUgYXZhaWxhYmxlLlxuICAgIHJldHVybiBkaWFnbm9zdGljLmZvcm1hdChwcm9qZWN0Um9vdCk7XG4gIH1cbiAgcmV0dXJuIF9mb3JtYXREaWFnbm9zdGljKGRpYWdub3N0aWMsIHByb2plY3RSb290KTtcbn1cblxuLyoqXG4gKiBGb3JtYXRzIGEgZGlhZ25vc3RpYyBtZXNzYWdlIHdpdGggY29sb3IgYW5kIGNvbnRleHQsIGlmIHBvc3NpYmxlLiBVc2Vyc1xuICogc2hvdWxkIHVzZSBgZm9ybWF0RGlhZ25vc3RpY2AgaW5zdGVhZCwgYXMgdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBpbnRlZGVkIGZvclxuICogaW50ZXJuYWwgdXNhZmUgb25seS5cbiAqXG4gKiBAcGFyYW0gZGlhZ25vc3RpYyAgdGhlIGRpYWdub3N0aWMgbWVzc2FnZSBvdCBiZSBmb3JtYXR0ZWQuXG4gKiBAcGFyYW0gcHJvamVjdFJvb3QgdGhlIHJvb3Qgb2YgdGhlIFR5cGVTY3JpcHQgcHJvamVjdC5cbiAqXG4gKiBAcmV0dXJucyBhIGZvcm1hdHRlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZm9ybWF0RGlhZ25vc3RpYyhcbiAgZGlhZ25vc3RpYzogdHMuRGlhZ25vc3RpYyxcbiAgcHJvamVjdFJvb3Q6IHN0cmluZyxcbikge1xuICBjb25zdCBmb3JtYXREaWFnbm9zdGljc0hvc3Q6IHRzLkZvcm1hdERpYWdub3N0aWNzSG9zdCA9IHtcbiAgICBnZXRDdXJyZW50RGlyZWN0b3J5OiAoKSA9PiBwcm9qZWN0Um9vdCxcbiAgICBnZXRDYW5vbmljYWxGaWxlTmFtZTogKGZpbGVOYW1lKSA9PiBmaWxlTmFtZSxcbiAgICBnZXROZXdMaW5lOiAoKSA9PiB0cy5zeXMubmV3TGluZSxcbiAgfTtcblxuICBjb25zdCBtZXNzYWdlID1cbiAgICBkaWFnbm9zdGljLmZpbGUgIT0gbnVsbFxuICAgICAgPyB0cy5mb3JtYXREaWFnbm9zdGljc1dpdGhDb2xvckFuZENvbnRleHQoXG4gICAgICAgICAgW2RpYWdub3N0aWNdLFxuICAgICAgICAgIGZvcm1hdERpYWdub3N0aWNzSG9zdCxcbiAgICAgICAgKVxuICAgICAgOiB0cy5mb3JtYXREaWFnbm9zdGljKGRpYWdub3N0aWMsIGZvcm1hdERpYWdub3N0aWNzSG9zdCk7XG5cbiAgaWYgKCFKc2lpRGlhZ25vc3RpYy5pc0pzaWlEaWFnbm9zdGljKGRpYWdub3N0aWMpKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cblxuICAvLyBUaGlzIGlzIG91ciBvd24gZGlhZ25vc3RpY3MsIHNvIHdlJ2xsIGZvcm1hdCBhcHByb3ByaWF0ZWx5IChyZXBsYWNpbmcgVFMjIyMjIHdpdGggSlNJSSMjIyMpLlxuICByZXR1cm4gbWVzc2FnZS5yZXBsYWNlKFxuICAgIGAgVFMke0pTSUlfRElBR05PU1RJQ1NfQ09ERX06IGAsXG4gICAgYCBKU0lJJHtkaWFnbm9zdGljLmpzaWlDb2RlfTogYCxcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZ0RpYWdub3N0aWMoZGlhZ25vc3RpYzogdHMuRGlhZ25vc3RpYywgcHJvamVjdFJvb3Q6IHN0cmluZykge1xuICBjb25zdCBsb2dGdW5jID0gZGlhZ25vc3RpY3NMb2dnZXIobG9nNGpzLmdldExvZ2dlcihESUFHTk9TVElDUyksIGRpYWdub3N0aWMpO1xuICBpZiAoIWxvZ0Z1bmMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbG9nRnVuYyhmb3JtYXREaWFnbm9zdGljKGRpYWdub3N0aWMsIHByb2plY3RSb290KS50cmltKCkpO1xufVxuXG5jb25zdCBQRVJTT05fUkVHRVggPSAvXlxccyooLis/KSg/Olxccyo8KFtePl0rKT4pPyg/OlxccypcXCgoW14pXSspXFwpKT9cXHMqJC87XG4vKipcbiAqIFBhcnNlcyBhIHN0cmluZy1mb3JtYXR0ZWQgcGVyc29uIGVudHJ5IGZyb20gYHBhY2thZ2UuanNvbmAuXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHN0cmluZy1mb3JtYXR0ZWQgcGVyc29uIGVudHJ5LlxuICpcbiAqIEBleGFtcGxlXG4gKiAgcGFyc2VQZXJzb24oXCJCYXJuZXkgUnViYmxlIDxiQHJ1YmJsZS5jb20+IChodHRwOi8vYmFybnlydWJibGUudHVtYmxyLmNvbS8pXCIpO1xuICogIC8vID0+IHsgbmFtZTogXCJCYXJuZXkgUnViYmxlXCIsIGVtYWlsOiBcImJAcnViYmxlLmNvbVwiLCB1cmw6IFwiaHR0cDovL2Jhcm55cnViYmxlLnR1bWJsci5jb20vXCIgfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQZXJzb24odmFsdWU6IHN0cmluZykge1xuICBjb25zdCBtYXRjaCA9IFBFUlNPTl9SRUdFWC5leGVjKHZhbHVlKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdHJpbmdpZmllZCBcInBlcnNvblwiIHZhbHVlOiAke3ZhbHVlfWApO1xuICB9XG4gIGNvbnN0IFssIG5hbWUsIGVtYWlsLCB1cmxdID0gbWF0Y2g7XG4gIGNvbnN0IHJlc3VsdDogeyBuYW1lOiBzdHJpbmc7IGVtYWlsPzogc3RyaW5nOyB1cmw/OiBzdHJpbmcgfSA9IHtcbiAgICBuYW1lOiBuYW1lLnRyaW0oKSxcbiAgfTtcbiAgaWYgKGVtYWlsKSB7XG4gICAgcmVzdWx0LmVtYWlsID0gZW1haWwudHJpbSgpO1xuICB9XG4gIGlmICh1cmwpIHtcbiAgICByZXN1bHQudXJsID0gdXJsLnRyaW0oKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBSRVBPU0lUT1JZX1JFR0VYID1cbiAgL14oPzooZ2l0aHVifGdpc3R8Yml0YnVja2V0fGdpdGxhYik6KT8oW0EtWmEtelxcZF8tXStcXC9bQS1aYS16XFxkXy1dKykkLztcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJlcG9zaXRvcnkodmFsdWU6IHN0cmluZyk6IHsgdXJsOiBzdHJpbmcgfSB7XG4gIGNvbnN0IG1hdGNoID0gUkVQT1NJVE9SWV9SRUdFWC5leGVjKHZhbHVlKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiB7IHVybDogdmFsdWUgfTtcbiAgfVxuICBjb25zdCBbLCBob3N0LCBzbHVnXSA9IG1hdGNoO1xuICBzd2l0Y2ggKGhvc3QgPz8gJ2dpdGh1YicpIHtcbiAgICBjYXNlICdnaXRodWInOlxuICAgICAgcmV0dXJuIHsgdXJsOiBgaHR0cHM6Ly9naXRodWIuY29tLyR7c2x1Z30uZ2l0YCB9O1xuICAgIGNhc2UgJ2dpc3QnOlxuICAgICAgcmV0dXJuIHsgdXJsOiBgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vJHtzbHVnfS5naXRgIH07XG4gICAgY2FzZSAnYml0YnVja2V0JzpcbiAgICAgIHJldHVybiB7IHVybDogYGh0dHBzOi8vYml0YnVja2V0Lm9yZy8ke3NsdWd9LmdpdGAgfTtcbiAgICBjYXNlICdnaXRsYWInOlxuICAgICAgcmV0dXJuIHsgdXJsOiBgaHR0cHM6Ly9naXRsYWIuY29tLyR7c2x1Z30uZ2l0YCB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gaG9zdCBzZXJ2aWNlOiAke2hvc3R9YCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN5bWJvbElkZW50aWZpZXIoXG4gIHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlcixcbiAgc3ltOiB0cy5TeW1ib2wsXG4pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBjb25zdCBpbkZpbGVOYW1lUGFydHM6IHN0cmluZ1tdID0gW107XG5cbiAgbGV0IGRlY2w6IHRzLk5vZGUgfCB1bmRlZmluZWQgPSBzeW0uZGVjbGFyYXRpb25zWzBdO1xuICB3aGlsZSAoZGVjbCAmJiAhdHMuaXNTb3VyY2VGaWxlKGRlY2wpKSB7XG4gICAgaWYgKFxuICAgICAgdHMuaXNDbGFzc0RlY2xhcmF0aW9uKGRlY2wpIHx8XG4gICAgICB0cy5pc05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uKGRlY2wpIHx8XG4gICAgICB0cy5pc05hbWVzcGFjZUV4cG9ydChkZWNsKSB8fFxuICAgICAgdHMuaXNFbnVtRGVjbGFyYXRpb24oZGVjbCkgfHxcbiAgICAgIHRzLmlzRW51bU1lbWJlcihkZWNsKSB8fFxuICAgICAgdHMuaXNJbnRlcmZhY2VEZWNsYXJhdGlvbihkZWNsKSB8fFxuICAgICAgdHMuaXNNZXRob2REZWNsYXJhdGlvbihkZWNsKSB8fFxuICAgICAgdHMuaXNNZXRob2RTaWduYXR1cmUoZGVjbCkgfHxcbiAgICAgIHRzLmlzUHJvcGVydHlEZWNsYXJhdGlvbihkZWNsKSB8fFxuICAgICAgdHMuaXNQcm9wZXJ0eVNpZ25hdHVyZShkZWNsKVxuICAgICkge1xuICAgICAgY29uc3QgbmFtZSA9IHRzLmdldE5hbWVPZkRlY2xhcmF0aW9uKGRlY2wpO1xuICAgICAgY29uc3QgZGVjbFN5bSA9IG5hbWUgPyB0eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKG5hbWUpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGRlY2xTeW0pIHtcbiAgICAgICAgaW5GaWxlTmFtZVBhcnRzLnVuc2hpZnQoZGVjbFN5bS5uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVjbCA9IGRlY2wucGFyZW50O1xuICB9XG4gIGlmICghZGVjbCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBuYW1lc3BhY2UgPSBnZXROYW1lc3BhY2UoZGVjbC5nZXRTb3VyY2VGaWxlKCkuZmlsZU5hbWUpO1xuXG4gIGlmICghbmFtZXNwYWNlKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBgJHtuYW1lc3BhY2V9OiR7aW5GaWxlTmFtZVBhcnRzLmpvaW4oJy4nKX1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmFtZXNwYWNlKHNvdXJjZUZpbGVOYW1lOiBzdHJpbmcpIHtcbiAgY29uc3QgcGFja2FnZUpzb25Mb2NhdGlvbiA9IGZpbmRQYWNrYWdlSnNvbkxvY2F0aW9uKFxuICAgIHBhdGguZGlybmFtZShzb3VyY2VGaWxlTmFtZSksXG4gICk7XG5cbiAgaWYgKCFwYWNrYWdlSnNvbkxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IHBhY2thZ2VKc29uID0gSlNPTi5wYXJzZShcbiAgICBmcy5yZWFkRmlsZVN5bmMocGFja2FnZUpzb25Mb2NhdGlvbikudG9TdHJpbmcoKSxcbiAgKTtcblxuICBjb25zdCBzb3VyY2VQYXRoID0gcmVtb3ZlUHJlZml4KFxuICAgIHBhY2thZ2VKc29uLmpzaWk/Lm91dGRpciA/PyAnJyxcbiAgICBwYXRoLnJlbGF0aXZlKHBhdGguZGlybmFtZShwYWNrYWdlSnNvbkxvY2F0aW9uKSwgc291cmNlRmlsZU5hbWUpLFxuICApO1xuXG4gIHJldHVybiBzb3VyY2VQYXRoLnJlcGxhY2UoLyhcXC5kKT9cXC50cyQvLCAnJyk7XG5cbiAgZnVuY3Rpb24gZmluZFBhY2thZ2VKc29uTG9jYXRpb24oY3VycmVudFBhdGg6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgY2FuZGlkYXRlID0gcGF0aC5qb2luKGN1cnJlbnRQYXRoLCAncGFja2FnZS5qc29uJyk7XG4gICAgaWYgKGZzLmV4aXN0c1N5bmMoY2FuZGlkYXRlKSkge1xuICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50UGF0aCA9IHBhdGgucmVzb2x2ZShjdXJyZW50UGF0aCwgJy4uJyk7XG4gICAgcmV0dXJuIHBhcmVudFBhdGggIT09IGN1cnJlbnRQYXRoXG4gICAgICA/IGZpbmRQYWNrYWdlSnNvbkxvY2F0aW9uKHBhcmVudFBhdGgpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVByZWZpeChwcmVmaXg6IHN0cmluZywgZmlsZVBhdGg6IHN0cmluZykge1xuICAgIGNvbnN0IHByZWZpeFBhcnRzID0gcHJlZml4LnNwbGl0KC9bL1xcXFxdL2cpO1xuICAgIGNvbnN0IHBhdGhQYXJ0cyA9IGZpbGVQYXRoLnNwbGl0KC9bL1xcXFxdL2cpO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAocHJlZml4UGFydHNbaV0gPT09IHBhdGhQYXJ0c1tpXSkge1xuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aFBhcnRzLnNsaWNlKGkpLmpvaW4oJy8nKTtcbiAgfVxufVxuIl19