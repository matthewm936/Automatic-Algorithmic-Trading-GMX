"use strict";
/**
 * Helper routines for use with the jsii compiler
 *
 * These are mostly used for testing, but all projects that need to exercise
 * the JSII compiler to test something need to share this code, so might as
 * well put it in one reusable place.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileJsiiForTest = exports.sourceToAssemblyHelper = void 0;
const fs = require("fs-extra");
const os = require("os");
const path = require("path");
const typescript_1 = require("typescript");
const compiler_1 = require("./compiler");
const project_info_1 = require("./project-info");
const utils_1 = require("./utils");
/**
 * Compile a piece of source and return the JSII assembly for it
 *
 * Only usable for trivial cases and tests.
 *
 * @param source can either be a single `string` (the content of `index.ts`), or
 *               a map of fileName to content, which *must* include `index.ts`.
 */
async function sourceToAssemblyHelper(source, cb) {
    return (await compileJsiiForTest(source, cb)).assembly;
}
exports.sourceToAssemblyHelper = sourceToAssemblyHelper;
/**
 * Compile a piece of source and return the assembly and compiled sources for it
 *
 * Only usable for trivial cases and tests.
 *
 * @param source can either be a single `string` (the content of `index.ts`), or
 *               a map of fileName to content, which *must* include `index.ts`.
 */
async function compileJsiiForTest(source, cb, compilerOptions) {
    if (typeof source === 'string') {
        source = { 'index.ts': source };
    }
    // Easiest way to get the source into the compiler is to write it to disk somewhere.
    // I guess we could make an in-memory compiler host but that seems like work...
    return inTempDir(async () => {
        await Promise.all(Object.entries(source).map(async ([fileName, content]) => {
            await fs.mkdirp(path.dirname(fileName));
            return fs.writeFile(fileName, content, { encoding: 'utf-8' });
        }));
        const projectInfo = await makeProjectInfo('index.ts', cb);
        const compiler = new compiler_1.Compiler({
            projectInfo,
            ...compilerOptions,
        });
        const emitResult = await compiler.emit();
        const errors = emitResult.diagnostics.filter((d) => d.category === typescript_1.DiagnosticCategory.Error);
        for (const error of errors) {
            console.error(utils_1.formatDiagnostic(error, projectInfo.projectRoot));
            // logDiagnostic() doesn't work out of the box, so console.error() it is.
        }
        if (errors.length > 0 || emitResult.emitSkipped) {
            throw new Error('There were compiler errors');
        }
        const assembly = await fs.readJSON('.jsii', { encoding: 'utf-8' });
        const files = {};
        for (const filename of Object.keys(source)) {
            const jsFile = filename.replace(/\.ts$/, '.js');
            const dtsFile = filename.replace(/\.ts$/, '.d.ts');
            // eslint-disable-next-line no-await-in-loop
            files[jsFile] = await fs.readFile(jsFile, { encoding: 'utf-8' });
            // eslint-disable-next-line no-await-in-loop
            files[dtsFile] = await fs.readFile(dtsFile, { encoding: 'utf-8' });
            const warningsFileName = '.warnings.jsii.js';
            if (fs.existsSync(warningsFileName)) {
                // eslint-disable-next-line no-await-in-loop
                files[warningsFileName] = await fs.readFile(warningsFileName, {
                    encoding: 'utf-8',
                });
            }
        }
        return { assembly, files };
    });
}
exports.compileJsiiForTest = compileJsiiForTest;
async function inTempDir(block) {
    const origDir = process.cwd();
    const tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'jsii'));
    process.chdir(tmpDir);
    const ret = await block();
    process.chdir(origDir);
    await fs.remove(tmpDir);
    return ret;
}
/**
 * Obtain project info so we can call the compiler
 *
 * Creating this directly in-memory leads to slightly different behavior from calling
 * jsii from the command-line, and I don't want to figure out right now.
 *
 * Most consistent behavior seems to be to write a package.json to disk and
 * then calling the same functions as the CLI would.
 */
async function makeProjectInfo(types, cb) {
    const packageInfo = {
        types,
        main: types.replace(/(?:\.d)?\.ts(x?)/, '.js$1'),
        name: 'testpkg',
        version: '0.0.1',
        license: 'Apache-2.0',
        author: { name: 'John Doe', roles: ['author'] },
        repository: { type: 'git', url: 'https://github.com/aws/jsii.git' },
        jsii: {},
    };
    if (cb) {
        await cb(packageInfo);
    }
    await fs.writeJson('package.json', packageInfo, {
        encoding: 'utf-8',
        replacer: (_, v) => v,
        spaces: 2,
    });
    const { projectInfo } = await project_info_1.loadProjectInfo(path.resolve(process.cwd(), '.'));
    return projectInfo;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhlbHBlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7R0FNRzs7O0FBR0gsK0JBQStCO0FBQy9CLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IsMkNBQWdEO0FBRWhELHlDQUF1RDtBQUN2RCxpREFBOEQ7QUFDOUQsbUNBQTJDO0FBRTNDOzs7Ozs7O0dBT0c7QUFDSSxLQUFLLFVBQVUsc0JBQXNCLENBQzFDLE1BQStELEVBQy9ELEVBQStCO0lBRS9CLE9BQU8sQ0FBQyxNQUFNLGtCQUFrQixDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQztBQUN6RCxDQUFDO0FBTEQsd0RBS0M7QUFhRDs7Ozs7OztHQU9HO0FBQ0ksS0FBSyxVQUFVLGtCQUFrQixDQUN0QyxNQUErRCxFQUMvRCxFQUErQixFQUMvQixlQUFnRTtJQUVoRSxJQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVEsRUFBRTtRQUM5QixNQUFNLEdBQUcsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLENBQUM7S0FDakM7SUFFRCxvRkFBb0Y7SUFDcEYsK0VBQStFO0lBQy9FLE9BQU8sU0FBUyxDQUFDLEtBQUssSUFBSSxFQUFFO1FBQzFCLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FDZixNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLEVBQUUsRUFBRTtZQUN2RCxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ3hDLE9BQU8sRUFBRSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsT0FBTyxFQUFFLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFDaEUsQ0FBQyxDQUFDLENBQ0gsQ0FBQztRQUNGLE1BQU0s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QUFLLFVBQVUsZUFBZSxDQUM1QixLQUFhLEVBQ2IsRUFBK0M7SUFFL0MsTUFBTSxXQUFXLEdBQWdCO1FBQy9CLEtBQUs7UUFDTCxJQUFJLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsRUFBRSxPQUFPLENBQUM7UUFDaEQsSUFBSSxFQUFFLFNBQVM7UUFDZixPQUFPLEVBQUUsT0FBTztRQUNoQixPQUFPLEVBQUUsWUFBWTtRQUNyQixNQUFNLEVBQUUsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1FBQy9DLFVBQVUsRUFBRSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLGlDQUFpQyxFQUFFO1FBQ25FLElBQUksRUFBRSxFQUFFO0tBQ1QsQ0FBQztJQUNGLElBQUksRUFBRSxFQUFFO1FBQ04sTUFBTSxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUM7S0FDdkI7SUFFRCxNQUFNLEVBQUUsQ0FBQyxTQUFTLENBQUMsY0FBYyxFQUFFLFdBQVcsRUFBRTtRQUM5QyxRQUFRLEVBQUUsT0FBTztRQUNqQixRQUFRLEVBQUUsQ0FBQyxDQUFTLEVBQUUsQ0FBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ2xDLE1BQU0sRUFBRSxDQUFDO0tBQ1YsQ0FBQyxDQUFDO0lBRUgsTUFBTSxFQUFFLFdBQVcsRUFBRSxHQUFHLE1BQU0sOEJBQWUsQ0FDM0MsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQ2pDLENBQUM7SUFDRixPQUFPLFdBQVcsQ0FBQztBQUNyQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXIgcm91dGluZXMgZm9yIHVzZSB3aXRoIHRoZSBqc2lpIGNvbXBpbGVyXG4gKlxuICogVGhlc2UgYXJlIG1vc3RseSB1c2VkIGZvciB0ZXN0aW5nLCBidXQgYWxsIHByb2plY3RzIHRoYXQgbmVlZCB0byBleGVyY2lzZVxuICogdGhlIEpTSUkgY29tcGlsZXIgdG8gdGVzdCBzb21ldGhpbmcgbmVlZCB0byBzaGFyZSB0aGlzIGNvZGUsIHNvIG1pZ2h0IGFzXG4gKiB3ZWxsIHB1dCBpdCBpbiBvbmUgcmV1c2FibGUgcGxhY2UuXG4gKi9cblxuaW1wb3J0ICogYXMgc3BlYyBmcm9tICdAanNpaS9zcGVjJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBEaWFnbm9zdGljQ2F0ZWdvcnkgfSBmcm9tICd0eXBlc2NyaXB0JztcblxuaW1wb3J0IHsgQ29tcGlsZXIsIENvbXBpbGVyT3B0aW9ucyB9IGZyb20gJy4vY29tcGlsZXInO1xuaW1wb3J0IHsgbG9hZFByb2plY3RJbmZvLCBQcm9qZWN0SW5mbyB9IGZyb20gJy4vcHJvamVjdC1pbmZvJztcbmltcG9ydCB7IGZvcm1hdERpYWdub3N0aWMgfSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBDb21waWxlIGEgcGllY2Ugb2Ygc291cmNlIGFuZCByZXR1cm4gdGhlIEpTSUkgYXNzZW1ibHkgZm9yIGl0XG4gKlxuICogT25seSB1c2FibGUgZm9yIHRyaXZpYWwgY2FzZXMgYW5kIHRlc3RzLlxuICpcbiAqIEBwYXJhbSBzb3VyY2UgY2FuIGVpdGhlciBiZSBhIHNpbmdsZSBgc3RyaW5nYCAodGhlIGNvbnRlbnQgb2YgYGluZGV4LnRzYCksIG9yXG4gKiAgICAgICAgICAgICAgIGEgbWFwIG9mIGZpbGVOYW1lIHRvIGNvbnRlbnQsIHdoaWNoICptdXN0KiBpbmNsdWRlIGBpbmRleC50c2AuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzb3VyY2VUb0Fzc2VtYmx5SGVscGVyKFxuICBzb3VyY2U6IHN0cmluZyB8IHsgJ2luZGV4LnRzJzogc3RyaW5nOyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIH0sXG4gIGNiPzogKG9iajogUGFja2FnZUluZm8pID0+IHZvaWQsXG4pOiBQcm9taXNlPHNwZWMuQXNzZW1ibHk+IHtcbiAgcmV0dXJuIChhd2FpdCBjb21waWxlSnNpaUZvclRlc3Qoc291cmNlLCBjYikpLmFzc2VtYmx5O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhlbHBlckNvbXBpbGF0aW9uUmVzdWx0IHtcbiAgLyoqXG4gICAqIFRoZSBnZW5lcmF0ZWQgYXNzZW1ibHlcbiAgICovXG4gIHJlYWRvbmx5IGFzc2VtYmx5OiBzcGVjLkFzc2VtYmx5O1xuICAvKipcbiAgICogR2VuZXJhdGVkIC5qcy8uZC50cyBmaWxlKHMpXG4gICAqL1xuICByZWFkb25seSBmaWxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgcGllY2Ugb2Ygc291cmNlIGFuZCByZXR1cm4gdGhlIGFzc2VtYmx5IGFuZCBjb21waWxlZCBzb3VyY2VzIGZvciBpdFxuICpcbiAqIE9ubHkgdXNhYmxlIGZvciB0cml2aWFsIGNhc2VzIGFuZCB0ZXN0cy5cbiAqXG4gKiBAcGFyYW0gc291cmNlIGNhbiBlaXRoZXIgYmUgYSBzaW5nbGUgYHN0cmluZ2AgKHRoZSBjb250ZW50IG9mIGBpbmRleC50c2ApLCBvclxuICogICAgICAgICAgICAgICBhIG1hcCBvZiBmaWxlTmFtZSB0byBjb250ZW50LCB3aGljaCAqbXVzdCogaW5jbHVkZSBgaW5kZXgudHNgLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29tcGlsZUpzaWlGb3JUZXN0KFxuICBzb3VyY2U6IHN0cmluZyB8IHsgJ2luZGV4LnRzJzogc3RyaW5nOyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIH0sXG4gIGNiPzogKG9iajogUGFja2FnZUluZm8pID0+IHZvaWQsXG4gIGNvbXBpbGVyT3B0aW9ucz86IE9taXQ8Q29tcGlsZXJPcHRpb25zLCAncHJvamVjdEluZm8nIHwgJ3dhdGNoJz4sXG4pOiBQcm9taXNlPEhlbHBlckNvbXBpbGF0aW9uUmVzdWx0PiB7XG4gIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZSA9IHsgJ2luZGV4LnRzJzogc291cmNlIH07XG4gIH1cblxuICAvLyBFYXNpZXN0IHdheSB0byBnZXQgdGhlIHNvdXJjZSBpbnRvIHRoZSBjb21waWxlciBpcyB0byB3cml0ZSBpdCB0byBkaXNrIHNvbWV3aGVyZS5cbiAgLy8gSSBndWVzcyB3ZSBjb3VsZCBtYWtlIGFuIGluLW1lbW9yeSBjb21waWxlciBob3N0IGJ1dCB0aGF0IHNlZW1zIGxpa2Ugd29yay4uLlxuICByZXR1cm4gaW5UZW1wRGlyKGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIE9iamVjdC5lbnRyaWVzKHNvdXJjZSkubWFwKGFzeW5jIChbZmlsZU5hbWUsIGNvbnRlbnRdKSA9PiB7XG4gICAgICAgIGF3YWl0IGZzLm1rZGlycChwYXRoLmRpcm5hbWUoZmlsZU5hbWUpKTtcbiAgICAgICAgcmV0dXJuIGZzLndyaXRlRmlsZShmaWxlTmFtZSwgY29udGVudCwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KTtcbiAgICAgIH0pLFxuICAgICk7XG4gICAgY29uc3QgcHJvamVjdEluZm8gPSBhd2FpdCBtYWtlUHJvamVjdEluZm8oJ2luZGV4LnRzJywgY2IpO1xuICAgIGNvbnN0IGNvbXBpbGVyID0gbmV3IENvbXBpbGVyKHtcbiAgICAgIHByb2plY3RJbmZvLFxuICAgICAgLi4uY29tcGlsZXJPcHRpb25zLFxuICAgIH0pO1xuICAgIGNvbnN0IGVtaXRSZXN1bHQgPSBhd2FpdCBjb21waWxlci5lbWl0KCk7XG5cbiAgICBjb25zdCBlcnJvcnMgPSBlbWl0UmVzdWx0LmRpYWdub3N0aWNzLmZpbHRlcihcbiAgICAgIChkKSA9PiBkLmNhdGVnb3J5ID09PSBEaWFnbm9zdGljQ2F0ZWdvcnkuRXJyb3IsXG4gICAgKTtcbiAgICBmb3IgKGNvbnN0IGVycm9yIG9mIGVycm9ycykge1xuICAgICAgY29uc29sZS5lcnJvcihmb3JtYXREaWFnbm9zdGljKGVycm9yLCBwcm9qZWN0SW5mby5wcm9qZWN0Um9vdCkpO1xuICAgICAgLy8gbG9nRGlhZ25vc3RpYygpIGRvZXNuJ3Qgd29yayBvdXQgb2YgdGhlIGJveCwgc28gY29uc29sZS5lcnJvcigpIGl0IGlzLlxuICAgIH1cbiAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDAgfHwgZW1pdFJlc3VsdC5lbWl0U2tpcHBlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSB3ZXJlIGNvbXBpbGVyIGVycm9ycycpO1xuICAgIH1cbiAgICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IGZzLnJlYWRKU09OKCcuanNpaScsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSk7XG4gICAgY29uc3QgZmlsZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcblxuICAgIGZvciAoY29uc3QgZmlsZW5hbWUgb2YgT2JqZWN0LmtleXMoc291cmNlKSkge1xuICAgICAgY29uc3QganNGaWxlID0gZmlsZW5hbWUucmVwbGFjZSgvXFwudHMkLywgJy5qcycpO1xuICAgICAgY29uc3QgZHRzRmlsZSA9IGZpbGVuYW1lLnJlcGxhY2UoL1xcLnRzJC8sICcuZC50cycpO1xuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgZmlsZXNbanNGaWxlXSA9IGF3YWl0IGZzLnJlYWRGaWxlKGpzRmlsZSwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICBmaWxlc1tkdHNGaWxlXSA9IGF3YWl0IGZzLnJlYWRGaWxlKGR0c0ZpbGUsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSk7XG5cbiAgICAgIGNvbnN0IHdhcm5pbmdzRmlsZU5hbWUgPSAnLndhcm5pbmdzLmpzaWkuanMnO1xuICAgICAgaWYgKGZzLmV4aXN0c1N5bmMod2FybmluZ3NGaWxlTmFtZSkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgZmlsZXNbd2FybmluZ3NGaWxlTmFtZV0gPSBhd2FpdCBmcy5yZWFkRmlsZSh3YXJuaW5nc0ZpbGVOYW1lLCB7XG4gICAgICAgICAgZW5jb2Rpbmc6ICd1dGYtOCcsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGFzc2VtYmx5LCBmaWxlcyB9O1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5UZW1wRGlyPFQ+KGJsb2NrOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gIGNvbnN0IG9yaWdEaXIgPSBwcm9jZXNzLmN3ZCgpO1xuICBjb25zdCB0bXBEaXIgPSBhd2FpdCBmcy5ta2R0ZW1wKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ2pzaWknKSk7XG4gIHByb2Nlc3MuY2hkaXIodG1wRGlyKTtcbiAgY29uc3QgcmV0ID0gYXdhaXQgYmxvY2soKTtcbiAgcHJvY2Vzcy5jaGRpcihvcmlnRGlyKTtcbiAgYXdhaXQgZnMucmVtb3ZlKHRtcERpcik7XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogT2J0YWluIHByb2plY3QgaW5mbyBzbyB3ZSBjYW4gY2FsbCB0aGUgY29tcGlsZXJcbiAqXG4gKiBDcmVhdGluZyB0aGlzIGRpcmVjdGx5IGluLW1lbW9yeSBsZWFkcyB0byBzbGlnaHRseSBkaWZmZXJlbnQgYmVoYXZpb3IgZnJvbSBjYWxsaW5nXG4gKiBqc2lpIGZyb20gdGhlIGNvbW1hbmQtbGluZSwgYW5kIEkgZG9uJ3Qgd2FudCB0byBmaWd1cmUgb3V0IHJpZ2h0IG5vdy5cbiAqXG4gKiBNb3N0IGNvbnNpc3RlbnQgYmVoYXZpb3Igc2VlbXMgdG8gYmUgdG8gd3JpdGUgYSBwYWNrYWdlLmpzb24gdG8gZGlzayBhbmRcbiAqIHRoZW4gY2FsbGluZyB0aGUgc2FtZSBmdW5jdGlvbnMgYXMgdGhlIENMSSB3b3VsZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbWFrZVByb2plY3RJbmZvKFxuICB0eXBlczogc3RyaW5nLFxuICBjYj86IChvYmo6IFBhY2thZ2VJbmZvKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZCxcbik6IFByb21pc2U8UHJvamVjdEluZm8+IHtcbiAgY29uc3QgcGFja2FnZUluZm86IFBhY2thZ2VJbmZvID0ge1xuICAgIHR5cGVzLFxuICAgIG1haW46IHR5cGVzLnJlcGxhY2UoLyg/OlxcLmQpP1xcLnRzKHg/KS8sICcuanMkMScpLFxuICAgIG5hbWU6ICd0ZXN0cGtnJywgLy8gVGhhdCdzIHdoYXQgcGFja2FnZS5qc29uIHdvdWxkIHRlbGwgaWYgd2UgbG9vayB1cC4uLlxuICAgIHZlcnNpb246ICcwLjAuMScsXG4gICAgbGljZW5zZTogJ0FwYWNoZS0yLjAnLFxuICAgIGF1dGhvcjogeyBuYW1lOiAnSm9obiBEb2UnLCByb2xlczogWydhdXRob3InXSB9LFxuICAgIHJlcG9zaXRvcnk6IHsgdHlwZTogJ2dpdCcsIHVybDogJ2h0dHBzOi8vZ2l0aHViLmNvbS9hd3MvanNpaS5naXQnIH0sXG4gICAganNpaToge30sXG4gIH07XG4gIGlmIChjYikge1xuICAgIGF3YWl0IGNiKHBhY2thZ2VJbmZvKTtcbiAgfVxuXG4gIGF3YWl0IGZzLndyaXRlSnNvbigncGFja2FnZS5qc29uJywgcGFja2FnZUluZm8sIHtcbiAgICBlbmNvZGluZzogJ3V0Zi04JyxcbiAgICByZXBsYWNlcjogKF86IHN0cmluZywgdjogYW55KSA9PiB2LFxuICAgIHNwYWNlczogMixcbiAgfSk7XG5cbiAgY29uc3QgeyBwcm9qZWN0SW5mbyB9ID0gYXdhaXQgbG9hZFByb2plY3RJbmZvKFxuICAgIHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCAnLicpLFxuICApO1xuICByZXR1cm4gcHJvamVjdEluZm87XG59XG5cbmV4cG9ydCB0eXBlIFBhY2thZ2VJbmZvID0ge1xuICBuYW1lOiBzdHJpbmc7XG4gIHZlcnNpb246IHN0cmluZztcbiAgbGljZW5zZTogc3RyaW5nO1xuICB0eXBlczogc3RyaW5nO1xuICBhdXRob3I6IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgcm9sZXM6IHN0cmluZ1tdO1xuICAgIFtrZXk6IHN0cmluZ106IGFueTtcbiAgfTtcbiAgcmVwb3NpdG9yeToge1xuICAgIHR5cGU/OiBzdHJpbmc7XG4gICAgdXJsOiBzdHJpbmc7XG4gICAgZGlyZWN0b3J5Pzogc3RyaW5nO1xuICAgIFtrZXk6IHN0cmluZ106IGFueTtcbiAgfTtcbiAganNpaToge1xuICAgIFtrZXk6IHN0cmluZ106IGFueTtcbiAgfTtcbiAgW2tleTogc3RyaW5nXTogYW55O1xufTtcbiJdfQ==