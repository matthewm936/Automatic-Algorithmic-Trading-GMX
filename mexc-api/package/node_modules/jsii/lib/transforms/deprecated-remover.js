"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeprecatedRemover = void 0;
const spec_1 = require("@jsii/spec");
const path_1 = require("path");
const ts = require("typescript");
const jsii_diagnostic_1 = require("../jsii-diagnostic");
const bindings = require("../node-bindings");
class DeprecatedRemover {
    constructor(typeChecker, allowlistedDeprecations) {
        this.typeChecker = typeChecker;
        this.allowlistedDeprecations = allowlistedDeprecations;
        this.transformations = new Array();
        this.nodesToRemove = new Set();
    }
    /**
     * Obtains the configuration for the TypeScript transform(s) that will remove
     * `@deprecated` members from the generated declarations (`.d.ts`) files. It
     * will leverage information accumulated during `#removeFrom(Assembly)` in
     * order to apply corrections to inheritance chains, ensuring a valid output
     * is produced.
     */
    get customTransformers() {
        return {
            afterDeclarations: [
                (context) => {
                    const transformer = new DeprecationRemovalTransformer(this.typeChecker, context, this.transformations, this.nodesToRemove);
                    return transformer.transform.bind(transformer);
                },
            ],
        };
    }
    /**
     * Removes all `@deprecated` API elements from the provided assembly, and
     * records the operations needed in order to fix the inheritance chains that
     * mix `@deprecated` and non-`@deprecated` types.
     *
     * @param assembly the assembly to be modified.
     *
     * @returns diagnostic messages produced when validating no remaining API
     *          makes use of a `@deprecated` type that was removed.
     */
    removeFrom(assembly) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (assembly.types == null) {
            return [];
        }
        const strippedFqns = new Set();
        const replaceWithClass = new Map();
        const replaceWithInterfaces = new Map();
        // Find all types that will be stripped out
        for (const [fqn, typeInfo] of Object.entries(assembly.types)) {
            if (((_a = typeInfo.docs) === null || _a === void 0 ? void 0 : _a.stability) === spec_1.Stability.Deprecated) {
                if (!this.shouldFqnBeStripped(fqn)) {
                    continue;
                }
                strippedFqns.add(fqn);
                if (spec_1.isClassType(typeInfo) && typeInfo.base != null) {
                    replaceWithClass.set(fqn, typeInfo.base);
                }
                if (spec_1.isClassOrInterfaceType(typeInfo) && typeInfo.interfaces != null) {
                    replaceWithInterfaces.set(fqn, typeInfo.interfaces);
                }
                this.nodesToRemove.add(bindings.getRelatedNode(typeInfo));
            }
        }
        for (const [fqn, typeInfo] of Object.entries(assembly.types)) {
            // Ignore `@deprecated` types
            if (strippedFqns.has(fqn)) {
                continue;
            }
            // Enums cannot have references to `@deprecated` types, but can have deprecated members
            if (spec_1.isEnumType(typeInfo)) {
                const enumNode = bindings.getEnumRelatedNode(typeInfo);
                const members = [];
                typeInfo.members.forEach((mem) => {
                    var _a;
                    if (((_a = mem.docs) === null || _a === void 0 ? void 0 : _a.stability) === spec_1.Stability.Deprecated &&
                        this.shouldFqnBeStripped(`${fqn}#${mem.name}`)) {
                        const matchingMemberNode = enumNode.members.find((enumMem) => enumMem.name.getText() === mem.name);
                        if (matchingMemberNode) {
                            this.nodesToRemove.add(matchingMemberNode);
                        }
                    }
                    else {
                        members.push(mem);
                    }
                });
                typeInfo.members = members;
                continue;
            }
            // For classes, we erase `@deprecated` base classes, replacing as needed
            const additionalInterfaces = new Set();
            if (spec_1.isClassType(typeInfo) &&
                typeInfo.base != null &&
                strippedFqns.has(typeInfo.base)) {
                while (typeInfo.base != null && strippedFqns.has(typeInfo.base)) {
                    const oldBase = assembly.types[typeInfo.base];
                    (_b = oldBase.interfaces) === null || _b === void 0 ? void 0 : _b.forEach((fqn) => additionalInterfaces.add(fqn));
                    typeInfo.base = replaceWithClass.get(typeInfo.base);
                }
                this.transformations.push(typeInfo.base != null
                    ? Transformation.replaceBaseClass(this.typeChecker, bindings.getClassRelatedNode(typeInfo), typeInfo.base in assembly.types
                        ? (_c = bindings.getClassRelatedNode(assembly.types[typeInfo.base])) !== null && _c !== void 0 ? _c : typeInfo.base : typeInfo.base)
                    : Transformation.removeBaseClass(this.typeChecker, bindings.getClassRelatedNode(typeInfo)));
            }
            // Be defensive in case we add other kinds in the future
            if (!spec_1.isClassOrInterfaceType(typeInfo)) {
                throw new Error(`Unhandled type encountered! ${JSON.stringify(typeInfo, null, 2)}`);
            }
            // Strip all `@deprecated` interfaces from the inheritance tree, replacing as needed
            if (((_d = typeInfo.interfaces) === null || _d === void 0 ? void 0 : _d.some((fqn) => strippedFqns.has(fqn))) ||
                additionalInterfaces.size > 0) {
                const originalSet = new Set((_e = typeInfo.interfaces) !== null && _e !== void 0 ? _e : []);
                const newSet = new Set();
                const candidates = Array.from(new Set([...originalSet, ...additionalInterfaces]));
                while (candidates.length > 0) {
                    const fqn = candidates.pop();
                    if (!strippedFqns.has(fqn)) {
                        newSet.add(fqn);
                        if (!originalSet.has(fqn)) {
                            this.transformations.push(Transformation.addInterface(this.typeChecker, bindings.getClassOrInterfaceRelatedNode(typeInfo), fqn in assembly.types
                                ? (_f = bindings.getInterfaceRelatedNode(assembly.types[fqn])) !== null && _f !== void 0 ? _f : fqn : fqn));
                        }
                        continue;
                    }
                    if (originalSet.has(fqn)) {
                        this.transformations.push(Transformation.removeInterface(this.typeChecker, bindings.getClassOrInterfaceRelatedNode(typeInfo), bindings.getInterfaceRelatedNode(assembly.types[fqn])));
                    }
                    const replacement = replaceWithInterfaces.get(fqn);
                    if (replacement != null) {
                        candidates.push(...replacement);
                    }
                }
                typeInfo.interfaces =
                    newSet.size > 0 ? Array.from(newSet).sort() : undefined;
            }
            // Drop all `@deprecated` members, and remove "overrides" from stripped types
            const methods = [];
            const properties = [];
            (_g = typeInfo.methods) === null || _g === void 0 ? void 0 : _g.forEach((meth) => {
                var _a;
                if (((_a = meth.docs) === null || _a === void 0 ? void 0 : _a.stability) === spec_1.Stability.Deprecated &&
                    this.shouldFqnBeStripped(`${fqn}#${meth.name}`)) {
                    this.nodesToRemove.add(bindings.getMethodRelatedNode(meth));
                }
                else {
                    methods.push(meth.overrides != null && strippedFqns.has(meth.overrides)
                        ? { ...meth, overrides: undefined }
                        : meth);
                }
            });
            typeInfo.methods = typeInfo.methods ? methods : undefined;
            (_h = typeInfo.properties) === null || _h === void 0 ? void 0 : _h.forEach((prop) => {
                var _a;
                if (((_a = prop.docs) === null || _a === void 0 ? void 0 : _a.stability) === spec_1.Stability.Deprecated &&
                    this.shouldFqnBeStripped(`${fqn}#${prop.name}`)) {
                    this.nodesToRemove.add(bindings.getParameterRelatedNode(prop));
                }
                else {
                    properties.push(prop.overrides != null && strippedFqns.has(prop.overrides)
                        ? { ...prop, overrides: undefined }
                        : prop);
                }
            });
            typeInfo.properties = typeInfo.properties ? properties : undefined;
        }
        const diagnostics = this.findLeftoverUseOfDeprecatedAPIs(assembly, strippedFqns);
        // Remove all `@deprecated` types, after we did everything, so we could
        // still access the related nodes from the assembly object.
        for (const fqn of strippedFqns) {
            if (this.shouldFqnBeStripped(fqn)) {
                delete assembly.types[fqn];
            }
        }
        return diagnostics;
    }
    findLeftoverUseOfDeprecatedAPIs(assembly, strippedFqns) {
        var _a, _b;
        if (assembly.types == null) {
            return [];
        }
        const result = new Array();
        for (const type of Object.values(assembly.types)) {
            if (spec_1.isEnumType(type) || strippedFqns.has(type.fqn)) {
                continue;
            }
            if (spec_1.isClassType(type) && type.initializer) {
                result.push(...this.verifyCallable(assembly, strippedFqns, type.initializer));
            }
            (_a = type.methods) === null || _a === void 0 ? void 0 : _a.forEach((method) => result.push(...this.verifyCallable(assembly, strippedFqns, method)));
            (_b = type.properties) === null || _b === void 0 ? void 0 : _b.forEach((property) => result.push(...this.verifyProperty(assembly, strippedFqns, property)));
        }
        return result;
    }
    verifyCallable(assembly, strippedFqns, method) {
        const diagnostics = new Array();
        const deprecatedReturnFqn = spec_1.isMethod(method) &&
            method.returns &&
            this.tryFindReference(method.returns.type, strippedFqns);
        if (deprecatedReturnFqn) {
            diagnostics.push(this.makeDiagnostic(deprecatedReturnFqn, 'Method', method, assembly));
        }
        if (method.parameters) {
            for (const parameter of method.parameters) {
                const deprecatedTypeFqn = this.tryFindReference(parameter.type, strippedFqns);
                if (deprecatedTypeFqn) {
                    diagnostics.push(this.makeDiagnostic(deprecatedTypeFqn, 'Parameter', parameter, assembly));
                }
            }
        }
        return diagnostics;
    }
    verifyProperty(assembly, strippedFqns, property) {
        const deprecatedTypeFqn = this.tryFindReference(property.type, strippedFqns);
        if (deprecatedTypeFqn) {
            return [
                this.makeDiagnostic(deprecatedTypeFqn, 'Property', property, assembly),
            ];
        }
        return [];
    }
    /**
     * Determines whether a `TypeReference` contains an FQN within a given set.
     *
     * @param ref  the tested `TypeReference`.
     * @param fqns the set of FQNs that are being searched for.
     *
     * @returns the first FQN that was identified.
     */
    tryFindReference(ref, fqns) {
        if (spec_1.isNamedTypeReference(ref)) {
            return fqns.has(ref.fqn) ? ref.fqn : undefined;
        }
        if (spec_1.isPrimitiveTypeReference(ref)) {
            return undefined;
        }
        if (spec_1.isCollectionTypeReference(ref)) {
            return this.tryFindReference(ref.collection.elementtype, fqns);
        }
        return ref.union.types
            .map((type) => this.tryFindReference(type, fqns))
            .find((ref) => ref != null);
    }
    shouldFqnBeStripped(fqn) {
        var _a, _b;
        return (_b = (_a = this.allowlistedDeprecations) === null || _a === void 0 ? void 0 : _a.has(fqn)) !== null && _b !== void 0 ? _b : true;
    }
    makeDiagnostic(fqn, messagePrefix, context, assembly) {
        var _a, _b, _c;
        const node = bindings.getRelatedNode(context);
        const diagnostic = jsii_diagnostic_1.JsiiDiagnostic.JSII_3999_INCOHERENT_TYPE_MODEL.create((_a = node === null || node === void 0 ? void 0 : node.type) !== null && _a !== void 0 ? _a : node, `${messagePrefix} has @deprecated type ${fqn}, and it is erased by --strip-deprecated.`);
        const typeInfo = (_b = assembly.types) === null || _b === void 0 ? void 0 : _b[fqn];
        const typeNode = typeInfo && bindings.getTypeRelatedNode(typeInfo);
        if (typeNode == null) {
            return diagnostic;
        }
        return diagnostic.addRelatedInformation((_c = ts.getNameOfDeclaration(typeNode)) !== null && _c !== void 0 ? _c : typeNode, `The @deprecated type is declared here`);
    }
}
exports.DeprecatedRemover = DeprecatedRemover;
class Transformation {
    constructor(typeChecker, node, apply) {
        this.typeChecker = typeChecker;
        this.apply = apply;
        this.nodeName = Transformation.fullyQualifiedName(typeChecker, node);
    }
    static addInterface(typeChecker, node, iface) {
        return new Transformation(typeChecker, node, (declaration) => {
            if (!ts.isClassDeclaration(declaration) &&
                !ts.isInterfaceDeclaration(declaration)) {
                throw new Error(`Expected a ClassDeclaration or InterfaceDeclaration, found a ${ts.SyntaxKind[declaration.kind]}`);
            }
            const { typeExpression: newInterface, syntheticImport } = Transformation.typeReference(iface, declaration, typeChecker);
            if (ts.isClassDeclaration(declaration)) {
                return {
                    node: ts.updateClassDeclaration(declaration, declaration.decorators, declaration.modifiers, declaration.name, declaration.typeParameters, addInterfaceTo(ts.SyntaxKind.ImplementsKeyword, declaration.heritageClauses), declaration.members),
                    syntheticImport,
                };
            }
            return {
                node: ts.updateInterfaceDeclaration(declaration, declaration.decorators, declaration.modifiers, declaration.name, declaration.typeParameters, addInterfaceTo(ts.SyntaxKind.ExtendsKeyword, declaration.heritageClauses), declaration.members),
                syntheticImport,
            };
            function addInterfaceTo(token, clauses = []) {
                const existingClause = clauses.find((clause) => clause.token === token);
                if (existingClause == null) {
                    return [...clauses, ts.createHeritageClause(token, [newInterface])];
                }
                return [
                    ...clauses.filter((clause) => clause !== existingClause),
                    ts.updateHeritageClause(existingClause, [
                        ...existingClause.types,
                        newInterface,
                    ]),
                ];
            }
        });
    }
    static replaceBaseClass(typeChecker, node, baseClass) {
        return new Transformation(typeChecker, node, (declaration) => {
            var _a, _b;
            if (!ts.isClassDeclaration(declaration)) {
                throw new Error(`Expected a ClassDeclaration, found a ${ts.SyntaxKind[declaration.kind]}`);
            }
            const { typeExpression: newBaseClass, syntheticImport } = Transformation.typeReference(baseClass, declaration, typeChecker);
            const existingClause = (_a = declaration.heritageClauses) === null || _a === void 0 ? void 0 : _a.find((clause) => clause.token === ts.SyntaxKind.ExtendsKeyword);
            return {
                node: ts.updateClassDeclaration(declaration, declaration.decorators, declaration.modifiers, declaration.name, declaration.typeParameters, [
                    ...((_b = declaration.heritageClauses) !== null && _b !== void 0 ? _b : []).filter((clause) => clause !== existingClause),
                    existingClause
                        ? ts.updateHeritageClause(existingClause, [newBaseClass])
                        : ts.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [
                            newBaseClass,
                        ]),
                ], declaration.members),
                syntheticImports: syntheticImport && [syntheticImport],
            };
        });
    }
    static removeBaseClass(typeChecker, node) {
        return new Transformation(typeChecker, node, (declaration) => {
            var _a;
            if (!ts.isClassDeclaration(declaration)) {
                throw new Error(`Expected a ClassDeclaration, found a ${ts.SyntaxKind[declaration.kind]}`);
            }
            return {
                node: ts.updateClassDeclaration(declaration, declaration.decorators, declaration.modifiers, declaration.name, declaration.typeParameters, (_a = declaration.heritageClauses) === null || _a === void 0 ? void 0 : _a.filter((clause) => clause.token !== ts.SyntaxKind.ExtendsKeyword), declaration.members),
            };
        });
    }
    static removeInterface(typeChecker, node, iface) {
        const ifaceName = Transformation.fullyQualifiedName(typeChecker, iface);
        return new Transformation(typeChecker, node, (declaration) => {
            if (ts.isClassDeclaration(declaration)) {
                return {
                    node: ts.updateClassDeclaration(declaration, declaration.decorators, declaration.modifiers, declaration.name, declaration.typeParameters, removeInterfaceHeritage(declaration.heritageClauses), declaration.members),
                };
            }
            else if (ts.isInterfaceDeclaration(declaration)) {
                return {
                    node: ts.updateInterfaceDeclaration(declaration, declaration.decorators, declaration.modifiers, declaration.name, declaration.typeParameters, removeInterfaceHeritage(declaration.heritageClauses), declaration.members),
                };
            }
            throw new Error(`Expected a ClassDeclaration or InterfaceDeclaration, found a ${ts.SyntaxKind[declaration.kind]}`);
        });
        function removeInterfaceHeritage(clauses) {
            if (clauses == null) {
                return clauses;
            }
            return clauses
                .map((clause) => {
                const types = clause.types.filter((type) => Transformation.fullyQualifiedName(typeChecker, type.expression) !== ifaceName);
                if (types.length === clause.types.length) {
                    // Means the interface was only transitively present...
                    return clause;
                }
                if (types.length === 0) {
                    return undefined;
                }
                return ts.updateHeritageClause(clause, types);
            })
                .filter((clause) => clause != null);
        }
    }
    static fullyQualifiedName(typeChecker, node) {
        var _a;
        const symbol = typeChecker.getSymbolAtLocation((_a = ts.getNameOfDeclaration(node)) !== null && _a !== void 0 ? _a : node);
        // This symbol ☝️ does not contain enough information in some cases - when
        // an imported type is part of a heritage clause - to produce the fqn.
        // Round tripping this to its type and back to a symbol seems to fix this.
        const type = symbol && typeChecker.getDeclaredTypeOfSymbol(symbol);
        return (type === null || type === void 0 ? void 0 : type.symbol) && typeChecker.getFullyQualifiedName(type.symbol);
    }
    static typeReference(type, context, typeChecker) {
        context = ts.getOriginalNode(context);
        const [, contextSource] = /^"([^"]+)"\..*$/.exec(typeChecker.getFullyQualifiedName(typeChecker.getSymbolAtLocation(ts.getNameOfDeclaration(context))));
        let expression;
        let syntheticImport;
        if (typeof type === 'string') {
            const [root, ...tail] = type.split('.');
            const syntheticImportName = ts.createUniqueName(root);
            syntheticImport = ts.createImportDeclaration(undefined /* decorators */, undefined /* modifiers */, ts.createImportClause(undefined, ts.createNamespaceImport(syntheticImportName)), ts.createStringLiteral(root));
            expression = tail.reduce((curr, elt) => ts.createPropertyAccess(curr, elt), syntheticImportName);
        }
        else {
            const [, typeSource, qualifiedName] = /^"([^"]+)"\.(.*)$/.exec(typeChecker.getFullyQualifiedName(typeChecker.getSymbolAtLocation(ts.getNameOfDeclaration(type))));
            if (typeSource === contextSource) {
                const [root, ...tail] = qualifiedName.split('.');
                expression = tail.reduce((curr, elt) => ts.createPropertyAccess(curr, elt), ts.createIdentifier(root));
            }
            else {
                const syntheticImportName = ts.createUniqueName(path_1.basename(typeSource));
                syntheticImport = ts.createImportDeclaration(undefined /* decorators */, undefined /* modifiers */, ts.createImportClause(undefined, ts.createNamespaceImport(syntheticImportName)), ts.createStringLiteral(`./${path_1.relative(path_1.dirname(contextSource), typeSource)}`));
                expression = qualifiedName
                    .split('.')
                    .reduce((curr, elt) => ts.createPropertyAccess(curr, elt), syntheticImportName);
            }
        }
        return {
            typeExpression: ts.createExpressionWithTypeArguments(undefined, expression),
            syntheticImport,
        };
    }
    targets(node) {
        return (this.nodeName ===
            Transformation.fullyQualifiedName(this.typeChecker, node));
    }
}
class DeprecationRemovalTransformer {
    constructor(typeChecker, context, transformations, nodesToRemove) {
        this.typeChecker = typeChecker;
        this.context = context;
        this.transformations = transformations;
        this.nodesToRemove = nodesToRemove;
        this.syntheticImports = new Array();
    }
    transform(node) {
        let result = this.visitEachChild(node);
        // If there are any synthetic imports, add them to the source file
        if (ts.isSourceFile(result) && this.syntheticImports.length > 0) {
            result = ts.updateSourceFileNode(result, [...this.syntheticImports, ...result.statements], result.isDeclarationFile, result.referencedFiles, result.typeReferenceDirectives, result.hasNoDefaultLib, result.libReferenceDirectives);
            this.syntheticImports = new Array();
        }
        return result;
    }
    visitEachChild(node) {
        return ts.visitEachChild(node, this.visitor.bind(this), this.context);
    }
    visitor(node) {
        var _a, _b, _c;
        if (this.isDeprecated(node)) {
            // Removing deprecated members by substituting "nothing" to them
            return undefined;
        }
        if (ts.isClassDeclaration(node) || ts.isInterfaceDeclaration(node)) {
            for (const transformation of this.transformations) {
                // 👇 as any because the assignment below confuses type checker
                if (transformation.targets(node)) {
                    const { node: transformedNode, syntheticImport } = transformation.apply(node);
                    node = transformedNode;
                    if (syntheticImport) {
                        this.syntheticImports.push(syntheticImport);
                    }
                }
            }
        }
        // Remove named imports of `@deprecated` members from the source...
        if (ts.isImportDeclaration(node) &&
            node.importClause &&
            node.importClause.namedBindings &&
            ts.isNamedImports(node.importClause.namedBindings)) {
            const filteredElements = node.importClause.namedBindings.elements.filter((element) => {
                var _a;
                // This symbol is local (it's declaration points back to the named import)
                const symbol = this.typeChecker.getSymbolAtLocation(element.name);
                const exportedSymbol = 
                // This "resolves" the imported type, so we can get to it's declaration(s)
                symbol && ((_a = this.typeChecker.getDeclaredTypeOfSymbol(symbol)) === null || _a === void 0 ? void 0 : _a.symbol);
                return !(exportedSymbol === null || exportedSymbol === void 0 ? void 0 : exportedSymbol.declarations.some((decl) => this.isDeprecated(decl)));
            });
            if (filteredElements.length !==
                node.importClause.namedBindings.elements.length) {
                return ts.updateImportDeclaration(node, node.decorators, node.modifiers, node.importClause.name != null || filteredElements.length > 0
                    ? ts.updateImportClause(node.importClause, node.importClause.name, ts.updateNamedImports(node.importClause.namedBindings, filteredElements), node.importClause.isTypeOnly)
                    : undefined, node.moduleSpecifier);
            }
            return node;
        }
        // Replace "export ... from ..." places that no longer export anything
        // with an "import from ...", so side effects are preserved.
        if (ts.isExportDeclaration(node) && node.moduleSpecifier) {
            const symbol = this.typeChecker.getSymbolAtLocation(node.moduleSpecifier);
            const moduleExports = symbol && ((_a = this.typeChecker
                .getExportsOfModule(symbol)) === null || _a === void 0 ? void 0 : _a.filter((sym) => !sym.declarations.some((decl) => this.isDeprecated(decl))));
            if ((node.exportClause == null ||
                ts.isNamespaceExport(node.exportClause)) &&
                (moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.length) === 0) {
                return ts.createImportDeclaration(undefined /* decorators */, undefined /* modifiers */, undefined /* importClause */, node.moduleSpecifier);
            }
            if (node.exportClause != null && moduleExports) {
                const bindings = node.exportClause;
                const exportedNames = new Set(moduleExports.map((sym) => sym.name));
                const filteredElements = (_b = bindings.elements) === null || _b === void 0 ? void 0 : _b.filter((elt) => exportedNames.has(elt.name.text));
                if ((filteredElements === null || filteredElements === void 0 ? void 0 : filteredElements.length) !== ((_c = bindings.elements) === null || _c === void 0 ? void 0 : _c.length)) {
                    return ts.updateExportDeclaration(node, node.decorators, node.modifiers, ts.updateNamedExports(bindings, filteredElements), node.moduleSpecifier, node.isTypeOnly);
                }
            }
        }
        return DeprecationRemovalTransformer.IGNORE_CHILDREN.has(node.kind)
            ? node
            : this.visitEachChild(node);
    }
    isDeprecated(node) {
        const original = ts.getOriginalNode(node);
        return (this.nodesToRemove.has(original) &&
            ts.getJSDocTags(original).some((tag) => tag.tagName.text === 'deprecated'));
    }
}
/**
 * A list of SyntaxKinds for which it is not necessary to evaluate children,
 * since they are never of interest to this transform. This opens up a wee
 * optimization, which is particularly useful when trying to troubleshoot the
 * transform in a debugger (saves a TON of time stepping into useless nodes
 * then).
 */
DeprecationRemovalTransformer.IGNORE_CHILDREN = new Set([
    ts.SyntaxKind.Constructor,
    ts.SyntaxKind.FunctionDeclaration,
    ts.SyntaxKind.GetAccessor,
    ts.SyntaxKind.MethodDeclaration,
    ts.SyntaxKind.MethodSignature,
    ts.SyntaxKind.PropertySignature,
    ts.SyntaxKind.PropertyDeclaration,
    ts.SyntaxKind.SetAccessor,
    ts.SyntaxKind.VariableDeclaration,
]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwcmVjYXRlZC1yZW1vdmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZGVwcmVjYXRlZC1yZW1vdmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHFDQWtCb0I7QUFDcEIsK0JBQW1EO0FBQ25ELGlDQUFpQztBQUVqQyx3REFBb0Q7QUFDcEQsNkNBQTZDO0FBRTdDLE1BQWEsaUJBQWlCO0lBSTVCLFlBQ21CLFdBQTJCLEVBQzNCLHVCQUFnRDtRQURoRCxnQkFBVyxHQUFYLFdBQVcsQ0FBZ0I7UUFDM0IsNEJBQXVCLEdBQXZCLHVCQUF1QixDQUF5QjtRQUxsRCxvQkFBZSxHQUFHLElBQUksS0FBSyxFQUFrQixDQUFDO1FBQzlDLGtCQUFhLEdBQUcsSUFBSSxHQUFHLEVBQVcsQ0FBQztJQUtqRCxDQUFDO0lBRUo7Ozs7OztPQU1HO0lBQ0gsSUFBVyxrQkFBa0I7UUFDM0IsT0FBTztZQUNMLGlCQUFpQixFQUFFO2dCQUNqQixDQUFDLE9BQU8sRUFBRSxFQUFFO29CQUNWLE1BQU0sV0FBVyxHQUFHLElBQUksNkJBQTZCLENBQ25ELElBQUksQ0FBQyxXQUFXLEVBQ2hCLE9BQU8sRUFDUCxJQUFJLENBQUMsZUFBZSxFQUNwQixJQUFJLENBQUMsYUFBYSxDQUNuQixDQUFDO29CQUNGLE9BQU8sV0FBVyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7Z0JBQ2pELENBQUM7YUFDRjtTQUNGLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0ksVUFBVSxDQUFDLFFBQWtCOztRQUNsQyxJQUFJLFFBQVEsQ0FBQyxLQUFLLElBQUksSUFBSSxFQUFFO1lBQzFCLE9BQU8sRUFBRSxDQUFDO1NBQ1g7UUFFRCxNQUFNLFlBQVksR0FBRyxJQUFJLEdBQUcsRUFBVSxDQUFDO1FBQ3ZDLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxHQUFHLEVBQWtCLENBQUM7UUFDbkQsTUFBTSxxQkFBcUIsR0FBRyxJQUFJLEdB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QWE7UUFDaEMsTUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMxQyxPQUFPLENBQ0wsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDO1lBQ2hDLEVBQUUsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksS0FBSyxZQUFZLENBQUMsQ0FDM0UsQ0FBQztJQUNKLENBQUM7O0FBN0tEOzs7Ozs7R0FNRztBQUNxQiw2Q0FBZSxHQUErQixJQUFJLEdBQUcsQ0FDM0U7SUFDRSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVc7SUFDekIsRUFBRSxDQUFDLFVBQVUsQ0FBQyxtQkFBbUI7SUFDakMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXO0lBQ3pCLEVBQUUsQ0FBQyxVQUFVLENBQUMsaUJBQWlCO0lBQy9CLEVBQUUsQ0FBQyxVQUFVLENBQUMsZUFBZTtJQUM3QixFQUFFLENBQUMsVUFBVSxDQUFDLGlCQUFpQjtJQUMvQixFQUFFLENBQUMsVUFBVSxDQUFDLG1CQUFtQjtJQUNqQyxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVc7SUFDekIsRUFBRSxDQUFDLFVBQVUsQ0FBQyxtQkFBbUI7Q0FDbEMsQ0FDRixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQXNzZW1ibHksXG4gIENsYXNzVHlwZSxcbiAgRW51bU1lbWJlcixcbiAgSW5pdGlhbGl6ZXIsXG4gIEludGVyZmFjZVR5cGUsXG4gIGlzQ2xhc3NPckludGVyZmFjZVR5cGUsXG4gIGlzQ2xhc3NUeXBlLFxuICBpc0NvbGxlY3Rpb25UeXBlUmVmZXJlbmNlLFxuICBpc0VudW1UeXBlLFxuICBpc01ldGhvZCxcbiAgaXNOYW1lZFR5cGVSZWZlcmVuY2UsXG4gIGlzUHJpbWl0aXZlVHlwZVJlZmVyZW5jZSxcbiAgTWV0aG9kLFxuICBQYXJhbWV0ZXIsXG4gIFByb3BlcnR5LFxuICBTdGFiaWxpdHksXG4gIFR5cGVSZWZlcmVuY2UsXG59IGZyb20gJ0Bqc2lpL3NwZWMnO1xuaW1wb3J0IHsgYmFzZW5hbWUsIGRpcm5hbWUsIHJlbGF0aXZlIH0gZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcblxuaW1wb3J0IHsgSnNpaURpYWdub3N0aWMgfSBmcm9tICcuLi9qc2lpLWRpYWdub3N0aWMnO1xuaW1wb3J0ICogYXMgYmluZGluZ3MgZnJvbSAnLi4vbm9kZS1iaW5kaW5ncyc7XG5cbmV4cG9ydCBjbGFzcyBEZXByZWNhdGVkUmVtb3ZlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgdHJhbnNmb3JtYXRpb25zID0gbmV3IEFycmF5PFRyYW5zZm9ybWF0aW9uPigpO1xuICBwcml2YXRlIHJlYWRvbmx5IG5vZGVzVG9SZW1vdmUgPSBuZXcgU2V0PHRzLk5vZGU+KCk7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYWxsb3dsaXN0ZWREZXByZWNhdGlvbnM6IFNldDxzdHJpbmc+IHwgdW5kZWZpbmVkLFxuICApIHt9XG5cbiAgLyoqXG4gICAqIE9idGFpbnMgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBUeXBlU2NyaXB0IHRyYW5zZm9ybShzKSB0aGF0IHdpbGwgcmVtb3ZlXG4gICAqIGBAZGVwcmVjYXRlZGAgbWVtYmVycyBmcm9tIHRoZSBnZW5lcmF0ZWQgZGVjbGFyYXRpb25zIChgLmQudHNgKSBmaWxlcy4gSXRcbiAgICogd2lsbCBsZXZlcmFnZSBpbmZvcm1hdGlvbiBhY2N1bXVsYXRlZCBkdXJpbmcgYCNyZW1vdmVGcm9tKEFzc2VtYmx5KWAgaW5cbiAgICogb3JkZXIgdG8gYXBwbHkgY29ycmVjdGlvbnMgdG8gaW5oZXJpdGFuY2UgY2hhaW5zLCBlbnN1cmluZyBhIHZhbGlkIG91dHB1dFxuICAgKiBpcyBwcm9kdWNlZC5cbiAgICovXG4gIHB1YmxpYyBnZXQgY3VzdG9tVHJhbnNmb3JtZXJzKCk6IHRzLkN1c3RvbVRyYW5zZm9ybWVycyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFmdGVyRGVjbGFyYXRpb25zOiBbXG4gICAgICAgIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgY29uc3QgdHJhbnNmb3JtZXIgPSBuZXcgRGVwcmVjYXRpb25SZW1vdmFsVHJhbnNmb3JtZXIoXG4gICAgICAgICAgICB0aGlzLnR5cGVDaGVja2VyLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtYXRpb25zLFxuICAgICAgICAgICAgdGhpcy5ub2Rlc1RvUmVtb3ZlLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybS5iaW5kKHRyYW5zZm9ybWVyKTtcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBgQGRlcHJlY2F0ZWRgIEFQSSBlbGVtZW50cyBmcm9tIHRoZSBwcm92aWRlZCBhc3NlbWJseSwgYW5kXG4gICAqIHJlY29yZHMgdGhlIG9wZXJhdGlvbnMgbmVlZGVkIGluIG9yZGVyIHRvIGZpeCB0aGUgaW5oZXJpdGFuY2UgY2hhaW5zIHRoYXRcbiAgICogbWl4IGBAZGVwcmVjYXRlZGAgYW5kIG5vbi1gQGRlcHJlY2F0ZWRgIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0gYXNzZW1ibHkgdGhlIGFzc2VtYmx5IHRvIGJlIG1vZGlmaWVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBkaWFnbm9zdGljIG1lc3NhZ2VzIHByb2R1Y2VkIHdoZW4gdmFsaWRhdGluZyBubyByZW1haW5pbmcgQVBJXG4gICAqICAgICAgICAgIG1ha2VzIHVzZSBvZiBhIGBAZGVwcmVjYXRlZGAgdHlwZSB0aGF0IHdhcyByZW1vdmVkLlxuICAgKi9cbiAgcHVibGljIHJlbW92ZUZyb20oYXNzZW1ibHk6IEFzc2VtYmx5KTogcmVhZG9ubHkgSnNpaURpYWdub3N0aWNbXSB7XG4gICAgaWYgKGFzc2VtYmx5LnR5cGVzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBzdHJpcHBlZEZxbnMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBjb25zdCByZXBsYWNlV2l0aENsYXNzID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcbiAgICBjb25zdCByZXBsYWNlV2l0aEludGVyZmFjZXMgPSBuZXcgTWFwPHN0cmluZywgcmVhZG9ubHkgc3RyaW5nW10+KCk7XG5cbiAgICAvLyBGaW5kIGFsbCB0eXBlcyB0aGF0IHdpbGwgYmUgc3RyaXBwZWQgb3V0XG4gICAgZm9yIChjb25zdCBbZnFuLCB0eXBlSW5mb10gb2YgT2JqZWN0LmVudHJpZXMoYXNzZW1ibHkudHlwZXMpKSB7XG4gICAgICBpZiAodHlwZUluZm8uZG9jcz8uc3RhYmlsaXR5ID09PSBTdGFiaWxpdHkuRGVwcmVjYXRlZCkge1xuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkRnFuQmVTdHJpcHBlZChmcW4pKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaXBwZWRGcW5zLmFkZChmcW4pO1xuXG4gICAgICAgIGlmIChpc0NsYXNzVHlwZSh0eXBlSW5mbykgJiYgdHlwZUluZm8uYmFzZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmVwbGFjZVdpdGhDbGFzcy5zZXQoZnFuLCB0eXBlSW5mby5iYXNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDbGFzc09ySW50ZXJmYWNlVHlwZSh0eXBlSW5mbykgJiYgdHlwZUluZm8uaW50ZXJmYWNlcyAhPSBudWxsKSB7XG4gICAgICAgICAgcmVwbGFjZVdpdGhJbnRlcmZhY2VzLnNldChmcW4sIHR5cGVJbmZvLmludGVyZmFjZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ub2Rlc1RvUmVtb3ZlLmFkZChiaW5kaW5ncy5nZXRSZWxhdGVkTm9kZSh0eXBlSW5mbykhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IFtmcW4sIHR5cGVJbmZvXSBvZiBPYmplY3QuZW50cmllcyhhc3NlbWJseS50eXBlcykpIHtcbiAgICAgIC8vIElnbm9yZSBgQGRlcHJlY2F0ZWRgIHR5cGVzXG4gICAgICBpZiAoc3RyaXBwZWRGcW5zLmhhcyhmcW4pKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBFbnVtcyBjYW5ub3QgaGF2ZSByZWZlcmVuY2VzIHRvIGBAZGVwcmVjYXRlZGAgdHlwZXMsIGJ1dCBjYW4gaGF2ZSBkZXByZWNhdGVkIG1lbWJlcnNcbiAgICAgIGlmIChpc0VudW1UeXBlKHR5cGVJbmZvKSkge1xuICAgICAgICBjb25zdCBlbnVtTm9kZSA9IGJpbmRpbmdzLmdldEVudW1SZWxhdGVkTm9kZSh0eXBlSW5mbykhO1xuICAgICAgICBjb25zdCBtZW1iZXJzOiBFbnVtTWVtYmVyW10gPSBbXTtcbiAgICAgICAgdHlwZUluZm8ubWVtYmVycy5mb3JFYWNoKChtZW0pID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBtZW0uZG9jcz8uc3RhYmlsaXR5ID09PSBTdGFiaWxpdHkuRGVwcmVjYXRlZCAmJlxuICAgICAgICAgICAgdGhpcy5zaG91bGRGcW5CZVN0cmlwcGVkKGAke2Zxbn0jJHttZW0ubmFtZX1gKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmdNZW1iZXJOb2RlID0gZW51bU5vZGUubWVtYmVycy5maW5kKFxuICAgICAgICAgICAgICAoZW51bU1lbSkgPT4gZW51bU1lbS5uYW1lLmdldFRleHQoKSA9PT0gbWVtLm5hbWUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nTWVtYmVyTm9kZSkge1xuICAgICAgICAgICAgICB0aGlzLm5vZGVzVG9SZW1vdmUuYWRkKG1hdGNoaW5nTWVtYmVyTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lbWJlcnMucHVzaChtZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHR5cGVJbmZvLm1lbWJlcnMgPSBtZW1iZXJzO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gRm9yIGNsYXNzZXMsIHdlIGVyYXNlIGBAZGVwcmVjYXRlZGAgYmFzZSBjbGFzc2VzLCByZXBsYWNpbmcgYXMgbmVlZGVkXG4gICAgICBjb25zdCBhZGRpdGlvbmFsSW50ZXJmYWNlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgaWYgKFxuICAgICAgICBpc0NsYXNzVHlwZSh0eXBlSW5mbykgJiZcbiAgICAgICAgdHlwZUluZm8uYmFzZSAhPSBudWxsICYmXG4gICAgICAgIHN0cmlwcGVkRnFucy5oYXModHlwZUluZm8uYmFzZSlcbiAgICAgICkge1xuICAgICAgICB3aGlsZSAodHlwZUluZm8uYmFzZSAhPSBudWxsICYmIHN0cmlwcGVkRnFucy5oYXModHlwZUluZm8uYmFzZSkpIHtcbiAgICAgICAgICBjb25zdCBvbGRCYXNlID0gYXNzZW1ibHkudHlwZXNbdHlwZUluZm8uYmFzZV0gYXMgQ2xhc3NUeXBlO1xuICAgICAgICAgIG9sZEJhc2UuaW50ZXJmYWNlcz8uZm9yRWFjaCgoZnFuKSA9PiBhZGRpdGlvbmFsSW50ZXJmYWNlcy5hZGQoZnFuKSk7XG4gICAgICAgICAgdHlwZUluZm8uYmFzZSA9IHJlcGxhY2VXaXRoQ2xhc3MuZ2V0KHR5cGVJbmZvLmJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNmb3JtYXRpb25zLnB1c2goXG4gICAgICAgICAgdHlwZUluZm8uYmFzZSAhPSBudWxsXG4gICAgICAgICAgICA/IFRyYW5zZm9ybWF0aW9uLnJlcGxhY2VCYXNlQ2xhc3MoXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlQ2hlY2tlcixcbiAgICAgICAgICAgICAgICBiaW5kaW5ncy5nZXRDbGFzc1JlbGF0ZWROb2RlKHR5cGVJbmZvKSEsXG4gICAgICAgICAgICAgICAgdHlwZUluZm8uYmFzZSBpbiBhc3NlbWJseS50eXBlc1xuICAgICAgICAgICAgICAgICAgPyBiaW5kaW5ncy5nZXRDbGFzc1JlbGF0ZWROb2RlKFxuICAgICAgICAgICAgICAgICAgICAgIGFzc2VtYmx5LnR5cGVzW3R5cGVJbmZvLmJhc2VdIGFzIENsYXNzVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgKSA/PyB0eXBlSW5mby5iYXNlXG4gICAgICAgICAgICAgICAgICA6IHR5cGVJbmZvLmJhc2UsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogVHJhbnNmb3JtYXRpb24ucmVtb3ZlQmFzZUNsYXNzKFxuICAgICAgICAgICAgICAgIHRoaXMudHlwZUNoZWNrZXIsXG4gICAgICAgICAgICAgICAgYmluZGluZ3MuZ2V0Q2xhc3NSZWxhdGVkTm9kZSh0eXBlSW5mbykhLFxuICAgICAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBCZSBkZWZlbnNpdmUgaW4gY2FzZSB3ZSBhZGQgb3RoZXIga2luZHMgaW4gdGhlIGZ1dHVyZVxuICAgICAgaWYgKCFpc0NsYXNzT3JJbnRlcmZhY2VUeXBlKHR5cGVJbmZvKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFVuaGFuZGxlZCB0eXBlIGVuY291bnRlcmVkISAke0pTT04uc3RyaW5naWZ5KHR5cGVJbmZvLCBudWxsLCAyKX1gLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBTdHJpcCBhbGwgYEBkZXByZWNhdGVkYCBpbnRlcmZhY2VzIGZyb20gdGhlIGluaGVyaXRhbmNlIHRyZWUsIHJlcGxhY2luZyBhcyBuZWVkZWRcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZUluZm8uaW50ZXJmYWNlcz8uc29tZSgoZnFuKSA9PiBzdHJpcHBlZEZxbnMuaGFzKGZxbikpIHx8XG4gICAgICAgIGFkZGl0aW9uYWxJbnRlcmZhY2VzLnNpemUgPiAwXG4gICAgICApIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTZXQgPSBuZXcgU2V0KHR5cGVJbmZvLmludGVyZmFjZXMgPz8gW10pO1xuICAgICAgICBjb25zdCBuZXdTZXQgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgICAgICBjb25zdCBjYW5kaWRhdGVzID0gQXJyYXkuZnJvbShcbiAgICAgICAgICBuZXcgU2V0KFsuLi5vcmlnaW5hbFNldCwgLi4uYWRkaXRpb25hbEludGVyZmFjZXNdKSxcbiAgICAgICAgKTtcbiAgICAgICAgd2hpbGUgKGNhbmRpZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGZxbiA9IGNhbmRpZGF0ZXMucG9wKCkhO1xuICAgICAgICAgIGlmICghc3RyaXBwZWRGcW5zLmhhcyhmcW4pKSB7XG4gICAgICAgICAgICBuZXdTZXQuYWRkKGZxbik7XG4gICAgICAgICAgICBpZiAoIW9yaWdpbmFsU2V0LmhhcyhmcW4pKSB7XG4gICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtYXRpb25zLnB1c2goXG4gICAgICAgICAgICAgICAgVHJhbnNmb3JtYXRpb24uYWRkSW50ZXJmYWNlKFxuICAgICAgICAgICAgICAgICAgdGhpcy50eXBlQ2hlY2tlcixcbiAgICAgICAgICAgICAgICAgIGJpbmRpbmdzLmdldENsYXNzT3JJbnRlcmZhY2VSZWxhdGVkTm9kZSh0eXBlSW5mbykhLFxuICAgICAgICAgICAgICAgICAgZnFuIGluIGFzc2VtYmx5LnR5cGVzXG4gICAgICAgICAgICAgICAgICAgID8gYmluZGluZ3MuZ2V0SW50ZXJmYWNlUmVsYXRlZE5vZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlbWJseS50eXBlc1tmcW5dIGFzIEludGVyZmFjZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgKSA/PyBmcW5cbiAgICAgICAgICAgICAgICAgICAgOiBmcW4sXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3JpZ2luYWxTZXQuaGFzKGZxbikpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtYXRpb25zLnB1c2goXG4gICAgICAgICAgICAgIFRyYW5zZm9ybWF0aW9uLnJlbW92ZUludGVyZmFjZShcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGVDaGVja2VyLFxuICAgICAgICAgICAgICAgIGJpbmRpbmdzLmdldENsYXNzT3JJbnRlcmZhY2VSZWxhdGVkTm9kZSh0eXBlSW5mbykhLFxuICAgICAgICAgICAgICAgIGJpbmRpbmdzLmdldEludGVyZmFjZVJlbGF0ZWROb2RlKFxuICAgICAgICAgICAgICAgICAgYXNzZW1ibHkudHlwZXNbZnFuXSBhcyBJbnRlcmZhY2VUeXBlLFxuICAgICAgICAgICAgICAgICkhLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSByZXBsYWNlV2l0aEludGVyZmFjZXMuZ2V0KGZxbik7XG4gICAgICAgICAgaWYgKHJlcGxhY2VtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCguLi5yZXBsYWNlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdHlwZUluZm8uaW50ZXJmYWNlcyA9XG4gICAgICAgICAgbmV3U2V0LnNpemUgPiAwID8gQXJyYXkuZnJvbShuZXdTZXQpLnNvcnQoKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gRHJvcCBhbGwgYEBkZXByZWNhdGVkYCBtZW1iZXJzLCBhbmQgcmVtb3ZlIFwib3ZlcnJpZGVzXCIgZnJvbSBzdHJpcHBlZCB0eXBlc1xuICAgICAgY29uc3QgbWV0aG9kczogTWV0aG9kW10gPSBbXTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXM6IFByb3BlcnR5W10gPSBbXTtcbiAgICAgIHR5cGVJbmZvLm1ldGhvZHM/LmZvckVhY2goKG1ldGgpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG1ldGguZG9jcz8uc3RhYmlsaXR5ID09PSBTdGFiaWxpdHkuRGVwcmVjYXRlZCAmJlxuICAgICAgICAgIHRoaXMuc2hvdWxkRnFuQmVTdHJpcHBlZChgJHtmcW59IyR7bWV0aC5uYW1lfWApXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMubm9kZXNUb1JlbW92ZS5hZGQoYmluZGluZ3MuZ2V0TWV0aG9kUmVsYXRlZE5vZGUobWV0aCkhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXRob2RzLnB1c2goXG4gICAgICAgICAgICBtZXRoLm92ZXJyaWRlcyAhPSBudWxsICYmIHN0cmlwcGVkRnFucy5oYXMobWV0aC5vdmVycmlkZXMpXG4gICAgICAgICAgICAgID8geyAuLi5tZXRoLCBvdmVycmlkZXM6IHVuZGVmaW5lZCB9XG4gICAgICAgICAgICAgIDogbWV0aCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHR5cGVJbmZvLm1ldGhvZHMgPSB0eXBlSW5mby5tZXRob2RzID8gbWV0aG9kcyA6IHVuZGVmaW5lZDtcbiAgICAgIHR5cGVJbmZvLnByb3BlcnRpZXM/LmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb3AuZG9jcz8uc3RhYmlsaXR5ID09PSBTdGFiaWxpdHkuRGVwcmVjYXRlZCAmJlxuICAgICAgICAgIHRoaXMuc2hvdWxkRnFuQmVTdHJpcHBlZChgJHtmcW59IyR7cHJvcC5uYW1lfWApXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMubm9kZXNUb1JlbW92ZS5hZGQoYmluZGluZ3MuZ2V0UGFyYW1ldGVyUmVsYXRlZE5vZGUocHJvcCkhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goXG4gICAgICAgICAgICBwcm9wLm92ZXJyaWRlcyAhPSBudWxsICYmIHN0cmlwcGVkRnFucy5oYXMocHJvcC5vdmVycmlkZXMpXG4gICAgICAgICAgICAgID8geyAuLi5wcm9wLCBvdmVycmlkZXM6IHVuZGVmaW5lZCB9XG4gICAgICAgICAgICAgIDogcHJvcCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHR5cGVJbmZvLnByb3BlcnRpZXMgPSB0eXBlSW5mby5wcm9wZXJ0aWVzID8gcHJvcGVydGllcyA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBkaWFnbm9zdGljcyA9IHRoaXMuZmluZExlZnRvdmVyVXNlT2ZEZXByZWNhdGVkQVBJcyhcbiAgICAgIGFzc2VtYmx5LFxuICAgICAgc3RyaXBwZWRGcW5zLFxuICAgICk7XG5cbiAgICAvLyBSZW1vdmUgYWxsIGBAZGVwcmVjYXRlZGAgdHlwZXMsIGFmdGVyIHdlIGRpZCBldmVyeXRoaW5nLCBzbyB3ZSBjb3VsZFxuICAgIC8vIHN0aWxsIGFjY2VzcyB0aGUgcmVsYXRlZCBub2RlcyBmcm9tIHRoZSBhc3NlbWJseSBvYmplY3QuXG4gICAgZm9yIChjb25zdCBmcW4gb2Ygc3RyaXBwZWRGcW5zKSB7XG4gICAgICBpZiAodGhpcy5zaG91bGRGcW5CZVN0cmlwcGVkKGZxbikpIHtcbiAgICAgICAgZGVsZXRlIGFzc2VtYmx5LnR5cGVzW2Zxbl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpYWdub3N0aWNzO1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5kTGVmdG92ZXJVc2VPZkRlcHJlY2F0ZWRBUElzKFxuICAgIGFzc2VtYmx5OiBBc3NlbWJseSxcbiAgICBzdHJpcHBlZEZxbnM6IFNldDxzdHJpbmc+LFxuICApOiByZWFkb25seSBKc2lpRGlhZ25vc3RpY1tdIHtcbiAgICBpZiAoYXNzZW1ibHkudHlwZXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheTxKc2lpRGlhZ25vc3RpYz4oKTtcblxuICAgIGZvciAoY29uc3QgdHlwZSBvZiBPYmplY3QudmFsdWVzKGFzc2VtYmx5LnR5cGVzKSkge1xuICAgICAgaWYgKGlzRW51bVR5cGUodHlwZSkgfHwgc3RyaXBwZWRGcW5zLmhhcyh0eXBlLmZxbikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNDbGFzc1R5cGUodHlwZSkgJiYgdHlwZS5pbml0aWFsaXplcikge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAuLi50aGlzLnZlcmlmeUNhbGxhYmxlKGFzc2VtYmx5LCBzdHJpcHBlZEZxbnMsIHR5cGUuaW5pdGlhbGl6ZXIpLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdHlwZS5tZXRob2RzPy5mb3JFYWNoKChtZXRob2QpID0+XG4gICAgICAgIHJlc3VsdC5wdXNoKC4uLnRoaXMudmVyaWZ5Q2FsbGFibGUoYXNzZW1ibHksIHN0cmlwcGVkRnFucywgbWV0aG9kKSksXG4gICAgICApO1xuICAgICAgdHlwZS5wcm9wZXJ0aWVzPy5mb3JFYWNoKChwcm9wZXJ0eSkgPT5cbiAgICAgICAgcmVzdWx0LnB1c2goLi4udGhpcy52ZXJpZnlQcm9wZXJ0eShhc3NlbWJseSwgc3RyaXBwZWRGcW5zLCBwcm9wZXJ0eSkpLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJpdmF0ZSB2ZXJpZnlDYWxsYWJsZShcbiAgICBhc3NlbWJseTogQXNzZW1ibHksXG4gICAgc3RyaXBwZWRGcW5zOiBSZWFkb25seVNldDxzdHJpbmc+LFxuICAgIG1ldGhvZDogTWV0aG9kIHwgSW5pdGlhbGl6ZXIsXG4gICk6IHJlYWRvbmx5IEpzaWlEaWFnbm9zdGljW10ge1xuICAgIGNvbnN0IGRpYWdub3N0aWNzID0gbmV3IEFycmF5PEpzaWlEaWFnbm9zdGljPigpO1xuICAgIGNvbnN0IGRlcHJlY2F0ZWRSZXR1cm5GcW4gPVxuICAgICAgaXNNZXRob2QobWV0aG9kKSAmJlxuICAgICAgbWV0aG9kLnJldHVybnMgJiZcbiAgICAgIHRoaXMudHJ5RmluZFJlZmVyZW5jZShtZXRob2QucmV0dXJucy50eXBlLCBzdHJpcHBlZEZxbnMpO1xuICAgIGlmIChkZXByZWNhdGVkUmV0dXJuRnFuKSB7XG4gICAgICBkaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICB0aGlzLm1ha2VEaWFnbm9zdGljKGRlcHJlY2F0ZWRSZXR1cm5GcW4sICdNZXRob2QnLCBtZXRob2QsIGFzc2VtYmx5KSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZC5wYXJhbWV0ZXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IHBhcmFtZXRlciBvZiBtZXRob2QucGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCBkZXByZWNhdGVkVHlwZUZxbiA9IHRoaXMudHJ5RmluZFJlZmVyZW5jZShcbiAgICAgICAgICBwYXJhbWV0ZXIudHlwZSxcbiAgICAgICAgICBzdHJpcHBlZEZxbnMsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChkZXByZWNhdGVkVHlwZUZxbikge1xuICAgICAgICAgIGRpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgICB0aGlzLm1ha2VEaWFnbm9zdGljKFxuICAgICAgICAgICAgICBkZXByZWNhdGVkVHlwZUZxbixcbiAgICAgICAgICAgICAgJ1BhcmFtZXRlcicsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcixcbiAgICAgICAgICAgICAgYXNzZW1ibHksXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpYWdub3N0aWNzO1xuICB9XG5cbiAgcHJpdmF0ZSB2ZXJpZnlQcm9wZXJ0eShcbiAgICBhc3NlbWJseTogQXNzZW1ibHksXG4gICAgc3RyaXBwZWRGcW5zOiBSZWFkb25seVNldDxzdHJpbmc+LFxuICAgIHByb3BlcnR5OiBQcm9wZXJ0eSxcbiAgKTogcmVhZG9ubHkgSnNpaURpYWdub3N0aWNbXSB7XG4gICAgY29uc3QgZGVwcmVjYXRlZFR5cGVGcW4gPSB0aGlzLnRyeUZpbmRSZWZlcmVuY2UoXG4gICAgICBwcm9wZXJ0eS50eXBlLFxuICAgICAgc3RyaXBwZWRGcW5zLFxuICAgICk7XG4gICAgaWYgKGRlcHJlY2F0ZWRUeXBlRnFuKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB0aGlzLm1ha2VEaWFnbm9zdGljKGRlcHJlY2F0ZWRUeXBlRnFuLCAnUHJvcGVydHknLCBwcm9wZXJ0eSwgYXNzZW1ibHkpLFxuICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBhIGBUeXBlUmVmZXJlbmNlYCBjb250YWlucyBhbiBGUU4gd2l0aGluIGEgZ2l2ZW4gc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gcmVmICB0aGUgdGVzdGVkIGBUeXBlUmVmZXJlbmNlYC5cbiAgICogQHBhcmFtIGZxbnMgdGhlIHNldCBvZiBGUU5zIHRoYXQgYXJlIGJlaW5nIHNlYXJjaGVkIGZvci5cbiAgICpcbiAgICogQHJldHVybnMgdGhlIGZpcnN0IEZRTiB0aGF0IHdhcyBpZGVudGlmaWVkLlxuICAgKi9cbiAgcHJpdmF0ZSB0cnlGaW5kUmVmZXJlbmNlKFxuICAgIHJlZjogVHlwZVJlZmVyZW5jZSxcbiAgICBmcW5zOiBSZWFkb25seVNldDxzdHJpbmc+LFxuICApOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGlmIChpc05hbWVkVHlwZVJlZmVyZW5jZShyZWYpKSB7XG4gICAgICByZXR1cm4gZnFucy5oYXMocmVmLmZxbikgPyByZWYuZnFuIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoaXNQcmltaXRpdmVUeXBlUmVmZXJlbmNlKHJlZikpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpc0NvbGxlY3Rpb25UeXBlUmVmZXJlbmNlKHJlZikpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyeUZpbmRSZWZlcmVuY2UocmVmLmNvbGxlY3Rpb24uZWxlbWVudHR5cGUsIGZxbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVmLnVuaW9uLnR5cGVzXG4gICAgICAubWFwKCh0eXBlKSA9PiB0aGlzLnRyeUZpbmRSZWZlcmVuY2UodHlwZSwgZnFucykpXG4gICAgICAuZmluZCgocmVmKSA9PiByZWYgIT0gbnVsbCk7XG4gIH1cblxuICBwcml2YXRlIHNob3VsZEZxbkJlU3RyaXBwZWQoZnFuOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxvd2xpc3RlZERlcHJlY2F0aW9ucz8uaGFzKGZxbikgPz8gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgbWFrZURpYWdub3N0aWMoXG4gICAgZnFuOiBzdHJpbmcsXG4gICAgbWVzc2FnZVByZWZpeDogJ01ldGhvZCcsXG4gICAgY29udGV4dDogTWV0aG9kIHwgSW5pdGlhbGl6ZXIsXG4gICAgYXNzZW1ibHk6IEFzc2VtYmx5LFxuICApOiBKc2lpRGlhZ25vc3RpYztcbiAgcHJpdmF0ZSBtYWtlRGlhZ25vc3RpYyhcbiAgICBmcW46IHN0cmluZyxcbiAgICBtZXNzYWdlUHJlZml4OiAnUGFyYW1ldGVyJyxcbiAgICBjb250ZXh0OiBQYXJhbWV0ZXIsXG4gICAgYXNzZW1ibHk6IEFzc2VtYmx5LFxuICApOiBKc2lpRGlhZ25vc3RpYztcbiAgcHJpdmF0ZSBtYWtlRGlhZ25vc3RpYyhcbiAgICBmcW46IHN0cmluZyxcbiAgICBtZXNzYWdlUHJlZml4OiAnUHJvcGVydHknLFxuICAgIGNvbnRleHQ6IFByb3BlcnR5LFxuICAgIGFzc2VtYmx5OiBBc3NlbWJseSxcbiAgKTogSnNpaURpYWdub3N0aWM7XG4gIHByaXZhdGUgbWFrZURpYWdub3N0aWMoXG4gICAgZnFuOiBzdHJpbmcsXG4gICAgbWVzc2FnZVByZWZpeDogJ01ldGhvZCcgfCAnUHJvcGVydHknIHwgJ1BhcmFtZXRlcicsXG4gICAgY29udGV4dDogTWV0aG9kIHwgSW5pdGlhbGl6ZXIgfCBQYXJhbWV0ZXIgfCBQcm9wZXJ0eSxcbiAgICBhc3NlbWJseTogQXNzZW1ibHksXG4gICk6IEpzaWlEaWFnbm9zdGljIHtcbiAgICBjb25zdCBub2RlID0gYmluZGluZ3MuZ2V0UmVsYXRlZE5vZGU8XG4gICAgICB8IHRzLkFjY2Vzc29yRGVjbGFyYXRpb25cbiAgICAgIHwgdHMuTWV0aG9kRGVjbGFyYXRpb25cbiAgICAgIHwgdHMuTWV0aG9kU2lnbmF0dXJlXG4gICAgICB8IHRzLlBhcmFtZXRlckRlY2xhcmF0aW9uXG4gICAgICB8IHRzLlByb3BlcnR5RGVjbGFyYXRpb25cbiAgICAgIHwgdHMuUHJvcGVydHlTaWduYXR1cmVcbiAgICA+KGNvbnRleHQpO1xuICAgIGNvbnN0IGRpYWdub3N0aWMgPSBKc2lpRGlhZ25vc3RpYy5KU0lJXzM5OTlfSU5DT0hFUkVOVF9UWVBFX01PREVMLmNyZWF0ZShcbiAgICAgIG5vZGU/LnR5cGUgPz8gbm9kZSEsXG4gICAgICBgJHttZXNzYWdlUHJlZml4fSBoYXMgQGRlcHJlY2F0ZWQgdHlwZSAke2Zxbn0sIGFuZCBpdCBpcyBlcmFzZWQgYnkgLS1zdHJpcC1kZXByZWNhdGVkLmAsXG4gICAgKTtcblxuICAgIGNvbnN0IHR5cGVJbmZvID0gYXNzZW1ibHkudHlwZXM/LltmcW5dO1xuICAgIGNvbnN0IHR5cGVOb2RlID0gdHlwZUluZm8gJiYgYmluZGluZ3MuZ2V0VHlwZVJlbGF0ZWROb2RlKHR5cGVJbmZvKTtcbiAgICBpZiAodHlwZU5vZGUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGRpYWdub3N0aWM7XG4gICAgfVxuICAgIHJldHVybiBkaWFnbm9zdGljLmFkZFJlbGF0ZWRJbmZvcm1hdGlvbihcbiAgICAgIHRzLmdldE5hbWVPZkRlY2xhcmF0aW9uKHR5cGVOb2RlKSA/PyB0eXBlTm9kZSxcbiAgICAgIGBUaGUgQGRlcHJlY2F0ZWQgdHlwZSBpcyBkZWNsYXJlZCBoZXJlYCxcbiAgICApO1xuICB9XG59XG5cbmNsYXNzIFRyYW5zZm9ybWF0aW9uIHtcbiAgcHVibGljIHN0YXRpYyBhZGRJbnRlcmZhY2UoXG4gICAgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLFxuICAgIG5vZGU6IHRzLkNsYXNzRGVjbGFyYXRpb24gfCB0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbixcbiAgICBpZmFjZTogdHMuSW50ZXJmYWNlRGVjbGFyYXRpb24gfCBzdHJpbmcsXG4gICkge1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtYXRpb24odHlwZUNoZWNrZXIsIG5vZGUsIChkZWNsYXJhdGlvbikgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAhdHMuaXNDbGFzc0RlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSAmJlxuICAgICAgICAhdHMuaXNJbnRlcmZhY2VEZWNsYXJhdGlvbihkZWNsYXJhdGlvbilcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEV4cGVjdGVkIGEgQ2xhc3NEZWNsYXJhdGlvbiBvciBJbnRlcmZhY2VEZWNsYXJhdGlvbiwgZm91bmQgYSAke1xuICAgICAgICAgICAgdHMuU3ludGF4S2luZFtkZWNsYXJhdGlvbi5raW5kXVxuICAgICAgICAgIH1gLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHR5cGVFeHByZXNzaW9uOiBuZXdJbnRlcmZhY2UsIHN5bnRoZXRpY0ltcG9ydCB9ID1cbiAgICAgICAgVHJhbnNmb3JtYXRpb24udHlwZVJlZmVyZW5jZShpZmFjZSwgZGVjbGFyYXRpb24sIHR5cGVDaGVja2VyKTtcbiAgICAgIGlmICh0cy5pc0NsYXNzRGVjbGFyYXRpb24oZGVjbGFyYXRpb24pKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogdHMudXBkYXRlQ2xhc3NEZWNsYXJhdGlvbihcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uLFxuICAgICAgICAgICAgZGVjbGFyYXRpb24uZGVjb3JhdG9ycyxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uLm1vZGlmaWVycyxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uLm5hbWUsXG4gICAgICAgICAgICBkZWNsYXJhdGlvbi50eXBlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGFkZEludGVyZmFjZVRvKFxuICAgICAgICAgICAgICB0cy5TeW50YXhLaW5kLkltcGxlbWVudHNLZXl3b3JkLFxuICAgICAgICAgICAgICBkZWNsYXJhdGlvbi5oZXJpdGFnZUNsYXVzZXMsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZGVjbGFyYXRpb24ubWVtYmVycyxcbiAgICAgICAgICApLFxuICAgICAgICAgIHN5bnRoZXRpY0ltcG9ydCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGU6IHRzLnVwZGF0ZUludGVyZmFjZURlY2xhcmF0aW9uKFxuICAgICAgICAgIGRlY2xhcmF0aW9uLFxuICAgICAgICAgIGRlY2xhcmF0aW9uLmRlY29yYXRvcnMsXG4gICAgICAgICAgZGVjbGFyYXRpb24ubW9kaWZpZXJzLFxuICAgICAgICAgIGRlY2xhcmF0aW9uLm5hbWUsXG4gICAgICAgICAgZGVjbGFyYXRpb24udHlwZVBhcmFtZXRlcnMsXG4gICAgICAgICAgYWRkSW50ZXJmYWNlVG8oXG4gICAgICAgICAgICB0cy5TeW50YXhLaW5kLkV4dGVuZHNLZXl3b3JkLFxuICAgICAgICAgICAgZGVjbGFyYXRpb24uaGVyaXRhZ2VDbGF1c2VzLFxuICAgICAgICAgICksXG4gICAgICAgICAgZGVjbGFyYXRpb24ubWVtYmVycyxcbiAgICAgICAgKSxcbiAgICAgICAgc3ludGhldGljSW1wb3J0LFxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gYWRkSW50ZXJmYWNlVG8oXG4gICAgICAgIHRva2VuOiB0cy5IZXJpdGFnZUNsYXVzZVsndG9rZW4nXSxcbiAgICAgICAgY2xhdXNlczogcmVhZG9ubHkgdHMuSGVyaXRhZ2VDbGF1c2VbXSA9IFtdLFxuICAgICAgKTogdHMuSGVyaXRhZ2VDbGF1c2VbXSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2xhdXNlID0gY2xhdXNlcy5maW5kKChjbGF1c2UpID0+IGNsYXVzZS50b2tlbiA9PT0gdG9rZW4pO1xuICAgICAgICBpZiAoZXhpc3RpbmdDbGF1c2UgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBbLi4uY2xhdXNlcywgdHMuY3JlYXRlSGVyaXRhZ2VDbGF1c2UodG9rZW4sIFtuZXdJbnRlcmZhY2VdKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAuLi5jbGF1c2VzLmZpbHRlcigoY2xhdXNlKSA9PiBjbGF1c2UgIT09IGV4aXN0aW5nQ2xhdXNlKSxcbiAgICAgICAgICB0cy51cGRhdGVIZXJpdGFnZUNsYXVzZShleGlzdGluZ0NsYXVzZSwgW1xuICAgICAgICAgICAgLi4uZXhpc3RpbmdDbGF1c2UudHlwZXMsXG4gICAgICAgICAgICBuZXdJbnRlcmZhY2UsXG4gICAgICAgICAgXSksXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIHJlcGxhY2VCYXNlQ2xhc3MoXG4gICAgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLFxuICAgIG5vZGU6IHRzLkNsYXNzRGVjbGFyYXRpb24sXG4gICAgYmFzZUNsYXNzOiB0cy5DbGFzc0RlY2xhcmF0aW9uIHwgc3RyaW5nLFxuICApIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybWF0aW9uKHR5cGVDaGVja2VyLCBub2RlLCAoZGVjbGFyYXRpb24pID0+IHtcbiAgICAgIGlmICghdHMuaXNDbGFzc0RlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEV4cGVjdGVkIGEgQ2xhc3NEZWNsYXJhdGlvbiwgZm91bmQgYSAke1xuICAgICAgICAgICAgdHMuU3ludGF4S2luZFtkZWNsYXJhdGlvbi5raW5kXVxuICAgICAgICAgIH1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB0eXBlRXhwcmVzc2lvbjogbmV3QmFzZUNsYXNzLCBzeW50aGV0aWNJbXBvcnQgfSA9XG4gICAgICAgIFRyYW5zZm9ybWF0aW9uLnR5cGVSZWZlcmVuY2UoYmFzZUNsYXNzLCBkZWNsYXJhdGlvbiwgdHlwZUNoZWNrZXIpO1xuICAgICAgY29uc3QgZXhpc3RpbmdDbGF1c2UgPSBkZWNsYXJhdGlvbi5oZXJpdGFnZUNsYXVzZXM/LmZpbmQoXG4gICAgICAgIChjbGF1c2UpID0+IGNsYXVzZS50b2tlbiA9PT0gdHMuU3ludGF4S2luZC5FeHRlbmRzS2V5d29yZCxcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlOiB0cy51cGRhdGVDbGFzc0RlY2xhcmF0aW9uKFxuICAgICAgICAgIGRlY2xhcmF0aW9uLFxuICAgICAgICAgIGRlY2xhcmF0aW9uLmRlY29yYXRvcnMsXG4gICAgICAgICAgZGVjbGFyYXRpb24ubW9kaWZpZXJzLFxuICAgICAgICAgIGRlY2xhcmF0aW9uLm5hbWUsXG4gICAgICAgICAgZGVjbGFyYXRpb24udHlwZVBhcmFtZXRlcnMsXG4gICAgICAgICAgW1xuICAgICAgICAgICAgLi4uKGRlY2xhcmF0aW9uLmhlcml0YWdlQ2xhdXNlcyA/PyBbXSkuZmlsdGVyKFxuICAgICAgICAgICAgICAoY2xhdXNlKSA9PiBjbGF1c2UgIT09IGV4aXN0aW5nQ2xhdXNlLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGV4aXN0aW5nQ2xhdXNlXG4gICAgICAgICAgICAgID8gdHMudXBkYXRlSGVyaXRhZ2VDbGF1c2UoZXhpc3RpbmdDbGF1c2UsIFtuZXdCYXNlQ2xhc3NdKVxuICAgICAgICAgICAgICA6IHRzLmNyZWF0ZUhlcml0YWdlQ2xhdXNlKHRzLlN5bnRheEtpbmQuRXh0ZW5kc0tleXdvcmQsIFtcbiAgICAgICAgICAgICAgICAgIG5ld0Jhc2VDbGFzcyxcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIGRlY2xhcmF0aW9uLm1lbWJlcnMsXG4gICAgICAgICksXG4gICAgICAgIHN5bnRoZXRpY0ltcG9ydHM6IHN5bnRoZXRpY0ltcG9ydCAmJiBbc3ludGhldGljSW1wb3J0XSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIHJlbW92ZUJhc2VDbGFzcyhcbiAgICB0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogdHMuQ2xhc3NEZWNsYXJhdGlvbixcbiAgKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1hdGlvbih0eXBlQ2hlY2tlciwgbm9kZSwgKGRlY2xhcmF0aW9uKSA9PiB7XG4gICAgICBpZiAoIXRzLmlzQ2xhc3NEZWNsYXJhdGlvbihkZWNsYXJhdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBFeHBlY3RlZCBhIENsYXNzRGVjbGFyYXRpb24sIGZvdW5kIGEgJHtcbiAgICAgICAgICAgIHRzLlN5bnRheEtpbmRbZGVjbGFyYXRpb24ua2luZF1cbiAgICAgICAgICB9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGU6IHRzLnVwZGF0ZUNsYXNzRGVjbGFyYXRpb24oXG4gICAgICAgICAgZGVjbGFyYXRpb24sXG4gICAgICAgICAgZGVjbGFyYXRpb24uZGVjb3JhdG9ycyxcbiAgICAgICAgICBkZWNsYXJhdGlvbi5tb2RpZmllcnMsXG4gICAgICAgICAgZGVjbGFyYXRpb24ubmFtZSxcbiAgICAgICAgICBkZWNsYXJhdGlvbi50eXBlUGFyYW1ldGVycyxcbiAgICAgICAgICBkZWNsYXJhdGlvbi5oZXJpdGFnZUNsYXVzZXM/LmZpbHRlcihcbiAgICAgICAgICAgIChjbGF1c2UpID0+IGNsYXVzZS50b2tlbiAhPT0gdHMuU3ludGF4S2luZC5FeHRlbmRzS2V5d29yZCxcbiAgICAgICAgICApLFxuICAgICAgICAgIGRlY2xhcmF0aW9uLm1lbWJlcnMsXG4gICAgICAgICksXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyByZW1vdmVJbnRlcmZhY2UoXG4gICAgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLFxuICAgIG5vZGU6IHRzLkNsYXNzRGVjbGFyYXRpb24gfCB0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbixcbiAgICBpZmFjZTogdHMuSW50ZXJmYWNlRGVjbGFyYXRpb24sXG4gICkge1xuICAgIGNvbnN0IGlmYWNlTmFtZSA9IFRyYW5zZm9ybWF0aW9uLmZ1bGx5UXVhbGlmaWVkTmFtZSh0eXBlQ2hlY2tlciwgaWZhY2UpITtcblxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtYXRpb24odHlwZUNoZWNrZXIsIG5vZGUsIChkZWNsYXJhdGlvbikgPT4ge1xuICAgICAgaWYgKHRzLmlzQ2xhc3NEZWNsYXJhdGlvbihkZWNsYXJhdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiB0cy51cGRhdGVDbGFzc0RlY2xhcmF0aW9uKFxuICAgICAgICAgICAgZGVjbGFyYXRpb24sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbi5kZWNvcmF0b3JzLFxuICAgICAgICAgICAgZGVjbGFyYXRpb24ubW9kaWZpZXJzLFxuICAgICAgICAgICAgZGVjbGFyYXRpb24ubmFtZSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uLnR5cGVQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcmVtb3ZlSW50ZXJmYWNlSGVyaXRhZ2UoZGVjbGFyYXRpb24uaGVyaXRhZ2VDbGF1c2VzKSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uLm1lbWJlcnMsXG4gICAgICAgICAgKSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodHMuaXNJbnRlcmZhY2VEZWNsYXJhdGlvbihkZWNsYXJhdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiB0cy51cGRhdGVJbnRlcmZhY2VEZWNsYXJhdGlvbihcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uLFxuICAgICAgICAgICAgZGVjbGFyYXRpb24uZGVjb3JhdG9ycyxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uLm1vZGlmaWVycyxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uLm5hbWUsXG4gICAgICAgICAgICBkZWNsYXJhdGlvbi50eXBlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJlbW92ZUludGVyZmFjZUhlcml0YWdlKGRlY2xhcmF0aW9uLmhlcml0YWdlQ2xhdXNlcyksXG4gICAgICAgICAgICBkZWNsYXJhdGlvbi5tZW1iZXJzLFxuICAgICAgICAgICksXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCBhIENsYXNzRGVjbGFyYXRpb24gb3IgSW50ZXJmYWNlRGVjbGFyYXRpb24sIGZvdW5kIGEgJHtcbiAgICAgICAgICB0cy5TeW50YXhLaW5kW2RlY2xhcmF0aW9uLmtpbmRdXG4gICAgICAgIH1gLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUludGVyZmFjZUhlcml0YWdlKFxuICAgICAgY2xhdXNlczogcmVhZG9ubHkgdHMuSGVyaXRhZ2VDbGF1c2VbXSB8IHVuZGVmaW5lZCxcbiAgICApOiB0cy5IZXJpdGFnZUNsYXVzZVtdIHwgdW5kZWZpbmVkIHtcbiAgICAgIGlmIChjbGF1c2VzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNsYXVzZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xhdXNlc1xuICAgICAgICAubWFwKChjbGF1c2UpID0+IHtcbiAgICAgICAgICBjb25zdCB0eXBlcyA9IGNsYXVzZS50eXBlcy5maWx0ZXIoXG4gICAgICAgICAgICAodHlwZSkgPT5cbiAgICAgICAgICAgICAgVHJhbnNmb3JtYXRpb24uZnVsbHlRdWFsaWZpZWROYW1lKFxuICAgICAgICAgICAgICAgIHR5cGVDaGVja2VyLFxuICAgICAgICAgICAgICAgIHR5cGUuZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgKSAhPT0gaWZhY2VOYW1lLFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gY2xhdXNlLnR5cGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gTWVhbnMgdGhlIGludGVyZmFjZSB3YXMgb25seSB0cmFuc2l0aXZlbHkgcHJlc2VudC4uLlxuICAgICAgICAgICAgcmV0dXJuIGNsYXVzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRzLnVwZGF0ZUhlcml0YWdlQ2xhdXNlKGNsYXVzZSwgdHlwZXMpO1xuICAgICAgICB9KVxuICAgICAgICAuZmlsdGVyKChjbGF1c2UpID0+IGNsYXVzZSAhPSBudWxsKSBhcyB0cy5IZXJpdGFnZUNsYXVzZVtdO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGZ1bGx5UXVhbGlmaWVkTmFtZShcbiAgICB0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogdHMuTm9kZSxcbiAgKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBzeW1ib2wgPSB0eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKFxuICAgICAgdHMuZ2V0TmFtZU9mRGVjbGFyYXRpb24obm9kZSBhcyB0cy5EZWNsYXJhdGlvbikgPz8gbm9kZSxcbiAgICApO1xuICAgIC8vIFRoaXMgc3ltYm9sIOKYne+4jyBkb2VzIG5vdCBjb250YWluIGVub3VnaCBpbmZvcm1hdGlvbiBpbiBzb21lIGNhc2VzIC0gd2hlblxuICAgIC8vIGFuIGltcG9ydGVkIHR5cGUgaXMgcGFydCBvZiBhIGhlcml0YWdlIGNsYXVzZSAtIHRvIHByb2R1Y2UgdGhlIGZxbi5cbiAgICAvLyBSb3VuZCB0cmlwcGluZyB0aGlzIHRvIGl0cyB0eXBlIGFuZCBiYWNrIHRvIGEgc3ltYm9sIHNlZW1zIHRvIGZpeCB0aGlzLlxuICAgIGNvbnN0IHR5cGUgPSBzeW1ib2wgJiYgdHlwZUNoZWNrZXIuZ2V0RGVjbGFyZWRUeXBlT2ZTeW1ib2woc3ltYm9sKTtcbiAgICByZXR1cm4gdHlwZT8uc3ltYm9sICYmIHR5cGVDaGVja2VyLmdldEZ1bGx5UXVhbGlmaWVkTmFtZSh0eXBlLnN5bWJvbCk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyB0eXBlUmVmZXJlbmNlKFxuICAgIHR5cGU6IHRzLkNsYXNzRGVjbGFyYXRpb24gfCB0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbiB8IHN0cmluZyxcbiAgICBjb250ZXh0OiB0cy5DbGFzc0RlY2xhcmF0aW9uIHwgdHMuSW50ZXJmYWNlRGVjbGFyYXRpb24sXG4gICAgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLFxuICApOiB7XG4gICAgdHlwZUV4cHJlc3Npb246IHRzLkV4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cztcbiAgICBzeW50aGV0aWNJbXBvcnQ/OiB0cy5JbXBvcnREZWNsYXJhdGlvbjtcbiAgfSB7XG4gICAgY29udGV4dCA9IHRzLmdldE9yaWdpbmFsTm9kZShjb250ZXh0KSBhcyBhbnk7XG5cbiAgICBjb25zdCBbLCBjb250ZXh0U291cmNlXSA9IC9eXCIoW15cIl0rKVwiXFwuLiokLy5leGVjKFxuICAgICAgdHlwZUNoZWNrZXIuZ2V0RnVsbHlRdWFsaWZpZWROYW1lKFxuICAgICAgICB0eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKHRzLmdldE5hbWVPZkRlY2xhcmF0aW9uKGNvbnRleHQpISkhLFxuICAgICAgKSxcbiAgICApITtcblxuICAgIGxldCBleHByZXNzaW9uOiB0cy5FeHByZXNzaW9uO1xuICAgIGxldCBzeW50aGV0aWNJbXBvcnQ6IHRzLkltcG9ydERlY2xhcmF0aW9uIHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgW3Jvb3QsIC4uLnRhaWxdID0gdHlwZS5zcGxpdCgnLicpO1xuICAgICAgY29uc3Qgc3ludGhldGljSW1wb3J0TmFtZSA9IHRzLmNyZWF0ZVVuaXF1ZU5hbWUocm9vdCk7XG4gICAgICBzeW50aGV0aWNJbXBvcnQgPSB0cy5jcmVhdGVJbXBvcnREZWNsYXJhdGlvbihcbiAgICAgICAgdW5kZWZpbmVkIC8qIGRlY29yYXRvcnMgKi8sXG4gICAgICAgIHVuZGVmaW5lZCAvKiBtb2RpZmllcnMgKi8sXG4gICAgICAgIHRzLmNyZWF0ZUltcG9ydENsYXVzZShcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgdHMuY3JlYXRlTmFtZXNwYWNlSW1wb3J0KHN5bnRoZXRpY0ltcG9ydE5hbWUpLFxuICAgICAgICApLFxuICAgICAgICB0cy5jcmVhdGVTdHJpbmdMaXRlcmFsKHJvb3QpLFxuICAgICAgKTtcbiAgICAgIGV4cHJlc3Npb24gPSB0YWlsLnJlZHVjZShcbiAgICAgICAgKGN1cnIsIGVsdCkgPT4gdHMuY3JlYXRlUHJvcGVydHlBY2Nlc3MoY3VyciwgZWx0KSxcbiAgICAgICAgc3ludGhldGljSW1wb3J0TmFtZSBhcyB0cy5FeHByZXNzaW9uLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgWywgdHlwZVNvdXJjZSwgcXVhbGlmaWVkTmFtZV0gPSAvXlwiKFteXCJdKylcIlxcLiguKikkLy5leGVjKFxuICAgICAgICB0eXBlQ2hlY2tlci5nZXRGdWxseVF1YWxpZmllZE5hbWUoXG4gICAgICAgICAgdHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbih0cy5nZXROYW1lT2ZEZWNsYXJhdGlvbih0eXBlKSEpISxcbiAgICAgICAgKSxcbiAgICAgICkhO1xuXG4gICAgICBpZiAodHlwZVNvdXJjZSA9PT0gY29udGV4dFNvdXJjZSkge1xuICAgICAgICBjb25zdCBbcm9vdCwgLi4udGFpbF0gPSBxdWFsaWZpZWROYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgIGV4cHJlc3Npb24gPSB0YWlsLnJlZHVjZShcbiAgICAgICAgICAoY3VyciwgZWx0KSA9PiB0cy5jcmVhdGVQcm9wZXJ0eUFjY2VzcyhjdXJyLCBlbHQpLFxuICAgICAgICAgIHRzLmNyZWF0ZUlkZW50aWZpZXIocm9vdCkgYXMgdHMuRXhwcmVzc2lvbixcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHN5bnRoZXRpY0ltcG9ydE5hbWUgPSB0cy5jcmVhdGVVbmlxdWVOYW1lKGJhc2VuYW1lKHR5cGVTb3VyY2UpKTtcbiAgICAgICAgc3ludGhldGljSW1wb3J0ID0gdHMuY3JlYXRlSW1wb3J0RGVjbGFyYXRpb24oXG4gICAgICAgICAgdW5kZWZpbmVkIC8qIGRlY29yYXRvcnMgKi8sXG4gICAgICAgICAgdW5kZWZpbmVkIC8qIG1vZGlmaWVycyAqLyxcbiAgICAgICAgICB0cy5jcmVhdGVJbXBvcnRDbGF1c2UoXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB0cy5jcmVhdGVOYW1lc3BhY2VJbXBvcnQoc3ludGhldGljSW1wb3J0TmFtZSksXG4gICAgICAgICAgKSxcbiAgICAgICAgICB0cy5jcmVhdGVTdHJpbmdMaXRlcmFsKFxuICAgICAgICAgICAgYC4vJHtyZWxhdGl2ZShkaXJuYW1lKGNvbnRleHRTb3VyY2UpLCB0eXBlU291cmNlKX1gLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICAgIGV4cHJlc3Npb24gPSBxdWFsaWZpZWROYW1lXG4gICAgICAgICAgLnNwbGl0KCcuJylcbiAgICAgICAgICAucmVkdWNlKFxuICAgICAgICAgICAgKGN1cnIsIGVsdCkgPT4gdHMuY3JlYXRlUHJvcGVydHlBY2Nlc3MoY3VyciwgZWx0KSxcbiAgICAgICAgICAgIHN5bnRoZXRpY0ltcG9ydE5hbWUgYXMgdHMuRXhwcmVzc2lvbixcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlRXhwcmVzc2lvbjogdHMuY3JlYXRlRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzKFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIGV4cHJlc3Npb24sXG4gICAgICApLFxuICAgICAgc3ludGhldGljSW1wb3J0LFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIHJlYWRvbmx5IG5vZGVOYW1lOiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlcixcbiAgICBub2RlOiB0cy5EZWNsYXJhdGlvbixcbiAgICBwdWJsaWMgcmVhZG9ubHkgYXBwbHk6IChcbiAgICAgIHRoaXM6IFRyYW5zZm9ybWF0aW9uLFxuICAgICAgbm9kZTogdHMuTm9kZSxcbiAgICApID0+IHsgbm9kZTogdHMuTm9kZTsgc3ludGhldGljSW1wb3J0PzogdHMuSW1wb3J0RGVjbGFyYXRpb24gfSxcbiAgKSB7XG4gICAgdGhpcy5ub2RlTmFtZSA9IFRyYW5zZm9ybWF0aW9uLmZ1bGx5UXVhbGlmaWVkTmFtZSh0eXBlQ2hlY2tlciwgbm9kZSkhO1xuICB9XG5cbiAgcHVibGljIHRhcmdldHMobm9kZTogdHMuRGVjbGFyYXRpb24pIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5ub2RlTmFtZSA9PT1cbiAgICAgIFRyYW5zZm9ybWF0aW9uLmZ1bGx5UXVhbGlmaWVkTmFtZSh0aGlzLnR5cGVDaGVja2VyLCBub2RlKVxuICAgICk7XG4gIH1cbn1cblxuY2xhc3MgRGVwcmVjYXRpb25SZW1vdmFsVHJhbnNmb3JtZXIge1xuICAvKipcbiAgICogQSBsaXN0IG9mIFN5bnRheEtpbmRzIGZvciB3aGljaCBpdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGV2YWx1YXRlIGNoaWxkcmVuLFxuICAgKiBzaW5jZSB0aGV5IGFyZSBuZXZlciBvZiBpbnRlcmVzdCB0byB0aGlzIHRyYW5zZm9ybS4gVGhpcyBvcGVucyB1cCBhIHdlZVxuICAgKiBvcHRpbWl6YXRpb24sIHdoaWNoIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgd2hlbiB0cnlpbmcgdG8gdHJvdWJsZXNob290IHRoZVxuICAgKiB0cmFuc2Zvcm0gaW4gYSBkZWJ1Z2dlciAoc2F2ZXMgYSBUT04gb2YgdGltZSBzdGVwcGluZyBpbnRvIHVzZWxlc3Mgbm9kZXNcbiAgICogdGhlbikuXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBJR05PUkVfQ0hJTERSRU46IFJlYWRvbmx5U2V0PHRzLlN5bnRheEtpbmQ+ID0gbmV3IFNldChcbiAgICBbXG4gICAgICB0cy5TeW50YXhLaW5kLkNvbnN0cnVjdG9yLFxuICAgICAgdHMuU3ludGF4S2luZC5GdW5jdGlvbkRlY2xhcmF0aW9uLFxuICAgICAgdHMuU3ludGF4S2luZC5HZXRBY2Nlc3NvcixcbiAgICAgIHRzLlN5bnRheEtpbmQuTWV0aG9kRGVjbGFyYXRpb24sXG4gICAgICB0cy5TeW50YXhLaW5kLk1ldGhvZFNpZ25hdHVyZSxcbiAgICAgIHRzLlN5bnRheEtpbmQuUHJvcGVydHlTaWduYXR1cmUsXG4gICAgICB0cy5TeW50YXhLaW5kLlByb3BlcnR5RGVjbGFyYXRpb24sXG4gICAgICB0cy5TeW50YXhLaW5kLlNldEFjY2Vzc29yLFxuICAgICAgdHMuU3ludGF4S2luZC5WYXJpYWJsZURlY2xhcmF0aW9uLFxuICAgIF0sXG4gICk7XG5cbiAgcHJpdmF0ZSBzeW50aGV0aWNJbXBvcnRzID0gbmV3IEFycmF5PHRzLkltcG9ydERlY2xhcmF0aW9uPigpO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbnRleHQ6IHRzLlRyYW5zZm9ybWF0aW9uQ29udGV4dCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRyYW5zZm9ybWF0aW9uczogcmVhZG9ubHkgVHJhbnNmb3JtYXRpb25bXSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG5vZGVzVG9SZW1vdmU6IFNldDx0cy5Ob2RlPixcbiAgKSB7fVxuXG4gIHB1YmxpYyB0cmFuc2Zvcm08VCBleHRlbmRzIHRzLk5vZGU+KG5vZGU6IFQpOiBUIHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy52aXNpdEVhY2hDaGlsZChub2RlKTtcblxuICAgIC8vIElmIHRoZXJlIGFyZSBhbnkgc3ludGhldGljIGltcG9ydHMsIGFkZCB0aGVtIHRvIHRoZSBzb3VyY2UgZmlsZVxuICAgIGlmICh0cy5pc1NvdXJjZUZpbGUocmVzdWx0KSAmJiB0aGlzLnN5bnRoZXRpY0ltcG9ydHMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0ID0gdHMudXBkYXRlU291cmNlRmlsZU5vZGUoXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgWy4uLnRoaXMuc3ludGhldGljSW1wb3J0cywgLi4ucmVzdWx0LnN0YXRlbWVudHNdLFxuICAgICAgICByZXN1bHQuaXNEZWNsYXJhdGlvbkZpbGUsXG4gICAgICAgIHJlc3VsdC5yZWZlcmVuY2VkRmlsZXMsXG4gICAgICAgIHJlc3VsdC50eXBlUmVmZXJlbmNlRGlyZWN0aXZlcyxcbiAgICAgICAgcmVzdWx0Lmhhc05vRGVmYXVsdExpYixcbiAgICAgICAgcmVzdWx0LmxpYlJlZmVyZW5jZURpcmVjdGl2ZXMsXG4gICAgICApIGFzIGFueTtcbiAgICAgIHRoaXMuc3ludGhldGljSW1wb3J0cyA9IG5ldyBBcnJheTx0cy5JbXBvcnREZWNsYXJhdGlvbj4oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJpdmF0ZSB2aXNpdEVhY2hDaGlsZDxUIGV4dGVuZHMgdHMuTm9kZT4obm9kZTogVCk6IFQge1xuICAgIHJldHVybiB0cy52aXNpdEVhY2hDaGlsZChub2RlLCB0aGlzLnZpc2l0b3IuYmluZCh0aGlzKSwgdGhpcy5jb250ZXh0KTtcbiAgfVxuXG4gIHByaXZhdGUgdmlzaXRvcjxUIGV4dGVuZHMgdHMuTm9kZT4obm9kZTogVCk6IHRzLlZpc2l0UmVzdWx0PFQ+IHtcbiAgICBpZiAodGhpcy5pc0RlcHJlY2F0ZWQobm9kZSkpIHtcbiAgICAgIC8vIFJlbW92aW5nIGRlcHJlY2F0ZWQgbWVtYmVycyBieSBzdWJzdGl0dXRpbmcgXCJub3RoaW5nXCIgdG8gdGhlbVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodHMuaXNDbGFzc0RlY2xhcmF0aW9uKG5vZGUpIHx8IHRzLmlzSW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSkpIHtcbiAgICAgIGZvciAoY29uc3QgdHJhbnNmb3JtYXRpb24gb2YgdGhpcy50cmFuc2Zvcm1hdGlvbnMpIHtcbiAgICAgICAgLy8g8J+RhyBhcyBhbnkgYmVjYXVzZSB0aGUgYXNzaWdubWVudCBiZWxvdyBjb25mdXNlcyB0eXBlIGNoZWNrZXJcbiAgICAgICAgaWYgKHRyYW5zZm9ybWF0aW9uLnRhcmdldHMobm9kZSBhcyBhbnkpKSB7XG4gICAgICAgICAgY29uc3QgeyBub2RlOiB0cmFuc2Zvcm1lZE5vZGUsIHN5bnRoZXRpY0ltcG9ydCB9ID1cbiAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uLmFwcGx5KG5vZGUpO1xuICAgICAgICAgIG5vZGUgPSB0cmFuc2Zvcm1lZE5vZGUgYXMgYW55O1xuICAgICAgICAgIGlmIChzeW50aGV0aWNJbXBvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3ludGhldGljSW1wb3J0cy5wdXNoKHN5bnRoZXRpY0ltcG9ydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIG5hbWVkIGltcG9ydHMgb2YgYEBkZXByZWNhdGVkYCBtZW1iZXJzIGZyb20gdGhlIHNvdXJjZS4uLlxuICAgIGlmIChcbiAgICAgIHRzLmlzSW1wb3J0RGVjbGFyYXRpb24obm9kZSkgJiZcbiAgICAgIG5vZGUuaW1wb3J0Q2xhdXNlICYmXG4gICAgICBub2RlLmltcG9ydENsYXVzZS5uYW1lZEJpbmRpbmdzICYmXG4gICAgICB0cy5pc05hbWVkSW1wb3J0cyhub2RlLmltcG9ydENsYXVzZS5uYW1lZEJpbmRpbmdzKVxuICAgICkge1xuICAgICAgY29uc3QgZmlsdGVyZWRFbGVtZW50cyA9IG5vZGUuaW1wb3J0Q2xhdXNlLm5hbWVkQmluZGluZ3MuZWxlbWVudHMuZmlsdGVyKFxuICAgICAgICAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgIC8vIFRoaXMgc3ltYm9sIGlzIGxvY2FsIChpdCdzIGRlY2xhcmF0aW9uIHBvaW50cyBiYWNrIHRvIHRoZSBuYW1lZCBpbXBvcnQpXG4gICAgICAgICAgY29uc3Qgc3ltYm9sID0gdGhpcy50eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKGVsZW1lbnQubmFtZSk7XG4gICAgICAgICAgY29uc3QgZXhwb3J0ZWRTeW1ib2wgPVxuICAgICAgICAgICAgLy8gVGhpcyBcInJlc29sdmVzXCIgdGhlIGltcG9ydGVkIHR5cGUsIHNvIHdlIGNhbiBnZXQgdG8gaXQncyBkZWNsYXJhdGlvbihzKVxuICAgICAgICAgICAgc3ltYm9sICYmIHRoaXMudHlwZUNoZWNrZXIuZ2V0RGVjbGFyZWRUeXBlT2ZTeW1ib2woc3ltYm9sKT8uc3ltYm9sO1xuICAgICAgICAgIHJldHVybiAhZXhwb3J0ZWRTeW1ib2w/LmRlY2xhcmF0aW9ucy5zb21lKChkZWNsKSA9PlxuICAgICAgICAgICAgdGhpcy5pc0RlcHJlY2F0ZWQoZGVjbCksXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIGZpbHRlcmVkRWxlbWVudHMubGVuZ3RoICE9PVxuICAgICAgICBub2RlLmltcG9ydENsYXVzZS5uYW1lZEJpbmRpbmdzLmVsZW1lbnRzLmxlbmd0aFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0cy51cGRhdGVJbXBvcnREZWNsYXJhdGlvbihcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIG5vZGUuZGVjb3JhdG9ycyxcbiAgICAgICAgICBub2RlLm1vZGlmaWVycyxcbiAgICAgICAgICBub2RlLmltcG9ydENsYXVzZS5uYW1lICE9IG51bGwgfHwgZmlsdGVyZWRFbGVtZW50cy5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IHRzLnVwZGF0ZUltcG9ydENsYXVzZShcbiAgICAgICAgICAgICAgICBub2RlLmltcG9ydENsYXVzZSxcbiAgICAgICAgICAgICAgICBub2RlLmltcG9ydENsYXVzZS5uYW1lLFxuICAgICAgICAgICAgICAgIHRzLnVwZGF0ZU5hbWVkSW1wb3J0cyhcbiAgICAgICAgICAgICAgICAgIG5vZGUuaW1wb3J0Q2xhdXNlLm5hbWVkQmluZGluZ3MsXG4gICAgICAgICAgICAgICAgICBmaWx0ZXJlZEVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbm9kZS5pbXBvcnRDbGF1c2UuaXNUeXBlT25seSxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgbm9kZS5tb2R1bGVTcGVjaWZpZXIsXG4gICAgICAgICkgYXMgYW55O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICAvLyBSZXBsYWNlIFwiZXhwb3J0IC4uLiBmcm9tIC4uLlwiIHBsYWNlcyB0aGF0IG5vIGxvbmdlciBleHBvcnQgYW55dGhpbmdcbiAgICAvLyB3aXRoIGFuIFwiaW1wb3J0IGZyb20gLi4uXCIsIHNvIHNpZGUgZWZmZWN0cyBhcmUgcHJlc2VydmVkLlxuICAgIGlmICh0cy5pc0V4cG9ydERlY2xhcmF0aW9uKG5vZGUpICYmIG5vZGUubW9kdWxlU3BlY2lmaWVyKSB7XG4gICAgICBjb25zdCBzeW1ib2wgPSB0aGlzLnR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24obm9kZS5tb2R1bGVTcGVjaWZpZXIpO1xuICAgICAgY29uc3QgbW9kdWxlRXhwb3J0cyA9XG4gICAgICAgIHN5bWJvbCAmJlxuICAgICAgICB0aGlzLnR5cGVDaGVja2VyXG4gICAgICAgICAgLmdldEV4cG9ydHNPZk1vZHVsZShzeW1ib2wpXG4gICAgICAgICAgPy5maWx0ZXIoXG4gICAgICAgICAgICAoc3ltKSA9PiAhc3ltLmRlY2xhcmF0aW9ucy5zb21lKChkZWNsKSA9PiB0aGlzLmlzRGVwcmVjYXRlZChkZWNsKSksXG4gICAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgKG5vZGUuZXhwb3J0Q2xhdXNlID09IG51bGwgfHxcbiAgICAgICAgICB0cy5pc05hbWVzcGFjZUV4cG9ydChub2RlLmV4cG9ydENsYXVzZSkpICYmXG4gICAgICAgIG1vZHVsZUV4cG9ydHM/Lmxlbmd0aCA9PT0gMFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0cy5jcmVhdGVJbXBvcnREZWNsYXJhdGlvbihcbiAgICAgICAgICB1bmRlZmluZWQgLyogZGVjb3JhdG9ycyAqLyxcbiAgICAgICAgICB1bmRlZmluZWQgLyogbW9kaWZpZXJzICovLFxuICAgICAgICAgIHVuZGVmaW5lZCAvKiBpbXBvcnRDbGF1c2UgKi8sXG4gICAgICAgICAgbm9kZS5tb2R1bGVTcGVjaWZpZXIsXG4gICAgICAgICkgYXMgYW55O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5leHBvcnRDbGF1c2UgIT0gbnVsbCAmJiBtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdzID0gbm9kZS5leHBvcnRDbGF1c2UgYXMgdHMuTmFtZWRFeHBvcnRzO1xuICAgICAgICBjb25zdCBleHBvcnRlZE5hbWVzID0gbmV3IFNldChtb2R1bGVFeHBvcnRzLm1hcCgoc3ltKSA9PiBzeW0ubmFtZSkpO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZEVsZW1lbnRzID0gYmluZGluZ3MuZWxlbWVudHM/LmZpbHRlcigoZWx0KSA9PlxuICAgICAgICAgIGV4cG9ydGVkTmFtZXMuaGFzKGVsdC5uYW1lLnRleHQpLFxuICAgICAgICApO1xuICAgICAgICBpZiAoZmlsdGVyZWRFbGVtZW50cz8ubGVuZ3RoICE9PSBiaW5kaW5ncy5lbGVtZW50cz8ubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRzLnVwZGF0ZUV4cG9ydERlY2xhcmF0aW9uKFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIG5vZGUuZGVjb3JhdG9ycyxcbiAgICAgICAgICAgIG5vZGUubW9kaWZpZXJzLFxuICAgICAgICAgICAgdHMudXBkYXRlTmFtZWRFeHBvcnRzKGJpbmRpbmdzLCBmaWx0ZXJlZEVsZW1lbnRzKSxcbiAgICAgICAgICAgIG5vZGUubW9kdWxlU3BlY2lmaWVyLFxuICAgICAgICAgICAgbm9kZS5pc1R5cGVPbmx5LFxuICAgICAgICAgICkgYXMgYW55O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIERlcHJlY2F0aW9uUmVtb3ZhbFRyYW5zZm9ybWVyLklHTk9SRV9DSElMRFJFTi5oYXMobm9kZS5raW5kKVxuICAgICAgPyBub2RlXG4gICAgICA6IHRoaXMudmlzaXRFYWNoQ2hpbGQobm9kZSk7XG4gIH1cblxuICBwcml2YXRlIGlzRGVwcmVjYXRlZChub2RlOiB0cy5Ob2RlKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgb3JpZ2luYWwgPSB0cy5nZXRPcmlnaW5hbE5vZGUobm9kZSk7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubm9kZXNUb1JlbW92ZS5oYXMob3JpZ2luYWwpICYmXG4gICAgICB0cy5nZXRKU0RvY1RhZ3Mob3JpZ2luYWwpLnNvbWUoKHRhZykgPT4gdGFnLnRhZ05hbWUudGV4dCA9PT0gJ2RlcHJlY2F0ZWQnKVxuICAgICk7XG4gIH1cbn1cbiJdfQ==