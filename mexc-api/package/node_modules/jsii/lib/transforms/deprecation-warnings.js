"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeprecationWarningsInjector = void 0;
const spec = require("@jsii/spec");
const fs = require("fs");
const path = require("path");
const typescript_1 = require("typescript");
const ts = require("typescript/lib/tsserverlibrary");
const utils_1 = require("../utils");
const FILE_NAME = '.warnings.jsii.js';
const WARNING_FUNCTION_NAME = 'print';
const PARAMETER_NAME = 'p';
const NAMESPACE = 'jsiiDeprecationWarnings';
const LOCAL_ENUM_NAMESPACE = 'ns';
const VISITED_OBJECTS_SET_NAME = 'visitedObjects';
class DeprecationWarningsInjector {
    constructor(typeChecker) {
        this.typeChecker = typeChecker;
        this.transformers = {
            before: [],
        };
    }
    process(assembly, projectInfo) {
        var _a, _b, _c, _d, _e, _f;
        const projectRoot = projectInfo.projectRoot;
        const functionDeclarations = [];
        const types = (_a = assembly.types) !== null && _a !== void 0 ? _a : {};
        for (const type of Object.values(types)) {
            const statements = [];
            let isEmpty = true;
            // This will add the parameter to the set of visited objects, to prevent infinite recursion
            statements.push(ts.createExpressionStatement(ts.createCall(ts.createIdentifier(`${VISITED_OBJECTS_SET_NAME}.add`), [], [ts.createIdentifier(PARAMETER_NAME)])));
            if (spec.isDeprecated(type) && spec.isEnumType(type)) {
                // The type is deprecated
                statements.push(createWarningFunctionCall(type.fqn, (_b = type.docs) === null || _b === void 0 ? void 0 : _b.deprecated));
                isEmpty = false;
            }
            if (spec.isEnumType(type) && ((_c = type.locationInModule) === null || _c === void 0 ? void 0 : _c.filename)) {
                statements.push(createEnumRequireStatement((_d = type.locationInModule) === null || _d === void 0 ? void 0 : _d.filename));
                statements.push(createDuplicateEnumValuesCheck(type));
                for (const member of Object.values((_e = type.members) !== null && _e !== void 0 ? _e : [])) {
                    if (spec.isDeprecated(member)) {
                        // The enum member is deprecated
                        const condition = ts.createIdentifier(`${PARAMETER_NAME} === ${LOCAL_ENUM_NAMESPACE}.${type.name}.${member.name}`);
                        statements.push(createWarningFunctionCall(`${type.fqn}#${member.name}`, (_f = member.docs) === null || _f === void 0 ? void 0 : _f.deprecated, condition));
                        isEmpty = false;
                    }
                }
            }
            else if (spec.isInterfaceType(type) && type.datatype) {
                const { statementsByProp, excludedProps } = processInterfaceType(type, types, assembly, projectInfo);
                for (const [name, statement] of statementsByProp.entries()) {
                    if (!excludedProps.has(name)) {
                        statements.push(statement);
                        isEmpty = false;
                    }
                }
            }
            statements.push(ts.createExpressionStatement(ts.createCall(ts.createIdentifier(`${VISITED_OBJECTS_SET_NAME}.delete`), [], [ts.createIdentifier(PARAMETER_NAME)])));
            const parameter = ts.createParameter(undefined, undefined, undefined, PARAMETER_NAME);
            const functionName = fnName(type.fqn);
            const functionDeclaration = ts.createFunctionDeclaration(undefined, undefined, undefined, functionName, undefined, [parameter], undefined, createFunctionBlock(isEmpty ? [] : statements));
            functionDeclarations.push(functionDeclaration);
        }
        this.transformers = {
            before: [
                (context) => {
                    const transformer = new Transformer(this.typeChecker, context, projectRoot, this.buildTypeIndex(assembly), assembly);
                    return transformer.transform.bind(transformer);
                },
            ],
        };
        generateWarningsFile(projectRoot, functionDeclarations);
    }
    get customTransformers() {
        return this.transformers;
    }
    buildTypeIndex(assembly) {
        var _a;
        const result = new Map();
        for (const type of Object.values((_a = assembly.types) !== null && _a !== void 0 ? _a : {})) {
            const symbolId = type.symbolId;
            if (symbolId) {
                result.set(symbolId, type);
            }
        }
        return result;
    }
}
exports.DeprecationWarningsInjector = DeprecationWarningsInjector;
function processInterfaceType(type, types, assembly, projectInfo, statementsByProp = new Map(), excludedProps = new Set()) {
    var _a, _b, _c, _d, _e;
    for (const prop of Object.values((_a = type.properties) !== null && _a !== void 0 ? _a : {})) {
        const fqn = `${type.fqn}#${prop.name}`;
        if (spec.isDeprecated(prop) || spec.isDeprecated(type)) {
            // If the property individually is deprecated, or the entire type is deprecated
            const deprecatedDocs = (_c = (_b = prop.docs) === null || _b === void 0 ? void 0 : _b.deprecated) !== null && _c !== void 0 ? _c : (_d = type.docs) === null || _d === void 0 ? void 0 : _d.deprecated;
            const statement = createWarningFunctionCall(fqn, deprecatedDocs, ts.createIdentifier(`"${prop.name}" in ${PARAMETER_NAME}`));
            statementsByProp.set(prop.name, statement);
        }
        else {
            /* If a prop is not deprecated, we don't want to generate a warning for it,
               even if another property with the same name is deprecated in another
               super-interface. */
            excludedProps.add(prop.name);
        }
        if (spec.isNamedTypeReference(prop.type) &&
            Object.keys(types).includes(prop.type.fqn)) {
            const functionName = importedFunctionName(prop.type.fqn, assembly, projectInfo);
            if (functionName) {
                const statement = createTypeHandlerCall(functionName, `${PARAMETER_NAME}.${prop.name}`);
                statementsByProp.set(`${prop.name}_`, statement);
            }
        }
        else if (spec.isCollectionTypeReference(prop.type) &&
            spec.isNamedTypeReference(prop.type.collection.elementtype)) {
            const functionName = importedFunctionName(prop.type.collection.elementtype.fqn, assembly, projectInfo);
            if (functionName) {
                const statement = createTypeHandlerCall(functionName, `${PARAMETER_NAME}.${prop.name}`);
                statementsByProp.set(`${prop.name}_`, statement);
            }
        }
        else if (spec.isUnionTypeReference(prop.type) &&
            spec.isNamedTypeReference(prop.type.union.types[0]) &&
            Object.keys(types).includes(prop.type.union.types[0].fqn)) {
            const functionName = importedFunctionName(prop.type.union.types[0].fqn, assembly, projectInfo);
            if (functionName) {
                const statement = createTypeHandlerCall(functionName, `${PARAMETER_NAME}.${prop.name}`);
                statementsByProp.set(`${prop.name}_`, statement);
            }
        }
    }
    // We also generate calls to all the supertypes
    for (const interfaceName of (_e = type.interfaces) !== null && _e !== void 0 ? _e : []) {
        const assemblies = projectInfo.dependencyClosure.concat(assembly);
        const superType = findType(interfaceName, assemblies);
        if (superType.type) {
            processInterfaceType(superType.type, types, assembly, projectInfo, statementsByProp, excludedProps);
        }
    }
    return { statementsByProp, excludedProps };
}
function fnName(fqn) {
    return fqn.replace(/[^\w\d]/g, '_');
}
function createFunctionBlock(statements) {
    if (statements.length > 0) {
        const validation = ts.createIf(ts.createIdentifier(`${PARAMETER_NAME} == null`), ts.createReturn());
        return ts.createBlock([validation, ...statements], true);
    }
    return ts.createBlock([], true);
}
function createWarningFunctionCall(fqn, message = '', condition, includeNamespace = false) {
    const functionName = includeNamespace
        ? `${NAMESPACE}.${WARNING_FUNCTION_NAME}`
        : WARNING_FUNCTION_NAME;
    const mainStatement = ts.createExpressionStatement(ts.createCall(ts.createIdentifier(functionName), [], [ts.createLiteral(fqn), ts.createLiteral(message)]));
    return condition ? ts.createIf(condition, mainStatement) : mainStatement;
}
function generateWarningsFile(projectRoot, functionDeclarations) {
    const names = [...functionDeclarations]
        .map((d) => { var _a; return (_a = d.name) === null || _a === void 0 ? void 0 : _a.text; })
        .filter(Boolean);
    const exports = [WARNING_FUNCTION_NAME, ...names].join(',');
    const functionText = `function ${WARNING_FUNCTION_NAME}(name, deprecationMessage) {
  const deprecated = process.env.JSII_DEPRECATED;
  const deprecationMode = ['warn', 'fail', 'quiet'].includes(deprecated) ? deprecated : 'warn';
  const message = \`\${name} is deprecated.\\n  \${deprecationMessage}\\n  This API will be removed in the next major release.\`;
  switch (deprecationMode) {
    case "fail":
      throw new DeprecationError(message);
    case "warn":
      console.warn("[WARNING]", message);
      break;
  }
}

const ${VISITED_OBJECTS_SET_NAME} = new Set();

class DeprecationError extends Error {}

module.exports = {${exports}}
module.exports.DeprecationError = DeprecationError;
`;
    const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
    const resultFile = ts.createSourceFile(path.join(projectRoot, FILE_NAME), functionText, ts.ScriptTarget.Latest, false, ts.ScriptKind.JS);
    const declarations = functionDeclarations.map((declaration) => printer.printNode(typescript_1.EmitHint.Unspecified, declaration, resultFile));
    const content = declarations.concat(printer.printFile(resultFile)).join('\n');
    fs.writeFileSync(path.join(projectRoot, FILE_NAME), content);
}
class Transformer {
    constructor(typeChecker, context, projectRoot, typeIndex, assembly) {
        this.typeChecker = typeChecker;
        this.context = context;
        this.projectRoot = projectRoot;
        this.typeIndex = typeIndex;
        this.assembly = assembly;
    }
    transform(node) {
        const result = this.visitEachChild(node);
        if (ts.isSourceFile(result)) {
            const importDir = path.relative(path.dirname(result.fileName), this.projectRoot);
            const importPath = importDir.startsWith('..')
                ? unixPath(path.join(importDir, FILE_NAME))
                : `./${FILE_NAME}`;
            return ts.updateSourceFileNode(result, [
                createRequireStatement(NAMESPACE, importPath),
                ...result.statements,
            ]);
        }
        return result;
    }
    visitEachChild(node) {
        return ts.visitEachChild(node, this.visitor.bind(this), this.context);
    }
    visitor(node) {
        if (ts.isMethodDeclaration(node) && node.body != null) {
            const statements = this.getStatementsForDeclaration(node);
            return ts.updateMethod(node, node.decorators, node.modifiers, node.asteriskToken, node.name, node.questionToken, node.typeParameters, node.parameters, node.type, ts.updateBlock(node.body, ts.createNodeArray([...statements, ...node.body.statements])));
        }
        else if (ts.isGetAccessorDeclaration(node) && node.body != null) {
            const statements = this.getStatementsForDeclaration(node);
            return ts.updateGetAccessor(node, node.decorators, node.modifiers, node.name, node.parameters, node.type, ts.updateBlock(node.body, ts.createNodeArray([...statements, ...node.body.statements])));
        }
        else if (ts.isSetAccessorDeclaration(node) && node.body != null) {
            const statements = this.getStatementsForDeclaration(node);
            return ts.updateSetAccessor(node, node.decorators, node.modifiers, node.name, node.parameters, ts.updateBlock(node.body, ts.createNodeArray([...statements, ...node.body.statements])));
        }
        else if (ts.isConstructorDeclaration(node) && node.body != null) {
            const statements = this.getStatementsForDeclaration(node);
            return ts.updateConstructor(node, node.decorators, node.modifiers, node.parameters, ts.updateBlock(node.body, insertStatements(node.body, statements)));
        }
        return this.visitEachChild(node);
    }
    getStatementsForDeclaration(node) {
        var _a, _b;
        const klass = node.parent;
        const classSymbolId = utils_1.symbolIdentifier(this.typeChecker, this.typeChecker.getTypeAtLocation(klass).symbol);
        if (classSymbolId && this.typeIndex.has(classSymbolId)) {
            const classType = this.typeIndex.get(classSymbolId);
            if (ts.isConstructorDeclaration(node)) {
                const initializer = classType === null || classType === void 0 ? void 0 : classType.initializer;
                if (initializer) {
                    return this.getStatements(classType, initializer);
                }
            }
            const methods = (_a = classType === null || classType === void 0 ? void 0 : classType.methods) !== null && _a !== void 0 ? _a : [];
            const method = methods.find((method) => { var _a; return method.name === ((_a = node.name) === null || _a === void 0 ? void 0 : _a.getText()); });
            if (method) {
                return this.getStatements(classType, method);
            }
            const properties = (_b = classType === null || classType === void 0 ? void 0 : classType.properties) !== null && _b !== void 0 ? _b : [];
            const property = properties.find((property) => { var _a; return property.name === ((_a = node.name) === null || _a === void 0 ? void 0 : _a.getText()); });
            if (property) {
                return createWarningStatementForElement(property, classType);
            }
        }
        return [];
    }
    getStatements(classType, method) {
        var _a;
        const statements = createWarningStatementForElement(method, classType);
        for (const parameter of Object.values((_a = method.parameters) !== null && _a !== void 0 ? _a : {})) {
            const parameterType = this.assembly.types && spec.isNamedTypeReference(parameter.type)
                ? this.assembly.types[parameter.type.fqn]
                : undefined;
            if (parameterType) {
                const functionName = `${NAMESPACE}.${fnName(parameterType.fqn)}`;
                statements.push(ts.createExpressionStatement(ts.createCall(ts.createIdentifier(functionName), [], [ts.createIdentifier(parameter.name)])));
            }
        }
        return statements;
    }
}
function createWarningStatementForElement(element, classType) {
    var _a;
    if (spec.isDeprecated(element)) {
        const elementName = element.name;
        const fqn = elementName ? `${classType.fqn}#${elementName}` : classType.fqn;
        return [
            createWarningFunctionCall(fqn, (_a = element.docs) === null || _a === void 0 ? void 0 : _a.deprecated, undefined, true),
        ];
    }
    return [];
}
/**
 * Inserts a list of statements in the correct position inside a block of statements.
 * If there is a `super` call, It inserts the statements just after it. Otherwise,
 * insert the statements right at the beginning of the block.
 */
function insertStatements(block, newStatements) {
    function splicePoint(statement) {
        if (statement == null) {
            return 0;
        }
        let isSuper = false;
        statement.forEachChild((node) => {
            if (ts.isCallExpression(node) &&
                node.expression.kind === ts.SyntaxKind.SuperKeyword) {
                isSuper = true;
            }
        });
        return isSuper ? 1 : 0;
    }
    const result = [...block.statements];
    result.splice(splicePoint(block.statements[0]), 0, ...newStatements);
    return ts.createNodeArray(result);
}
function createEnumRequireStatement(typeLocation) {
    const { ext } = path.parse(typeLocation);
    const jsFileName = typeLocation.replace(ext, '.js');
    return createRequireStatement(LOCAL_ENUM_NAMESPACE, `./${jsFileName}`);
}
function createRequireStatement(name, importPath) {
    return ts.createVariableStatement(undefined, ts.createVariableDeclarationList([
        ts.createVariableDeclaration(name, undefined, ts.createCall(ts.createIdentifier('require'), undefined, [
            ts.createLiteral(importPath),
        ])),
    ], ts.NodeFlags.Const));
}
/**
 * Returns a ready-to-used function name (including a `require`, if necessary)
 */
function importedFunctionName(typeName, assembly, projectInfo) {
    const assemblies = projectInfo.dependencyClosure.concat(assembly);
    const { type, moduleName } = findType(typeName, assemblies);
    if (type) {
        return moduleName !== assembly.name
            ? `require("${moduleName}/${FILE_NAME}").${fnName(type.fqn)}`
            : fnName(type.fqn);
    }
    return undefined;
}
/**
 * Find the type and module name in an array of assemblies
 * matching a given type name
 */
function findType(typeName, assemblies) {
    var _a, _b, _c;
    for (const asm of assemblies) {
        if ((_b = (_a = asm.metadata) === null || _a === void 0 ? void 0 : _a.jsii) === null || _b === void 0 ? void 0 : _b.compiledWithDeprecationWarnings) {
            const types = (_c = asm.types) !== null && _c !== void 0 ? _c : {};
            for (const name of Object.keys(types)) {
                if (typeName === name) {
                    return { type: types[name], moduleName: asm.name };
                }
            }
        }
    }
    return {};
}
function createTypeHandlerCall(functionName, parameter) {
    return ts.createIf(ts.createIdentifier(`!${VISITED_OBJECTS_SET_NAME}.has(${parameter})`), ts.createExpressionStatement(ts.createCall(ts.createIdentifier(functionName), [], [ts.createIdentifier(parameter)])));
}
/**
 * There is a chance an enum contains duplicates values with distinct keys,
 * with one of those keys being deprecated. This is a potential pattern to "rename" an enum.
 * In this case, we can't concretely determine if the deprecated member was used or not,
 * so in those cases we skip the warnings altogether, rather than erroneously warning for valid usage.
 * This create a statement to check if the enum value is a duplicate:
 *
 * if (Object.values(Foo).filter(x => x === p).length > 1) { return; }
 *
 * Note that we can't just check the assembly for these duplicates, due to:
 * https://github.com/aws/jsii/issues/2782
 */
function createDuplicateEnumValuesCheck(type) {
    return ts.createIf(ts.createBinary(ts.createPropertyAccess(ts.createCall(ts.createPropertyAccess(ts.createCall(ts.createIdentifier('Object.values'), undefined, [
        ts.createIdentifier(`${LOCAL_ENUM_NAMESPACE}.${type.name}`),
    ]), ts.createIdentifier('filter')), undefined, [
        ts.createArrowFunction(undefined, undefined, [ts.createParameter(undefined, undefined, undefined, 'x')], undefined, ts.createToken(ts.SyntaxKind.EqualsGreaterThanToken), ts.createBinary(ts.createIdentifier('x'), ts.createToken(ts.SyntaxKind.EqualsEqualsEqualsToken), ts.createIdentifier(PARAMETER_NAME))),
    ]), ts.createIdentifier('length')), ts.createToken(ts.SyntaxKind.GreaterThanToken), ts.createNumericLiteral('1')), ts.createReturn());
}
/**
 * Force a path to be UNIXy (use `/` as a separator)
 *
 * `path.join()` etc. will use the system-dependent path separator (either `/` or `\`
 * depending on your platform).
 *
 * However, if we actually emit the path-dependent separator to the `.js` files, then
 * files compiled with jsii on Windows cannot be used on any other platform. That seems
 * like an unnecessary restriction, especially since a `/` will work fine on Windows,
 * so make sure to always emit `/`.
 *
 * TSC itself always strictly emits `/` (or at least, emits the same what you put in).
 */
function unixPath(filePath) {
    if (path.sep === '\\') {
        return filePath.replace(/\\/g, '/');
    }
    return filePath;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwcmVjYXRpb24td2FybmluZ3MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJkZXByZWNhdGlvbi13YXJuaW5ncy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxtQ0FBbUM7QUFFbkMseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QiwyQ0FBaUQ7QUFDakQscURBQXFEO0FBR3JELG9DQUE0QztBQUU1QyxNQUFNLFNBQVMsR0FBRyxtQkFBbUIsQ0FBQztBQUN0QyxNQUFNLHFCQUFxQixHQUFHLE9BQU8sQ0FBQztBQUN0QyxNQUFNLGNBQWMsR0FBRyxHQUFHLENBQUM7QUFDM0IsTUFBTSxTQUFTLEdBQUcseUJBQXlCLENBQUM7QUFDNUMsTUFBTSxvQkFBb0IsR0FBRyxJQUFJLENBQUM7QUFDbEMsTUFBTSx3QkFBd0IsR0FBRyxnQkFBZ0IsQ0FBQztBQUVsRCxNQUFhLDJCQUEyQjtJQUt0QyxZQUFvQyxXQUEyQjtRQUEzQixnQkFBVyxHQUFYLFdBQVcsQ0FBZ0I7UUFKdkQsaUJBQVksR0FBMEI7WUFDNUMsTUFBTSxFQUFFLEVBQUU7U0FDWCxDQUFDO0lBRWdFLENBQUM7SUFFNUQsT0FBTyxDQUFDLFFBQWtCLEVBQUUsV0FBd0I7O1FBQ3pELE1BQU0sV0FBVyxHQUFHLFdBQVcsQ0FBQyxXQUFXLENBQUM7UUFDNUMsTUFBTSxvQkFBb0IsR0FBNkIsRUFBRSxDQUFDO1FBRTFELE1BQU0sS0FBSyxTQUFHLFFBQVEsQ0FBQyxLQUFLLG1DQUFJLEVBQUUsQ0FBQztRQUNuQyxLQUFLLE1BQU0sSUFBSSxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDdkMsTUFBTSxVQUFVLEdBQWdCLEVBQUUsQ0FBQztZQUNuQyxJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUM7WUFFbkIsMkZBQTJGO1lBQzNGLFVBQVUsQ0FBQyxJQUFJLENBQ2IsRUFBRSxDQUFDLHlCQUF5QixDQUMxQixFQUFFLENBQUMsVUFBVSxDQUNYLEVBQUUsQ0FB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Q0osQ0FBQztBQUVEOzs7Ozs7Ozs7Ozs7R0FZRztBQUNILFNBQVMsUUFBUSxDQUFDLFFBQWdCO0lBQ2hDLElBQUksSUFBSSxDQUFDLEdBQUcsS0FBSyxJQUFJLEVBQUU7UUFDckIsT0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztLQUNyQztJQUNELE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBzcGVjIGZyb20gJ0Bqc2lpL3NwZWMnO1xuaW1wb3J0IHsgQXNzZW1ibHkgfSBmcm9tICdAanNpaS9zcGVjJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBFbWl0SGludCwgU3RhdGVtZW50IH0gZnJvbSAndHlwZXNjcmlwdCc7XG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0L2xpYi90c3NlcnZlcmxpYnJhcnknO1xuXG5pbXBvcnQgeyBQcm9qZWN0SW5mbyB9IGZyb20gJy4uL3Byb2plY3QtaW5mbyc7XG5pbXBvcnQgeyBzeW1ib2xJZGVudGlmaWVyIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCBGSUxFX05BTUUgPSAnLndhcm5pbmdzLmpzaWkuanMnO1xuY29uc3QgV0FSTklOR19GVU5DVElPTl9OQU1FID0gJ3ByaW50JztcbmNvbnN0IFBBUkFNRVRFUl9OQU1FID0gJ3AnO1xuY29uc3QgTkFNRVNQQUNFID0gJ2pzaWlEZXByZWNhdGlvbldhcm5pbmdzJztcbmNvbnN0IExPQ0FMX0VOVU1fTkFNRVNQQUNFID0gJ25zJztcbmNvbnN0IFZJU0lURURfT0JKRUNUU19TRVRfTkFNRSA9ICd2aXNpdGVkT2JqZWN0cyc7XG5cbmV4cG9ydCBjbGFzcyBEZXByZWNhdGlvbldhcm5pbmdzSW5qZWN0b3Ige1xuICBwcml2YXRlIHRyYW5zZm9ybWVyczogdHMuQ3VzdG9tVHJhbnNmb3JtZXJzID0ge1xuICAgIGJlZm9yZTogW10sXG4gIH07XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyKSB7fVxuXG4gIHB1YmxpYyBwcm9jZXNzKGFzc2VtYmx5OiBBc3NlbWJseSwgcHJvamVjdEluZm86IFByb2plY3RJbmZvKSB7XG4gICAgY29uc3QgcHJvamVjdFJvb3QgPSBwcm9qZWN0SW5mby5wcm9qZWN0Um9vdDtcbiAgICBjb25zdCBmdW5jdGlvbkRlY2xhcmF0aW9uczogdHMuRnVuY3Rpb25EZWNsYXJhdGlvbltdID0gW107XG5cbiAgICBjb25zdCB0eXBlcyA9IGFzc2VtYmx5LnR5cGVzID8/IHt9O1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiBPYmplY3QudmFsdWVzKHR5cGVzKSkge1xuICAgICAgY29uc3Qgc3RhdGVtZW50czogU3RhdGVtZW50W10gPSBbXTtcbiAgICAgIGxldCBpc0VtcHR5ID0gdHJ1ZTtcblxuICAgICAgLy8gVGhpcyB3aWxsIGFkZCB0aGUgcGFyYW1ldGVyIHRvIHRoZSBzZXQgb2YgdmlzaXRlZCBvYmplY3RzLCB0byBwcmV2ZW50IGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgc3RhdGVtZW50cy5wdXNoKFxuICAgICAgICB0cy5jcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50KFxuICAgICAgICAgIHRzLmNyZWF0ZUNhbGwoXG4gICAgICAgICAgICB0cy5jcmVhdGVJZGVudGlmaWVyKGAke1ZJU0lURURfT0JKRUNUU19TRVRfTkFNRX0uYWRkYCksXG4gICAgICAgICAgICBbXSxcbiAgICAgICAgICAgIFt0cy5jcmVhdGVJZGVudGlmaWVyKFBBUkFNRVRFUl9OQU1FKV0sXG4gICAgICAgICAgKSxcbiAgICAgICAgKSxcbiAgICAgICk7XG5cbiAgICAgIGlmIChzcGVjLmlzRGVwcmVjYXRlZCh0eXBlKSAmJiBzcGVjLmlzRW51bVR5cGUodHlwZSkpIHtcbiAgICAgICAgLy8gVGhlIHR5cGUgaXMgZGVwcmVjYXRlZFxuICAgICAgICBzdGF0ZW1lbnRzLnB1c2goXG4gICAgICAgICAgY3JlYXRlV2FybmluZ0Z1bmN0aW9uQ2FsbCh0eXBlLmZxbiwgdHlwZS5kb2NzPy5kZXByZWNhdGVkKSxcbiAgICAgICAgKTtcbiAgICAgICAgaXNFbXB0eSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BlYy5pc0VudW1UeXBlKHR5cGUpICYmIHR5cGUubG9jYXRpb25Jbk1vZHVsZT8uZmlsZW5hbWUpIHtcbiAgICAgICAgc3RhdGVtZW50cy5wdXNoKFxuICAgICAgICAgIGNyZWF0ZUVudW1SZXF1aXJlU3RhdGVtZW50KHR5cGUubG9jYXRpb25Jbk1vZHVsZT8uZmlsZW5hbWUpLFxuICAgICAgICApO1xuICAgICAgICBzdGF0ZW1lbnRzLnB1c2goY3JlYXRlRHVwbGljYXRlRW51bVZhbHVlc0NoZWNrKHR5cGUpKTtcblxuICAgICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBPYmplY3QudmFsdWVzKHR5cGUubWVtYmVycyA/PyBbXSkpIHtcbiAgICAgICAgICBpZiAoc3BlYy5pc0RlcHJlY2F0ZWQobWVtYmVyKSkge1xuICAgICAgICAgICAgLy8gVGhlIGVudW0gbWVtYmVyIGlzIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHRzLmNyZWF0ZUlkZW50aWZpZXIoXG4gICAgICAgICAgICAgIGAke1BBUkFNRVRFUl9OQU1FfSA9PT0gJHtMT0NBTF9FTlVNX05BTUVTUEFDRX0uJHt0eXBlLm5hbWV9LiR7bWVtYmVyLm5hbWV9YCxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChcbiAgICAgICAgICAgICAgY3JlYXRlV2FybmluZ0Z1bmN0aW9uQ2FsbChcbiAgICAgICAgICAgICAgICBgJHt0eXBlLmZxbn0jJHttZW1iZXIubmFtZX1gLFxuICAgICAgICAgICAgICAgIG1lbWJlci5kb2NzPy5kZXByZWNhdGVkLFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNwZWMuaXNJbnRlcmZhY2VUeXBlKHR5cGUpICYmIHR5cGUuZGF0YXR5cGUpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0ZW1lbnRzQnlQcm9wLCBleGNsdWRlZFByb3BzIH0gPSBwcm9jZXNzSW50ZXJmYWNlVHlwZShcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHR5cGVzLFxuICAgICAgICAgIGFzc2VtYmx5LFxuICAgICAgICAgIHByb2plY3RJbmZvLFxuICAgICAgICApO1xuXG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHN0YXRlbWVudF0gb2Ygc3RhdGVtZW50c0J5UHJvcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICBpZiAoIWV4Y2x1ZGVkUHJvcHMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goc3RhdGVtZW50KTtcbiAgICAgICAgICAgIGlzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRlbWVudHMucHVzaChcbiAgICAgICAgdHMuY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudChcbiAgICAgICAgICB0cy5jcmVhdGVDYWxsKFxuICAgICAgICAgICAgdHMuY3JlYXRlSWRlbnRpZmllcihgJHtWSVNJVEVEX09CSkVDVFNfU0VUX05BTUV9LmRlbGV0ZWApLFxuICAgICAgICAgICAgW10sXG4gICAgICAgICAgICBbdHMuY3JlYXRlSWRlbnRpZmllcihQQVJBTUVURVJfTkFNRSldLFxuICAgICAgICAgICksXG4gICAgICAgICksXG4gICAgICApO1xuXG4gICAgICBjb25zdCBwYXJhbWV0ZXIgPSB0cy5jcmVhdGVQYXJhbWV0ZXIoXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIFBBUkFNRVRFUl9OQU1FLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGZuTmFtZSh0eXBlLmZxbik7XG4gICAgICBjb25zdCBmdW5jdGlvbkRlY2xhcmF0aW9uID0gdHMuY3JlYXRlRnVuY3Rpb25EZWNsYXJhdGlvbihcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgZnVuY3Rpb25OYW1lLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIFtwYXJhbWV0ZXJdLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIGNyZWF0ZUZ1bmN0aW9uQmxvY2soaXNFbXB0eSA/IFtdIDogc3RhdGVtZW50cyksXG4gICAgICApO1xuICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbnMucHVzaChmdW5jdGlvbkRlY2xhcmF0aW9uKTtcbiAgICB9XG4gICAgdGhpcy50cmFuc2Zvcm1lcnMgPSB7XG4gICAgICBiZWZvcmU6IFtcbiAgICAgICAgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IG5ldyBUcmFuc2Zvcm1lcihcbiAgICAgICAgICAgIHRoaXMudHlwZUNoZWNrZXIsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgcHJvamVjdFJvb3QsXG4gICAgICAgICAgICB0aGlzLmJ1aWxkVHlwZUluZGV4KGFzc2VtYmx5KSxcbiAgICAgICAgICAgIGFzc2VtYmx5LFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybS5iaW5kKHRyYW5zZm9ybWVyKTtcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfTtcbiAgICBnZW5lcmF0ZVdhcm5pbmdzRmlsZShwcm9qZWN0Um9vdCwgZnVuY3Rpb25EZWNsYXJhdGlvbnMpO1xuICB9XG5cbiAgcHVibGljIGdldCBjdXN0b21UcmFuc2Zvcm1lcnMoKTogdHMuQ3VzdG9tVHJhbnNmb3JtZXJzIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1lcnM7XG4gIH1cblxuICBwcml2YXRlIGJ1aWxkVHlwZUluZGV4KGFzc2VtYmx5OiBBc3NlbWJseSk6IE1hcDxzdHJpbmcsIHNwZWMuVHlwZT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXA8c3RyaW5nLCBzcGVjLlR5cGU+KCk7XG5cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgT2JqZWN0LnZhbHVlcyhhc3NlbWJseS50eXBlcyA/PyB7fSkpIHtcbiAgICAgIGNvbnN0IHN5bWJvbElkID0gdHlwZS5zeW1ib2xJZDtcbiAgICAgIGlmIChzeW1ib2xJZCkge1xuICAgICAgICByZXN1bHQuc2V0KHN5bWJvbElkLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJbnRlcmZhY2VUeXBlKFxuICB0eXBlOiBzcGVjLkludGVyZmFjZVR5cGUsXG4gIHR5cGVzOiB7IFtwOiBzdHJpbmddOiBzcGVjLlR5cGUgfSxcbiAgYXNzZW1ibHk6IEFzc2VtYmx5LFxuICBwcm9qZWN0SW5mbzogUHJvamVjdEluZm8sXG4gIHN0YXRlbWVudHNCeVByb3A6IE1hcDxzdHJpbmcsIFN0YXRlbWVudD4gPSBuZXcgTWFwPHN0cmluZywgdHMuU3RhdGVtZW50PigpLFxuICBleGNsdWRlZFByb3BzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQ8c3RyaW5nPigpLFxuKSB7XG4gIGZvciAoY29uc3QgcHJvcCBvZiBPYmplY3QudmFsdWVzKHR5cGUucHJvcGVydGllcyA/PyB7fSkpIHtcbiAgICBjb25zdCBmcW4gPSBgJHt0eXBlLmZxbn0jJHtwcm9wLm5hbWV9YDtcbiAgICBpZiAoc3BlYy5pc0RlcHJlY2F0ZWQocHJvcCkgfHwgc3BlYy5pc0RlcHJlY2F0ZWQodHlwZSkpIHtcbiAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBpbmRpdmlkdWFsbHkgaXMgZGVwcmVjYXRlZCwgb3IgdGhlIGVudGlyZSB0eXBlIGlzIGRlcHJlY2F0ZWRcbiAgICAgIGNvbnN0IGRlcHJlY2F0ZWREb2NzID0gcHJvcC5kb2NzPy5kZXByZWNhdGVkID8/IHR5cGUuZG9jcz8uZGVwcmVjYXRlZDtcbiAgICAgIGNvbnN0IHN0YXRlbWVudCA9IGNyZWF0ZVdhcm5pbmdGdW5jdGlvbkNhbGwoXG4gICAgICAgIGZxbixcbiAgICAgICAgZGVwcmVjYXRlZERvY3MsXG4gICAgICAgIHRzLmNyZWF0ZUlkZW50aWZpZXIoYFwiJHtwcm9wLm5hbWV9XCIgaW4gJHtQQVJBTUVURVJfTkFNRX1gKSxcbiAgICAgICk7XG4gICAgICBzdGF0ZW1lbnRzQnlQcm9wLnNldChwcm9wLm5hbWUsIHN0YXRlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIElmIGEgcHJvcCBpcyBub3QgZGVwcmVjYXRlZCwgd2UgZG9uJ3Qgd2FudCB0byBnZW5lcmF0ZSBhIHdhcm5pbmcgZm9yIGl0LFxuICAgICAgICAgZXZlbiBpZiBhbm90aGVyIHByb3BlcnR5IHdpdGggdGhlIHNhbWUgbmFtZSBpcyBkZXByZWNhdGVkIGluIGFub3RoZXJcbiAgICAgICAgIHN1cGVyLWludGVyZmFjZS4gKi9cbiAgICAgIGV4Y2x1ZGVkUHJvcHMuYWRkKHByb3AubmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgc3BlYy5pc05hbWVkVHlwZVJlZmVyZW5jZShwcm9wLnR5cGUpICYmXG4gICAgICBPYmplY3Qua2V5cyh0eXBlcykuaW5jbHVkZXMocHJvcC50eXBlLmZxbilcbiAgICApIHtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGltcG9ydGVkRnVuY3Rpb25OYW1lKFxuICAgICAgICBwcm9wLnR5cGUuZnFuLFxuICAgICAgICBhc3NlbWJseSxcbiAgICAgICAgcHJvamVjdEluZm8sXG4gICAgICApO1xuICAgICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgICBjb25zdCBzdGF0ZW1lbnQgPSBjcmVhdGVUeXBlSGFuZGxlckNhbGwoXG4gICAgICAgICAgZnVuY3Rpb25OYW1lLFxuICAgICAgICAgIGAke1BBUkFNRVRFUl9OQU1FfS4ke3Byb3AubmFtZX1gLFxuICAgICAgICApO1xuICAgICAgICBzdGF0ZW1lbnRzQnlQcm9wLnNldChgJHtwcm9wLm5hbWV9X2AsIHN0YXRlbWVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNwZWMuaXNDb2xsZWN0aW9uVHlwZVJlZmVyZW5jZShwcm9wLnR5cGUpICYmXG4gICAgICBzcGVjLmlzTmFtZWRUeXBlUmVmZXJlbmNlKHByb3AudHlwZS5jb2xsZWN0aW9uLmVsZW1lbnR0eXBlKVxuICAgICkge1xuICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gaW1wb3J0ZWRGdW5jdGlvbk5hbWUoXG4gICAgICAgIHByb3AudHlwZS5jb2xsZWN0aW9uLmVsZW1lbnR0eXBlLmZxbixcbiAgICAgICAgYXNzZW1ibHksXG4gICAgICAgIHByb2plY3RJbmZvLFxuICAgICAgKTtcbiAgICAgIGlmIChmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgY29uc3Qgc3RhdGVtZW50ID0gY3JlYXRlVHlwZUhhbmRsZXJDYWxsKFxuICAgICAgICAgIGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICBgJHtQQVJBTUVURVJfTkFNRX0uJHtwcm9wLm5hbWV9YCxcbiAgICAgICAgKTtcbiAgICAgICAgc3RhdGVtZW50c0J5UHJvcC5zZXQoYCR7cHJvcC5uYW1lfV9gLCBzdGF0ZW1lbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzcGVjLmlzVW5pb25UeXBlUmVmZXJlbmNlKHByb3AudHlwZSkgJiZcbiAgICAgIHNwZWMuaXNOYW1lZFR5cGVSZWZlcmVuY2UocHJvcC50eXBlLnVuaW9uLnR5cGVzWzBdKSAmJlxuICAgICAgT2JqZWN0LmtleXModHlwZXMpLmluY2x1ZGVzKHByb3AudHlwZS51bmlvbi50eXBlc1swXS5mcW4pXG4gICAgKSB7XG4gICAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBpbXBvcnRlZEZ1bmN0aW9uTmFtZShcbiAgICAgICAgcHJvcC50eXBlLnVuaW9uLnR5cGVzWzBdLmZxbixcbiAgICAgICAgYXNzZW1ibHksXG4gICAgICAgIHByb2plY3RJbmZvLFxuICAgICAgKTtcbiAgICAgIGlmIChmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgY29uc3Qgc3RhdGVtZW50ID0gY3JlYXRlVHlwZUhhbmRsZXJDYWxsKFxuICAgICAgICAgIGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICBgJHtQQVJBTUVURVJfTkFNRX0uJHtwcm9wLm5hbWV9YCxcbiAgICAgICAgKTtcbiAgICAgICAgc3RhdGVtZW50c0J5UHJvcC5zZXQoYCR7cHJvcC5uYW1lfV9gLCBzdGF0ZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFdlIGFsc28gZ2VuZXJhdGUgY2FsbHMgdG8gYWxsIHRoZSBzdXBlcnR5cGVzXG4gIGZvciAoY29uc3QgaW50ZXJmYWNlTmFtZSBvZiB0eXBlLmludGVyZmFjZXMgPz8gW10pIHtcbiAgICBjb25zdCBhc3NlbWJsaWVzID0gcHJvamVjdEluZm8uZGVwZW5kZW5jeUNsb3N1cmUuY29uY2F0KGFzc2VtYmx5KTtcbiAgICBjb25zdCBzdXBlclR5cGUgPSBmaW5kVHlwZShpbnRlcmZhY2VOYW1lLCBhc3NlbWJsaWVzKTtcbiAgICBpZiAoc3VwZXJUeXBlLnR5cGUpIHtcbiAgICAgIHByb2Nlc3NJbnRlcmZhY2VUeXBlKFxuICAgICAgICBzdXBlclR5cGUudHlwZSBhcyBzcGVjLkludGVyZmFjZVR5cGUsXG4gICAgICAgIHR5cGVzLFxuICAgICAgICBhc3NlbWJseSxcbiAgICAgICAgcHJvamVjdEluZm8sXG4gICAgICAgIHN0YXRlbWVudHNCeVByb3AsXG4gICAgICAgIGV4Y2x1ZGVkUHJvcHMsXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBzdGF0ZW1lbnRzQnlQcm9wLCBleGNsdWRlZFByb3BzIH07XG59XG5cbmZ1bmN0aW9uIGZuTmFtZShmcW46IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBmcW4ucmVwbGFjZSgvW15cXHdcXGRdL2csICdfJyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQmxvY2soc3RhdGVtZW50czogU3RhdGVtZW50W10pOiB0cy5CbG9jayB7XG4gIGlmIChzdGF0ZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCB2YWxpZGF0aW9uID0gdHMuY3JlYXRlSWYoXG4gICAgICB0cy5jcmVhdGVJZGVudGlmaWVyKGAke1BBUkFNRVRFUl9OQU1FfSA9PSBudWxsYCksXG4gICAgICB0cy5jcmVhdGVSZXR1cm4oKSxcbiAgICApO1xuICAgIHJldHVybiB0cy5jcmVhdGVCbG9jayhbdmFsaWRhdGlvbiwgLi4uc3RhdGVtZW50c10sIHRydWUpO1xuICB9XG4gIHJldHVybiB0cy5jcmVhdGVCbG9jayhbXSwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhcm5pbmdGdW5jdGlvbkNhbGwoXG4gIGZxbjogc3RyaW5nLFxuICBtZXNzYWdlID0gJycsXG4gIGNvbmRpdGlvbj86IHRzLklkZW50aWZpZXIsXG4gIGluY2x1ZGVOYW1lc3BhY2UgPSBmYWxzZSxcbik6IFN0YXRlbWVudCB7XG4gIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGluY2x1ZGVOYW1lc3BhY2VcbiAgICA/IGAke05BTUVTUEFDRX0uJHtXQVJOSU5HX0ZVTkNUSU9OX05BTUV9YFxuICAgIDogV0FSTklOR19GVU5DVElPTl9OQU1FO1xuXG4gIGNvbnN0IG1haW5TdGF0ZW1lbnQgPSB0cy5jcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50KFxuICAgIHRzLmNyZWF0ZUNhbGwoXG4gICAgICB0cy5jcmVhdGVJZGVudGlmaWVyKGZ1bmN0aW9uTmFtZSksXG4gICAgICBbXSxcbiAgICAgIFt0cy5jcmVhdGVMaXRlcmFsKGZxbiksIHRzLmNyZWF0ZUxpdGVyYWwobWVzc2FnZSldLFxuICAgICksXG4gICk7XG5cbiAgcmV0dXJuIGNvbmRpdGlvbiA/IHRzLmNyZWF0ZUlmKGNvbmRpdGlvbiwgbWFpblN0YXRlbWVudCkgOiBtYWluU3RhdGVtZW50O1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVdhcm5pbmdzRmlsZShcbiAgcHJvamVjdFJvb3Q6IHN0cmluZyxcbiAgZnVuY3Rpb25EZWNsYXJhdGlvbnM6IHRzLkZ1bmN0aW9uRGVjbGFyYXRpb25bXSxcbikge1xuICBjb25zdCBuYW1lcyA9IFsuLi5mdW5jdGlvbkRlY2xhcmF0aW9uc11cbiAgICAubWFwKChkKSA9PiBkLm5hbWU/LnRleHQpXG4gICAgLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3QgZXhwb3J0cyA9IFtXQVJOSU5HX0ZVTkNUSU9OX05BTUUsIC4uLm5hbWVzXS5qb2luKCcsJyk7XG5cbiAgY29uc3QgZnVuY3Rpb25UZXh0ID0gYGZ1bmN0aW9uICR7V0FSTklOR19GVU5DVElPTl9OQU1FfShuYW1lLCBkZXByZWNhdGlvbk1lc3NhZ2UpIHtcbiAgY29uc3QgZGVwcmVjYXRlZCA9IHByb2Nlc3MuZW52LkpTSUlfREVQUkVDQVRFRDtcbiAgY29uc3QgZGVwcmVjYXRpb25Nb2RlID0gWyd3YXJuJywgJ2ZhaWwnLCAncXVpZXQnXS5pbmNsdWRlcyhkZXByZWNhdGVkKSA/IGRlcHJlY2F0ZWQgOiAnd2Fybic7XG4gIGNvbnN0IG1lc3NhZ2UgPSBcXGBcXCR7bmFtZX0gaXMgZGVwcmVjYXRlZC5cXFxcbiAgXFwke2RlcHJlY2F0aW9uTWVzc2FnZX1cXFxcbiAgVGhpcyBBUEkgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXFxgO1xuICBzd2l0Y2ggKGRlcHJlY2F0aW9uTW9kZSkge1xuICAgIGNhc2UgXCJmYWlsXCI6XG4gICAgICB0aHJvdyBuZXcgRGVwcmVjYXRpb25FcnJvcihtZXNzYWdlKTtcbiAgICBjYXNlIFwid2FyblwiOlxuICAgICAgY29uc29sZS53YXJuKFwiW1dBUk5JTkddXCIsIG1lc3NhZ2UpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuY29uc3QgJHtWSVNJVEVEX09CSkVDVFNfU0VUX05BTUV9ID0gbmV3IFNldCgpO1xuXG5jbGFzcyBEZXByZWNhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxubW9kdWxlLmV4cG9ydHMgPSB7JHtleHBvcnRzfX1cbm1vZHVsZS5leHBvcnRzLkRlcHJlY2F0aW9uRXJyb3IgPSBEZXByZWNhdGlvbkVycm9yO1xuYDtcblxuICBjb25zdCBwcmludGVyID0gdHMuY3JlYXRlUHJpbnRlcih7IG5ld0xpbmU6IHRzLk5ld0xpbmVLaW5kLkxpbmVGZWVkIH0pO1xuICBjb25zdCByZXN1bHRGaWxlID0gdHMuY3JlYXRlU291cmNlRmlsZShcbiAgICBwYXRoLmpvaW4ocHJvamVjdFJvb3QsIEZJTEVfTkFNRSksXG4gICAgZnVuY3Rpb25UZXh0LFxuICAgIHRzLlNjcmlwdFRhcmdldC5MYXRlc3QsXG4gICAgZmFsc2UsXG4gICAgdHMuU2NyaXB0S2luZC5KUyxcbiAgKTtcblxuICBjb25zdCBkZWNsYXJhdGlvbnMgPSBmdW5jdGlvbkRlY2xhcmF0aW9ucy5tYXAoKGRlY2xhcmF0aW9uKSA9PlxuICAgIHByaW50ZXIucHJpbnROb2RlKEVtaXRIaW50LlVuc3BlY2lmaWVkLCBkZWNsYXJhdGlvbiwgcmVzdWx0RmlsZSksXG4gICk7XG5cbiAgY29uc3QgY29udGVudCA9IGRlY2xhcmF0aW9ucy5jb25jYXQocHJpbnRlci5wcmludEZpbGUocmVzdWx0RmlsZSkpLmpvaW4oJ1xcbicpO1xuXG4gIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHByb2plY3RSb290LCBGSUxFX05BTUUpLCBjb250ZW50KTtcbn1cblxuY2xhc3MgVHJhbnNmb3JtZXIge1xuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSB0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsXG4gICAgcHJpdmF0ZSByZWFkb25seSBjb250ZXh0OiB0cy5UcmFuc2Zvcm1hdGlvbkNvbnRleHQsXG4gICAgcHJpdmF0ZSByZWFkb25seSBwcm9qZWN0Um9vdDogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdHlwZUluZGV4OiBNYXA8c3RyaW5nLCBzcGVjLlR5cGU+LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYXNzZW1ibHk6IEFzc2VtYmx5LFxuICApIHt9XG5cbiAgcHVibGljIHRyYW5zZm9ybTxUIGV4dGVuZHMgdHMuTm9kZT4obm9kZTogVCk6IFQge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudmlzaXRFYWNoQ2hpbGQobm9kZSk7XG5cbiAgICBpZiAodHMuaXNTb3VyY2VGaWxlKHJlc3VsdCkpIHtcbiAgICAgIGNvbnN0IGltcG9ydERpciA9IHBhdGgucmVsYXRpdmUoXG4gICAgICAgIHBhdGguZGlybmFtZShyZXN1bHQuZmlsZU5hbWUpLFxuICAgICAgICB0aGlzLnByb2plY3RSb290LFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGltcG9ydFBhdGggPSBpbXBvcnREaXIuc3RhcnRzV2l0aCgnLi4nKVxuICAgICAgICA/IHVuaXhQYXRoKHBhdGguam9pbihpbXBvcnREaXIsIEZJTEVfTkFNRSkpXG4gICAgICAgIDogYC4vJHtGSUxFX05BTUV9YDtcblxuICAgICAgcmV0dXJuIHRzLnVwZGF0ZVNvdXJjZUZpbGVOb2RlKHJlc3VsdCwgW1xuICAgICAgICBjcmVhdGVSZXF1aXJlU3RhdGVtZW50KE5BTUVTUEFDRSwgaW1wb3J0UGF0aCksXG4gICAgICAgIC4uLnJlc3VsdC5zdGF0ZW1lbnRzLFxuICAgICAgXSkgYXMgYW55O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJpdmF0ZSB2aXNpdEVhY2hDaGlsZDxUIGV4dGVuZHMgdHMuTm9kZT4obm9kZTogVCk6IFQge1xuICAgIHJldHVybiB0cy52aXNpdEVhY2hDaGlsZChub2RlLCB0aGlzLnZpc2l0b3IuYmluZCh0aGlzKSwgdGhpcy5jb250ZXh0KTtcbiAgfVxuXG4gIHByaXZhdGUgdmlzaXRvcjxUIGV4dGVuZHMgdHMuTm9kZT4obm9kZTogVCk6IHRzLlZpc2l0UmVzdWx0PFQ+IHtcbiAgICBpZiAodHMuaXNNZXRob2REZWNsYXJhdGlvbihub2RlKSAmJiBub2RlLmJvZHkgIT0gbnVsbCkge1xuICAgICAgY29uc3Qgc3RhdGVtZW50cyA9IHRoaXMuZ2V0U3RhdGVtZW50c0ZvckRlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgcmV0dXJuIHRzLnVwZGF0ZU1ldGhvZChcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbm9kZS5kZWNvcmF0b3JzLFxuICAgICAgICBub2RlLm1vZGlmaWVycyxcbiAgICAgICAgbm9kZS5hc3Rlcmlza1Rva2VuLFxuICAgICAgICBub2RlLm5hbWUsXG4gICAgICAgIG5vZGUucXVlc3Rpb25Ub2tlbixcbiAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyxcbiAgICAgICAgbm9kZS5wYXJhbWV0ZXJzLFxuICAgICAgICBub2RlLnR5cGUsXG4gICAgICAgIHRzLnVwZGF0ZUJsb2NrKFxuICAgICAgICAgIG5vZGUuYm9keSxcbiAgICAgICAgICB0cy5jcmVhdGVOb2RlQXJyYXkoWy4uLnN0YXRlbWVudHMsIC4uLm5vZGUuYm9keS5zdGF0ZW1lbnRzXSksXG4gICAgICAgICksXG4gICAgICApIGFzIGFueTtcbiAgICB9IGVsc2UgaWYgKHRzLmlzR2V0QWNjZXNzb3JEZWNsYXJhdGlvbihub2RlKSAmJiBub2RlLmJvZHkgIT0gbnVsbCkge1xuICAgICAgY29uc3Qgc3RhdGVtZW50cyA9IHRoaXMuZ2V0U3RhdGVtZW50c0ZvckRlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgcmV0dXJuIHRzLnVwZGF0ZUdldEFjY2Vzc29yKFxuICAgICAgICBub2RlLFxuICAgICAgICBub2RlLmRlY29yYXRvcnMsXG4gICAgICAgIG5vZGUubW9kaWZpZXJzLFxuICAgICAgICBub2RlLm5hbWUsXG4gICAgICAgIG5vZGUucGFyYW1ldGVycyxcbiAgICAgICAgbm9kZS50eXBlLFxuICAgICAgICB0cy51cGRhdGVCbG9jayhcbiAgICAgICAgICBub2RlLmJvZHksXG4gICAgICAgICAgdHMuY3JlYXRlTm9kZUFycmF5KFsuLi5zdGF0ZW1lbnRzLCAuLi5ub2RlLmJvZHkuc3RhdGVtZW50c10pLFxuICAgICAgICApLFxuICAgICAgKSBhcyBhbnk7XG4gICAgfSBlbHNlIGlmICh0cy5pc1NldEFjY2Vzc29yRGVjbGFyYXRpb24obm9kZSkgJiYgbm9kZS5ib2R5ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHN0YXRlbWVudHMgPSB0aGlzLmdldFN0YXRlbWVudHNGb3JEZWNsYXJhdGlvbihub2RlKTtcbiAgICAgIHJldHVybiB0cy51cGRhdGVTZXRBY2Nlc3NvcihcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbm9kZS5kZWNvcmF0b3JzLFxuICAgICAgICBub2RlLm1vZGlmaWVycyxcbiAgICAgICAgbm9kZS5uYW1lLFxuICAgICAgICBub2RlLnBhcmFtZXRlcnMsXG4gICAgICAgIHRzLnVwZGF0ZUJsb2NrKFxuICAgICAgICAgIG5vZGUuYm9keSxcbiAgICAgICAgICB0cy5jcmVhdGVOb2RlQXJyYXkoWy4uLnN0YXRlbWVudHMsIC4uLm5vZGUuYm9keS5zdGF0ZW1lbnRzXSksXG4gICAgICAgICksXG4gICAgICApIGFzIGFueTtcbiAgICB9IGVsc2UgaWYgKHRzLmlzQ29uc3RydWN0b3JEZWNsYXJhdGlvbihub2RlKSAmJiBub2RlLmJvZHkgIT0gbnVsbCkge1xuICAgICAgY29uc3Qgc3RhdGVtZW50cyA9IHRoaXMuZ2V0U3RhdGVtZW50c0ZvckRlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgcmV0dXJuIHRzLnVwZGF0ZUNvbnN0cnVjdG9yKFxuICAgICAgICBub2RlLFxuICAgICAgICBub2RlLmRlY29yYXRvcnMsXG4gICAgICAgIG5vZGUubW9kaWZpZXJzLFxuICAgICAgICBub2RlLnBhcmFtZXRlcnMsXG4gICAgICAgIHRzLnVwZGF0ZUJsb2NrKG5vZGUuYm9keSwgaW5zZXJ0U3RhdGVtZW50cyhub2RlLmJvZHksIHN0YXRlbWVudHMpKSxcbiAgICAgICkgYXMgYW55O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnZpc2l0RWFjaENoaWxkKG5vZGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRTdGF0ZW1lbnRzRm9yRGVjbGFyYXRpb24oXG4gICAgbm9kZTpcbiAgICAgIHwgdHMuTWV0aG9kRGVjbGFyYXRpb25cbiAgICAgIHwgdHMuR2V0QWNjZXNzb3JEZWNsYXJhdGlvblxuICAgICAgfCB0cy5TZXRBY2Nlc3NvckRlY2xhcmF0aW9uXG4gICAgICB8IHRzLkNvbnN0cnVjdG9yRGVjbGFyYXRpb24sXG4gICk6IHRzLlN0YXRlbWVudFtdIHtcbiAgICBjb25zdCBrbGFzcyA9IG5vZGUucGFyZW50O1xuICAgIGNvbnN0IGNsYXNzU3ltYm9sSWQgPSBzeW1ib2xJZGVudGlmaWVyKFxuICAgICAgdGhpcy50eXBlQ2hlY2tlcixcbiAgICAgIHRoaXMudHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24oa2xhc3MpLnN5bWJvbCxcbiAgICApO1xuICAgIGlmIChjbGFzc1N5bWJvbElkICYmIHRoaXMudHlwZUluZGV4LmhhcyhjbGFzc1N5bWJvbElkKSkge1xuICAgICAgY29uc3QgY2xhc3NUeXBlID0gdGhpcy50eXBlSW5kZXguZ2V0KGNsYXNzU3ltYm9sSWQpISBhcyBzcGVjLkNsYXNzVHlwZTtcblxuICAgICAgaWYgKHRzLmlzQ29uc3RydWN0b3JEZWNsYXJhdGlvbihub2RlKSkge1xuICAgICAgICBjb25zdCBpbml0aWFsaXplciA9IGNsYXNzVHlwZT8uaW5pdGlhbGl6ZXI7XG4gICAgICAgIGlmIChpbml0aWFsaXplcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlbWVudHMoY2xhc3NUeXBlLCBpbml0aWFsaXplcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgbWV0aG9kcyA9IGNsYXNzVHlwZT8ubWV0aG9kcyA/PyBbXTtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IG1ldGhvZHMuZmluZChcbiAgICAgICAgKG1ldGhvZCkgPT4gbWV0aG9kLm5hbWUgPT09IG5vZGUubmFtZT8uZ2V0VGV4dCgpLFxuICAgICAgKTtcbiAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGVtZW50cyhjbGFzc1R5cGUsIG1ldGhvZCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBjbGFzc1R5cGU/LnByb3BlcnRpZXMgPz8gW107XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IHByb3BlcnRpZXMuZmluZChcbiAgICAgICAgKHByb3BlcnR5KSA9PiBwcm9wZXJ0eS5uYW1lID09PSBub2RlLm5hbWU/LmdldFRleHQoKSxcbiAgICAgICk7XG4gICAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVdhcm5pbmdTdGF0ZW1lbnRGb3JFbGVtZW50KHByb3BlcnR5LCBjbGFzc1R5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBwcml2YXRlIGdldFN0YXRlbWVudHMoXG4gICAgY2xhc3NUeXBlOiBzcGVjLkNsYXNzVHlwZSxcbiAgICBtZXRob2Q6IHNwZWMuTWV0aG9kIHwgc3BlYy5Jbml0aWFsaXplcixcbiAgKSB7XG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IGNyZWF0ZVdhcm5pbmdTdGF0ZW1lbnRGb3JFbGVtZW50KG1ldGhvZCwgY2xhc3NUeXBlKTtcblxuICAgIGZvciAoY29uc3QgcGFyYW1ldGVyIG9mIE9iamVjdC52YWx1ZXMobWV0aG9kLnBhcmFtZXRlcnMgPz8ge30pKSB7XG4gICAgICBjb25zdCBwYXJhbWV0ZXJUeXBlID1cbiAgICAgICAgdGhpcy5hc3NlbWJseS50eXBlcyAmJiBzcGVjLmlzTmFtZWRUeXBlUmVmZXJlbmNlKHBhcmFtZXRlci50eXBlKVxuICAgICAgICAgID8gdGhpcy5hc3NlbWJseS50eXBlc1twYXJhbWV0ZXIudHlwZS5mcW5dXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChwYXJhbWV0ZXJUeXBlKSB7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke05BTUVTUEFDRX0uJHtmbk5hbWUocGFyYW1ldGVyVHlwZS5mcW4pfWA7XG4gICAgICAgIHN0YXRlbWVudHMucHVzaChcbiAgICAgICAgICB0cy5jcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50KFxuICAgICAgICAgICAgdHMuY3JlYXRlQ2FsbChcbiAgICAgICAgICAgICAgdHMuY3JlYXRlSWRlbnRpZmllcihmdW5jdGlvbk5hbWUpLFxuICAgICAgICAgICAgICBbXSxcbiAgICAgICAgICAgICAgW3RzLmNyZWF0ZUlkZW50aWZpZXIocGFyYW1ldGVyLm5hbWUpXSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGVtZW50cztcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXJuaW5nU3RhdGVtZW50Rm9yRWxlbWVudChcbiAgZWxlbWVudDogc3BlYy5DYWxsYWJsZSB8IHNwZWMuUHJvcGVydHksXG4gIGNsYXNzVHlwZTogc3BlYy5DbGFzc1R5cGUsXG4pOiB0cy5TdGF0ZW1lbnRbXSB7XG4gIGlmIChzcGVjLmlzRGVwcmVjYXRlZChlbGVtZW50KSkge1xuICAgIGNvbnN0IGVsZW1lbnROYW1lID0gKGVsZW1lbnQgYXMgc3BlYy5NZXRob2QgfCBzcGVjLlByb3BlcnR5KS5uYW1lO1xuICAgIGNvbnN0IGZxbiA9IGVsZW1lbnROYW1lID8gYCR7Y2xhc3NUeXBlLmZxbn0jJHtlbGVtZW50TmFtZX1gIDogY2xhc3NUeXBlLmZxbjtcbiAgICByZXR1cm4gW1xuICAgICAgY3JlYXRlV2FybmluZ0Z1bmN0aW9uQ2FsbChmcW4sIGVsZW1lbnQuZG9jcz8uZGVwcmVjYXRlZCwgdW5kZWZpbmVkLCB0cnVlKSxcbiAgICBdO1xuICB9XG4gIHJldHVybiBbXTtcbn1cblxuLyoqXG4gKiBJbnNlcnRzIGEgbGlzdCBvZiBzdGF0ZW1lbnRzIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGluc2lkZSBhIGJsb2NrIG9mIHN0YXRlbWVudHMuXG4gKiBJZiB0aGVyZSBpcyBhIGBzdXBlcmAgY2FsbCwgSXQgaW5zZXJ0cyB0aGUgc3RhdGVtZW50cyBqdXN0IGFmdGVyIGl0LiBPdGhlcndpc2UsXG4gKiBpbnNlcnQgdGhlIHN0YXRlbWVudHMgcmlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYmxvY2suXG4gKi9cbmZ1bmN0aW9uIGluc2VydFN0YXRlbWVudHMoYmxvY2s6IHRzLkJsb2NrLCBuZXdTdGF0ZW1lbnRzOiB0cy5TdGF0ZW1lbnRbXSkge1xuICBmdW5jdGlvbiBzcGxpY2VQb2ludChzdGF0ZW1lbnQ6IHRzLlN0YXRlbWVudCB8IHVuZGVmaW5lZCkge1xuICAgIGlmIChzdGF0ZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGxldCBpc1N1cGVyID0gZmFsc2U7XG4gICAgc3RhdGVtZW50LmZvckVhY2hDaGlsZCgobm9kZSkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICB0cy5pc0NhbGxFeHByZXNzaW9uKG5vZGUpICYmXG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbi5raW5kID09PSB0cy5TeW50YXhLaW5kLlN1cGVyS2V5d29yZFxuICAgICAgKSB7XG4gICAgICAgIGlzU3VwZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpc1N1cGVyID8gMSA6IDA7XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSBbLi4uYmxvY2suc3RhdGVtZW50c107XG4gIHJlc3VsdC5zcGxpY2Uoc3BsaWNlUG9pbnQoYmxvY2suc3RhdGVtZW50c1swXSksIDAsIC4uLm5ld1N0YXRlbWVudHMpO1xuICByZXR1cm4gdHMuY3JlYXRlTm9kZUFycmF5KHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVudW1SZXF1aXJlU3RhdGVtZW50KHR5cGVMb2NhdGlvbjogc3RyaW5nKTogdHMuU3RhdGVtZW50IHtcbiAgY29uc3QgeyBleHQgfSA9IHBhdGgucGFyc2UodHlwZUxvY2F0aW9uKTtcbiAgY29uc3QganNGaWxlTmFtZSA9IHR5cGVMb2NhdGlvbi5yZXBsYWNlKGV4dCwgJy5qcycpO1xuXG4gIHJldHVybiBjcmVhdGVSZXF1aXJlU3RhdGVtZW50KExPQ0FMX0VOVU1fTkFNRVNQQUNFLCBgLi8ke2pzRmlsZU5hbWV9YCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVpcmVTdGF0ZW1lbnQoXG4gIG5hbWU6IHN0cmluZyxcbiAgaW1wb3J0UGF0aDogc3RyaW5nLFxuKTogdHMuU3RhdGVtZW50IHtcbiAgcmV0dXJuIHRzLmNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50KFxuICAgIHVuZGVmaW5lZCxcbiAgICB0cy5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChcbiAgICAgIFtcbiAgICAgICAgdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbihcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICB0cy5jcmVhdGVDYWxsKHRzLmNyZWF0ZUlkZW50aWZpZXIoJ3JlcXVpcmUnKSwgdW5kZWZpbmVkLCBbXG4gICAgICAgICAgICB0cy5jcmVhdGVMaXRlcmFsKGltcG9ydFBhdGgpLFxuICAgICAgICAgIF0pLFxuICAgICAgICApLFxuICAgICAgXSxcbiAgICAgIHRzLk5vZGVGbGFncy5Db25zdCxcbiAgICApLFxuICApO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByZWFkeS10by11c2VkIGZ1bmN0aW9uIG5hbWUgKGluY2x1ZGluZyBhIGByZXF1aXJlYCwgaWYgbmVjZXNzYXJ5KVxuICovXG5mdW5jdGlvbiBpbXBvcnRlZEZ1bmN0aW9uTmFtZShcbiAgdHlwZU5hbWU6IHN0cmluZyxcbiAgYXNzZW1ibHk6IEFzc2VtYmx5LFxuICBwcm9qZWN0SW5mbzogUHJvamVjdEluZm8sXG4pIHtcbiAgY29uc3QgYXNzZW1ibGllcyA9IHByb2plY3RJbmZvLmRlcGVuZGVuY3lDbG9zdXJlLmNvbmNhdChhc3NlbWJseSk7XG4gIGNvbnN0IHsgdHlwZSwgbW9kdWxlTmFtZSB9ID0gZmluZFR5cGUodHlwZU5hbWUsIGFzc2VtYmxpZXMpO1xuICBpZiAodHlwZSkge1xuICAgIHJldHVybiBtb2R1bGVOYW1lICE9PSBhc3NlbWJseS5uYW1lXG4gICAgICA/IGByZXF1aXJlKFwiJHttb2R1bGVOYW1lfS8ke0ZJTEVfTkFNRX1cIikuJHtmbk5hbWUodHlwZS5mcW4pfWBcbiAgICAgIDogZm5OYW1lKHR5cGUuZnFuKTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEZpbmQgdGhlIHR5cGUgYW5kIG1vZHVsZSBuYW1lIGluIGFuIGFycmF5IG9mIGFzc2VtYmxpZXNcbiAqIG1hdGNoaW5nIGEgZ2l2ZW4gdHlwZSBuYW1lXG4gKi9cbmZ1bmN0aW9uIGZpbmRUeXBlKHR5cGVOYW1lOiBzdHJpbmcsIGFzc2VtYmxpZXM6IEFzc2VtYmx5W10pIHtcbiAgZm9yIChjb25zdCBhc20gb2YgYXNzZW1ibGllcykge1xuICAgIGlmIChhc20ubWV0YWRhdGE/LmpzaWk/LmNvbXBpbGVkV2l0aERlcHJlY2F0aW9uV2FybmluZ3MpIHtcbiAgICAgIGNvbnN0IHR5cGVzID0gYXNtLnR5cGVzID8/IHt9O1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKHR5cGVzKSkge1xuICAgICAgICBpZiAodHlwZU5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiB0eXBlc1tuYW1lXSwgbW9kdWxlTmFtZTogYXNtLm5hbWUgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVIYW5kbGVyQ2FsbChcbiAgZnVuY3Rpb25OYW1lOiBzdHJpbmcsXG4gIHBhcmFtZXRlcjogc3RyaW5nLFxuKTogU3RhdGVtZW50IHtcbiAgcmV0dXJuIHRzLmNyZWF0ZUlmKFxuICAgIHRzLmNyZWF0ZUlkZW50aWZpZXIoYCEke1ZJU0lURURfT0JKRUNUU19TRVRfTkFNRX0uaGFzKCR7cGFyYW1ldGVyfSlgKSxcbiAgICB0cy5jcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50KFxuICAgICAgdHMuY3JlYXRlQ2FsbChcbiAgICAgICAgdHMuY3JlYXRlSWRlbnRpZmllcihmdW5jdGlvbk5hbWUpLFxuICAgICAgICBbXSxcbiAgICAgICAgW3RzLmNyZWF0ZUlkZW50aWZpZXIocGFyYW1ldGVyKV0sXG4gICAgICApLFxuICAgICksXG4gICk7XG59XG5cbi8qKlxuICogVGhlcmUgaXMgYSBjaGFuY2UgYW4gZW51bSBjb250YWlucyBkdXBsaWNhdGVzIHZhbHVlcyB3aXRoIGRpc3RpbmN0IGtleXMsXG4gKiB3aXRoIG9uZSBvZiB0aG9zZSBrZXlzIGJlaW5nIGRlcHJlY2F0ZWQuIFRoaXMgaXMgYSBwb3RlbnRpYWwgcGF0dGVybiB0byBcInJlbmFtZVwiIGFuIGVudW0uXG4gKiBJbiB0aGlzIGNhc2UsIHdlIGNhbid0IGNvbmNyZXRlbHkgZGV0ZXJtaW5lIGlmIHRoZSBkZXByZWNhdGVkIG1lbWJlciB3YXMgdXNlZCBvciBub3QsXG4gKiBzbyBpbiB0aG9zZSBjYXNlcyB3ZSBza2lwIHRoZSB3YXJuaW5ncyBhbHRvZ2V0aGVyLCByYXRoZXIgdGhhbiBlcnJvbmVvdXNseSB3YXJuaW5nIGZvciB2YWxpZCB1c2FnZS5cbiAqIFRoaXMgY3JlYXRlIGEgc3RhdGVtZW50IHRvIGNoZWNrIGlmIHRoZSBlbnVtIHZhbHVlIGlzIGEgZHVwbGljYXRlOlxuICpcbiAqIGlmIChPYmplY3QudmFsdWVzKEZvbykuZmlsdGVyKHggPT4geCA9PT0gcCkubGVuZ3RoID4gMSkgeyByZXR1cm47IH1cbiAqXG4gKiBOb3RlIHRoYXQgd2UgY2FuJ3QganVzdCBjaGVjayB0aGUgYXNzZW1ibHkgZm9yIHRoZXNlIGR1cGxpY2F0ZXMsIGR1ZSB0bzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvanNpaS9pc3N1ZXMvMjc4MlxuICovXG5mdW5jdGlvbiBjcmVhdGVEdXBsaWNhdGVFbnVtVmFsdWVzQ2hlY2soXG4gIHR5cGU6IHNwZWMuVHlwZUJhc2UgJiBzcGVjLkVudW1UeXBlLFxuKTogdHMuU3RhdGVtZW50IHtcbiAgcmV0dXJuIHRzLmNyZWF0ZUlmKFxuICAgIHRzLmNyZWF0ZUJpbmFyeShcbiAgICAgIHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKFxuICAgICAgICB0cy5jcmVhdGVDYWxsKFxuICAgICAgICAgIHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKFxuICAgICAgICAgICAgdHMuY3JlYXRlQ2FsbCh0cy5jcmVhdGVJZGVudGlmaWVyKCdPYmplY3QudmFsdWVzJyksIHVuZGVmaW5lZCwgW1xuICAgICAgICAgICAgICB0cy5jcmVhdGVJZGVudGlmaWVyKGAke0xPQ0FMX0VOVU1fTkFNRVNQQUNFfS4ke3R5cGUubmFtZX1gKSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgdHMuY3JlYXRlSWRlbnRpZmllcignZmlsdGVyJyksXG4gICAgICAgICAgKSxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgW1xuICAgICAgICAgICAgdHMuY3JlYXRlQXJyb3dGdW5jdGlvbihcbiAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIFt0cy5jcmVhdGVQYXJhbWV0ZXIodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgJ3gnKV0sXG4gICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgdHMuY3JlYXRlVG9rZW4odHMuU3ludGF4S2luZC5FcXVhbHNHcmVhdGVyVGhhblRva2VuKSxcbiAgICAgICAgICAgICAgdHMuY3JlYXRlQmluYXJ5KFxuICAgICAgICAgICAgICAgIHRzLmNyZWF0ZUlkZW50aWZpZXIoJ3gnKSxcbiAgICAgICAgICAgICAgICB0cy5jcmVhdGVUb2tlbih0cy5TeW50YXhLaW5kLkVxdWFsc0VxdWFsc0VxdWFsc1Rva2VuKSxcbiAgICAgICAgICAgICAgICB0cy5jcmVhdGVJZGVudGlmaWVyKFBBUkFNRVRFUl9OQU1FKSxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgXSxcbiAgICAgICAgKSxcbiAgICAgICAgdHMuY3JlYXRlSWRlbnRpZmllcignbGVuZ3RoJyksXG4gICAgICApLFxuICAgICAgdHMuY3JlYXRlVG9rZW4odHMuU3ludGF4S2luZC5HcmVhdGVyVGhhblRva2VuKSxcbiAgICAgIHRzLmNyZWF0ZU51bWVyaWNMaXRlcmFsKCcxJyksXG4gICAgKSxcbiAgICB0cy5jcmVhdGVSZXR1cm4oKSxcbiAgKTtcbn1cblxuLyoqXG4gKiBGb3JjZSBhIHBhdGggdG8gYmUgVU5JWHkgKHVzZSBgL2AgYXMgYSBzZXBhcmF0b3IpXG4gKlxuICogYHBhdGguam9pbigpYCBldGMuIHdpbGwgdXNlIHRoZSBzeXN0ZW0tZGVwZW5kZW50IHBhdGggc2VwYXJhdG9yIChlaXRoZXIgYC9gIG9yIGBcXGBcbiAqIGRlcGVuZGluZyBvbiB5b3VyIHBsYXRmb3JtKS5cbiAqXG4gKiBIb3dldmVyLCBpZiB3ZSBhY3R1YWxseSBlbWl0IHRoZSBwYXRoLWRlcGVuZGVudCBzZXBhcmF0b3IgdG8gdGhlIGAuanNgIGZpbGVzLCB0aGVuXG4gKiBmaWxlcyBjb21waWxlZCB3aXRoIGpzaWkgb24gV2luZG93cyBjYW5ub3QgYmUgdXNlZCBvbiBhbnkgb3RoZXIgcGxhdGZvcm0uIFRoYXQgc2VlbXNcbiAqIGxpa2UgYW4gdW5uZWNlc3NhcnkgcmVzdHJpY3Rpb24sIGVzcGVjaWFsbHkgc2luY2UgYSBgL2Agd2lsbCB3b3JrIGZpbmUgb24gV2luZG93cyxcbiAqIHNvIG1ha2Ugc3VyZSB0byBhbHdheXMgZW1pdCBgL2AuXG4gKlxuICogVFNDIGl0c2VsZiBhbHdheXMgc3RyaWN0bHkgZW1pdHMgYC9gIChvciBhdCBsZWFzdCwgZW1pdHMgdGhlIHNhbWUgd2hhdCB5b3UgcHV0IGluKS5cbiAqL1xuZnVuY3Rpb24gdW5peFBhdGgoZmlsZVBhdGg6IHN0cmluZykge1xuICBpZiAocGF0aC5zZXAgPT09ICdcXFxcJykge1xuICAgIHJldHVybiBmaWxlUGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gIH1cbiAgcmV0dXJuIGZpbGVQYXRoO1xufVxuIl19