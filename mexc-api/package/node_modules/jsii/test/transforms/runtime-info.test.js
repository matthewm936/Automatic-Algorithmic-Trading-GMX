"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const runtime_info_1 = require("../../lib/transforms/runtime-info");
test('leaves files without classes unaltered', () => {
    expect(transformedSource(EXAMPLE_NO_CLASS, 'Foo')).not.toContain('JSII_RTTI_SYMBOL');
});
test('leaves files without classes with metadata unaltered', () => {
    expect(transformedSource(EXAMPLE_SINGLE_CLASS)).not.toContain('JSII_RTTI_SYMBOL');
});
test('adds jsii.rtti symbol at the top of each file when classes are present', () => {
    expect(transformedSource(EXAMPLE_SINGLE_CLASS, 'Foo')).toContain('const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");');
});
test('adds runtime info for a class', () => {
    expect(transformedSource(EXAMPLE_SINGLE_CLASS, 'Foo')).toContain('private static readonly [JSII_RTTI_SYMBOL_1] = { fqn: "RuntimeInfoTest.Foo", version: "1.2.3" }');
});
test('adds runtime info for each class', () => {
    const transformed = transformedSource(EXAMPLE_MULTIPLE_CLASSES, 'Foo', 'Bar');
    expect(transformed).toContain('private static readonly [JSII_RTTI_SYMBOL_1] = { fqn: "RuntimeInfoTest.Foo", version: "1.2.3" }');
    expect(transformed).toContain('private static readonly [JSII_RTTI_SYMBOL_1] = { fqn: "RuntimeInfoTest.Bar", version: "1.2.3" }');
});
test('skips runtime info if not available', () => {
    const transformed = transformedSource(EXAMPLE_MULTIPLE_CLASSES, 'Foo');
    expect(transformed).toContain('private static readonly [JSII_RTTI_SYMBOL_1] = { fqn: "RuntimeInfoTest.Foo", version: "1.2.3" }');
    expect(transformed).not.toContain('private static readonly [JSII_RTTI_SYMBOL_1] = { fqn: "RuntimeInfoTest.Bar", version: "1.2.3" }');
});
test('creates a unique name if the default is taken', () => {
    // Conflicting example has existing variable for JSII_RTTI_SYMBOL_1, so transformation should use _2.
    const transformed = transformedSource(EXAMPLE_CONFLICTING_NAME, 'Foo');
    expect(transformed).toContain('const JSII_RTTI_SYMBOL_2 = Symbol.for("jsii.rtti");');
    expect(transformed).toContain('private static readonly [JSII_RTTI_SYMBOL_2] = { fqn: "RuntimeInfoTest.Foo", version: "1.2.3" }');
});
function transformedSource(source, ...classNames) {
    const mockedTypeInfo = mockedTypeInfoForClasses(...classNames);
    const injector = new TestRuntimeTypeInfoInjector(mockedTypeInfo);
    const transformed = ts.transform(ts.createSourceFile('source.ts', source, ts.ScriptTarget.Latest), [injector.runtimeTypeTransformer()]);
    return ts
        .createPrinter()
        .printBundle(ts.createBundle(transformed.transformed));
}
/** Test subclass of RuntimeTypeInfoInjector that accepts overrides for type info */
class TestRuntimeTypeInfoInjector extends runtime_info_1.RuntimeTypeInfoInjector {
    constructor(typeInfo) {
        super('1.2.3');
        this.typeInfo = typeInfo;
    }
    getClassFqn(clazz) {
        return clazz.name ? this.typeInfo.get(clazz.name.text) : undefined;
    }
}
/**
 * Mock the Map<ts.ClassDefinition, string> of classes to fqns.
 * This assumes each class name only appears once in the source,
 * which is a reasonable assumption for these tests.
 */
function mockedTypeInfoForClasses(...classNames) {
    const typeInfoMap = new Map();
    classNames.forEach((clazz) => typeInfoMap.set(clazz, `RuntimeInfoTest.${clazz}`));
    return typeInfoMap;
}
/**
 * ===============================
 * =    EXAMPLE SOURCE FILES     =
 * ===============================
 */
const EXAMPLE_NO_CLASS = `
import * as ts from 'typescript';

interface Foo {
  readonly foobar: string;
}
`;
const EXAMPLE_SINGLE_CLASS = `
import * as ts from 'typescript';

class Foo {
  constructor(public readonly bar: string) {}
}
`;
const EXAMPLE_MULTIPLE_CLASSES = `
class Foo {
  constructor(public readonly bar: string) {}
  public doStuff() { return 42; }
}

interface FooBar {
  readonly answer: number;
}

/**
 * A bar.
 */
class Bar {
  public doStuffToo() {
    return new class implements FooBar {
      public readonly answer = 21;
    }();
  }
}

export default class {
  constructor() {}
}
`;
const EXAMPLE_CONFLICTING_NAME = `
import * as ts from 'typescript';

const JSII_RTTI_SYMBOL_1 = 42;

class Foo {
  constructor(public readonly bar: string) {}
}
`;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicnVudGltZS1pbmZvLnRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJydW50aW1lLWluZm8udGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLGlDQUFpQztBQUVqQyxvRUFBNEU7QUFFNUUsSUFBSSxDQUFDLHdDQUF3QyxFQUFFLEdBQUcsRUFBRTtJQUNsRCxNQUFNLENBQUMsaUJBQWlCLENBQUMsZ0JBQWdCLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUM5RCxrQkFBa0IsQ0FDbkIsQ0FBQztBQUNKLENBQUMsQ0FBQyxDQUFDO0FBRUgsSUFBSSxDQUFDLHNEQUFzRCxFQUFFLEdBQUcsRUFBRTtJQUNoRSxNQUFNLENBQUMsaUJBQWlCLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQzNELGtCQUFrQixDQUNuQixDQUFDO0FBQ0osQ0FBQyxDQUFDLENBQUM7QUFFSCxJQUFJLENBQUMsd0VBQXdFLEVBQUUsR0FBRyxFQUFFO0lBQ2xGLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxvQkFBb0IsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FDOUQscURBQXFELENBQ3RELENBQUM7QUFDSixDQUFDLENBQUMsQ0FBQztBQUVILElBQUksQ0FBQywrQkFBK0IsRUFBRSxHQUFHLEVBQUU7SUFDekMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLG9CQUFvQixFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUM5RCxpR0FBaUcsQ0FDbEcsQ0FBQztBQUNKLENBQUMsQ0FBQyxDQUFDO0FBRUgsSUFBSSxDQUFDLGtDQUFrQyxFQUFFLEdBQUcsRUFBRTtJQUM1QyxNQUFNLFdBQVcsR0FBRyxpQkFBaUIsQ0FBQyx3QkFBd0IsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDOUUsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLFNBQVMsQ0FDM0IsaUdBQWlHLENBQ2xHLENBQUM7SUFDRixNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsU0FBUyxDQUMzQixpR0FBaUcsQ0FDbEcsQ0FBQztBQUNKLENBQUMsQ0FBQyxDQUFDO0FBRUgsSUFBSSxDQUFDLHFDQUFxQyxFQUFFLEdBQUcsRUFBRTtJQUMvQyxNQUFNLFdBQVcsR0FBRyxpQkFBaUIsQ0FBQyx3QkFBd0IsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN2RSxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsU0FBUyxDQUMzQixpR0FBaUcsQ0FDbEcsQ0FBQztJQUNGLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUMvQixpR0FBaUcsQ0FDbEcsQ0FBQztBQUNKLENBQUMsQ0FBQyxDQUFDO0FBRUgsSUFBSSxDQUFDLCtDQUErQyxFQUFFLEdBQUcsRUFBRTtJQUN6RCxxR0FBcUc7SUFDckcsTUFBTSxXQUFXLEdBQUcsaUJBQWlCLENBQUMsd0JBQXdCLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDdkUsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLFNBQVMsQ0FDM0IscURBQXFELENBQ3RELENBQUM7SUFDRixNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsU0FBUyxDQUMzQixpR0FBaUcsQ0FDbEcsQ0FBQztBQUNKLENBQUMsQ0FBQyxDQUFDO0FBRUgsU0FBUyxpQkFBaUIsQ0FBQyxNQUFjLEVBQUUsR0FBRyxVQUFvQjtJQUNoRSxNQUFNLGNBQWMsR0FBRyx3QkFBd0IsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDO0lBQy9ELE1BQU0sUUFBUSxHQUFHLElBQUksMkJBQTJCLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDakUsTUFBTSxXQUFXLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FDOUIsRUFBRSxDQUFDLGdCQUFnQixDQUFDLFdBQVcsRUFBRSxNQUFNLEVBQUUsRUFBRSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsRUFDaEUsQ0FBQyxRQUFRLENBQUMsc0JBQXNCLEVBQUUsQ0FBQyxDQUNwQyxDQUFDO0lBQ0YsT0FBTyxFQUFFO1NBQ04sYUFBYSxFQUFFO1NBQ2YsV0FBVyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7QUFDM0QsQ0FBQztBQUVELG9GQUFvRjtBQUNwRixNQUFNLDJCQUE0QixTQUFRLHNDQUF1QjtJQUMvRCxZQUFvQyxRQUE2QjtRQUMvRCxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFEbUIsYUFBUSxHQUFSLFFBQVEsQ0FBcUI7SUFFakUsQ0FBQztJQUVTLFdBQVcsQ0FBQyxLQUEwQjtRQUM5QyxPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztJQUNyRSxDQUFDO0NBQ0Y7QUFFRDs7OztHQUlHO0FBQ0gsU0FBUyx3QkFBd0IsQ0FDL0IsR0FBRyxVQUFvQjtJQUV2QixNQUFNLFdBQVcsR0FBRyxJQUFJLEdBQUcsRUFBa0IsQ0FBQztJQUM5QyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FDM0IsV0FBVyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsbUJBQW1CLEtBQUssRUFBRSxDQUFDLENBQ25ELENBQUM7SUFDRixPQUFPLFdBQVcsQ0FBQztBQUNyQixDQUFDO0FBRUQ7Ozs7R0FJRztBQUVILE1BQU0sZ0JBQWdCLEdBQUc7Ozs7OztDQU14QixDQUFDO0FBRUYsTUFBTSxvQkFBb0IsR0FBRzs7Ozs7O0NBTTVCLENBQUM7QUFFRixNQUFNLHdCQUF3QixHQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F3QmhDLENBQUM7QUFFRixNQUFNLHdCQUF3QixHQUFHOzs7Ozs7OztDQVFoQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7IFJ1bnRpbWVUeXBlSW5mb0luamVjdG9yIH0gZnJvbSAnLi4vLi4vbGliL3RyYW5zZm9ybXMvcnVudGltZS1pbmZvJztcblxudGVzdCgnbGVhdmVzIGZpbGVzIHdpdGhvdXQgY2xhc3NlcyB1bmFsdGVyZWQnLCAoKSA9PiB7XG4gIGV4cGVjdCh0cmFuc2Zvcm1lZFNvdXJjZShFWEFNUExFX05PX0NMQVNTLCAnRm9vJykpLm5vdC50b0NvbnRhaW4oXG4gICAgJ0pTSUlfUlRUSV9TWU1CT0wnLFxuICApO1xufSk7XG5cbnRlc3QoJ2xlYXZlcyBmaWxlcyB3aXRob3V0IGNsYXNzZXMgd2l0aCBtZXRhZGF0YSB1bmFsdGVyZWQnLCAoKSA9PiB7XG4gIGV4cGVjdCh0cmFuc2Zvcm1lZFNvdXJjZShFWEFNUExFX1NJTkdMRV9DTEFTUykpLm5vdC50b0NvbnRhaW4oXG4gICAgJ0pTSUlfUlRUSV9TWU1CT0wnLFxuICApO1xufSk7XG5cbnRlc3QoJ2FkZHMganNpaS5ydHRpIHN5bWJvbCBhdCB0aGUgdG9wIG9mIGVhY2ggZmlsZSB3aGVuIGNsYXNzZXMgYXJlIHByZXNlbnQnLCAoKSA9PiB7XG4gIGV4cGVjdCh0cmFuc2Zvcm1lZFNvdXJjZShFWEFNUExFX1NJTkdMRV9DTEFTUywgJ0ZvbycpKS50b0NvbnRhaW4oXG4gICAgJ2NvbnN0IEpTSUlfUlRUSV9TWU1CT0xfMSA9IFN5bWJvbC5mb3IoXCJqc2lpLnJ0dGlcIik7JyxcbiAgKTtcbn0pO1xuXG50ZXN0KCdhZGRzIHJ1bnRpbWUgaW5mbyBmb3IgYSBjbGFzcycsICgpID0+IHtcbiAgZXhwZWN0KHRyYW5zZm9ybWVkU291cmNlKEVYQU1QTEVfU0lOR0xFX0NMQVNTLCAnRm9vJykpLnRvQ29udGFpbihcbiAgICAncHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgW0pTSUlfUlRUSV9TWU1CT0xfMV0gPSB7IGZxbjogXCJSdW50aW1lSW5mb1Rlc3QuRm9vXCIsIHZlcnNpb246IFwiMS4yLjNcIiB9JyxcbiAgKTtcbn0pO1xuXG50ZXN0KCdhZGRzIHJ1bnRpbWUgaW5mbyBmb3IgZWFjaCBjbGFzcycsICgpID0+IHtcbiAgY29uc3QgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm1lZFNvdXJjZShFWEFNUExFX01VTFRJUExFX0NMQVNTRVMsICdGb28nLCAnQmFyJyk7XG4gIGV4cGVjdCh0cmFuc2Zvcm1lZCkudG9Db250YWluKFxuICAgICdwcml2YXRlIHN0YXRpYyByZWFkb25seSBbSlNJSV9SVFRJX1NZTUJPTF8xXSA9IHsgZnFuOiBcIlJ1bnRpbWVJbmZvVGVzdC5Gb29cIiwgdmVyc2lvbjogXCIxLjIuM1wiIH0nLFxuICApO1xuICBleHBlY3QodHJhbnNmb3JtZWQpLnRvQ29udGFpbihcbiAgICAncHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgW0pTSUlfUlRUSV9TWU1CT0xfMV0gPSB7IGZxbjogXCJSdW50aW1lSW5mb1Rlc3QuQmFyXCIsIHZlcnNpb246IFwiMS4yLjNcIiB9JyxcbiAgKTtcbn0pO1xuXG50ZXN0KCdza2lwcyBydW50aW1lIGluZm8gaWYgbm90IGF2YWlsYWJsZScsICgpID0+IHtcbiAgY29uc3QgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm1lZFNvdXJjZShFWEFNUExFX01VTFRJUExFX0NMQVNTRVMsICdGb28nKTtcbiAgZXhwZWN0KHRyYW5zZm9ybWVkKS50b0NvbnRhaW4oXG4gICAgJ3ByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFtKU0lJX1JUVElfU1lNQk9MXzFdID0geyBmcW46IFwiUnVudGltZUluZm9UZXN0LkZvb1wiLCB2ZXJzaW9uOiBcIjEuMi4zXCIgfScsXG4gICk7XG4gIGV4cGVjdCh0cmFuc2Zvcm1lZCkubm90LnRvQ29udGFpbihcbiAgICAncHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgW0pTSUlfUlRUSV9TWU1CT0xfMV0gPSB7IGZxbjogXCJSdW50aW1lSW5mb1Rlc3QuQmFyXCIsIHZlcnNpb246IFwiMS4yLjNcIiB9JyxcbiAgKTtcbn0pO1xuXG50ZXN0KCdjcmVhdGVzIGEgdW5pcXVlIG5hbWUgaWYgdGhlIGRlZmF1bHQgaXMgdGFrZW4nLCAoKSA9PiB7XG4gIC8vIENvbmZsaWN0aW5nIGV4YW1wbGUgaGFzIGV4aXN0aW5nIHZhcmlhYmxlIGZvciBKU0lJX1JUVElfU1lNQk9MXzEsIHNvIHRyYW5zZm9ybWF0aW9uIHNob3VsZCB1c2UgXzIuXG4gIGNvbnN0IHRyYW5zZm9ybWVkID0gdHJhbnNmb3JtZWRTb3VyY2UoRVhBTVBMRV9DT05GTElDVElOR19OQU1FLCAnRm9vJyk7XG4gIGV4cGVjdCh0cmFuc2Zvcm1lZCkudG9Db250YWluKFxuICAgICdjb25zdCBKU0lJX1JUVElfU1lNQk9MXzIgPSBTeW1ib2wuZm9yKFwianNpaS5ydHRpXCIpOycsXG4gICk7XG4gIGV4cGVjdCh0cmFuc2Zvcm1lZCkudG9Db250YWluKFxuICAgICdwcml2YXRlIHN0YXRpYyByZWFkb25seSBbSlNJSV9SVFRJX1NZTUJPTF8yXSA9IHsgZnFuOiBcIlJ1bnRpbWVJbmZvVGVzdC5Gb29cIiwgdmVyc2lvbjogXCIxLjIuM1wiIH0nLFxuICApO1xufSk7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWVkU291cmNlKHNvdXJjZTogc3RyaW5nLCAuLi5jbGFzc05hbWVzOiBzdHJpbmdbXSkge1xuICBjb25zdCBtb2NrZWRUeXBlSW5mbyA9IG1vY2tlZFR5cGVJbmZvRm9yQ2xhc3NlcyguLi5jbGFzc05hbWVzKTtcbiAgY29uc3QgaW5qZWN0b3IgPSBuZXcgVGVzdFJ1bnRpbWVUeXBlSW5mb0luamVjdG9yKG1vY2tlZFR5cGVJbmZvKTtcbiAgY29uc3QgdHJhbnNmb3JtZWQgPSB0cy50cmFuc2Zvcm0oXG4gICAgdHMuY3JlYXRlU291cmNlRmlsZSgnc291cmNlLnRzJywgc291cmNlLCB0cy5TY3JpcHRUYXJnZXQuTGF0ZXN0KSxcbiAgICBbaW5qZWN0b3IucnVudGltZVR5cGVUcmFuc2Zvcm1lcigpXSxcbiAgKTtcbiAgcmV0dXJuIHRzXG4gICAgLmNyZWF0ZVByaW50ZXIoKVxuICAgIC5wcmludEJ1bmRsZSh0cy5jcmVhdGVCdW5kbGUodHJhbnNmb3JtZWQudHJhbnNmb3JtZWQpKTtcbn1cblxuLyoqIFRlc3Qgc3ViY2xhc3Mgb2YgUnVudGltZVR5cGVJbmZvSW5qZWN0b3IgdGhhdCBhY2NlcHRzIG92ZXJyaWRlcyBmb3IgdHlwZSBpbmZvICovXG5jbGFzcyBUZXN0UnVudGltZVR5cGVJbmZvSW5qZWN0b3IgZXh0ZW5kcyBSdW50aW1lVHlwZUluZm9JbmplY3RvciB7XG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHR5cGVJbmZvOiBNYXA8c3RyaW5nLCBzdHJpbmc+KSB7XG4gICAgc3VwZXIoJzEuMi4zJyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0Q2xhc3NGcW4oY2xheno6IHRzLkNsYXNzRGVjbGFyYXRpb24pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBjbGF6ei5uYW1lID8gdGhpcy50eXBlSW5mby5nZXQoY2xhenoubmFtZS50ZXh0KSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIE1vY2sgdGhlIE1hcDx0cy5DbGFzc0RlZmluaXRpb24sIHN0cmluZz4gb2YgY2xhc3NlcyB0byBmcW5zLlxuICogVGhpcyBhc3N1bWVzIGVhY2ggY2xhc3MgbmFtZSBvbmx5IGFwcGVhcnMgb25jZSBpbiB0aGUgc291cmNlLFxuICogd2hpY2ggaXMgYSByZWFzb25hYmxlIGFzc3VtcHRpb24gZm9yIHRoZXNlIHRlc3RzLlxuICovXG5mdW5jdGlvbiBtb2NrZWRUeXBlSW5mb0ZvckNsYXNzZXMoXG4gIC4uLmNsYXNzTmFtZXM6IHN0cmluZ1tdXG4pOiBNYXA8c3RyaW5nLCBzdHJpbmc+IHtcbiAgY29uc3QgdHlwZUluZm9NYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuICBjbGFzc05hbWVzLmZvckVhY2goKGNsYXp6KSA9PlxuICAgIHR5cGVJbmZvTWFwLnNldChjbGF6eiwgYFJ1bnRpbWVJbmZvVGVzdC4ke2NsYXp6fWApLFxuICApO1xuICByZXR1cm4gdHlwZUluZm9NYXA7XG59XG5cbi8qKlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogPSAgICBFWEFNUExFIFNPVVJDRSBGSUxFUyAgICAgPVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmNvbnN0IEVYQU1QTEVfTk9fQ0xBU1MgPSBgXG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcblxuaW50ZXJmYWNlIEZvbyB7XG4gIHJlYWRvbmx5IGZvb2Jhcjogc3RyaW5nO1xufVxuYDtcblxuY29uc3QgRVhBTVBMRV9TSU5HTEVfQ0xBU1MgPSBgXG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcblxuY2xhc3MgRm9vIHtcbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGJhcjogc3RyaW5nKSB7fVxufVxuYDtcblxuY29uc3QgRVhBTVBMRV9NVUxUSVBMRV9DTEFTU0VTID0gYFxuY2xhc3MgRm9vIHtcbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGJhcjogc3RyaW5nKSB7fVxuICBwdWJsaWMgZG9TdHVmZigpIHsgcmV0dXJuIDQyOyB9XG59XG5cbmludGVyZmFjZSBGb29CYXIge1xuICByZWFkb25seSBhbnN3ZXI6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBBIGJhci5cbiAqL1xuY2xhc3MgQmFyIHtcbiAgcHVibGljIGRvU3R1ZmZUb28oKSB7XG4gICAgcmV0dXJuIG5ldyBjbGFzcyBpbXBsZW1lbnRzIEZvb0JhciB7XG4gICAgICBwdWJsaWMgcmVhZG9ubHkgYW5zd2VyID0gMjE7XG4gICAgfSgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7fVxufVxuYDtcblxuY29uc3QgRVhBTVBMRV9DT05GTElDVElOR19OQU1FID0gYFxuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmNvbnN0IEpTSUlfUlRUSV9TWU1CT0xfMSA9IDQyO1xuXG5jbGFzcyBGb28ge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgYmFyOiBzdHJpbmcpIHt9XG59XG5gO1xuIl19