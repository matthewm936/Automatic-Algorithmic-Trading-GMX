"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lib_1 = require("../lib");
test('submodules loaded from directories can have a README', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper({
        'index.ts': 'export * as submodule from "./subdir"',
        'subdir/index.ts': 'export class Foo { }',
        'subdir/README.md': 'This is the README',
    });
    expect(assembly.submodules['testpkg.submodule']).toEqual(expect.objectContaining({
        readme: {
            markdown: 'This is the README',
        },
    }));
});
test('submodules loaded from files can have a README', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper({
        'index.ts': 'export * as submodule from "./submod"',
        'submod.ts': 'export class Foo { }',
        'submod.README.md': 'This is the README',
    });
    expect(assembly.submodules['testpkg.submodule']).toEqual(expect.objectContaining({
        readme: {
            markdown: 'This is the README',
        },
    }));
});
test('submodules loaded from directories can have targets', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper({
        'index.ts': 'export * as submodule from "./subdir"',
        'subdir/index.ts': 'export class Foo { }',
        'subdir/.jsiirc.json': JSON.stringify({
            targets: {
                python: 'fun',
            },
        }),
    });
    expect(assembly.submodules['testpkg.submodule']).toEqual(expect.objectContaining({
        targets: {
            python: 'fun',
        },
    }));
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3VibW9kdWxlcy50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic3VibW9kdWxlcy50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsZ0NBQWdEO0FBRWhELElBQUksQ0FBQyxzREFBc0QsRUFBRSxLQUFLLElBQUksRUFBRTtJQUN0RSxNQUFNLFFBQVEsR0FBRyxNQUFNLDRCQUFzQixDQUFDO1FBQzVDLFVBQVUsRUFBRSx1Q0FBdUM7UUFDbkQsaUJBQWlCLEVBQUUsc0JBQXNCO1FBQ3pDLGtCQUFrQixFQUFFLG9CQUFvQjtLQUN6QyxDQUFDLENBQUM7SUFFSCxNQUFNLENBQUMsUUFBUSxDQUFDLFVBQVcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUN2RCxNQUFNLENBQUMsZ0JBQWdCLENBQUM7UUFDdEIsTUFBTSxFQUFFO1lBQ04sUUFBUSxFQUFFLG9CQUFvQjtTQUMvQjtLQUNGLENBQUMsQ0FDSCxDQUFDO0FBQ0osQ0FBQyxDQUFDLENBQUM7QUFFSCxJQUFJLENBQUMsZ0RBQWdELEVBQUUsS0FBSyxJQUFJLEVBQUU7SUFDaEUsTUFBTSxRQUFRLEdBQUcsTUFBTSw0QkFBc0IsQ0FBQztRQUM1QyxVQUFVLEVBQUUsdUNBQXVDO1FBQ25ELFdBQVcsRUFBRSxzQkFBc0I7UUFDbkMsa0JBQWtCLEVBQUUsb0JBQW9CO0tBQ3pDLENBQUMsQ0FBQztJQUVILE1BQU0sQ0FBQyxRQUFRLENBQUMsVUFBVyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxPQUFPLENBQ3ZELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztRQUN0QixNQUFNLEVBQUU7WUFDTixRQUFRLEVBQUUsb0JBQW9CO1NBQy9CO0tBQ0YsQ0FBQyxDQUNILENBQUM7QUFDSixDQUFDLENBQUMsQ0FBQztBQUVILElBQUksQ0FBQyxxREFBcUQsRUFBRSxLQUFLLElBQUksRUFBRTtJQUNyRSxNQUFNLFFBQVEsR0FBRyxNQUFNLDRCQUFzQixDQUFDO1FBQzVDLFVBQVUsRUFBRSx1Q0FBdUM7UUFDbkQsaUJBQWlCLEVBQUUsc0JBQXNCO1FBQ3pDLHFCQUFxQixFQUFFLElBQUksQ0FBQyxTQUFTLENBQUM7WUFDcEMsT0FBTyxFQUFFO2dCQUNQLE1BQU0sRUFBRSxLQUFLO2FBQ2Q7U0FDRixDQUFDO0tBQ0gsQ0FBQyxDQUFDO0lBRUgsTUFBTSxDQUFDLFFBQVEsQ0FBQyxVQUFXLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FDdkQsTUFBTSxDQUFDLGdCQUFnQixDQUFDO1FBQ3RCLE9BQU8sRUFBRTtZQUNQLE1BQU0sRUFBRSxLQUFLO1NBQ2Q7S0FDRixDQUFDLENBQ0gsQ0FBQztBQUNKLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc291cmNlVG9Bc3NlbWJseUhlbHBlciB9IGZyb20gJy4uL2xpYic7XG5cbnRlc3QoJ3N1Ym1vZHVsZXMgbG9hZGVkIGZyb20gZGlyZWN0b3JpZXMgY2FuIGhhdmUgYSBSRUFETUUnLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGFzc2VtYmx5ID0gYXdhaXQgc291cmNlVG9Bc3NlbWJseUhlbHBlcih7XG4gICAgJ2luZGV4LnRzJzogJ2V4cG9ydCAqIGFzIHN1Ym1vZHVsZSBmcm9tIFwiLi9zdWJkaXJcIicsXG4gICAgJ3N1YmRpci9pbmRleC50cyc6ICdleHBvcnQgY2xhc3MgRm9vIHsgfScsXG4gICAgJ3N1YmRpci9SRUFETUUubWQnOiAnVGhpcyBpcyB0aGUgUkVBRE1FJyxcbiAgfSk7XG5cbiAgZXhwZWN0KGFzc2VtYmx5LnN1Ym1vZHVsZXMhWyd0ZXN0cGtnLnN1Ym1vZHVsZSddKS50b0VxdWFsKFxuICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgIHJlYWRtZToge1xuICAgICAgICBtYXJrZG93bjogJ1RoaXMgaXMgdGhlIFJFQURNRScsXG4gICAgICB9LFxuICAgIH0pLFxuICApO1xufSk7XG5cbnRlc3QoJ3N1Ym1vZHVsZXMgbG9hZGVkIGZyb20gZmlsZXMgY2FuIGhhdmUgYSBSRUFETUUnLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGFzc2VtYmx5ID0gYXdhaXQgc291cmNlVG9Bc3NlbWJseUhlbHBlcih7XG4gICAgJ2luZGV4LnRzJzogJ2V4cG9ydCAqIGFzIHN1Ym1vZHVsZSBmcm9tIFwiLi9zdWJtb2RcIicsXG4gICAgJ3N1Ym1vZC50cyc6ICdleHBvcnQgY2xhc3MgRm9vIHsgfScsXG4gICAgJ3N1Ym1vZC5SRUFETUUubWQnOiAnVGhpcyBpcyB0aGUgUkVBRE1FJyxcbiAgfSk7XG5cbiAgZXhwZWN0KGFzc2VtYmx5LnN1Ym1vZHVsZXMhWyd0ZXN0cGtnLnN1Ym1vZHVsZSddKS50b0VxdWFsKFxuICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgIHJlYWRtZToge1xuICAgICAgICBtYXJrZG93bjogJ1RoaXMgaXMgdGhlIFJFQURNRScsXG4gICAgICB9LFxuICAgIH0pLFxuICApO1xufSk7XG5cbnRlc3QoJ3N1Ym1vZHVsZXMgbG9hZGVkIGZyb20gZGlyZWN0b3JpZXMgY2FuIGhhdmUgdGFyZ2V0cycsIGFzeW5jICgpID0+IHtcbiAgY29uc3QgYXNzZW1ibHkgPSBhd2FpdCBzb3VyY2VUb0Fzc2VtYmx5SGVscGVyKHtcbiAgICAnaW5kZXgudHMnOiAnZXhwb3J0ICogYXMgc3VibW9kdWxlIGZyb20gXCIuL3N1YmRpclwiJyxcbiAgICAnc3ViZGlyL2luZGV4LnRzJzogJ2V4cG9ydCBjbGFzcyBGb28geyB9JyxcbiAgICAnc3ViZGlyLy5qc2lpcmMuanNvbic6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHRhcmdldHM6IHtcbiAgICAgICAgcHl0aG9uOiAnZnVuJyxcbiAgICAgIH0sXG4gICAgfSksXG4gIH0pO1xuXG4gIGV4cGVjdChhc3NlbWJseS5zdWJtb2R1bGVzIVsndGVzdHBrZy5zdWJtb2R1bGUnXSkudG9FcXVhbChcbiAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICB0YXJnZXRzOiB7XG4gICAgICAgIHB5dGhvbjogJ2Z1bicsXG4gICAgICB9LFxuICAgIH0pLFxuICApO1xufSk7XG4iXX0=