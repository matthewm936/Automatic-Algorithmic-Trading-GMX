"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = require("fs-extra");
const os_1 = require("os");
const path_1 = require("path");
const compiler_1 = require("../lib/compiler");
describe(compiler_1.Compiler, () => {
    describe('generated tsconfig', () => {
        test('default is tsconfig.json', async () => {
            const sourceDir = await fs_extra_1.mkdtemp(path_1.join(os_1.tmpdir(), 'jsii-compiler-watch-mode-'));
            const compiler = new compiler_1.Compiler({
                projectInfo: _makeProjectInfo(sourceDir, 'index.d.ts'),
            });
            await compiler.emit();
            expect(await fs_extra_1.readJson(path_1.join(sourceDir, 'tsconfig.json'), 'utf-8')).toEqual(expectedTypeScriptConfig());
        });
        test('file name can be customized', async () => {
            const sourceDir = await fs_extra_1.mkdtemp(path_1.join(os_1.tmpdir(), 'jsii-compiler-watch-mode-'));
            const compiler = new compiler_1.Compiler({
                projectInfo: _makeProjectInfo(sourceDir, 'index.d.ts'),
                generateTypeScriptConfig: 'tsconfig.jsii.json',
            });
            await compiler.emit();
            expect(await fs_extra_1.readJson(path_1.join(sourceDir, 'tsconfig.jsii.json'), 'utf-8')).toEqual(expectedTypeScriptConfig());
        });
    });
    test('"watch" mode', async () => {
        // This can be a little slow, allowing 15 seconds maximum here (default is 5 seconds)
        jest.setTimeout(15000);
        const sourceDir = await fs_extra_1.mkdtemp(path_1.join(os_1.tmpdir(), 'jsii-compiler-watch-mode-'));
        try {
            await fs_extra_1.writeFile(path_1.join(sourceDir, 'index.ts'), 'export class MarkerA {}');
            // Intentionally using lower case name - it should be case-insensitive
            await fs_extra_1.writeFile(path_1.join(sourceDir, 'readme.md'), '# Test Package');
            const compiler = new compiler_1.Compiler({
                projectInfo: _makeProjectInfo(sourceDir, 'index.d.ts'),
                failOnWarnings: true,
                projectReferences: false,
            });
            let firstCompilation = true;
            let onWatchClosed;
            let onWatchFailed;
            const watchClosed = new Promise((ok, ko) => {
                onWatchClosed = ok;
                onWatchFailed = ko;
            });
            const watch = await compiler.watch({
                nonBlocking: true,
                // Ignore diagnostics reporting (not to pollute test console output)
                reportDiagnostics: () => null,
                // Ignore watch status reporting (not to pollute test console output)
                reportWatchStatus: () => null,
                // Verify everything goes according to plan
                compilationComplete: async (emitResult) => {
                    try {
                        expect(emitResult.emitSkipped).toBeFalsy();
                        const output = await fs_extra_1.readFile(path_1.join(sourceDir, '.jsii'), {
                            encoding: 'utf-8',
                        });
                        if (firstCompilation) {
                            firstCompilation = false;
                            expect(output).toContain('"MarkerA"');
                            await fs_extra_1.writeFile(path_1.join(sourceDir, 'index.ts'), 'export class MarkerB {}');
                            return;
                        }
                        expect(output).toContain('"MarkerB"');
                        watch.close();
                        // Tell the test suite we're done here!
                        onWatchClosed();
                    }
                    catch (e) {
                        watch.close();
                        onWatchFailed(e);
                    }
                },
            });
            await watchClosed;
        }
        finally {
            await fs_extra_1.remove(sourceDir);
        }
    });
});
function _makeProjectInfo(sourceDir, types) {
    return {
        projectRoot: sourceDir,
        packageJson: undefined,
        types,
        main: types.replace(/(?:\.d)?\.ts(x?)/, '.js$1'),
        name: 'jsii',
        version: '0.0.1',
        jsiiVersionFormat: 'short',
        license: 'Apache-2.0',
        author: { name: 'John Doe', roles: ['author'] },
        repository: { type: 'git', url: 'https://github.com/aws/jsii.git' },
        dependencies: {},
        peerDependencies: {},
        dependencyClosure: [],
        bundleDependencies: {},
        targets: {},
        excludeTypescript: [],
    };
}
function expectedTypeScriptConfig() {
    return {
        _generated_by_jsii_: 'Generated by jsii - safe to delete, and ideally should be in .gitignore',
        compilerOptions: {
            alwaysStrict: true,
            charset: 'utf8',
            composite: false,
            declaration: true,
            experimentalDecorators: true,
            incremental: true,
            inlineSourceMap: true,
            inlineSources: true,
            lib: ['es2019'],
            module: 'CommonJS',
            newLine: 'lf',
            noEmitOnError: true,
            noFallthroughCasesInSwitch: true,
            noImplicitAny: true,
            noImplicitReturns: true,
            noImplicitThis: true,
            noUnusedLocals: true,
            noUnusedParameters: true,
            resolveJsonModule: true,
            strict: true,
            strictNullChecks: true,
            strictPropertyInitialization: true,
            stripInternal: false,
            target: 'ES2019',
            tsBuildInfoFile: 'tsconfig.tsbuildinfo',
        },
        exclude: ['node_modules'],
        include: [path_1.join('**', '*.ts')],
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZXIudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvbXBpbGVyLnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSx1Q0FBMEU7QUFDMUUsMkJBQTRCO0FBQzVCLCtCQUE0QjtBQUU1Qiw4Q0FBMkM7QUFHM0MsUUFBUSxDQUFDLG1CQUFRLEVBQUUsR0FBRyxFQUFFO0lBQ3RCLFFBQVEsQ0FBQyxvQkFBb0IsRUFBRSxHQUFHLEVBQUU7UUFDbEMsSUFBSSxDQUFDLDBCQUEwQixFQUFFLEtBQUssSUFBSSxFQUFFO1lBQzFDLE1BQU0sU0FBUyxHQUFHLE1BQU0sa0JBQU8sQ0FDN0IsV0FBSSxDQUFDLFdBQU0sRUFBRSxFQUFFLDJCQUEyQixDQUFDLENBQzVDLENBQUM7WUFFRixNQUFNLFFBQVEsR0FBRyxJQUFJLG1CQUFRLENBQUM7Z0JBQzVCLFdBQVcsRUFBRSxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsWUFBWSxDQUFDO2FBQ3ZELENBQUMsQ0FBQztZQUVILE1BQU0sUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO1lBRXRCLE1BQU0sQ0FBQyxNQUFNLG1CQUFRLENBQUMsV0FBSSxDQUFDLFNBQVMsRUFBRSxlQUFlLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FDdkUsd0JBQXdCLEVBQUUsQ0FDM0IsQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLDZCQUE2QixFQUFFLEtBQUssSUFBSSxFQUFFO1lBQzdDLE1BQU0sU0FBUyxHQUFHLE1BQU0sa0JBQU8sQ0FDN0IsV0FBSSxDQUFDLFdBQU0sRUFBRSxFQUFFLDJCQUEyQixDQUFDLENBQzVDLENBQUM7WUFFRixNQUFNLFFBQVEsR0FBRyxJQUFJLG1CQUFRLENBQUM7Z0JBQzVCLFdBQVcsRUFBRSxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsWUFBWSxDQUFDO2dCQUN0RCx3QkFBd0IsRUFBRSxvQkFBb0I7YUFDL0MsQ0FBQyxDQUFDO1lB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QUFVO1lBQ2xCLE9BQU8sRUFBRSxJQUFJO1lBQ2IsYUFBYSxFQUFFLElBQUk7WUFDbkIsMEJBQTBCLEVBQUUsSUFBSTtZQUNoQyxhQUFhLEVBQUUsSUFBSTtZQUNuQixpQkFBaUIsRUFBRSxJQUFJO1lBQ3ZCLGNBQWMsRUFBRSxJQUFJO1lBQ3BCLGNBQWMsRUFBRSxJQUFJO1lBQ3BCLGtCQUFrQixFQUFFLElBQUk7WUFDeEIsaUJBQWlCLEVBQUUsSUFBSTtZQUN2QixNQUFNLEVBQUUsSUFBSTtZQUNaLGdCQUFnQixFQUFFLElBQUk7WUFDdEIsNEJBQTRCLEVBQUUsSUFBSTtZQUNsQyxhQUFhLEVBQUUsS0FBSztZQUNwQixNQUFNLEVBQUUsUUFBUTtZQUNoQixlQUFlLEVBQUUsc0JBQXNCO1NBQ3hDO1FBQ0QsT0FBTyxFQUFFLENBQUMsY0FBYyxDQUFDO1FBQ3pCLE9BQU8sRUFBRSxDQUFDLFdBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7S0FDOUIsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBta2R0ZW1wLCByZW1vdmUsIHdyaXRlRmlsZSwgcmVhZEZpbGUsIHJlYWRKc29uIH0gZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHsgdG1wZGlyIH0gZnJvbSAnb3MnO1xuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyBDb21waWxlciB9IGZyb20gJy4uL2xpYi9jb21waWxlcic7XG5pbXBvcnQgeyBQcm9qZWN0SW5mbyB9IGZyb20gJy4uL2xpYi9wcm9qZWN0LWluZm8nO1xuXG5kZXNjcmliZShDb21waWxlciwgKCkgPT4ge1xuICBkZXNjcmliZSgnZ2VuZXJhdGVkIHRzY29uZmlnJywgKCkgPT4ge1xuICAgIHRlc3QoJ2RlZmF1bHQgaXMgdHNjb25maWcuanNvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNvdXJjZURpciA9IGF3YWl0IG1rZHRlbXAoXG4gICAgICAgIGpvaW4odG1wZGlyKCksICdqc2lpLWNvbXBpbGVyLXdhdGNoLW1vZGUtJyksXG4gICAgICApO1xuXG4gICAgICBjb25zdCBjb21waWxlciA9IG5ldyBDb21waWxlcih7XG4gICAgICAgIHByb2plY3RJbmZvOiBfbWFrZVByb2plY3RJbmZvKHNvdXJjZURpciwgJ2luZGV4LmQudHMnKSxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBjb21waWxlci5lbWl0KCk7XG5cbiAgICAgIGV4cGVjdChhd2FpdCByZWFkSnNvbihqb2luKHNvdXJjZURpciwgJ3RzY29uZmlnLmpzb24nKSwgJ3V0Zi04JykpLnRvRXF1YWwoXG4gICAgICAgIGV4cGVjdGVkVHlwZVNjcmlwdENvbmZpZygpLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2ZpbGUgbmFtZSBjYW4gYmUgY3VzdG9taXplZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNvdXJjZURpciA9IGF3YWl0IG1rZHRlbXAoXG4gICAgICAgIGpvaW4odG1wZGlyKCksICdqc2lpLWNvbXBpbGVyLXdhdGNoLW1vZGUtJyksXG4gICAgICApO1xuXG4gICAgICBjb25zdCBjb21waWxlciA9IG5ldyBDb21waWxlcih7XG4gICAgICAgIHByb2plY3RJbmZvOiBfbWFrZVByb2plY3RJbmZvKHNvdXJjZURpciwgJ2luZGV4LmQudHMnKSxcbiAgICAgICAgZ2VuZXJhdGVUeXBlU2NyaXB0Q29uZmlnOiAndHNjb25maWcuanNpaS5qc29uJyxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBjb21waWxlci5lbWl0KCk7XG5cbiAgICAgIGV4cGVjdChcbiAgICAgICAgYXdhaXQgcmVhZEpzb24oam9pbihzb3VyY2VEaXIsICd0c2NvbmZpZy5qc2lpLmpzb24nKSwgJ3V0Zi04JyksXG4gICAgICApLnRvRXF1YWwoZXhwZWN0ZWRUeXBlU2NyaXB0Q29uZmlnKCkpO1xuICAgIH0pO1xuICB9KTtcbiAgdGVzdCgnXCJ3YXRjaFwiIG1vZGUnLCBhc3luYyAoKSA9PiB7XG4gICAgLy8gVGhpcyBjYW4gYmUgYSBsaXR0bGUgc2xvdywgYWxsb3dpbmcgMTUgc2Vjb25kcyBtYXhpbXVtIGhlcmUgKGRlZmF1bHQgaXMgNSBzZWNvbmRzKVxuICAgIGplc3Quc2V0VGltZW91dCgxNV8wMDApO1xuXG4gICAgY29uc3Qgc291cmNlRGlyID0gYXdhaXQgbWtkdGVtcChcbiAgICAgIGpvaW4odG1wZGlyKCksICdqc2lpLWNvbXBpbGVyLXdhdGNoLW1vZGUtJyksXG4gICAgKTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB3cml0ZUZpbGUoam9pbihzb3VyY2VEaXIsICdpbmRleC50cycpLCAnZXhwb3J0IGNsYXNzIE1hcmtlckEge30nKTtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgdXNpbmcgbG93ZXIgY2FzZSBuYW1lIC0gaXQgc2hvdWxkIGJlIGNhc2UtaW5zZW5zaXRpdmVcbiAgICAgIGF3YWl0IHdyaXRlRmlsZShqb2luKHNvdXJjZURpciwgJ3JlYWRtZS5tZCcpLCAnIyBUZXN0IFBhY2thZ2UnKTtcblxuICAgICAgY29uc3QgY29tcGlsZXIgPSBuZXcgQ29tcGlsZXIoe1xuICAgICAgICBwcm9qZWN0SW5mbzogX21ha2VQcm9qZWN0SW5mbyhzb3VyY2VEaXIsICdpbmRleC5kLnRzJyksXG4gICAgICAgIGZhaWxPbldhcm5pbmdzOiB0cnVlLFxuICAgICAgICBwcm9qZWN0UmVmZXJlbmNlczogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgbGV0IGZpcnN0Q29tcGlsYXRpb24gPSB0cnVlO1xuICAgICAgbGV0IG9uV2F0Y2hDbG9zZWQ6ICgpID0+IHZvaWQ7XG4gICAgICBsZXQgb25XYXRjaEZhaWxlZDogKGVycjogRXJyb3IpID0+IHZvaWQ7XG4gICAgICBjb25zdCB3YXRjaENsb3NlZCA9IG5ldyBQcm9taXNlPHZvaWQ+KChvaywga28pID0+IHtcbiAgICAgICAgb25XYXRjaENsb3NlZCA9IG9rO1xuICAgICAgICBvbldhdGNoRmFpbGVkID0ga287XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHdhdGNoID0gYXdhaXQgY29tcGlsZXIud2F0Y2goe1xuICAgICAgICBub25CbG9ja2luZzogdHJ1ZSxcbiAgICAgICAgLy8gSWdub3JlIGRpYWdub3N0aWNzIHJlcG9ydGluZyAobm90IHRvIHBvbGx1dGUgdGVzdCBjb25zb2xlIG91dHB1dClcbiAgICAgICAgcmVwb3J0RGlhZ25vc3RpY3M6ICgpID0+IG51bGwsXG4gICAgICAgIC8vIElnbm9yZSB3YXRjaCBzdGF0dXMgcmVwb3J0aW5nIChub3QgdG8gcG9sbHV0ZSB0ZXN0IGNvbnNvbGUgb3V0cHV0KVxuICAgICAgICByZXBvcnRXYXRjaFN0YXR1czogKCkgPT4gbnVsbCxcbiAgICAgICAgLy8gVmVyaWZ5IGV2ZXJ5dGhpbmcgZ29lcyBhY2NvcmRpbmcgdG8gcGxhblxuICAgICAgICBjb21waWxhdGlvbkNvbXBsZXRlOiBhc3luYyAoZW1pdFJlc3VsdCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBleHBlY3QoZW1pdFJlc3VsdC5lbWl0U2tpcHBlZCkudG9CZUZhbHN5KCk7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCByZWFkRmlsZShqb2luKHNvdXJjZURpciwgJy5qc2lpJyksIHtcbiAgICAgICAgICAgICAgZW5jb2Rpbmc6ICd1dGYtOCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChmaXJzdENvbXBpbGF0aW9uKSB7XG4gICAgICAgICAgICAgIGZpcnN0Q29tcGlsYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgZXhwZWN0KG91dHB1dCkudG9Db250YWluKCdcIk1hcmtlckFcIicpO1xuICAgICAgICAgICAgICBhd2FpdCB3cml0ZUZpbGUoXG4gICAgICAgICAgICAgICAgam9pbihzb3VyY2VEaXIsICdpbmRleC50cycpLFxuICAgICAgICAgICAgICAgICdleHBvcnQgY2xhc3MgTWFya2VyQiB7fScsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cGVjdChvdXRwdXQpLnRvQ29udGFpbignXCJNYXJrZXJCXCInKTtcbiAgICAgICAgICAgIHdhdGNoLmNsb3NlKCk7XG4gICAgICAgICAgICAvLyBUZWxsIHRoZSB0ZXN0IHN1aXRlIHdlJ3JlIGRvbmUgaGVyZSFcbiAgICAgICAgICAgIG9uV2F0Y2hDbG9zZWQoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB3YXRjaC5jbG9zZSgpO1xuICAgICAgICAgICAgb25XYXRjaEZhaWxlZChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHdhdGNoQ2xvc2VkO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCByZW1vdmUoc291cmNlRGlyKTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIF9tYWtlUHJvamVjdEluZm8oc291cmNlRGlyOiBzdHJpbmcsIHR5cGVzOiBzdHJpbmcpOiBQcm9qZWN0SW5mbyB7XG4gIHJldHVybiB7XG4gICAgcHJvamVjdFJvb3Q6IHNvdXJjZURpcixcbiAgICBwYWNrYWdlSnNvbjogdW5kZWZpbmVkLFxuICAgIHR5cGVzLFxuICAgIG1haW46IHR5cGVzLnJlcGxhY2UoLyg/OlxcLmQpP1xcLnRzKHg/KS8sICcuanMkMScpLFxuICAgIG5hbWU6ICdqc2lpJywgLy8gVGhhdCdzIHdoYXQgcGFja2FnZS5qc29uIHdvdWxkIHRlbGwgaWYgd2UgbG9vayB1cC4uLlxuICAgIHZlcnNpb246ICcwLjAuMScsXG4gICAganNpaVZlcnNpb25Gb3JtYXQ6ICdzaG9ydCcsXG4gICAgbGljZW5zZTogJ0FwYWNoZS0yLjAnLFxuICAgIGF1dGhvcjogeyBuYW1lOiAnSm9obiBEb2UnLCByb2xlczogWydhdXRob3InXSB9LFxuICAgIHJlcG9zaXRvcnk6IHsgdHlwZTogJ2dpdCcsIHVybDogJ2h0dHBzOi8vZ2l0aHViLmNvbS9hd3MvanNpaS5naXQnIH0sXG4gICAgZGVwZW5kZW5jaWVzOiB7fSxcbiAgICBwZWVyRGVwZW5kZW5jaWVzOiB7fSxcbiAgICBkZXBlbmRlbmN5Q2xvc3VyZTogW10sXG4gICAgYnVuZGxlRGVwZW5kZW5jaWVzOiB7fSxcbiAgICB0YXJnZXRzOiB7fSxcbiAgICBleGNsdWRlVHlwZXNjcmlwdDogW10sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4cGVjdGVkVHlwZVNjcmlwdENvbmZpZygpIHtcbiAgcmV0dXJuIHtcbiAgICBfZ2VuZXJhdGVkX2J5X2pzaWlfOlxuICAgICAgJ0dlbmVyYXRlZCBieSBqc2lpIC0gc2FmZSB0byBkZWxldGUsIGFuZCBpZGVhbGx5IHNob3VsZCBiZSBpbiAuZ2l0aWdub3JlJyxcbiAgICBjb21waWxlck9wdGlvbnM6IHtcbiAgICAgIGFsd2F5c1N0cmljdDogdHJ1ZSxcbiAgICAgIGNoYXJzZXQ6ICd1dGY4JyxcbiAgICAgIGNvbXBvc2l0ZTogZmFsc2UsXG4gICAgICBkZWNsYXJhdGlvbjogdHJ1ZSxcbiAgICAgIGV4cGVyaW1lbnRhbERlY29yYXRvcnM6IHRydWUsXG4gICAgICBpbmNyZW1lbnRhbDogdHJ1ZSxcbiAgICAgIGlubGluZVNvdXJjZU1hcDogdHJ1ZSxcbiAgICAgIGlubGluZVNvdXJjZXM6IHRydWUsXG4gICAgICBsaWI6IFsnZXMyMDE5J10sXG4gICAgICBtb2R1bGU6ICdDb21tb25KUycsXG4gICAgICBuZXdMaW5lOiAnbGYnLFxuICAgICAgbm9FbWl0T25FcnJvcjogdHJ1ZSxcbiAgICAgIG5vRmFsbHRocm91Z2hDYXNlc0luU3dpdGNoOiB0cnVlLFxuICAgICAgbm9JbXBsaWNpdEFueTogdHJ1ZSxcbiAgICAgIG5vSW1wbGljaXRSZXR1cm5zOiB0cnVlLFxuICAgICAgbm9JbXBsaWNpdFRoaXM6IHRydWUsXG4gICAgICBub1VudXNlZExvY2FsczogdHJ1ZSxcbiAgICAgIG5vVW51c2VkUGFyYW1ldGVyczogdHJ1ZSxcbiAgICAgIHJlc29sdmVKc29uTW9kdWxlOiB0cnVlLFxuICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgc3RyaWN0TnVsbENoZWNrczogdHJ1ZSxcbiAgICAgIHN0cmljdFByb3BlcnR5SW5pdGlhbGl6YXRpb246IHRydWUsXG4gICAgICBzdHJpcEludGVybmFsOiBmYWxzZSxcbiAgICAgIHRhcmdldDogJ0VTMjAxOScsXG4gICAgICB0c0J1aWxkSW5mb0ZpbGU6ICd0c2NvbmZpZy50c2J1aWxkaW5mbycsXG4gICAgfSxcbiAgICBleGNsdWRlOiBbJ25vZGVfbW9kdWxlcyddLFxuICAgIGluY2x1ZGU6IFtqb2luKCcqKicsICcqLnRzJyldLFxuICB9O1xufVxuIl19