"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const spec = require("@jsii/spec");
const spec_1 = require("@jsii/spec");
const lib_1 = require("../lib");
const docs_1 = require("../lib/docs");
jest.setTimeout(60000);
// ----------------------------------------------------------------------
test('extract summary line from doc block, ends with a period', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper(`
    /**
     * Hello this is the documentation for this class
     */
    export class Foo {
      public bar() { }
    }
  `);
    expect(assembly.types['testpkg.Foo'].docs).toEqual({
        summary: 'Hello this is the documentation for this class.',
    });
});
// ----------------------------------------------------------------------
test('extract remarks from whitespace-separated doc block', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper(`
    /**
     * Hello this is the documentation for this class.
     *
     * Here are some more details about it.
     *
     * It looks pretty good, doesn't it?
     */
    export class Foo {
      public bar() { }
    }
  `);
    expect(assembly.types['testpkg.Foo'].docs.remarks).toBe("Here are some more details about it.\n\nIt looks pretty good, doesn't it?");
});
// ----------------------------------------------------------------------
test('separate long doc comment into summary and remarks', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper(`
    /**
     * Lots of people enjoy writing very long captions here. I think it's because they
     * copy/paste them out of CloudFormation, which has a tendency to just have one
     * doc block per API item and no structural separation.
     */
    export class Foo {
      public bar() { }
    }
  `);
    expect(assembly.types['testpkg.Foo'].docs).toEqual({
        summary: 'Lots of people enjoy writing very long captions here.',
        remarks: "I think it's because they\ncopy/paste them out of CloudFormation, which has a tendency to just have one\n" +
            'doc block per API item and no structural separation.',
    });
});
// ----------------------------------------------------------------------
test('separate non-space but newline terminated docs into summary&remarks', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper(`
    /**
     * Lots of people enjoy writing very long captions here.
     * I think it's because they copy/paste them out of CloudFormation,
     * which has a tendency to just have one
     * doc block per API item and no structural separation.
     */
    export class Foo {
      public bar() { }
    }
  `);
    expect(assembly.types['testpkg.Foo'].docs).toEqual({
        summary: 'Lots of people enjoy writing very long captions here.',
        remarks: "I think it's because they copy/paste them out of CloudFormation,\nwhich has a tendency to just have one\n" +
            'doc block per API item and no structural separation.',
    });
});
// ----------------------------------------------------------------------
test('dont add period to summary that ends in exclamation mark', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper(`
    /**
     * I'm happy about this class!
     */
    export class Foo {
      public bar() { }
    }
  `);
    expect(assembly.types['testpkg.Foo'].docs).toEqual({
        summary: "I'm happy about this class!",
    });
});
// ----------------------------------------------------------------------
test('parse method docs', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper(`
    export class Foo {
      /**
       * Do the foo
       */
      public bar(arg: string) { Array.isArray(arg); }
    }
  `);
    const classType = assembly.types['testpkg.Foo'];
    expect(classType.methods[0].docs).toEqual({
        summary: 'Do the foo.',
    });
});
// ----------------------------------------------------------------------
test('associate parameter comments with right parameter', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper(`
    export class Foo {
      /**
       * Do the foo
       *
       * @param arg First argument is best argument
       */
      public bar(arg: string) { Array.isArray(arg); }
    }
  `);
    const classType = assembly.types['testpkg.Foo'];
    expect(classType.methods[0].parameters[0].docs).toEqual({
        summary: 'First argument is best argument.',
    });
});
// ----------------------------------------------------------------------
test('read example', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper(`
    export class Foo {
      /**
       * Do the foo
       *
       * @example
       *
       * // Example of fooing it up:
       * new Foo().bar();
       */
      public bar() {}
    }
  `);
    const classType = assembly.types['testpkg.Foo'];
    expect(classType.methods[0].docs.example).toBe('// Example of fooing it up:\n' + 'new Foo().bar();');
});
// ----------------------------------------------------------------------
test('read default value', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper(`
    export interface Foo {
      /**
       * The foo we're talking about
       *
       * @default Some foo
       */
      readonly foo?: string;
    }
  `);
    const classType = assembly.types['testpkg.Foo'];
    expect(classType.properties[0].docs.default).toBe('Some foo');
});
// ----------------------------------------------------------------------
test('read "see" annotation', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper(`
    /**
     * @see http://lmgtfy.com/
     */
    export class Foo {
    }
  `);
    expect(assembly.types['testpkg.Foo'].docs.see).toBe('http://lmgtfy.com/');
});
// ----------------------------------------------------------------------
test('read "returns" annotation', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper(`
    export class Foo {
      /**
       * Do the foo
       *
       * @returns Nothing, why would it?
       */
      public bar(arg: string) { Array.isArray(arg); }
    }
  `);
    const classType = assembly.types['testpkg.Foo'];
    expect(classType.methods[0].docs.returns).toBe('Nothing, why would it?');
});
// ----------------------------------------------------------------------
test('can haz deprecated', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper(`
    export class Foo {
      /**
       * Do the foo
       *
       * @deprecated These days we do the bar
       */
      public bar(arg: string) { Array.isArray(arg); }
    }
  `);
    const classType = assembly.types['testpkg.Foo'];
    expect(classType.methods[0].docs.deprecated).toBe('These days we do the bar');
});
// ----------------------------------------------------------------------
test('can mark stable', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper(`
    /**
     * Rock solid Foo
     *
     * @stable
     */
    export class Foo {
    }
  `);
    const classType = assembly.types['testpkg.Foo'];
    expect(classType.docs.stability).toBe(spec.Stability.Stable);
});
// ----------------------------------------------------------------------
test('can mark experimental', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper(`
    /**
     * Slightly less solid Foo
     *
     * @experimental
     */
    export class Foo {
    }
  `);
    const classType = assembly.types['testpkg.Foo'];
    expect(classType.docs.stability).toBe(spec.Stability.Experimental);
});
// ----------------------------------------------------------------------
test('can mark external', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper(`
    /**
     * @stability external
     */
    export class Foo {
      public floop() {
        Array.isArray(3);
      }
    }
  `);
    const classType = assembly.types['testpkg.Foo'];
    const method = classType.methods.find((m) => m.name === 'floop');
    expect(classType.docs.stability).toBe(spec.Stability.External);
    expect(method.docs.stability).toBe(spec.Stability.External);
});
// ----------------------------------------------------------------------
test('can mark subclassable', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper(`
    /**
     * Become this Foo
     *
     * @subclassable
     */
    export class Foo {
    }
  `);
    const classType = assembly.types['testpkg.Foo'];
    expect(classType.docs.subclassable).toBeTruthy();
});
// ----------------------------------------------------------------------
test('can add arbitrary tags', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper(`
    /**
     * @boop
     */
    export class Foo {
    }
  `);
    const classType = assembly.types['testpkg.Foo'];
    expect(classType.docs.custom).toEqual({ boop: 'true' });
});
// ----------------------------------------------------------------------
test('stability is inherited from parent type', async () => {
    const stabilities = [
        ['@deprecated Not good no more', spec_1.Stability.Deprecated],
        ['@experimental', spec_1.Stability.Experimental],
        ['@stable', spec_1.Stability.Stable],
    ];
    for (const [tag, stability] of stabilities) {
        // eslint-disable-next-line no-await-in-loop
        const assembly = await lib_1.sourceToAssemblyHelper(`
      /**
       * ${tag}
       */
      export class Foo {
        constructor() {
          Array.isArray(3);
        }

        public bar() {
          Array.isArray(3);
        }
      }
    `);
        /* eslint-enable no-await-in-loop */
        const classType = assembly.types['testpkg.Foo'];
        const initializer = classType.initializer;
        const method = classType.methods.find((m) => m.name === 'bar');
        expect(classType.docs.stability).toBe(stability);
        expect(initializer.docs.stability).toBe(stability);
        expect(method.docs.stability).toBe(stability);
    }
});
// ----------------------------------------------------------------------
test('@example can contain @ sign', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper(`
    /**
     * An IAM role to associate with the instance profile assigned to this Auto Scaling Group.
     *
     * @example
     *
     * import * as x from '@banana';
     */
    export class Foo {
    }
  `);
    const classType = assembly.types['testpkg.Foo'];
    expect(classType.docs.example).toBe("import * as x from '@banana';");
});
// ----------------------------------------------------------------------
test('@experimental status is reflected in generated docstring', async () => {
    const result = await lib_1.compileJsiiForTest(`
    /**
     * Here is a fresh class
     *
     * @experimental
     */
    export class Foo {
    }
  `);
    expect(result.files['index.js']).toContain(lines('/**', ' * (experimental) Here is a fresh class.', ' *', ' * @experimental', ' */', 'class Foo {', '}'));
    expect(result.files['index.d.ts']).toContain(lines('/**', ' * (experimental) Here is a fresh class.', ' *', ' * @experimental', ' */', 'export declare class Foo {', '}'));
});
// ----------------------------------------------------------------------
test('@deprecated status is reflected in generated docstring', async () => {
    const result = await lib_1.compileJsiiForTest(`
    /**
     * Here is an old class
     *
     * @deprecated Use something else
     */
    export class Fogey {
    }
  `);
    expect(result.files['index.js']).toContain(lines('/**', ' * (deprecated) Here is an old class.', ' *', ' * @deprecated Use something else', ' */', 'class Fogey {', '}'));
    expect(result.files['index.d.ts']).toContain(lines('/**', ' * (deprecated) Here is an old class.', ' *', ' * @deprecated Use something else', ' */', 'export declare class Fogey {', '}'));
});
// ----------------------------------------------------------------------
test('Rendering jsii docs back to a doc comment', () => {
    expect(docs_1.renderSymbolDocumentation({
        summary: 'This is the summary',
        remarks: 'You can use this\nor not, as you see fit.',
        default: 'thas a default value',
        see: 'https://some.url/',
        subclassable: true,
        returns: 'A value',
        example: 'print("a thing");',
        custom: {
            sing: 'whenyourewinning',
        },
    })).toEqual(lines('This is the summary', '', 'You can use this', 'or not, as you see fit.', '', '@returns A value', '@default thas a default value', '@see https://some.url/', '@subclassable', '@sing whenyourewinning', '@example', '', 'print("a thing");'));
});
// ----------------------------------------------------------------------
function lines(...ls) {
    return indented(0, ...ls);
}
function indented(indent, ...lines) {
    const prefix = ' '.repeat(indent);
    return lines.map((l) => `${prefix}${l}`).join('\n');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9jcy50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZG9jcy50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsbUNBQW1DO0FBQ25DLHFDQUF1QztBQUV2QyxnQ0FBK0U7QUFDL0Usc0NBQXdEO0FBRXhELElBQUksQ0FBQyxVQUFVLENBQUMsS0FBTSxDQUFDLENBQUM7QUFFeEIseUVBQXlFO0FBQ3pFLElBQUksQ0FBQyx5REFBeUQsRUFBRSxLQUFLLElBQUksRUFBRTtJQUN6RSxNQUFNLFFBQVEsR0FBRyxNQUFNLDRCQUFPLENBQUM7Ozs7Ozs7R0FPOUIsQ0FBQyxDQUFDO0lBRUgsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDO1FBQ2xELE9BQU8sRUFBRSxpREFBaUQ7S0FDM0QsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUM7QUFFSCx5RUFBeUU7QUFDekUsSUFBSSxDQUFDLHFEQUFxRCxFQUFFLEtBQUssSUFBSSxFQUFFO0lBQ3JFLE1BQU0sUUFBUSxHQUFHLE1BQU0sNEJBQU8sQ0FBQzs7Ozs7Ozs7Ozs7R0FXOUIsQ0FBQyxDQUFDO0lBRUgsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsSUFBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FDdkQsMkVBQTJFLENBQzVFLENBQUM7QUFDSixDQUFDLENBQUMsQ0FBQztBQUVILHlFQUF5RTtBQUN6RSxJQUFJLENBQUMsb0RBQW9ELEVBQUUsS0FBSyxJQUFJLEVBQUU7SUFDcEUsTUFBTSxRQUFRLEdBQUcsTUFBTSw0QkFBTyxDQUFDOzs7Ozs7Ozs7R0FTOUIsQ0FBQyxDQUFDO0lBRUgsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDO1FBQ2xELE9BQU8sRUFBRSx1REFBdUQ7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L3NwZWMnO1xuaW1wb3J0IHsgU3RhYmlsaXR5IH0gZnJvbSAnQGpzaWkvc3BlYyc7XG5cbmltcG9ydCB7IHNvdXJjZVRvQXNzZW1ibHlIZWxwZXIgYXMgY29tcGlsZSwgY29tcGlsZUpzaWlGb3JUZXN0IH0gZnJvbSAnLi4vbGliJztcbmltcG9ydCB7IHJlbmRlclN5bWJvbERvY3VtZW50YXRpb24gfSBmcm9tICcuLi9saWIvZG9jcyc7XG5cbmplc3Quc2V0VGltZW91dCg2MF8wMDApO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG50ZXN0KCdleHRyYWN0IHN1bW1hcnkgbGluZSBmcm9tIGRvYyBibG9jaywgZW5kcyB3aXRoIGEgcGVyaW9kJywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IGNvbXBpbGUoYFxuICAgIC8qKlxuICAgICAqIEhlbGxvIHRoaXMgaXMgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoaXMgY2xhc3NcbiAgICAgKi9cbiAgICBleHBvcnQgY2xhc3MgRm9vIHtcbiAgICAgIHB1YmxpYyBiYXIoKSB7IH1cbiAgICB9XG4gIGApO1xuXG4gIGV4cGVjdChhc3NlbWJseS50eXBlcyFbJ3Rlc3Rwa2cuRm9vJ10uZG9jcykudG9FcXVhbCh7XG4gICAgc3VtbWFyeTogJ0hlbGxvIHRoaXMgaXMgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoaXMgY2xhc3MuJyxcbiAgfSk7XG59KTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudGVzdCgnZXh0cmFjdCByZW1hcmtzIGZyb20gd2hpdGVzcGFjZS1zZXBhcmF0ZWQgZG9jIGJsb2NrJywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IGNvbXBpbGUoYFxuICAgIC8qKlxuICAgICAqIEhlbGxvIHRoaXMgaXMgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoaXMgY2xhc3MuXG4gICAgICpcbiAgICAgKiBIZXJlIGFyZSBzb21lIG1vcmUgZGV0YWlscyBhYm91dCBpdC5cbiAgICAgKlxuICAgICAqIEl0IGxvb2tzIHByZXR0eSBnb29kLCBkb2Vzbid0IGl0P1xuICAgICAqL1xuICAgIGV4cG9ydCBjbGFzcyBGb28ge1xuICAgICAgcHVibGljIGJhcigpIHsgfVxuICAgIH1cbiAgYCk7XG5cbiAgZXhwZWN0KGFzc2VtYmx5LnR5cGVzIVsndGVzdHBrZy5Gb28nXS5kb2NzIS5yZW1hcmtzKS50b0JlKFxuICAgIFwiSGVyZSBhcmUgc29tZSBtb3JlIGRldGFpbHMgYWJvdXQgaXQuXFxuXFxuSXQgbG9va3MgcHJldHR5IGdvb2QsIGRvZXNuJ3QgaXQ/XCIsXG4gICk7XG59KTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudGVzdCgnc2VwYXJhdGUgbG9uZyBkb2MgY29tbWVudCBpbnRvIHN1bW1hcnkgYW5kIHJlbWFya3MnLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGFzc2VtYmx5ID0gYXdhaXQgY29tcGlsZShgXG4gICAgLyoqXG4gICAgICogTG90cyBvZiBwZW9wbGUgZW5qb3kgd3JpdGluZyB2ZXJ5IGxvbmcgY2FwdGlvbnMgaGVyZS4gSSB0aGluayBpdCdzIGJlY2F1c2UgdGhleVxuICAgICAqIGNvcHkvcGFzdGUgdGhlbSBvdXQgb2YgQ2xvdWRGb3JtYXRpb24sIHdoaWNoIGhhcyBhIHRlbmRlbmN5IHRvIGp1c3QgaGF2ZSBvbmVcbiAgICAgKiBkb2MgYmxvY2sgcGVyIEFQSSBpdGVtIGFuZCBubyBzdHJ1Y3R1cmFsIHNlcGFyYXRpb24uXG4gICAgICovXG4gICAgZXhwb3J0IGNsYXNzIEZvbyB7XG4gICAgICBwdWJsaWMgYmFyKCkgeyB9XG4gICAgfVxuICBgKTtcblxuICBleHBlY3QoYXNzZW1ibHkudHlwZXMhWyd0ZXN0cGtnLkZvbyddLmRvY3MpLnRvRXF1YWwoe1xuICAgIHN1bW1hcnk6ICdMb3RzIG9mIHBlb3BsZSBlbmpveSB3cml0aW5nIHZlcnkgbG9uZyBjYXB0aW9ucyBoZXJlLicsXG4gICAgcmVtYXJrczpcbiAgICAgIFwiSSB0aGluayBpdCdzIGJlY2F1c2UgdGhleVxcbmNvcHkvcGFzdGUgdGhlbSBvdXQgb2YgQ2xvdWRGb3JtYXRpb24sIHdoaWNoIGhhcyBhIHRlbmRlbmN5IHRvIGp1c3QgaGF2ZSBvbmVcXG5cIiArXG4gICAgICAnZG9jIGJsb2NrIHBlciBBUEkgaXRlbSBhbmQgbm8gc3RydWN0dXJhbCBzZXBhcmF0aW9uLicsXG4gIH0pO1xufSk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnRlc3QoJ3NlcGFyYXRlIG5vbi1zcGFjZSBidXQgbmV3bGluZSB0ZXJtaW5hdGVkIGRvY3MgaW50byBzdW1tYXJ5JnJlbWFya3MnLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGFzc2VtYmx5ID0gYXdhaXQgY29tcGlsZShgXG4gICAgLyoqXG4gICAgICogTG90cyBvZiBwZW9wbGUgZW5qb3kgd3JpdGluZyB2ZXJ5IGxvbmcgY2FwdGlvbnMgaGVyZS5cbiAgICAgKiBJIHRoaW5rIGl0J3MgYmVjYXVzZSB0aGV5IGNvcHkvcGFzdGUgdGhlbSBvdXQgb2YgQ2xvdWRGb3JtYXRpb24sXG4gICAgICogd2hpY2ggaGFzIGEgdGVuZGVuY3kgdG8ganVzdCBoYXZlIG9uZVxuICAgICAqIGRvYyBibG9jayBwZXIgQVBJIGl0ZW0gYW5kIG5vIHN0cnVjdHVyYWwgc2VwYXJhdGlvbi5cbiAgICAgKi9cbiAgICBleHBvcnQgY2xhc3MgRm9vIHtcbiAgICAgIHB1YmxpYyBiYXIoKSB7IH1cbiAgICB9XG4gIGApO1xuXG4gIGV4cGVjdChhc3NlbWJseS50eXBlcyFbJ3Rlc3Rwa2cuRm9vJ10uZG9jcykudG9FcXVhbCh7XG4gICAgc3VtbWFyeTogJ0xvdHMgb2YgcGVvcGxlIGVuam95IHdyaXRpbmcgdmVyeSBsb25nIGNhcHRpb25zIGhlcmUuJyxcbiAgICByZW1hcmtzOlxuICAgICAgXCJJIHRoaW5rIGl0J3MgYmVjYXVzZSB0aGV5IGNvcHkvcGFzdGUgdGhlbSBvdXQgb2YgQ2xvdWRGb3JtYXRpb24sXFxud2hpY2ggaGFzIGEgdGVuZGVuY3kgdG8ganVzdCBoYXZlIG9uZVxcblwiICtcbiAgICAgICdkb2MgYmxvY2sgcGVyIEFQSSBpdGVtIGFuZCBubyBzdHJ1Y3R1cmFsIHNlcGFyYXRpb24uJyxcbiAgfSk7XG59KTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudGVzdCgnZG9udCBhZGQgcGVyaW9kIHRvIHN1bW1hcnkgdGhhdCBlbmRzIGluIGV4Y2xhbWF0aW9uIG1hcmsnLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGFzc2VtYmx5ID0gYXdhaXQgY29tcGlsZShgXG4gICAgLyoqXG4gICAgICogSSdtIGhhcHB5IGFib3V0IHRoaXMgY2xhc3MhXG4gICAgICovXG4gICAgZXhwb3J0IGNsYXNzIEZvbyB7XG4gICAgICBwdWJsaWMgYmFyKCkgeyB9XG4gICAgfVxuICBgKTtcblxuICBleHBlY3QoYXNzZW1ibHkudHlwZXMhWyd0ZXN0cGtnLkZvbyddLmRvY3MpLnRvRXF1YWwoe1xuICAgIHN1bW1hcnk6IFwiSSdtIGhhcHB5IGFib3V0IHRoaXMgY2xhc3MhXCIsXG4gIH0pO1xufSk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnRlc3QoJ3BhcnNlIG1ldGhvZCBkb2NzJywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IGNvbXBpbGUoYFxuICAgIGV4cG9ydCBjbGFzcyBGb28ge1xuICAgICAgLyoqXG4gICAgICAgKiBEbyB0aGUgZm9vXG4gICAgICAgKi9cbiAgICAgIHB1YmxpYyBiYXIoYXJnOiBzdHJpbmcpIHsgQXJyYXkuaXNBcnJheShhcmcpOyB9XG4gICAgfVxuICBgKTtcblxuICBjb25zdCBjbGFzc1R5cGUgPSBhc3NlbWJseS50eXBlcyFbJ3Rlc3Rwa2cuRm9vJ10gYXMgc3BlYy5DbGFzc1R5cGU7XG5cbiAgZXhwZWN0KGNsYXNzVHlwZS5tZXRob2RzIVswXS5kb2NzKS50b0VxdWFsKHtcbiAgICBzdW1tYXJ5OiAnRG8gdGhlIGZvby4nLFxuICB9KTtcbn0pO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG50ZXN0KCdhc3NvY2lhdGUgcGFyYW1ldGVyIGNvbW1lbnRzIHdpdGggcmlnaHQgcGFyYW1ldGVyJywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IGNvbXBpbGUoYFxuICAgIGV4cG9ydCBjbGFzcyBGb28ge1xuICAgICAgLyoqXG4gICAgICAgKiBEbyB0aGUgZm9vXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIGFyZyBGaXJzdCBhcmd1bWVudCBpcyBiZXN0IGFyZ3VtZW50XG4gICAgICAgKi9cbiAgICAgIHB1YmxpYyBiYXIoYXJnOiBzdHJpbmcpIHsgQXJyYXkuaXNBcnJheShhcmcpOyB9XG4gICAgfVxuICBgKTtcblxuICBjb25zdCBjbGFzc1R5cGUgPSBhc3NlbWJseS50eXBlcyFbJ3Rlc3Rwa2cuRm9vJ10gYXMgc3BlYy5DbGFzc1R5cGU7XG5cbiAgZXhwZWN0KGNsYXNzVHlwZS5tZXRob2RzIVswXS5wYXJhbWV0ZXJzIVswXS5kb2NzKS50b0VxdWFsKHtcbiAgICBzdW1tYXJ5OiAnRmlyc3QgYXJndW1lbnQgaXMgYmVzdCBhcmd1bWVudC4nLFxuICB9KTtcbn0pO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG50ZXN0KCdyZWFkIGV4YW1wbGUnLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGFzc2VtYmx5ID0gYXdhaXQgY29tcGlsZShgXG4gICAgZXhwb3J0IGNsYXNzIEZvbyB7XG4gICAgICAvKipcbiAgICAgICAqIERvIHRoZSBmb29cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICpcbiAgICAgICAqIC8vIEV4YW1wbGUgb2YgZm9vaW5nIGl0IHVwOlxuICAgICAgICogbmV3IEZvbygpLmJhcigpO1xuICAgICAgICovXG4gICAgICBwdWJsaWMgYmFyKCkge31cbiAgICB9XG4gIGApO1xuXG4gIGNvbnN0IGNsYXNzVHlwZSA9IGFzc2VtYmx5LnR5cGVzIVsndGVzdHBrZy5Gb28nXSBhcyBzcGVjLkNsYXNzVHlwZTtcblxuICBleHBlY3QoY2xhc3NUeXBlLm1ldGhvZHMhWzBdLmRvY3MhLmV4YW1wbGUpLnRvQmUoXG4gICAgJy8vIEV4YW1wbGUgb2YgZm9vaW5nIGl0IHVwOlxcbicgKyAnbmV3IEZvbygpLmJhcigpOycsXG4gICk7XG59KTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudGVzdCgncmVhZCBkZWZhdWx0IHZhbHVlJywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IGNvbXBpbGUoYFxuICAgIGV4cG9ydCBpbnRlcmZhY2UgRm9vIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGZvbyB3ZSdyZSB0YWxraW5nIGFib3V0XG4gICAgICAgKlxuICAgICAgICogQGRlZmF1bHQgU29tZSBmb29cbiAgICAgICAqL1xuICAgICAgcmVhZG9ubHkgZm9vPzogc3RyaW5nO1xuICAgIH1cbiAgYCk7XG5cbiAgY29uc3QgY2xhc3NUeXBlID0gYXNzZW1ibHkudHlwZXMhWyd0ZXN0cGtnLkZvbyddIGFzIHNwZWMuSW50ZXJmYWNlVHlwZTtcblxuICBleHBlY3QoY2xhc3NUeXBlLnByb3BlcnRpZXMhWzBdLmRvY3MhLmRlZmF1bHQpLnRvQmUoJ1NvbWUgZm9vJyk7XG59KTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudGVzdCgncmVhZCBcInNlZVwiIGFubm90YXRpb24nLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGFzc2VtYmx5ID0gYXdhaXQgY29tcGlsZShgXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwOi8vbG1ndGZ5LmNvbS9cbiAgICAgKi9cbiAgICBleHBvcnQgY2xhc3MgRm9vIHtcbiAgICB9XG4gIGApO1xuXG4gIGV4cGVjdChhc3NlbWJseS50eXBlcyFbJ3Rlc3Rwa2cuRm9vJ10uZG9jcyEuc2VlKS50b0JlKCdodHRwOi8vbG1ndGZ5LmNvbS8nKTtcbn0pO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG50ZXN0KCdyZWFkIFwicmV0dXJuc1wiIGFubm90YXRpb24nLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGFzc2VtYmx5ID0gYXdhaXQgY29tcGlsZShgXG4gICAgZXhwb3J0IGNsYXNzIEZvbyB7XG4gICAgICAvKipcbiAgICAgICAqIERvIHRoZSBmb29cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyBOb3RoaW5nLCB3aHkgd291bGQgaXQ/XG4gICAgICAgKi9cbiAgICAgIHB1YmxpYyBiYXIoYXJnOiBzdHJpbmcpIHsgQXJyYXkuaXNBcnJheShhcmcpOyB9XG4gICAgfVxuICBgKTtcblxuICBjb25zdCBjbGFzc1R5cGUgPSBhc3NlbWJseS50eXBlcyFbJ3Rlc3Rwa2cuRm9vJ10gYXMgc3BlYy5DbGFzc1R5cGU7XG5cbiAgZXhwZWN0KGNsYXNzVHlwZS5tZXRob2RzIVswXS5kb2NzIS5yZXR1cm5zKS50b0JlKCdOb3RoaW5nLCB3aHkgd291bGQgaXQ/Jyk7XG59KTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudGVzdCgnY2FuIGhheiBkZXByZWNhdGVkJywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IGNvbXBpbGUoYFxuICAgIGV4cG9ydCBjbGFzcyBGb28ge1xuICAgICAgLyoqXG4gICAgICAgKiBEbyB0aGUgZm9vXG4gICAgICAgKlxuICAgICAgICogQGRlcHJlY2F0ZWQgVGhlc2UgZGF5cyB3ZSBkbyB0aGUgYmFyXG4gICAgICAgKi9cbiAgICAgIHB1YmxpYyBiYXIoYXJnOiBzdHJpbmcpIHsgQXJyYXkuaXNBcnJheShhcmcpOyB9XG4gICAgfVxuICBgKTtcblxuICBjb25zdCBjbGFzc1R5cGUgPSBhc3NlbWJseS50eXBlcyFbJ3Rlc3Rwa2cuRm9vJ10gYXMgc3BlYy5DbGFzc1R5cGU7XG5cbiAgZXhwZWN0KGNsYXNzVHlwZS5tZXRob2RzIVswXS5kb2NzIS5kZXByZWNhdGVkKS50b0JlKFxuICAgICdUaGVzZSBkYXlzIHdlIGRvIHRoZSBiYXInLFxuICApO1xufSk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnRlc3QoJ2NhbiBtYXJrIHN0YWJsZScsIGFzeW5jICgpID0+IHtcbiAgY29uc3QgYXNzZW1ibHkgPSBhd2FpdCBjb21waWxlKGBcbiAgICAvKipcbiAgICAgKiBSb2NrIHNvbGlkIEZvb1xuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIGV4cG9ydCBjbGFzcyBGb28ge1xuICAgIH1cbiAgYCk7XG5cbiAgY29uc3QgY2xhc3NUeXBlID0gYXNzZW1ibHkudHlwZXMhWyd0ZXN0cGtnLkZvbyddIGFzIHNwZWMuQ2xhc3NUeXBlO1xuXG4gIGV4cGVjdChjbGFzc1R5cGUuZG9jcyEuc3RhYmlsaXR5KS50b0JlKHNwZWMuU3RhYmlsaXR5LlN0YWJsZSk7XG59KTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudGVzdCgnY2FuIG1hcmsgZXhwZXJpbWVudGFsJywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IGNvbXBpbGUoYFxuICAgIC8qKlxuICAgICAqIFNsaWdodGx5IGxlc3Mgc29saWQgRm9vXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgZXhwb3J0IGNsYXNzIEZvbyB7XG4gICAgfVxuICBgKTtcblxuICBjb25zdCBjbGFzc1R5cGUgPSBhc3NlbWJseS50eXBlcyFbJ3Rlc3Rwa2cuRm9vJ10gYXMgc3BlYy5DbGFzc1R5cGU7XG5cbiAgZXhwZWN0KGNsYXNzVHlwZS5kb2NzIS5zdGFiaWxpdHkpLnRvQmUoc3BlYy5TdGFiaWxpdHkuRXhwZXJpbWVudGFsKTtcbn0pO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnRlc3QoJ2NhbiBtYXJrIGV4dGVybmFsJywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IGNvbXBpbGUoYFxuICAgIC8qKlxuICAgICAqIEBzdGFiaWxpdHkgZXh0ZXJuYWxcbiAgICAgKi9cbiAgICBleHBvcnQgY2xhc3MgRm9vIHtcbiAgICAgIHB1YmxpYyBmbG9vcCgpIHtcbiAgICAgICAgQXJyYXkuaXNBcnJheSgzKTtcbiAgICAgIH1cbiAgICB9XG4gIGApO1xuXG4gIGNvbnN0IGNsYXNzVHlwZSA9IGFzc2VtYmx5LnR5cGVzIVsndGVzdHBrZy5Gb28nXSBhcyBzcGVjLkNsYXNzVHlwZTtcbiAgY29uc3QgbWV0aG9kID0gY2xhc3NUeXBlLm1ldGhvZHMhLmZpbmQoKG0pID0+IG0ubmFtZSA9PT0gJ2Zsb29wJyk7XG5cbiAgZXhwZWN0KGNsYXNzVHlwZS5kb2NzIS5zdGFiaWxpdHkpLnRvQmUoc3BlYy5TdGFiaWxpdHkuRXh0ZXJuYWwpO1xuICBleHBlY3QobWV0aG9kIS5kb2NzIS5zdGFiaWxpdHkpLnRvQmUoc3BlYy5TdGFiaWxpdHkuRXh0ZXJuYWwpO1xufSk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnRlc3QoJ2NhbiBtYXJrIHN1YmNsYXNzYWJsZScsIGFzeW5jICgpID0+IHtcbiAgY29uc3QgYXNzZW1ibHkgPSBhd2FpdCBjb21waWxlKGBcbiAgICAvKipcbiAgICAgKiBCZWNvbWUgdGhpcyBGb29cbiAgICAgKlxuICAgICAqIEBzdWJjbGFzc2FibGVcbiAgICAgKi9cbiAgICBleHBvcnQgY2xhc3MgRm9vIHtcbiAgICB9XG4gIGApO1xuXG4gIGNvbnN0IGNsYXNzVHlwZSA9IGFzc2VtYmx5LnR5cGVzIVsndGVzdHBrZy5Gb28nXSBhcyBzcGVjLkNsYXNzVHlwZTtcblxuICBleHBlY3QoY2xhc3NUeXBlLmRvY3MhLnN1YmNsYXNzYWJsZSkudG9CZVRydXRoeSgpO1xufSk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnRlc3QoJ2NhbiBhZGQgYXJiaXRyYXJ5IHRhZ3MnLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGFzc2VtYmx5ID0gYXdhaXQgY29tcGlsZShgXG4gICAgLyoqXG4gICAgICogQGJvb3BcbiAgICAgKi9cbiAgICBleHBvcnQgY2xhc3MgRm9vIHtcbiAgICB9XG4gIGApO1xuXG4gIGNvbnN0IGNsYXNzVHlwZSA9IGFzc2VtYmx5LnR5cGVzIVsndGVzdHBrZy5Gb28nXSBhcyBzcGVjLkNsYXNzVHlwZTtcblxuICBleHBlY3QoY2xhc3NUeXBlLmRvY3MhLmN1c3RvbSkudG9FcXVhbCh7IGJvb3A6ICd0cnVlJyB9KTtcbn0pO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG50ZXN0KCdzdGFiaWxpdHkgaXMgaW5oZXJpdGVkIGZyb20gcGFyZW50IHR5cGUnLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHN0YWJpbGl0aWVzID0gW1xuICAgIFsnQGRlcHJlY2F0ZWQgTm90IGdvb2Qgbm8gbW9yZScsIFN0YWJpbGl0eS5EZXByZWNhdGVkXSxcbiAgICBbJ0BleHBlcmltZW50YWwnLCBTdGFiaWxpdHkuRXhwZXJpbWVudGFsXSxcbiAgICBbJ0BzdGFibGUnLCBTdGFiaWxpdHkuU3RhYmxlXSxcbiAgXTtcblxuICBmb3IgKGNvbnN0IFt0YWcsIHN0YWJpbGl0eV0gb2Ygc3RhYmlsaXRpZXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgIGNvbnN0IGFzc2VtYmx5ID0gYXdhaXQgY29tcGlsZShgXG4gICAgICAvKipcbiAgICAgICAqICR7dGFnfVxuICAgICAgICovXG4gICAgICBleHBvcnQgY2xhc3MgRm9vIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgQXJyYXkuaXNBcnJheSgzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB1YmxpYyBiYXIoKSB7XG4gICAgICAgICAgQXJyYXkuaXNBcnJheSgzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGApO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tYXdhaXQtaW4tbG9vcCAqL1xuXG4gICAgY29uc3QgY2xhc3NUeXBlID0gYXNzZW1ibHkudHlwZXMhWyd0ZXN0cGtnLkZvbyddIGFzIHNwZWMuQ2xhc3NUeXBlO1xuICAgIGNvbnN0IGluaXRpYWxpemVyID0gY2xhc3NUeXBlLmluaXRpYWxpemVyITtcbiAgICBjb25zdCBtZXRob2QgPSBjbGFzc1R5cGUubWV0aG9kcyEuZmluZCgobSkgPT4gbS5uYW1lID09PSAnYmFyJykhO1xuXG4gICAgZXhwZWN0KGNsYXNzVHlwZS5kb2NzIS5zdGFiaWxpdHkpLnRvQmUoc3RhYmlsaXR5KTtcbiAgICBleHBlY3QoaW5pdGlhbGl6ZXIuZG9jcyEuc3RhYmlsaXR5KS50b0JlKHN0YWJpbGl0eSk7XG4gICAgZXhwZWN0KG1ldGhvZC5kb2NzIS5zdGFiaWxpdHkpLnRvQmUoc3RhYmlsaXR5KTtcbiAgfVxufSk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnRlc3QoJ0BleGFtcGxlIGNhbiBjb250YWluIEAgc2lnbicsIGFzeW5jICgpID0+IHtcbiAgY29uc3QgYXNzZW1ibHkgPSBhd2FpdCBjb21waWxlKGBcbiAgICAvKipcbiAgICAgKiBBbiBJQU0gcm9sZSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgaW5zdGFuY2UgcHJvZmlsZSBhc3NpZ25lZCB0byB0aGlzIEF1dG8gU2NhbGluZyBHcm91cC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBpbXBvcnQgKiBhcyB4IGZyb20gJ0BiYW5hbmEnO1xuICAgICAqL1xuICAgIGV4cG9ydCBjbGFzcyBGb28ge1xuICAgIH1cbiAgYCk7XG5cbiAgY29uc3QgY2xhc3NUeXBlID0gYXNzZW1ibHkudHlwZXMhWyd0ZXN0cGtnLkZvbyddIGFzIHNwZWMuQ2xhc3NUeXBlO1xuICBleHBlY3QoY2xhc3NUeXBlLmRvY3MhLmV4YW1wbGUpLnRvQmUoXCJpbXBvcnQgKiBhcyB4IGZyb20gJ0BiYW5hbmEnO1wiKTtcbn0pO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnRlc3QoJ0BleHBlcmltZW50YWwgc3RhdHVzIGlzIHJlZmxlY3RlZCBpbiBnZW5lcmF0ZWQgZG9jc3RyaW5nJywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb21waWxlSnNpaUZvclRlc3QoYFxuICAgIC8qKlxuICAgICAqIEhlcmUgaXMgYSBmcmVzaCBjbGFzc1xuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGV4cG9ydCBjbGFzcyBGb28ge1xuICAgIH1cbiAgYCk7XG5cbiAgZXhwZWN0KHJlc3VsdC5maWxlc1snaW5kZXguanMnXSkudG9Db250YWluKFxuICAgIGxpbmVzKFxuICAgICAgJy8qKicsXG4gICAgICAnICogKGV4cGVyaW1lbnRhbCkgSGVyZSBpcyBhIGZyZXNoIGNsYXNzLicsXG4gICAgICAnIConLFxuICAgICAgJyAqIEBleHBlcmltZW50YWwnLFxuICAgICAgJyAqLycsXG4gICAgICAnY2xhc3MgRm9vIHsnLFxuICAgICAgJ30nLFxuICAgICksXG4gICk7XG5cbiAgZXhwZWN0KHJlc3VsdC5maWxlc1snaW5kZXguZC50cyddKS50b0NvbnRhaW4oXG4gICAgbGluZXMoXG4gICAgICAnLyoqJyxcbiAgICAgICcgKiAoZXhwZXJpbWVudGFsKSBIZXJlIGlzIGEgZnJlc2ggY2xhc3MuJyxcbiAgICAgICcgKicsXG4gICAgICAnICogQGV4cGVyaW1lbnRhbCcsXG4gICAgICAnICovJyxcbiAgICAgICdleHBvcnQgZGVjbGFyZSBjbGFzcyBGb28geycsXG4gICAgICAnfScsXG4gICAgKSxcbiAgKTtcbn0pO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnRlc3QoJ0BkZXByZWNhdGVkIHN0YXR1cyBpcyByZWZsZWN0ZWQgaW4gZ2VuZXJhdGVkIGRvY3N0cmluZycsIGFzeW5jICgpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29tcGlsZUpzaWlGb3JUZXN0KGBcbiAgICAvKipcbiAgICAgKiBIZXJlIGlzIGFuIG9sZCBjbGFzc1xuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHNvbWV0aGluZyBlbHNlXG4gICAgICovXG4gICAgZXhwb3J0IGNsYXNzIEZvZ2V5IHtcbiAgICB9XG4gIGApO1xuXG4gIGV4cGVjdChyZXN1bHQuZmlsZXNbJ2luZGV4LmpzJ10pLnRvQ29udGFpbihcbiAgICBsaW5lcyhcbiAgICAgICcvKionLFxuICAgICAgJyAqIChkZXByZWNhdGVkKSBIZXJlIGlzIGFuIG9sZCBjbGFzcy4nLFxuICAgICAgJyAqJyxcbiAgICAgICcgKiBAZGVwcmVjYXRlZCBVc2Ugc29tZXRoaW5nIGVsc2UnLFxuICAgICAgJyAqLycsXG4gICAgICAnY2xhc3MgRm9nZXkgeycsXG4gICAgICAnfScsXG4gICAgKSxcbiAgKTtcblxuICBleHBlY3QocmVzdWx0LmZpbGVzWydpbmRleC5kLnRzJ10pLnRvQ29udGFpbihcbiAgICBsaW5lcyhcbiAgICAgICcvKionLFxuICAgICAgJyAqIChkZXByZWNhdGVkKSBIZXJlIGlzIGFuIG9sZCBjbGFzcy4nLFxuICAgICAgJyAqJyxcbiAgICAgICcgKiBAZGVwcmVjYXRlZCBVc2Ugc29tZXRoaW5nIGVsc2UnLFxuICAgICAgJyAqLycsXG4gICAgICAnZXhwb3J0IGRlY2xhcmUgY2xhc3MgRm9nZXkgeycsXG4gICAgICAnfScsXG4gICAgKSxcbiAgKTtcbn0pO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnRlc3QoJ1JlbmRlcmluZyBqc2lpIGRvY3MgYmFjayB0byBhIGRvYyBjb21tZW50JywgKCkgPT4ge1xuICBleHBlY3QoXG4gICAgcmVuZGVyU3ltYm9sRG9jdW1lbnRhdGlvbih7XG4gICAgICBzdW1tYXJ5OiAnVGhpcyBpcyB0aGUgc3VtbWFyeScsXG4gICAgICByZW1hcmtzOiAnWW91IGNhbiB1c2UgdGhpc1xcbm9yIG5vdCwgYXMgeW91IHNlZSBmaXQuJyxcbiAgICAgIGRlZmF1bHQ6ICd0aGFzIGEgZGVmYXVsdCB2YWx1ZScsXG4gICAgICBzZWU6ICdodHRwczovL3NvbWUudXJsLycsXG4gICAgICBzdWJjbGFzc2FibGU6IHRydWUsXG4gICAgICByZXR1cm5zOiAnQSB2YWx1ZScsXG4gICAgICBleGFtcGxlOiAncHJpbnQoXCJhIHRoaW5nXCIpOycsXG4gICAgICBjdXN0b206IHtcbiAgICAgICAgc2luZzogJ3doZW55b3VyZXdpbm5pbmcnLFxuICAgICAgfSxcbiAgICB9KSxcbiAgKS50b0VxdWFsKFxuICAgIGxpbmVzKFxuICAgICAgJ1RoaXMgaXMgdGhlIHN1bW1hcnknLFxuICAgICAgJycsXG4gICAgICAnWW91IGNhbiB1c2UgdGhpcycsXG4gICAgICAnb3Igbm90LCBhcyB5b3Ugc2VlIGZpdC4nLFxuICAgICAgJycsXG4gICAgICAnQHJldHVybnMgQSB2YWx1ZScsXG4gICAgICAnQGRlZmF1bHQgdGhhcyBhIGRlZmF1bHQgdmFsdWUnLFxuICAgICAgJ0BzZWUgaHR0cHM6Ly9zb21lLnVybC8nLFxuICAgICAgJ0BzdWJjbGFzc2FibGUnLFxuICAgICAgJ0BzaW5nIHdoZW55b3VyZXdpbm5pbmcnLFxuICAgICAgJ0BleGFtcGxlJyxcbiAgICAgICcnLFxuICAgICAgJ3ByaW50KFwiYSB0aGluZ1wiKTsnLFxuICAgICksXG4gICk7XG59KTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBsaW5lcyguLi5sczogc3RyaW5nW10pIHtcbiAgcmV0dXJuIGluZGVudGVkKDAsIC4uLmxzKTtcbn1cblxuZnVuY3Rpb24gaW5kZW50ZWQoaW5kZW50OiBudW1iZXIsIC4uLmxpbmVzOiBzdHJpbmdbXSkge1xuICBjb25zdCBwcmVmaXggPSAnICcucmVwZWF0KGluZGVudCk7XG4gIHJldHVybiBsaW5lcy5tYXAoKGwpID0+IGAke3ByZWZpeH0ke2x9YCkuam9pbignXFxuJyk7XG59XG4iXX0=