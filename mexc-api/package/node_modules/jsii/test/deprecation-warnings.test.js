"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// eslint-disable-next-line import/no-extraneous-dependencies
const fs = require("fs");
const path = require("path");
const lib_1 = require("../lib");
const compiler_1 = require("../lib/compiler");
const project_info_1 = require("../lib/project-info");
const DEPRECATED = '/** @deprecated Use something else */';
describe('Function generation', () => {
    test('generates the print function', async () => {
        const result = await lib_1.compileJsiiForTest(``, undefined /* callback */, {
            addDeprecationWarnings: true,
        });
        expect(jsFile(result, '.warnings.jsii')).toMatch(`function print(name, deprecationMessage) {
    const deprecated = process.env.JSII_DEPRECATED;
    const deprecationMode = ["warn", "fail", "quiet"].includes(deprecated) ? deprecated : "warn";
    const message = \`\${name} is deprecated.\\n  \${deprecationMessage}\\n  This API will be removed in the next major release.\`;
    switch (deprecationMode) {
        case "fail":
            throw new DeprecationError(message);
        case "warn":
            console.warn("[WARNING]", message);
            break;
    }
}
const visitedObjects = new Set();
class DeprecationError extends Error {
}
module.exports = { print };
module.exports.DeprecationError = DeprecationError;
`);
    });
    test('generates a function for each type', async () => {
        const result = await lib_1.compileJsiiForTest(`
        export interface Foo {}
        export interface Bar {}
        export interface Baz {}
        `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result, '.warnings.jsii')).toMatch(`function testpkg_Foo(p) {
}
function testpkg_Bar(p) {
}
function testpkg_Baz(p) {
}`);
    });
    test('generates metadata', async () => {
        var _a, _b;
        const result = await lib_1.compileJsiiForTest(`
        export interface Foo {}
        export interface Bar {}
        export interface Baz {}
        `, undefined /* callback */, { addDeprecationWarnings: true });
        expect((_b = (_a = result.assembly.metadata) === null || _a === void 0 ? void 0 : _a.jsii) === null || _b === void 0 ? void 0 : _b.compiledWithDeprecationWarnings).toBe(true);
    });
    test('for each non-primitive property, generates a call', async () => {
        const result = await lib_1.compileJsiiForTest(`
        export interface Foo {}
        export interface Bar {}
        export interface Baz {
          readonly foo: Foo;
          readonly bar: Bar;
          readonly x: string;
        }
        `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result, '.warnings.jsii')).toMatch(`function testpkg_Baz(p) {
    if (p == null)
        return;
    visitedObjects.add(p);
    if (!visitedObjects.has(p.bar))
        testpkg_Bar(p.bar);
    if (!visitedObjects.has(p.foo))
        testpkg_Foo(p.foo);
    visitedObjects.delete(p);
}`);
    });
    test('generates empty functions for interfaces', async () => {
        const result = await lib_1.compileJsiiForTest(`
        export interface IFoo {
          bar(): string;
        }
        `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result, '.warnings.jsii')).toMatch(`function testpkg_IFoo(p) {
}`);
    });
    test('generates empty functions for classes', async () => {
        const result = await lib_1.compileJsiiForTest(`
        export class Foo {
          bar() {return 0};
        }
        `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result, '.warnings.jsii')).toMatch(`function testpkg_Foo(p) {
}`);
    });
    test('generates calls for recursive types', async () => {
        const result = await lib_1.compileJsiiForTest(`
        export interface Bar {readonly bar?: Bar}
        `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result, '.warnings.jsii')).toMatch(`function testpkg_Bar(p) {
    if (p == null)
        return;
    visitedObjects.add(p);
    if (!visitedObjects.has(p.bar))
        testpkg_Bar(p.bar);
    visitedObjects.delete(p);
}`);
    });
    test('generates exports for all the functions', async () => {
        const result = await lib_1.compileJsiiForTest(`
        export interface Foo {}
        export interface Bar {}
        export interface Baz {}
        `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result, '.warnings.jsii')).toMatch(`module.exports = { print, testpkg_Foo, testpkg_Bar, testpkg_Baz };`);
    });
    test('generates functions for enums', async () => {
        const result = await lib_1.compileJsiiForTest(`
        export enum State {
          ON,

          ${DEPRECATED}
          OFF
        }
        `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result, '.warnings.jsii'))
            .toMatch(`function testpkg_State(p) {
    if (p == null)
        return;
    visitedObjects.add(p);
    const ns = require("./index.js");
    if (Object.values(ns.State).filter(x => x === p).length > 1)
        return;
    if (p === ns.State.OFF)
        print("testpkg.State#OFF", "Use something else");
    visitedObjects.delete(p);
}
`);
    });
    test('generates calls for deprecated inherited properties', async () => {
        const result = await lib_1.compileJsiiForTest(`
        export interface Baz {
          /** @deprecated message from Baz */
          readonly x: string;          
        }
        export interface Bar {
          /** @deprecated message from Bar */
          readonly x: string;          
        }
        export interface Foo extends Bar, Baz {
        }
        `, undefined /* callback */, { addDeprecationWarnings: true });
        const warningsFileContent = jsFile(result, '.warnings.jsii');
        // For each supertype, its corresponding function should be generated, as usual
        expect(warningsFileContent).toMatch(`function testpkg_Baz(p) {
    if (p == null)
        return;
    visitedObjects.add(p);
    if ("x" in p)
        print("testpkg.Baz#x", "message from Baz");
    visitedObjects.delete(p);
}`);
        expect(warningsFileContent).toMatch(`function testpkg_Bar(p) {
    if (p == null)
        return;
    visitedObjects.add(p);
    if ("x" in p)
        print("testpkg.Bar#x", "message from Bar");
    visitedObjects.delete(p);
}`);
        // But a call for one of the instances of the property should also be generated in the base function
        expect(warningsFileContent).toMatch(`function testpkg_Foo(p) {
    if (p == null)
        return;
    visitedObjects.add(p);
    if ("x" in p)
        print("testpkg.Baz#x", "message from Baz");
    visitedObjects.delete(p);
}`);
    });
    test('skips properties that are deprecated in one supertype but not the other', async () => {
        const result = await lib_1.compileJsiiForTest(`
        export interface Baz {
          readonly x: string;          
        }
        export interface Bar {
          /** @deprecated message from Bar */
          readonly x: string;          
        }
        export interface Foo extends Bar, Baz {
        }
        `, undefined /* callback */, { addDeprecationWarnings: true });
        const warningsFileContent = jsFile(result, '.warnings.jsii');
        expect(warningsFileContent).toMatch(`function testpkg_Foo(p) {
}`);
    });
    test('generates calls for types with deprecated properties', async () => {
        const result = await lib_1.compileJsiiForTest(`
      export interface Bar {
        readonly x: string;
      }

      export interface Foo {
        readonly y: string;

        /** @deprecated kkkkkkkk */
        readonly bar: Bar;
      }
      `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result, '.warnings.jsii')).toMatch(`function testpkg_Foo(p) {
    if (p == null)
        return;
    visitedObjects.add(p);
    if ("bar" in p)
        print("testpkg.Foo#bar", "kkkkkkkk");
    if (!visitedObjects.has(p.bar))
        testpkg_Bar(p.bar);
    visitedObjects.delete(p);
}
`);
    });
    test('generates calls for each property of a deprecated type', async () => {
        const result = await lib_1.compileJsiiForTest(`
      /** @deprecated use Bar instead */
      export interface Foo {
        readonly bar: string;
        readonly baz: number;
      }
      `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result, '.warnings.jsii')).toMatch(`function testpkg_Foo(p) {
    if (p == null)
        return;
    visitedObjects.add(p);
    if ("bar" in p)
        print("testpkg.Foo#bar", "use Bar instead");
    if ("baz" in p)
        print("testpkg.Foo#baz", "use Bar instead");
    visitedObjects.delete(p);
}
`);
    });
    test('generates calls for types in other assemblies', async () => {
        const calcBaseOfBaseRoot = resolveModuleDir('@scope/jsii-calc-base-of-base');
        const calcBaseRoot = resolveModuleDir('@scope/jsii-calc-base');
        const calcLibRoot = resolveModuleDir('@scope/jsii-calc-lib');
        await compile(calcBaseOfBaseRoot, false);
        await compile(calcBaseRoot, true);
        await compile(calcLibRoot, true);
        const warningsFile = loadWarningsFile(calcBaseRoot);
        // jsii-calc-base was compiled with warnings. So we expect to see handlers for its types in the warnings file
        expect(warningsFile).toMatch('_scope_jsii_calc_base');
        // jsii-calc-base-of-base was not compiled with warnings. Its types shouldn't be in the warnings file
        expect(warningsFile).not.toMatch('_scope_jsii_calc_base_of_base');
        // Recompiling without deprecation warning to leave the packages in a clean state
        await compile(calcBaseRoot, false);
        await compile(calcLibRoot, false);
    }, 30000);
});
describe('Call injections', () => {
    test('does not add warnings by default', async () => {
        var _a, _b;
        const result = await lib_1.compileJsiiForTest(`
    export class Foo {
      ${DEPRECATED}
      public bar(){}
    }
  `);
        expect(jsFile(result)).toMatch('bar() { }');
        expect((_b = (_a = result.assembly.metadata) === null || _a === void 0 ? void 0 : _a.jsii) === null || _b === void 0 ? void 0 : _b.compiledWithDeprecationWarnings).toBeFalsy();
    });
    test('generates a require statement', async () => {
        const result = await lib_1.compileJsiiForTest({
            'index.ts': `export * from './some/folder/source'`,
            'some/folder/source.ts': `
          export class Foo {
            ${DEPRECATED}
            public bar(){}
          }
        `,
        }, undefined /* callback */, { addDeprecationWarnings: true });
        const expectedPath = ['..', '..', '.warnings.jsii.js'].join('/');
        const content = jsFile(result, 'some/folder/source');
        expect(content).toContain(`const jsiiDeprecationWarnings = require("${expectedPath}")`);
    });
    test('deprecated methods', async () => {
        const result = await lib_1.compileJsiiForTest(`
    export class Foo {
      ${DEPRECATED}
      public bar(){}
    }
  `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result)).toMatch('bar() { jsiiDeprecationWarnings.print("testpkg.Foo#bar", "Use something else"); }');
    });
    test('methods with parameters', async () => {
        const result = await lib_1.compileJsiiForTest(`
    export interface A {readonly x: number;}
    export class Foo {
      public bar(a: A, b: number){return a.x + b;}
    }
  `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result)).toMatch('bar(a, b) { jsiiDeprecationWarnings.testpkg_A(a); return a.x + b; }');
    });
    test('deprecated getters', async () => {
        const result = await lib_1.compileJsiiForTest(`
    export class Foo {
      private _x = 0;
      ${DEPRECATED}
      public get x(){return this._x}
    }
  `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result)).toMatch('get x() { jsiiDeprecationWarnings.print("testpkg.Foo#x", "Use something else"); return this._x; }');
    });
    test('deprecated setters', async () => {
        const result = await lib_1.compileJsiiForTest(`
    export class Foo {
      private _x = 0;
      public get x(){return this._x}

      ${DEPRECATED}
      public set x(_x: number) {this._x = _x;}
    }
  `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result)).toMatch('set x(_x) { jsiiDeprecationWarnings.print("testpkg.Foo#x", "Use something else"); this._x = _x; }');
    });
    test('deprecated classes', async () => {
        const result = await lib_1.compileJsiiForTest(`
    ${DEPRECATED}
    export class Foo {
      constructor(){}
    }
  `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result)).toMatch('constructor() { jsiiDeprecationWarnings.print("testpkg.Foo", ""); }');
    });
});
function jsFile(result, baseName = 'index') {
    const file = Object.entries(result.files).find(([name]) => name === `${baseName}.js`);
    return file[1];
}
function resolveModuleDir(name) {
    return path.dirname(require.resolve(`${name}/package.json`));
}
async function compile(projectRoot, addDeprecationWarnings) {
    const { projectInfo } = await project_info_1.loadProjectInfo(projectRoot);
    const compiler = new compiler_1.Compiler({
        projectInfo,
        addDeprecationWarnings,
    });
    await compiler.emit();
}
function loadWarningsFile(projectRoot) {
    return fs
        .readFileSync(path.join(projectRoot, '.warnings.jsii.js'))
        .toString();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwcmVjYXRpb24td2FybmluZ3MudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImRlcHJlY2F0aW9uLXdhcm5pbmdzLnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSw2REFBNkQ7QUFDN0QseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUU3QixnQ0FBcUU7QUFDckUsOENBQTJDO0FBQzNDLHNEQUFzRDtBQUV0RCxNQUFNLFVBQVUsR0FBRyx1Q0FBdUMsQ0FBQztBQUUzRCxRQUFRLENBQUMscUJBQXFCLEVBQUUsR0FBRyxFQUFFO0lBQ25DLElBQUksQ0FBQyw4QkFBOEIsRUFBRSxLQUFLLElBQUksRUFBRTtRQUM5QyxNQUFNLE1BQU0sR0FBRyxNQUFNLHdCQUFrQixDQUFDLEVBQUUsRUFBRSxTQUFTLENBQUMsY0FBYyxFQUFFO1lBQ3BFLHNCQUFzQixFQUFFLElBQUk7U0FDN0IsQ0FBQyxDQUFDO1FBRUgsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FDOUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJMLENBQ0ksQ0FBQztJQUNKLENBQUMsQ0FBQyxDQUFDO0lBRUgsSUFBSSxDQUFDLG9DQUFvQyxFQUFFLEtBQUssSUFBSSxFQUFFO1FBQ3BELE1BQU0sTUFBTSxHQUFHLE1BQU0sd0JBQWtCLENBQ3JDOzs7O1NBSUcsRUFDSCxTQUFTLENBQUMsY0FBYyxFQUN4QixFQUFFLHNCQUFzQixFQUFFLElBQUksRUFBRSxDQUNqQyxDQUFDO1FBRUYsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FDOUM7Ozs7O0VBS0osQ0FDRyxDQUFDO0lBQ0osQ0FBQyxDQUFDLENBQUM7SUFFSCxJQUFJLENBQUMsb0JBQW9CLEVBQUUsS0FBSyxJQUFJLEVBQUU7O1FBQ3BDLE1BQU0sTUFBTSxHQUFHLE1BQU0sd0JBQWtCLENBQ3JDOzs7O1NB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QVEsR0FBRyxJQUFJLG1CQUFRLENBQUM7UUFDNUIsV0FBVztRQUNYLHNCQUFzQjtLQUN2QixDQUFDLENBQUM7SUFFSCxNQUFNLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUN4QixDQUFDO0FBRUQsU0FBUyxnQkFBZ0IsQ0FBQyxXQUFtQjtJQUMzQyxPQUFPLEVBQUU7U0FDTixZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztTQUN6RCxRQUFRLEVBQUUsQ0FBQztBQUNoQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHsgY29tcGlsZUpzaWlGb3JUZXN0LCBIZWxwZXJDb21waWxhdGlvblJlc3VsdCB9IGZyb20gJy4uL2xpYic7XG5pbXBvcnQgeyBDb21waWxlciB9IGZyb20gJy4uL2xpYi9jb21waWxlcic7XG5pbXBvcnQgeyBsb2FkUHJvamVjdEluZm8gfSBmcm9tICcuLi9saWIvcHJvamVjdC1pbmZvJztcblxuY29uc3QgREVQUkVDQVRFRCA9ICcvKiogQGRlcHJlY2F0ZWQgVXNlIHNvbWV0aGluZyBlbHNlICovJztcblxuZGVzY3JpYmUoJ0Z1bmN0aW9uIGdlbmVyYXRpb24nLCAoKSA9PiB7XG4gIHRlc3QoJ2dlbmVyYXRlcyB0aGUgcHJpbnQgZnVuY3Rpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29tcGlsZUpzaWlGb3JUZXN0KGBgLCB1bmRlZmluZWQgLyogY2FsbGJhY2sgKi8sIHtcbiAgICAgIGFkZERlcHJlY2F0aW9uV2FybmluZ3M6IHRydWUsXG4gICAgfSk7XG5cbiAgICBleHBlY3QoanNGaWxlKHJlc3VsdCwgJy53YXJuaW5ncy5qc2lpJykpLnRvTWF0Y2goXG4gICAgICBgZnVuY3Rpb24gcHJpbnQobmFtZSwgZGVwcmVjYXRpb25NZXNzYWdlKSB7XG4gICAgY29uc3QgZGVwcmVjYXRlZCA9IHByb2Nlc3MuZW52LkpTSUlfREVQUkVDQVRFRDtcbiAgICBjb25zdCBkZXByZWNhdGlvbk1vZGUgPSBbXCJ3YXJuXCIsIFwiZmFpbFwiLCBcInF1aWV0XCJdLmluY2x1ZGVzKGRlcHJlY2F0ZWQpID8gZGVwcmVjYXRlZCA6IFwid2FyblwiO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBcXGBcXCR7bmFtZX0gaXMgZGVwcmVjYXRlZC5cXFxcbiAgXFwke2RlcHJlY2F0aW9uTWVzc2FnZX1cXFxcbiAgVGhpcyBBUEkgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXFxgO1xuICAgIHN3aXRjaCAoZGVwcmVjYXRpb25Nb2RlKSB7XG4gICAgICAgIGNhc2UgXCJmYWlsXCI6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRGVwcmVjYXRpb25FcnJvcihtZXNzYWdlKTtcbiAgICAgICAgY2FzZSBcIndhcm5cIjpcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltXQVJOSU5HXVwiLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbmNvbnN0IHZpc2l0ZWRPYmplY3RzID0gbmV3IFNldCgpO1xuY2xhc3MgRGVwcmVjYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbm1vZHVsZS5leHBvcnRzID0geyBwcmludCB9O1xubW9kdWxlLmV4cG9ydHMuRGVwcmVjYXRpb25FcnJvciA9IERlcHJlY2F0aW9uRXJyb3I7XG5gLFxuICAgICk7XG4gIH0pO1xuXG4gIHRlc3QoJ2dlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBlYWNoIHR5cGUnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29tcGlsZUpzaWlGb3JUZXN0KFxuICAgICAgYFxuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIEZvbyB7fVxuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIEJhciB7fVxuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIEJheiB7fVxuICAgICAgICBgLFxuICAgICAgdW5kZWZpbmVkIC8qIGNhbGxiYWNrICovLFxuICAgICAgeyBhZGREZXByZWNhdGlvbldhcm5pbmdzOiB0cnVlIH0sXG4gICAgKTtcblxuICAgIGV4cGVjdChqc0ZpbGUocmVzdWx0LCAnLndhcm5pbmdzLmpzaWknKSkudG9NYXRjaChcbiAgICAgIGBmdW5jdGlvbiB0ZXN0cGtnX0ZvbyhwKSB7XG59XG5mdW5jdGlvbiB0ZXN0cGtnX0JhcihwKSB7XG59XG5mdW5jdGlvbiB0ZXN0cGtnX0JheihwKSB7XG59YCxcbiAgICApO1xuICB9KTtcblxuICB0ZXN0KCdnZW5lcmF0ZXMgbWV0YWRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29tcGlsZUpzaWlGb3JUZXN0KFxuICAgICAgYFxuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIEZvbyB7fVxuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIEJhciB7fVxuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIEJheiB7fVxuICAgICAgICBgLFxuICAgICAgdW5kZWZpbmVkIC8qIGNhbGxiYWNrICovLFxuICAgICAgeyBhZGREZXByZWNhdGlvbldhcm5pbmdzOiB0cnVlIH0sXG4gICAgKTtcbiAgICBleHBlY3QoXG4gICAgICByZXN1bHQuYXNzZW1ibHkubWV0YWRhdGE/LmpzaWk/LmNvbXBpbGVkV2l0aERlcHJlY2F0aW9uV2FybmluZ3MsXG4gICAgKS50b0JlKHRydWUpO1xuICB9KTtcblxuICB0ZXN0KCdmb3IgZWFjaCBub24tcHJpbWl0aXZlIHByb3BlcnR5LCBnZW5lcmF0ZXMgYSBjYWxsJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdChcbiAgICAgIGBcbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBGb28ge31cbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBCYXIge31cbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBCYXoge1xuICAgICAgICAgIHJlYWRvbmx5IGZvbzogRm9vO1xuICAgICAgICAgIHJlYWRvbmx5IGJhcjogQmFyO1xuICAgICAgICAgIHJlYWRvbmx5IHg6IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBgLFxuICAgICAgdW5kZWZpbmVkIC8qIGNhbGxiYWNrICovLFxuICAgICAgeyBhZGREZXByZWNhdGlvbldhcm5pbmdzOiB0cnVlIH0sXG4gICAgKTtcblxuICAgIGV4cGVjdChqc0ZpbGUocmVzdWx0LCAnLndhcm5pbmdzLmpzaWknKSkudG9NYXRjaChgZnVuY3Rpb24gdGVzdHBrZ19CYXoocCkge1xuICAgIGlmIChwID09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICB2aXNpdGVkT2JqZWN0cy5hZGQocCk7XG4gICAgaWYgKCF2aXNpdGVkT2JqZWN0cy5oYXMocC5iYXIpKVxuICAgICAgICB0ZXN0cGtnX0JhcihwLmJhcik7XG4gICAgaWYgKCF2aXNpdGVkT2JqZWN0cy5oYXMocC5mb28pKVxuICAgICAgICB0ZXN0cGtnX0ZvbyhwLmZvbyk7XG4gICAgdmlzaXRlZE9iamVjdHMuZGVsZXRlKHApO1xufWApO1xuICB9KTtcblxuICB0ZXN0KCdnZW5lcmF0ZXMgZW1wdHkgZnVuY3Rpb25zIGZvciBpbnRlcmZhY2VzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdChcbiAgICAgIGBcbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBJRm9vIHtcbiAgICAgICAgICBiYXIoKTogc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGAsXG4gICAgICB1bmRlZmluZWQgLyogY2FsbGJhY2sgKi8sXG4gICAgICB7IGFkZERlcHJlY2F0aW9uV2FybmluZ3M6IHRydWUgfSxcbiAgICApO1xuXG4gICAgZXhwZWN0KGpzRmlsZShyZXN1bHQsICcud2FybmluZ3MuanNpaScpKS50b01hdGNoKGBmdW5jdGlvbiB0ZXN0cGtnX0lGb28ocCkge1xufWApO1xuICB9KTtcblxuICB0ZXN0KCdnZW5lcmF0ZXMgZW1wdHkgZnVuY3Rpb25zIGZvciBjbGFzc2VzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdChcbiAgICAgIGBcbiAgICAgICAgZXhwb3J0IGNsYXNzIEZvbyB7XG4gICAgICAgICAgYmFyKCkge3JldHVybiAwfTtcbiAgICAgICAgfVxuICAgICAgICBgLFxuICAgICAgdW5kZWZpbmVkIC8qIGNhbGxiYWNrICovLFxuICAgICAgeyBhZGREZXByZWNhdGlvbldhcm5pbmdzOiB0cnVlIH0sXG4gICAgKTtcblxuICAgIGV4cGVjdChqc0ZpbGUocmVzdWx0LCAnLndhcm5pbmdzLmpzaWknKSkudG9NYXRjaChgZnVuY3Rpb24gdGVzdHBrZ19Gb28ocCkge1xufWApO1xuICB9KTtcblxuICB0ZXN0KCdnZW5lcmF0ZXMgY2FsbHMgZm9yIHJlY3Vyc2l2ZSB0eXBlcycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb21waWxlSnNpaUZvclRlc3QoXG4gICAgICBgXG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQmFyIHtyZWFkb25seSBiYXI/OiBCYXJ9XG4gICAgICAgIGAsXG4gICAgICB1bmRlZmluZWQgLyogY2FsbGJhY2sgKi8sXG4gICAgICB7IGFkZERlcHJlY2F0aW9uV2FybmluZ3M6IHRydWUgfSxcbiAgICApO1xuXG4gICAgZXhwZWN0KGpzRmlsZShyZXN1bHQsICcud2FybmluZ3MuanNpaScpKS50b01hdGNoKFxuICAgICAgYGZ1bmN0aW9uIHRlc3Rwa2dfQmFyKHApIHtcbiAgICBpZiAocCA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgdmlzaXRlZE9iamVjdHMuYWRkKHApO1xuICAgIGlmICghdmlzaXRlZE9iamVjdHMuaGFzKHAuYmFyKSlcbiAgICAgICAgdGVzdHBrZ19CYXIocC5iYXIpO1xuICAgIHZpc2l0ZWRPYmplY3RzLmRlbGV0ZShwKTtcbn1gLFxuICAgICk7XG4gIH0pO1xuXG4gIHRlc3QoJ2dlbmVyYXRlcyBleHBvcnRzIGZvciBhbGwgdGhlIGZ1bmN0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb21waWxlSnNpaUZvclRlc3QoXG4gICAgICBgXG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRm9vIHt9XG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQmFyIHt9XG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQmF6IHt9XG4gICAgICAgIGAsXG4gICAgICB1bmRlZmluZWQgLyogY2FsbGJhY2sgKi8sXG4gICAgICB7IGFkZERlcHJlY2F0aW9uV2FybmluZ3M6IHRydWUgfSxcbiAgICApO1xuXG4gICAgZXhwZWN0KGpzRmlsZShyZXN1bHQsICcud2FybmluZ3MuanNpaScpKS50b01hdGNoKFxuICAgICAgYG1vZHVsZS5leHBvcnRzID0geyBwcmludCwgdGVzdHBrZ19Gb28sIHRlc3Rwa2dfQmFyLCB0ZXN0cGtnX0JheiB9O2AsXG4gICAgKTtcbiAgfSk7XG5cbiAgdGVzdCgnZ2VuZXJhdGVzIGZ1bmN0aW9ucyBmb3IgZW51bXMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29tcGlsZUpzaWlGb3JUZXN0KFxuICAgICAgYFxuICAgICAgICBleHBvcnQgZW51bSBTdGF0ZSB7XG4gICAgICAgICAgT04sXG5cbiAgICAgICAgICAke0RFUFJFQ0FURUR9XG4gICAgICAgICAgT0ZGXG4gICAgICAgIH1cbiAgICAgICAgYCxcbiAgICAgIHVuZGVmaW5lZCAvKiBjYWxsYmFjayAqLyxcbiAgICAgIHsgYWRkRGVwcmVjYXRpb25XYXJuaW5nczogdHJ1ZSB9LFxuICAgICk7XG5cbiAgICBleHBlY3QoanNGaWxlKHJlc3VsdCwgJy53YXJuaW5ncy5qc2lpJykpXG4gICAgICAudG9NYXRjaChgZnVuY3Rpb24gdGVzdHBrZ19TdGF0ZShwKSB7XG4gICAgaWYgKHAgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZpc2l0ZWRPYmplY3RzLmFkZChwKTtcbiAgICBjb25zdCBucyA9IHJlcXVpcmUoXCIuL2luZGV4LmpzXCIpO1xuICAgIGlmIChPYmplY3QudmFsdWVzKG5zLlN0YXRlKS5maWx0ZXIoeCA9PiB4ID09PSBwKS5sZW5ndGggPiAxKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHAgPT09IG5zLlN0YXRlLk9GRilcbiAgICAgICAgcHJpbnQoXCJ0ZXN0cGtnLlN0YXRlI09GRlwiLCBcIlVzZSBzb21ldGhpbmcgZWxzZVwiKTtcbiAgICB2aXNpdGVkT2JqZWN0cy5kZWxldGUocCk7XG59XG5gKTtcbiAgfSk7XG5cbiAgdGVzdCgnZ2VuZXJhdGVzIGNhbGxzIGZvciBkZXByZWNhdGVkIGluaGVyaXRlZCBwcm9wZXJ0aWVzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdChcbiAgICAgIGBcbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBCYXoge1xuICAgICAgICAgIC8qKiBAZGVwcmVjYXRlZCBtZXNzYWdlIGZyb20gQmF6ICovXG4gICAgICAgICAgcmVhZG9ubHkgeDogc3RyaW5nOyAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIEJhciB7XG4gICAgICAgICAgLyoqIEBkZXByZWNhdGVkIG1lc3NhZ2UgZnJvbSBCYXIgKi9cbiAgICAgICAgICByZWFkb25seSB4OiBzdHJpbmc7ICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRm9vIGV4dGVuZHMgQmFyLCBCYXoge1xuICAgICAgICB9XG4gICAgICAgIGAsXG4gICAgICB1bmRlZmluZWQgLyogY2FsbGJhY2sgKi8sXG4gICAgICB7IGFkZERlcHJlY2F0aW9uV2FybmluZ3M6IHRydWUgfSxcbiAgICApO1xuXG4gICAgY29uc3Qgd2FybmluZ3NGaWxlQ29udGVudCA9IGpzRmlsZShyZXN1bHQsICcud2FybmluZ3MuanNpaScpO1xuXG4gICAgLy8gRm9yIGVhY2ggc3VwZXJ0eXBlLCBpdHMgY29ycmVzcG9uZGluZyBmdW5jdGlvbiBzaG91bGQgYmUgZ2VuZXJhdGVkLCBhcyB1c3VhbFxuICAgIGV4cGVjdCh3YXJuaW5nc0ZpbGVDb250ZW50KS50b01hdGNoKGBmdW5jdGlvbiB0ZXN0cGtnX0JheihwKSB7XG4gICAgaWYgKHAgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZpc2l0ZWRPYmplY3RzLmFkZChwKTtcbiAgICBpZiAoXCJ4XCIgaW4gcClcbiAgICAgICAgcHJpbnQoXCJ0ZXN0cGtnLkJheiN4XCIsIFwibWVzc2FnZSBmcm9tIEJhelwiKTtcbiAgICB2aXNpdGVkT2JqZWN0cy5kZWxldGUocCk7XG59YCk7XG4gICAgZXhwZWN0KHdhcm5pbmdzRmlsZUNvbnRlbnQpLnRvTWF0Y2goYGZ1bmN0aW9uIHRlc3Rwa2dfQmFyKHApIHtcbiAgICBpZiAocCA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgdmlzaXRlZE9iamVjdHMuYWRkKHApO1xuICAgIGlmIChcInhcIiBpbiBwKVxuICAgICAgICBwcmludChcInRlc3Rwa2cuQmFyI3hcIiwgXCJtZXNzYWdlIGZyb20gQmFyXCIpO1xuICAgIHZpc2l0ZWRPYmplY3RzLmRlbGV0ZShwKTtcbn1gKTtcblxuICAgIC8vIEJ1dCBhIGNhbGwgZm9yIG9uZSBvZiB0aGUgaW5zdGFuY2VzIG9mIHRoZSBwcm9wZXJ0eSBzaG91bGQgYWxzbyBiZSBnZW5lcmF0ZWQgaW4gdGhlIGJhc2UgZnVuY3Rpb25cbiAgICBleHBlY3Qod2FybmluZ3NGaWxlQ29udGVudCkudG9NYXRjaChgZnVuY3Rpb24gdGVzdHBrZ19Gb28ocCkge1xuICAgIGlmIChwID09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICB2aXNpdGVkT2JqZWN0cy5hZGQocCk7XG4gICAgaWYgKFwieFwiIGluIHApXG4gICAgICAgIHByaW50KFwidGVzdHBrZy5CYXojeFwiLCBcIm1lc3NhZ2UgZnJvbSBCYXpcIik7XG4gICAgdmlzaXRlZE9iamVjdHMuZGVsZXRlKHApO1xufWApO1xuICB9KTtcblxuICB0ZXN0KCdza2lwcyBwcm9wZXJ0aWVzIHRoYXQgYXJlIGRlcHJlY2F0ZWQgaW4gb25lIHN1cGVydHlwZSBidXQgbm90IHRoZSBvdGhlcicsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb21waWxlSnNpaUZvclRlc3QoXG4gICAgICBgXG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQmF6IHtcbiAgICAgICAgICByZWFkb25seSB4OiBzdHJpbmc7ICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQmFyIHtcbiAgICAgICAgICAvKiogQGRlcHJlY2F0ZWQgbWVzc2FnZSBmcm9tIEJhciAqL1xuICAgICAgICAgIHJlYWRvbmx5IHg6IHN0cmluZzsgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBGb28gZXh0ZW5kcyBCYXIsIEJheiB7XG4gICAgICAgIH1cbiAgICAgICAgYCxcbiAgICAgIHVuZGVmaW5lZCAvKiBjYWxsYmFjayAqLyxcbiAgICAgIHsgYWRkRGVwcmVjYXRpb25XYXJuaW5nczogdHJ1ZSB9LFxuICAgICk7XG5cbiAgICBjb25zdCB3YXJuaW5nc0ZpbGVDb250ZW50ID0ganNGaWxlKHJlc3VsdCwgJy53YXJuaW5ncy5qc2lpJyk7XG5cbiAgICBleHBlY3Qod2FybmluZ3NGaWxlQ29udGVudCkudG9NYXRjaChgZnVuY3Rpb24gdGVzdHBrZ19Gb28ocCkge1xufWApO1xuICB9KTtcblxuICB0ZXN0KCdnZW5lcmF0ZXMgY2FsbHMgZm9yIHR5cGVzIHdpdGggZGVwcmVjYXRlZCBwcm9wZXJ0aWVzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdChcbiAgICAgIGBcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQmFyIHtcbiAgICAgICAgcmVhZG9ubHkgeDogc3RyaW5nO1xuICAgICAgfVxuXG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEZvbyB7XG4gICAgICAgIHJlYWRvbmx5IHk6IHN0cmluZztcblxuICAgICAgICAvKiogQGRlcHJlY2F0ZWQga2tra2tra2sgKi9cbiAgICAgICAgcmVhZG9ubHkgYmFyOiBCYXI7XG4gICAgICB9XG4gICAgICBgLFxuICAgICAgdW5kZWZpbmVkIC8qIGNhbGxiYWNrICovLFxuICAgICAgeyBhZGREZXByZWNhdGlvbldhcm5pbmdzOiB0cnVlIH0sXG4gICAgKTtcblxuICAgIGV4cGVjdChqc0ZpbGUocmVzdWx0LCAnLndhcm5pbmdzLmpzaWknKSkudG9NYXRjaChgZnVuY3Rpb24gdGVzdHBrZ19Gb28ocCkge1xuICAgIGlmIChwID09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICB2aXNpdGVkT2JqZWN0cy5hZGQocCk7XG4gICAgaWYgKFwiYmFyXCIgaW4gcClcbiAgICAgICAgcHJpbnQoXCJ0ZXN0cGtnLkZvbyNiYXJcIiwgXCJra2tra2tra1wiKTtcbiAgICBpZiAoIXZpc2l0ZWRPYmplY3RzLmhhcyhwLmJhcikpXG4gICAgICAgIHRlc3Rwa2dfQmFyKHAuYmFyKTtcbiAgICB2aXNpdGVkT2JqZWN0cy5kZWxldGUocCk7XG59XG5gKTtcbiAgfSk7XG5cbiAgdGVzdCgnZ2VuZXJhdGVzIGNhbGxzIGZvciBlYWNoIHByb3BlcnR5IG9mIGEgZGVwcmVjYXRlZCB0eXBlJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdChcbiAgICAgIGBcbiAgICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgQmFyIGluc3RlYWQgKi9cbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRm9vIHtcbiAgICAgICAgcmVhZG9ubHkgYmFyOiBzdHJpbmc7XG4gICAgICAgIHJlYWRvbmx5IGJhejogbnVtYmVyO1xuICAgICAgfVxuICAgICAgYCxcbiAgICAgIHVuZGVmaW5lZCAvKiBjYWxsYmFjayAqLyxcbiAgICAgIHsgYWRkRGVwcmVjYXRpb25XYXJuaW5nczogdHJ1ZSB9LFxuICAgICk7XG5cbiAgICBleHBlY3QoanNGaWxlKHJlc3VsdCwgJy53YXJuaW5ncy5qc2lpJykpLnRvTWF0Y2goYGZ1bmN0aW9uIHRlc3Rwa2dfRm9vKHApIHtcbiAgICBpZiAocCA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgdmlzaXRlZE9iamVjdHMuYWRkKHApO1xuICAgIGlmIChcImJhclwiIGluIHApXG4gICAgICAgIHByaW50KFwidGVzdHBrZy5Gb28jYmFyXCIsIFwidXNlIEJhciBpbnN0ZWFkXCIpO1xuICAgIGlmIChcImJhelwiIGluIHApXG4gICAgICAgIHByaW50KFwidGVzdHBrZy5Gb28jYmF6XCIsIFwidXNlIEJhciBpbnN0ZWFkXCIpO1xuICAgIHZpc2l0ZWRPYmplY3RzLmRlbGV0ZShwKTtcbn1cbmApO1xuICB9KTtcblxuICB0ZXN0KCdnZW5lcmF0ZXMgY2FsbHMgZm9yIHR5cGVzIGluIG90aGVyIGFzc2VtYmxpZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgY2FsY0Jhc2VPZkJhc2VSb290ID0gcmVzb2x2ZU1vZHVsZURpcihcbiAgICAgICdAc2NvcGUvanNpaS1jYWxjLWJhc2Utb2YtYmFzZScsXG4gICAgKTtcbiAgICBjb25zdCBjYWxjQmFzZVJvb3QgPSByZXNvbHZlTW9kdWxlRGlyKCdAc2NvcGUvanNpaS1jYWxjLWJhc2UnKTtcbiAgICBjb25zdCBjYWxjTGliUm9vdCA9IHJlc29sdmVNb2R1bGVEaXIoJ0BzY29wZS9qc2lpLWNhbGMtbGliJyk7XG5cbiAgICBhd2FpdCBjb21waWxlKGNhbGNCYXNlT2ZCYXNlUm9vdCwgZmFsc2UpO1xuICAgIGF3YWl0IGNvbXBpbGUoY2FsY0Jhc2VSb290LCB0cnVlKTtcbiAgICBhd2FpdCBjb21waWxlKGNhbGNMaWJSb290LCB0cnVlKTtcbiAgICBjb25zdCB3YXJuaW5nc0ZpbGUgPSBsb2FkV2FybmluZ3NGaWxlKGNhbGNCYXNlUm9vdCk7XG5cbiAgICAvLyBqc2lpLWNhbGMtYmFzZSB3YXMgY29tcGlsZWQgd2l0aCB3YXJuaW5ncy4gU28gd2UgZXhwZWN0IHRvIHNlZSBoYW5kbGVycyBmb3IgaXRzIHR5cGVzIGluIHRoZSB3YXJuaW5ncyBmaWxlXG4gICAgZXhwZWN0KHdhcm5pbmdzRmlsZSkudG9NYXRjaCgnX3Njb3BlX2pzaWlfY2FsY19iYXNlJyk7XG5cbiAgICAvLyBqc2lpLWNhbGMtYmFzZS1vZi1iYXNlIHdhcyBub3QgY29tcGlsZWQgd2l0aCB3YXJuaW5ncy4gSXRzIHR5cGVzIHNob3VsZG4ndCBiZSBpbiB0aGUgd2FybmluZ3MgZmlsZVxuICAgIGV4cGVjdCh3YXJuaW5nc0ZpbGUpLm5vdC50b01hdGNoKCdfc2NvcGVfanNpaV9jYWxjX2Jhc2Vfb2ZfYmFzZScpO1xuXG4gICAgLy8gUmVjb21waWxpbmcgd2l0aG91dCBkZXByZWNhdGlvbiB3YXJuaW5nIHRvIGxlYXZlIHRoZSBwYWNrYWdlcyBpbiBhIGNsZWFuIHN0YXRlXG4gICAgYXdhaXQgY29tcGlsZShjYWxjQmFzZVJvb3QsIGZhbHNlKTtcbiAgICBhd2FpdCBjb21waWxlKGNhbGNMaWJSb290LCBmYWxzZSk7XG4gIH0sIDMwMDAwKTtcbn0pO1xuXG5kZXNjcmliZSgnQ2FsbCBpbmplY3Rpb25zJywgKCkgPT4ge1xuICB0ZXN0KCdkb2VzIG5vdCBhZGQgd2FybmluZ3MgYnkgZGVmYXVsdCcsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb21waWxlSnNpaUZvclRlc3QoXG4gICAgICBgXG4gICAgZXhwb3J0IGNsYXNzIEZvbyB7XG4gICAgICAke0RFUFJFQ0FURUR9XG4gICAgICBwdWJsaWMgYmFyKCl7fVxuICAgIH1cbiAgYCxcbiAgICApO1xuXG4gICAgZXhwZWN0KGpzRmlsZShyZXN1bHQpKS50b01hdGNoKCdiYXIoKSB7IH0nKTtcbiAgICBleHBlY3QoXG4gICAgICByZXN1bHQuYXNzZW1ibHkubWV0YWRhdGE/LmpzaWk/LmNvbXBpbGVkV2l0aERlcHJlY2F0aW9uV2FybmluZ3MsXG4gICAgKS50b0JlRmFsc3koKTtcbiAgfSk7XG5cbiAgdGVzdCgnZ2VuZXJhdGVzIGEgcmVxdWlyZSBzdGF0ZW1lbnQnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29tcGlsZUpzaWlGb3JUZXN0KFxuICAgICAge1xuICAgICAgICAnaW5kZXgudHMnOiBgZXhwb3J0ICogZnJvbSAnLi9zb21lL2ZvbGRlci9zb3VyY2UnYCxcbiAgICAgICAgJ3NvbWUvZm9sZGVyL3NvdXJjZS50cyc6IGBcbiAgICAgICAgICBleHBvcnQgY2xhc3MgRm9vIHtcbiAgICAgICAgICAgICR7REVQUkVDQVRFRH1cbiAgICAgICAgICAgIHB1YmxpYyBiYXIoKXt9XG4gICAgICAgICAgfVxuICAgICAgICBgLFxuICAgICAgfSxcbiAgICAgIHVuZGVmaW5lZCAvKiBjYWxsYmFjayAqLyxcbiAgICAgIHsgYWRkRGVwcmVjYXRpb25XYXJuaW5nczogdHJ1ZSB9LFxuICAgICk7XG5cbiAgICBjb25zdCBleHBlY3RlZFBhdGggPSBbJy4uJywgJy4uJywgJy53YXJuaW5ncy5qc2lpLmpzJ10uam9pbignLycpO1xuXG4gICAgY29uc3QgY29udGVudCA9IGpzRmlsZShyZXN1bHQsICdzb21lL2ZvbGRlci9zb3VyY2UnKTtcbiAgICBleHBlY3QoY29udGVudCkudG9Db250YWluKFxuICAgICAgYGNvbnN0IGpzaWlEZXByZWNhdGlvbldhcm5pbmdzID0gcmVxdWlyZShcIiR7ZXhwZWN0ZWRQYXRofVwiKWAsXG4gICAgKTtcbiAgfSk7XG5cbiAgdGVzdCgnZGVwcmVjYXRlZCBtZXRob2RzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdChcbiAgICAgIGBcbiAgICBleHBvcnQgY2xhc3MgRm9vIHtcbiAgICAgICR7REVQUkVDQVRFRH1cbiAgICAgIHB1YmxpYyBiYXIoKXt9XG4gICAgfVxuICBgLFxuICAgICAgdW5kZWZpbmVkIC8qIGNhbGxiYWNrICovLFxuICAgICAgeyBhZGREZXByZWNhdGlvbldhcm5pbmdzOiB0cnVlIH0sXG4gICAgKTtcblxuICAgIGV4cGVjdChqc0ZpbGUocmVzdWx0KSkudG9NYXRjaChcbiAgICAgICdiYXIoKSB7IGpzaWlEZXByZWNhdGlvbldhcm5pbmdzLnByaW50KFwidGVzdHBrZy5Gb28jYmFyXCIsIFwiVXNlIHNvbWV0aGluZyBlbHNlXCIpOyB9JyxcbiAgICApO1xuICB9KTtcblxuICB0ZXN0KCdtZXRob2RzIHdpdGggcGFyYW1ldGVycycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb21waWxlSnNpaUZvclRlc3QoXG4gICAgICBgXG4gICAgZXhwb3J0IGludGVyZmFjZSBBIHtyZWFkb25seSB4OiBudW1iZXI7fVxuICAgIGV4cG9ydCBjbGFzcyBGb28ge1xuICAgICAgcHVibGljIGJhcihhOiBBLCBiOiBudW1iZXIpe3JldHVybiBhLnggKyBiO31cbiAgICB9XG4gIGAsXG4gICAgICB1bmRlZmluZWQgLyogY2FsbGJhY2sgKi8sXG4gICAgICB7IGFkZERlcHJlY2F0aW9uV2FybmluZ3M6IHRydWUgfSxcbiAgICApO1xuXG4gICAgZXhwZWN0KGpzRmlsZShyZXN1bHQpKS50b01hdGNoKFxuICAgICAgJ2JhcihhLCBiKSB7IGpzaWlEZXByZWNhdGlvbldhcm5pbmdzLnRlc3Rwa2dfQShhKTsgcmV0dXJuIGEueCArIGI7IH0nLFxuICAgICk7XG4gIH0pO1xuXG4gIHRlc3QoJ2RlcHJlY2F0ZWQgZ2V0dGVycycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb21waWxlSnNpaUZvclRlc3QoXG4gICAgICBgXG4gICAgZXhwb3J0IGNsYXNzIEZvbyB7XG4gICAgICBwcml2YXRlIF94ID0gMDtcbiAgICAgICR7REVQUkVDQVRFRH1cbiAgICAgIHB1YmxpYyBnZXQgeCgpe3JldHVybiB0aGlzLl94fVxuICAgIH1cbiAgYCxcbiAgICAgIHVuZGVmaW5lZCAvKiBjYWxsYmFjayAqLyxcbiAgICAgIHsgYWRkRGVwcmVjYXRpb25XYXJuaW5nczogdHJ1ZSB9LFxuICAgICk7XG5cbiAgICBleHBlY3QoanNGaWxlKHJlc3VsdCkpLnRvTWF0Y2goXG4gICAgICAnZ2V0IHgoKSB7IGpzaWlEZXByZWNhdGlvbldhcm5pbmdzLnByaW50KFwidGVzdHBrZy5Gb28jeFwiLCBcIlVzZSBzb21ldGhpbmcgZWxzZVwiKTsgcmV0dXJuIHRoaXMuX3g7IH0nLFxuICAgICk7XG4gIH0pO1xuXG4gIHRlc3QoJ2RlcHJlY2F0ZWQgc2V0dGVycycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb21waWxlSnNpaUZvclRlc3QoXG4gICAgICBgXG4gICAgZXhwb3J0IGNsYXNzIEZvbyB7XG4gICAgICBwcml2YXRlIF94ID0gMDtcbiAgICAgIHB1YmxpYyBnZXQgeCgpe3JldHVybiB0aGlzLl94fVxuXG4gICAgICAke0RFUFJFQ0FURUR9XG4gICAgICBwdWJsaWMgc2V0IHgoX3g6IG51bWJlcikge3RoaXMuX3ggPSBfeDt9XG4gICAgfVxuICBgLFxuICAgICAgdW5kZWZpbmVkIC8qIGNhbGxiYWNrICovLFxuICAgICAgeyBhZGREZXByZWNhdGlvbldhcm5pbmdzOiB0cnVlIH0sXG4gICAgKTtcblxuICAgIGV4cGVjdChqc0ZpbGUocmVzdWx0KSkudG9NYXRjaChcbiAgICAgICdzZXQgeChfeCkgeyBqc2lpRGVwcmVjYXRpb25XYXJuaW5ncy5wcmludChcInRlc3Rwa2cuRm9vI3hcIiwgXCJVc2Ugc29tZXRoaW5nIGVsc2VcIik7IHRoaXMuX3ggPSBfeDsgfScsXG4gICAgKTtcbiAgfSk7XG5cbiAgdGVzdCgnZGVwcmVjYXRlZCBjbGFzc2VzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdChcbiAgICAgIGBcbiAgICAke0RFUFJFQ0FURUR9XG4gICAgZXhwb3J0IGNsYXNzIEZvbyB7XG4gICAgICBjb25zdHJ1Y3Rvcigpe31cbiAgICB9XG4gIGAsXG4gICAgICB1bmRlZmluZWQgLyogY2FsbGJhY2sgKi8sXG4gICAgICB7IGFkZERlcHJlY2F0aW9uV2FybmluZ3M6IHRydWUgfSxcbiAgICApO1xuXG4gICAgZXhwZWN0KGpzRmlsZShyZXN1bHQpKS50b01hdGNoKFxuICAgICAgJ2NvbnN0cnVjdG9yKCkgeyBqc2lpRGVwcmVjYXRpb25XYXJuaW5ncy5wcmludChcInRlc3Rwa2cuRm9vXCIsIFwiXCIpOyB9JyxcbiAgICApO1xuICB9KTtcbn0pO1xuXG5mdW5jdGlvbiBqc0ZpbGUocmVzdWx0OiBIZWxwZXJDb21waWxhdGlvblJlc3VsdCwgYmFzZU5hbWUgPSAnaW5kZXgnKTogc3RyaW5nIHtcbiAgY29uc3QgZmlsZSA9IE9iamVjdC5lbnRyaWVzKHJlc3VsdC5maWxlcykuZmluZChcbiAgICAoW25hbWVdKSA9PiBuYW1lID09PSBgJHtiYXNlTmFtZX0uanNgLFxuICApO1xuXG4gIHJldHVybiBmaWxlIVsxXTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZHVsZURpcihuYW1lOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHBhdGguZGlybmFtZShyZXF1aXJlLnJlc29sdmUoYCR7bmFtZX0vcGFja2FnZS5qc29uYCkpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjb21waWxlKHByb2plY3RSb290OiBzdHJpbmcsIGFkZERlcHJlY2F0aW9uV2FybmluZ3M6IGJvb2xlYW4pIHtcbiAgY29uc3QgeyBwcm9qZWN0SW5mbyB9ID0gYXdhaXQgbG9hZFByb2plY3RJbmZvKHByb2plY3RSb290KTtcblxuICBjb25zdCBjb21waWxlciA9IG5ldyBDb21waWxlcih7XG4gICAgcHJvamVjdEluZm8sXG4gICAgYWRkRGVwcmVjYXRpb25XYXJuaW5ncyxcbiAgfSk7XG5cbiAgYXdhaXQgY29tcGlsZXIuZW1pdCgpO1xufVxuXG5mdW5jdGlvbiBsb2FkV2FybmluZ3NGaWxlKHByb2plY3RSb290OiBzdHJpbmcpIHtcbiAgcmV0dXJuIGZzXG4gICAgLnJlYWRGaWxlU3luYyhwYXRoLmpvaW4ocHJvamVjdFJvb3QsICcud2FybmluZ3MuanNpaS5qcycpKVxuICAgIC50b1N0cmluZygpO1xufVxuIl19