"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.flatten = exports.wait = exports.filterAsync = exports.setExtend = exports.Scratch = exports.slugify = exports.shell = exports.retry = exports.AllAttemptsFailed = exports.resolveDependencyDirectory = void 0;
const child_process_1 = require("child_process");
const fs = require("fs-extra");
const os = require("os");
const path = require("path");
const logging = require("./logging");
/**
 * Given an npm package directory and a dependency name, returns the package directory of the dep.
 * @param packageDir     the root of the package declaring the dependency.
 * @param dependencyName the name of the dependency to be resolved.
 * @return the resolved directory path.
 */
function resolveDependencyDirectory(packageDir, dependencyName) {
    const lookupPaths = [path.join(packageDir, 'node_modules')];
    return path.dirname(require.resolve(`${dependencyName}/package.json`, { paths: lookupPaths }));
}
exports.resolveDependencyDirectory = resolveDependencyDirectory;
class AllAttemptsFailed extends Error {
    constructor(callback, errors) {
        super(`All attempts failed. Last error: ${errors[errors.length - 1].message}`);
        this.callback = callback;
        this.errors = errors;
    }
}
exports.AllAttemptsFailed = AllAttemptsFailed;
/**
 * Adds back-off and retry logic around the provided callback.
 *
 * @param cb   the callback which is to be retried.
 * @param opts the backoff-and-retry configuration
 *
 * @returns the result of `cb`
 */
async function retry(cb, opts = {}, waiter = wait) {
    var _a, _b, _c;
    let attemptsLeft = (_a = opts.maxAttempts) !== null && _a !== void 0 ? _a : 5;
    let backoffMs = (_b = opts.backoffBaseMilliseconds) !== null && _b !== void 0 ? _b : 150;
    const backoffMult = (_c = opts.backoffMultiplier) !== null && _c !== void 0 ? _c : 2;
    // Check for incorrect usage
    if (attemptsLeft <= 0) {
        throw new Error('maxTries must be > 0');
    }
    if (backoffMs <= 0) {
        throw new Error('backoffBaseMilliseconds must be > 0');
    }
    if (backoffMult <= 1) {
        throw new Error('backoffMultiplier must be > 1');
    }
    const errors = new Array();
    while (attemptsLeft > 0) {
        attemptsLeft--;
        try {
            // eslint-disable-next-line no-await-in-loop
            return await cb();
        }
        catch (error) {
            errors.push(error);
            if (opts.onFailedAttempt != null) {
                opts.onFailedAttempt(error, attemptsLeft, backoffMs);
            }
        }
        if (attemptsLeft > 0) {
            // eslint-disable-next-line no-await-in-loop
            await waiter(backoffMs).then(() => (backoffMs *= backoffMult));
        }
    }
    return Promise.reject(new AllAttemptsFailed(cb, errors));
}
exports.retry = retry;
/**
 * Spawns a child process with the provided command and arguments. The child
 * process is always spawned using `shell: true`, and the contents of
 * `process.env` is used as the initial value of the `env` spawn option (values
 * provided in `options.env` can override those).
 *
 * @param cmd     the command to shell out to.
 * @param args    the arguments to provide to `cmd`
 * @param options any options to pass to `spawn`
 */
async function shell(cmd, args, { retry: retryOptions, ...options } = {}) {
    var _a;
    async function spawn1() {
        logging.debug(cmd, args.join(' '), JSON.stringify(options));
        return new Promise((ok, ko) => {
            var _a;
            const child = child_process_1.spawn(cmd, args, {
                ...options,
                shell: true,
                env: { ...process.env, ...((_a = options.env) !== null && _a !== void 0 ? _a : {}) },
                stdio: ['ignore', 'pipe', 'pipe'],
            });
            const stdout = new Array();
            const stderr = new Array();
            child.stdout.on('data', (chunk) => {
                if (logging.level >= logging.LEVEL_SILLY) {
                    process.stderr.write(chunk); // notice - we emit all build output to stderr
                }
                stdout.push(Buffer.from(chunk));
            });
            child.stderr.on('data', (chunk) => {
                if (logging.level >= logging.LEVEL_SILLY) {
                    process.stderr.write(chunk);
                }
                stderr.push(Buffer.from(chunk));
            });
            child.once('error', ko);
            // Must use CLOSE instead of EXIT; EXIT may fire while there is still data in the
            // I/O pipes, which we will miss if we return at that point.
            child.once('close', (code, signal) => {
                const out = Buffer.concat(stdout).toString('utf-8');
                if (code === 0) {
                    return ok(out);
                }
                const err = Buffer.concat(stderr).toString('utf-8');
                const reason = signal != null ? `signal ${signal}` : `status ${code}`;
                const command = `${cmd} ${args.join(' ')}`;
                return ko(new Error([
                    `Command (${command}) failed with ${reason}:`,
                    // STDERR first, the erro message could be truncated in logs.
                    prefix(err, '#STDERR> '),
                    prefix(out, '#STDOUT> '),
                ].join('\n')));
                function prefix(text, add) {
                    return text
                        .split('\n')
                        .map((line) => `${add}${line}`)
                        .join('\n');
                }
            });
        });
    }
    if (retryOptions != null) {
        return retry(spawn1, {
            ...retryOptions,
            onFailedAttempt: (_a = retryOptions.onFailedAttempt) !== null && _a !== void 0 ? _a : ((error, attemptsLeft, backoffMs) => {
                var _a;
                const message = (_a = error.message) !== null && _a !== void 0 ? _a : error;
                const retryInfo = attemptsLeft > 0
                    ? `Waiting ${backoffMs} ms before retrying (${attemptsLeft} attempts left)`
                    : 'No attempts left';
                logging.info(`Command "${cmd} ${args.join(' ')}" failed with ${message}. ${retryInfo}.`);
            }),
        });
    }
    return spawn1();
}
exports.shell = shell;
/**
 * Strip filesystem unsafe characters from a string
 */
function slugify(x) {
    return x.replace(/[^a-zA-Z0-9_-]/g, '_');
}
exports.slugify = slugify;
/**
 * Class that makes a temporary directory and holds on to an operation object
 */
class Scratch {
    constructor(directory, object, fake) {
        this.directory = directory;
        this.object = object;
        this.fake = fake;
    }
    static async make(factory) {
        const tmpdir = await fs.mkdtemp(path.join(os.tmpdir(), 'npm-pack'));
        return new Scratch(tmpdir, await factory(tmpdir), false);
    }
    static fake(directory, object) {
        return new Scratch(directory, object, true);
    }
    static async cleanupAll(tempDirs) {
        await Promise.all(tempDirs.map((t) => t.cleanup()));
    }
    async cleanup() {
        if (!this.fake) {
            try {
                await fs.remove(this.directory);
            }
            catch (e) {
                if (e.code === 'EBUSY') {
                    // This occasionally happens on Windows if we try to clean up too
                    // quickly after we're done... Could be because some AV software is
                    // still running in the background.
                    // Wait 1s and retry once!
                    await new Promise((ok) => setTimeout(ok, 1000));
                    try {
                        await fs.remove(this.directory);
                    }
                    catch (e2) {
                        logging.warn(`Unable to clean up ${this.directory}: ${e2}`);
                    }
                    return;
                }
                logging.warn(`Unable to clean up ${this.directory}: ${e}`);
            }
        }
    }
}
exports.Scratch = Scratch;
function setExtend(xs, els) {
    for (const el of els) {
        xs.add(el);
    }
}
exports.setExtend = setExtend;
async function filterAsync(xs, pred) {
    const mapped = await Promise.all(xs.map(async (x) => ({ x, pred: await pred(x) })));
    return mapped.filter(({ pred }) => pred).map(({ x }) => x);
}
exports.filterAsync = filterAsync;
async function wait(ms) {
    return new Promise((ok) => setTimeout(ok, ms));
}
exports.wait = wait;
function flatten(xs) {
    return Array.prototype.concat.call([], ...xs);
}
exports.flatten = flatten;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsaURBQW9EO0FBQ3BELCtCQUErQjtBQUMvQix5QkFBeUI7QUFDekIsNkJBQTZCO0FBRTdCLHFDQUFxQztBQUVyQzs7Ozs7R0FLRztBQUNILFNBQWdCLDBCQUEwQixDQUN4QyxVQUFrQixFQUNsQixjQUFzQjtJQUV0QixNQUFNLFdBQVcsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUM7SUFDNUQsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUNqQixPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsY0FBYyxlQUFlLEVBQUUsRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLENBQUMsQ0FDMUUsQ0FBQztBQUNKLENBQUM7QUFSRCxnRUFRQztBQTZDRCxNQUFhLGlCQUFxQixTQUFRLEtBQUs7SUFDN0MsWUFDa0IsUUFBMEIsRUFDMUIsTUFBd0I7UUFFeEMsS0FBSyxDQUNILG9DQUFvQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FDeEUsQ0FBQztRQUxjLGFBQVEsR0FBUixRQUFRLENBQWtCO1FBQzFCLFdBQU0sR0FBTixNQUFNLENBQWtCO0lBSzFDLENBQUM7Q0FDRjtBQVRELDhDQVNDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNJLEtBQUssVUFBVSxLQUFLLENBQ3pCLEVBQW9CLEVBQ3BCLE9BQXFCLEVBQUUsRUFDdkIsU0FBd0MsSUFBSTs7SUFFNUMsSUFBSSxZQUFZLFNBQUcsSUFBSSxDQUFDLFdBQVcsbUNBQUksQ0FBQyxDQUFDO0lBQ3pDLElBQUksU0FBUyxTQUFHLElBQUksQ0FBQyx1QkFBdUIsbUNBQUksR0FBRyxDQUFDO0lBQ3BELE1BQU0sV0FBVyxTQUFHLElBQUksQ0FBQyxpQkFBaUIsbUNBQUksQ0FBQyxDQUFDO0lBRWhE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QyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzdELENBQUM7QUFSRCxrQ0FRQztBQUVNLEtBQUssVUFBVSxJQUFJLENBQUMsRUFBVTtJQUNuQyxPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDakQsQ0FBQztBQUZELG9CQUVDO0FBRUQsU0FBZ0IsT0FBTyxDQUFJLEVBQWtCO0lBQzNDLE9BQU8sS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0FBQ2hELENBQUM7QUFGRCwwQkFFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNwYXduLCBTcGF3bk9wdGlvbnMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5cbmltcG9ydCAqIGFzIGxvZ2dpbmcgZnJvbSAnLi9sb2dnaW5nJztcblxuLyoqXG4gKiBHaXZlbiBhbiBucG0gcGFja2FnZSBkaXJlY3RvcnkgYW5kIGEgZGVwZW5kZW5jeSBuYW1lLCByZXR1cm5zIHRoZSBwYWNrYWdlIGRpcmVjdG9yeSBvZiB0aGUgZGVwLlxuICogQHBhcmFtIHBhY2thZ2VEaXIgICAgIHRoZSByb290IG9mIHRoZSBwYWNrYWdlIGRlY2xhcmluZyB0aGUgZGVwZW5kZW5jeS5cbiAqIEBwYXJhbSBkZXBlbmRlbmN5TmFtZSB0aGUgbmFtZSBvZiB0aGUgZGVwZW5kZW5jeSB0byBiZSByZXNvbHZlZC5cbiAqIEByZXR1cm4gdGhlIHJlc29sdmVkIGRpcmVjdG9yeSBwYXRoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZURlcGVuZGVuY3lEaXJlY3RvcnkoXG4gIHBhY2thZ2VEaXI6IHN0cmluZyxcbiAgZGVwZW5kZW5jeU5hbWU6IHN0cmluZyxcbik6IHN0cmluZyB7XG4gIGNvbnN0IGxvb2t1cFBhdGhzID0gW3BhdGguam9pbihwYWNrYWdlRGlyLCAnbm9kZV9tb2R1bGVzJyldO1xuICByZXR1cm4gcGF0aC5kaXJuYW1lKFxuICAgIHJlcXVpcmUucmVzb2x2ZShgJHtkZXBlbmRlbmN5TmFtZX0vcGFja2FnZS5qc29uYCwgeyBwYXRoczogbG9va3VwUGF0aHMgfSksXG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmV0cnlPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIGFtb3VudCBvZiBhdHRlbXB0cyB0byBtYWtlLlxuICAgKlxuICAgKiBAZGVmYXVsdCA1XG4gICAqL1xuICBtYXhBdHRlbXB0cz86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiB0aW1lIChpbiBtaWxsaXNlY29uZHMpIHRvIHdhaXQgYWZ0ZXIgdGhlIGZpcnN0IGZhaWxlZCBhdHRlbXB0LlxuICAgKlxuICAgKiBAZGVmYXVsdCAxNTBcbiAgICovXG4gIGJhY2tvZmZCYXNlTWlsbGlzZWNvbmRzPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbXVsdGlwbGllciB0byBhcHBseSBhZnRlciBlYWNoIGZhaWxlZCBhdHRlbXB0cy4gSWYgdGhlIGJhY2tvZmYgYmVmb3JlXG4gICAqIHRoZSBwcmV2aW91cyBhdHRlbXB0IHdhcyBgQmAsIHRoZSBuZXh0IGJhY2tvZmYgaXMgY29tcHV0ZWQgYXNcbiAgICogYEIgKiBiYWNrb2ZmTXVsdGlwbGllcmAsIGNyZWF0aW5nIGFuIGV4cG9uZW50aWFsIHNlcmllcy5cbiAgICpcbiAgICogQGRlZmF1bHQgMlxuICAgKi9cbiAgYmFja29mZk11bHRpcGxpZXI/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbm5hbCBjYWxsYmFjayB0aGF0IGdldHMgaW52b2tlZCB3aGVuIGFuIGF0dGVtcHQgZmFpbGVkLiBUaGlzIGNhbiBiZVxuICAgKiB1c2VkIHRvIGdpdmUgdGhlIHVzZXIgaW5kaWNhdGlvbnMgb2Ygd2hhdCBpcyBoYXBwZW5pbmcuXG4gICAqXG4gICAqIFRoaXMgY2FsbGJhY2sgbXVzdCBub3QgdGhyb3cuXG4gICAqXG4gICAqIEBwYXJhbSBlcnJvciAgICAgICAgICAgICAgIHRoZSBlcnJvciB0aGF0IGp1c3Qgb2NjdXJyZWRcbiAgICogQHBhcmFtIGF0dGVtcHRzTGVmdCAgICAgICAgdGhlIG51bWJlciBvZiBhdHRlbXB0cyBsZWZ0XG4gICAqIEBwYXJhbSBiYWNrb2ZmTWlsbGlzZWNvbmRzIHRoZSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIG9mIGJhY2stb2ZmIHRoYXQgd2lsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBhd2FpdGVkIGJlZm9yZSBtYWtpbmcgdGhlIG5leHQgYXR0ZW1wdCAoaWZcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlcmUgYXJlIGF0dGVtcHRzIGxlZnQpXG4gICAqL1xuICBvbkZhaWxlZEF0dGVtcHQ/OiAoXG4gICAgZXJyb3I6IHVua25vd24sXG4gICAgYXR0ZW1wdHNMZWZ0OiBudW1iZXIsXG4gICAgYmFja29mZk1pbGxpc2Vjb25kczogbnVtYmVyLFxuICApID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBjbGFzcyBBbGxBdHRlbXB0c0ZhaWxlZDxSPiBleHRlbmRzIEVycm9yIHtcbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSBjYWxsYmFjazogKCkgPT4gUHJvbWlzZTxSPixcbiAgICBwdWJsaWMgcmVhZG9ubHkgZXJyb3JzOiByZWFkb25seSBFcnJvcltdLFxuICApIHtcbiAgICBzdXBlcihcbiAgICAgIGBBbGwgYXR0ZW1wdHMgZmFpbGVkLiBMYXN0IGVycm9yOiAke2Vycm9yc1tlcnJvcnMubGVuZ3RoIC0gMV0ubWVzc2FnZX1gLFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGJhY2stb2ZmIGFuZCByZXRyeSBsb2dpYyBhcm91bmQgdGhlIHByb3ZpZGVkIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSBjYiAgIHRoZSBjYWxsYmFjayB3aGljaCBpcyB0byBiZSByZXRyaWVkLlxuICogQHBhcmFtIG9wdHMgdGhlIGJhY2tvZmYtYW5kLXJldHJ5IGNvbmZpZ3VyYXRpb25cbiAqXG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0IG9mIGBjYmBcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJldHJ5PFI+KFxuICBjYjogKCkgPT4gUHJvbWlzZTxSPixcbiAgb3B0czogUmV0cnlPcHRpb25zID0ge30sXG4gIHdhaXRlcjogKG1zOiBudW1iZXIpID0+IFByb21pc2U8dm9pZD4gPSB3YWl0LFxuKTogUHJvbWlzZTxSPiB7XG4gIGxldCBhdHRlbXB0c0xlZnQgPSBvcHRzLm1heEF0dGVtcHRzID8/IDU7XG4gIGxldCBiYWNrb2ZmTXMgPSBvcHRzLmJhY2tvZmZCYXNlTWlsbGlzZWNvbmRzID8/IDE1MDtcbiAgY29uc3QgYmFja29mZk11bHQgPSBvcHRzLmJhY2tvZmZNdWx0aXBsaWVyID8/IDI7XG5cbiAgLy8gQ2hlY2sgZm9yIGluY29ycmVjdCB1c2FnZVxuICBpZiAoYXR0ZW1wdHNMZWZ0IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21heFRyaWVzIG11c3QgYmUgPiAwJyk7XG4gIH1cbiAgaWYgKGJhY2tvZmZNcyA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWNrb2ZmQmFzZU1pbGxpc2Vjb25kcyBtdXN0IGJlID4gMCcpO1xuICB9XG4gIGlmIChiYWNrb2ZmTXVsdCA8PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWNrb2ZmTXVsdGlwbGllciBtdXN0IGJlID4gMScpO1xuICB9XG5cbiAgY29uc3QgZXJyb3JzID0gbmV3IEFycmF5PEVycm9yPigpO1xuICB3aGlsZSAoYXR0ZW1wdHNMZWZ0ID4gMCkge1xuICAgIGF0dGVtcHRzTGVmdC0tO1xuICAgIHRyeSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgcmV0dXJuIGF3YWl0IGNiKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIGlmIChvcHRzLm9uRmFpbGVkQXR0ZW1wdCAhPSBudWxsKSB7XG4gICAgICAgIG9wdHMub25GYWlsZWRBdHRlbXB0KGVycm9yLCBhdHRlbXB0c0xlZnQsIGJhY2tvZmZNcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdHRlbXB0c0xlZnQgPiAwKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgYXdhaXQgd2FpdGVyKGJhY2tvZmZNcykudGhlbigoKSA9PiAoYmFja29mZk1zICo9IGJhY2tvZmZNdWx0KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgQWxsQXR0ZW1wdHNGYWlsZWQoY2IsIGVycm9ycykpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNoZWxsT3B0aW9ucyBleHRlbmRzIE9taXQ8U3Bhd25PcHRpb25zLCAnc2hlbGwnIHwgJ3N0ZGlvJz4ge1xuICAvKipcbiAgICogQ29uZmlndXJlIGluLWxpbmUgcmV0cmllcyBpZiB0aGUgZXhlY3V0aW9uIGZhaWxzLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIG5vIHJldHJpZXNcbiAgICovXG4gIHJlYWRvbmx5IHJldHJ5PzogUmV0cnlPcHRpb25zO1xufVxuXG4vKipcbiAqIFNwYXducyBhIGNoaWxkIHByb2Nlc3Mgd2l0aCB0aGUgcHJvdmlkZWQgY29tbWFuZCBhbmQgYXJndW1lbnRzLiBUaGUgY2hpbGRcbiAqIHByb2Nlc3MgaXMgYWx3YXlzIHNwYXduZWQgdXNpbmcgYHNoZWxsOiB0cnVlYCwgYW5kIHRoZSBjb250ZW50cyBvZlxuICogYHByb2Nlc3MuZW52YCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBgZW52YCBzcGF3biBvcHRpb24gKHZhbHVlc1xuICogcHJvdmlkZWQgaW4gYG9wdGlvbnMuZW52YCBjYW4gb3ZlcnJpZGUgdGhvc2UpLlxuICpcbiAqIEBwYXJhbSBjbWQgICAgIHRoZSBjb21tYW5kIHRvIHNoZWxsIG91dCB0by5cbiAqIEBwYXJhbSBhcmdzICAgIHRoZSBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgY21kYFxuICogQHBhcmFtIG9wdGlvbnMgYW55IG9wdGlvbnMgdG8gcGFzcyB0byBgc3Bhd25gXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaGVsbChcbiAgY21kOiBzdHJpbmcsXG4gIGFyZ3M6IHN0cmluZ1tdLFxuICB7IHJldHJ5OiByZXRyeU9wdGlvbnMsIC4uLm9wdGlvbnMgfTogU2hlbGxPcHRpb25zID0ge30sXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBhc3luYyBmdW5jdGlvbiBzcGF3bjEoKSB7XG4gICAgbG9nZ2luZy5kZWJ1ZyhjbWQsIGFyZ3Muam9pbignICcpLCBKU09OLnN0cmluZ2lmeShvcHRpb25zKSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHN0cmluZz4oKG9rLCBrbykgPT4ge1xuICAgICAgY29uc3QgY2hpbGQgPSBzcGF3bihjbWQsIGFyZ3MsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgc2hlbGw6IHRydWUsXG4gICAgICAgIGVudjogeyAuLi5wcm9jZXNzLmVudiwgLi4uKG9wdGlvbnMuZW52ID8/IHt9KSB9LFxuICAgICAgICBzdGRpbzogWydpZ25vcmUnLCAncGlwZScsICdwaXBlJ10sXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHN0ZG91dCA9IG5ldyBBcnJheTxCdWZmZXI+KCk7XG4gICAgICBjb25zdCBzdGRlcnIgPSBuZXcgQXJyYXk8QnVmZmVyPigpO1xuICAgICAgY2hpbGQuc3Rkb3V0Lm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgIGlmIChsb2dnaW5nLmxldmVsID49IGxvZ2dpbmcuTEVWRUxfU0lMTFkpIHtcbiAgICAgICAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShjaHVuayk7IC8vIG5vdGljZSAtIHdlIGVtaXQgYWxsIGJ1aWxkIG91dHB1dCB0byBzdGRlcnJcbiAgICAgICAgfVxuICAgICAgICBzdGRvdXQucHVzaChCdWZmZXIuZnJvbShjaHVuaykpO1xuICAgICAgfSk7XG4gICAgICBjaGlsZC5zdGRlcnIub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgICAgaWYgKGxvZ2dpbmcubGV2ZWwgPj0gbG9nZ2luZy5MRVZFTF9TSUxMWSkge1xuICAgICAgICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBzdGRlcnIucHVzaChCdWZmZXIuZnJvbShjaHVuaykpO1xuICAgICAgfSk7XG4gICAgICBjaGlsZC5vbmNlKCdlcnJvcicsIGtvKTtcblxuICAgICAgLy8gTXVzdCB1c2UgQ0xPU0UgaW5zdGVhZCBvZiBFWElUOyBFWElUIG1heSBmaXJlIHdoaWxlIHRoZXJlIGlzIHN0aWxsIGRhdGEgaW4gdGhlXG4gICAgICAvLyBJL08gcGlwZXMsIHdoaWNoIHdlIHdpbGwgbWlzcyBpZiB3ZSByZXR1cm4gYXQgdGhhdCBwb2ludC5cbiAgICAgIGNoaWxkLm9uY2UoJ2Nsb3NlJywgKGNvZGUsIHNpZ25hbCkgPT4ge1xuICAgICAgICBjb25zdCBvdXQgPSBCdWZmZXIuY29uY2F0KHN0ZG91dCkudG9TdHJpbmcoJ3V0Zi04Jyk7XG4gICAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG9rKG91dCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyID0gQnVmZmVyLmNvbmNhdChzdGRlcnIpLnRvU3RyaW5nKCd1dGYtOCcpO1xuICAgICAgICBjb25zdCByZWFzb24gPSBzaWduYWwgIT0gbnVsbCA/IGBzaWduYWwgJHtzaWduYWx9YCA6IGBzdGF0dXMgJHtjb2RlfWA7XG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSBgJHtjbWR9ICR7YXJncy5qb2luKCcgJyl9YDtcbiAgICAgICAgcmV0dXJuIGtvKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgYENvbW1hbmQgKCR7Y29tbWFuZH0pIGZhaWxlZCB3aXRoICR7cmVhc29ufTpgLFxuICAgICAgICAgICAgICAvLyBTVERFUlIgZmlyc3QsIHRoZSBlcnJvIG1lc3NhZ2UgY291bGQgYmUgdHJ1bmNhdGVkIGluIGxvZ3MuXG4gICAgICAgICAgICAgIHByZWZpeChlcnIsICcjU1RERVJSPiAnKSxcbiAgICAgICAgICAgICAgcHJlZml4KG91dCwgJyNTVERPVVQ+ICcpLFxuICAgICAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuXG4gICAgICAgIGZ1bmN0aW9uIHByZWZpeCh0ZXh0OiBzdHJpbmcsIGFkZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgICByZXR1cm4gdGV4dFxuICAgICAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAgICAgLm1hcCgobGluZSkgPT4gYCR7YWRkfSR7bGluZX1gKVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXRyeU9wdGlvbnMgIT0gbnVsbCkge1xuICAgIHJldHVybiByZXRyeShzcGF3bjEsIHtcbiAgICAgIC4uLnJldHJ5T3B0aW9ucyxcbiAgICAgIG9uRmFpbGVkQXR0ZW1wdDpcbiAgICAgICAgcmV0cnlPcHRpb25zLm9uRmFpbGVkQXR0ZW1wdCA/P1xuICAgICAgICAoKGVycm9yLCBhdHRlbXB0c0xlZnQsIGJhY2tvZmZNcykgPT4ge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2UgPz8gZXJyb3I7XG4gICAgICAgICAgY29uc3QgcmV0cnlJbmZvID1cbiAgICAgICAgICAgIGF0dGVtcHRzTGVmdCA+IDBcbiAgICAgICAgICAgICAgPyBgV2FpdGluZyAke2JhY2tvZmZNc30gbXMgYmVmb3JlIHJldHJ5aW5nICgke2F0dGVtcHRzTGVmdH0gYXR0ZW1wdHMgbGVmdClgXG4gICAgICAgICAgICAgIDogJ05vIGF0dGVtcHRzIGxlZnQnO1xuICAgICAgICAgIGxvZ2dpbmcuaW5mbyhcbiAgICAgICAgICAgIGBDb21tYW5kIFwiJHtjbWR9ICR7YXJncy5qb2luKFxuICAgICAgICAgICAgICAnICcsXG4gICAgICAgICAgICApfVwiIGZhaWxlZCB3aXRoICR7bWVzc2FnZX0uICR7cmV0cnlJbmZvfS5gLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzcGF3bjEoKTtcbn1cblxuLyoqXG4gKiBTdHJpcCBmaWxlc3lzdGVtIHVuc2FmZSBjaGFyYWN0ZXJzIGZyb20gYSBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsdWdpZnkoeDogc3RyaW5nKSB7XG4gIHJldHVybiB4LnJlcGxhY2UoL1teYS16QS1aMC05Xy1dL2csICdfJyk7XG59XG5cbi8qKlxuICogQ2xhc3MgdGhhdCBtYWtlcyBhIHRlbXBvcmFyeSBkaXJlY3RvcnkgYW5kIGhvbGRzIG9uIHRvIGFuIG9wZXJhdGlvbiBvYmplY3RcbiAqL1xuZXhwb3J0IGNsYXNzIFNjcmF0Y2g8QT4ge1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIG1ha2U8QT4oXG4gICAgZmFjdG9yeTogKGRpcjogc3RyaW5nKSA9PiBQcm9taXNlPEE+LFxuICApOiBQcm9taXNlPFNjcmF0Y2g8QT4+O1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIG1ha2U8QT4oZmFjdG9yeTogKGRpcjogc3RyaW5nKSA9PiBBKTogUHJvbWlzZTxTY3JhdGNoPEE+PjtcbiAgcHVibGljIHN0YXRpYyBhc3luYyBtYWtlPEE+KGZhY3Rvcnk6IChkaXI6IHN0cmluZykgPT4gQSB8IFByb21pc2U8QT4pIHtcbiAgICBjb25zdCB0bXBkaXIgPSBhd2FpdCBmcy5ta2R0ZW1wKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ25wbS1wYWNrJykpO1xuICAgIHJldHVybiBuZXcgU2NyYXRjaCh0bXBkaXIsIGF3YWl0IGZhY3RvcnkodG1wZGlyKSwgZmFsc2UpO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBmYWtlPEE+KGRpcmVjdG9yeTogc3RyaW5nLCBvYmplY3Q6IEEpIHtcbiAgICByZXR1cm4gbmV3IFNjcmF0Y2goZGlyZWN0b3J5LCBvYmplY3QsIHRydWUpO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBhc3luYyBjbGVhbnVwQWxsPEE+KHRlbXBEaXJzOiBBcnJheTxTY3JhdGNoPEE+Pikge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHRlbXBEaXJzLm1hcCgodCkgPT4gdC5jbGVhbnVwKCkpKTtcbiAgfVxuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlYWRvbmx5IGRpcmVjdG9yeTogc3RyaW5nLFxuICAgIHB1YmxpYyByZWFkb25seSBvYmplY3Q6IEEsXG4gICAgcHJpdmF0ZSByZWFkb25seSBmYWtlOiBib29sZWFuLFxuICApIHt9XG5cbiAgcHVibGljIGFzeW5jIGNsZWFudXAoKSB7XG4gICAgaWYgKCF0aGlzLmZha2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZzLnJlbW92ZSh0aGlzLmRpcmVjdG9yeSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLmNvZGUgPT09ICdFQlVTWScpIHtcbiAgICAgICAgICAvLyBUaGlzIG9jY2FzaW9uYWxseSBoYXBwZW5zIG9uIFdpbmRvd3MgaWYgd2UgdHJ5IHRvIGNsZWFuIHVwIHRvb1xuICAgICAgICAgIC8vIHF1aWNrbHkgYWZ0ZXIgd2UncmUgZG9uZS4uLiBDb3VsZCBiZSBiZWNhdXNlIHNvbWUgQVYgc29mdHdhcmUgaXNcbiAgICAgICAgICAvLyBzdGlsbCBydW5uaW5nIGluIHRoZSBiYWNrZ3JvdW5kLlxuICAgICAgICAgIC8vIFdhaXQgMXMgYW5kIHJldHJ5IG9uY2UhXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKG9rKSA9PiBzZXRUaW1lb3V0KG9rLCAxXzAwMCkpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBmcy5yZW1vdmUodGhpcy5kaXJlY3RvcnkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICBsb2dnaW5nLndhcm4oYFVuYWJsZSB0byBjbGVhbiB1cCAke3RoaXMuZGlyZWN0b3J5fTogJHtlMn1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dpbmcud2FybihgVW5hYmxlIHRvIGNsZWFuIHVwICR7dGhpcy5kaXJlY3Rvcnl9OiAke2V9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRFeHRlbmQ8QT4oeHM6IFNldDxBPiwgZWxzOiBJdGVyYWJsZTxBPikge1xuICBmb3IgKGNvbnN0IGVsIG9mIGVscykge1xuICAgIHhzLmFkZChlbCk7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZpbHRlckFzeW5jPEE+KFxuICB4czogQVtdLFxuICBwcmVkOiAoeDogQSkgPT4gUHJvbWlzZTxib29sZWFuPixcbik6IFByb21pc2U8QVtdPiB7XG4gIGNvbnN0IG1hcHBlZCA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHhzLm1hcChhc3luYyAoeCkgPT4gKHsgeCwgcHJlZDogYXdhaXQgcHJlZCh4KSB9KSksXG4gICk7XG4gIHJldHVybiBtYXBwZWQuZmlsdGVyKCh7IHByZWQgfSkgPT4gcHJlZCkubWFwKCh7IHggfSkgPT4geCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3YWl0KG1zOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChvaykgPT4gc2V0VGltZW91dChvaywgbXMpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW48QT4oeHM6IHJlYWRvbmx5IEFbXVtdKTogQVtdIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuY2FsbChbXSwgLi4ueHMpO1xufVxuIl19