"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Generator = void 0;
const spec = require("@jsii/spec");
const clone = require("clone");
const codemaker_1 = require("codemaker");
const crypto = require("crypto");
const fs = require("fs-extra");
const path = require("path");
const version_1 = require("./version");
/**
 * Abstract base class for jsii package generators.
 * Given a jsii module, it will invoke "events" to emit various elements.
 */
class Generator {
    constructor(options = {}) {
        this.options = options;
        this.excludeTypes = new Array();
        this.code = new codemaker_1.CodeMaker();
    }
    get assembly() {
        if (!this._assembly) {
            throw new Error('No assembly has been loaded! The #load() method must be called first!');
        }
        return this._assembly;
    }
    get reflectAssembly() {
        if (!this._reflectAssembly) {
            throw new Error('Call load() first');
        }
        return this._reflectAssembly;
    }
    get metadata() {
        return { fingerprint: this.fingerprint };
    }
    async load(_packageRoot, assembly) {
        this._reflectAssembly = assembly;
        this._assembly = assembly.spec;
        // Including the version of jsii-pacmak in the fingerprint, as a new version may imply different code generation.
        this.fingerprint = crypto
            .createHash('sha256')
            .update(version_1.VERSION_DESC)
            .update('\0')
            .update(this.assembly.fingerprint)
            .digest('base64');
        return Promise.resolve();
    }
    /**
     * Runs the generator (in-memory).
     */
    generate(fingerprint) {
        this.onBeginAssembly(this.assembly, fingerprint);
        this.visit(spec.NameTree.of(this.assembly));
        this.onEndAssembly(this.assembly, fingerprint);
    }
    async upToDate(_) {
        return Promise.resolve(false);
    }
    /**
     * Returns the file name of the assembly resource as it is going to be saved.
     */
    getAssemblyFileName() {
        let name = this.assembly.name;
        const parts = name.split('/');
        if (parts.length === 1) {
            name = parts[0];
        }
        else if (parts.length === 2 && parts[0].startsWith('@')) {
            name = parts[1];
        }
        else {
            throw new Error('Malformed assembly name. Expecting either <name> or @<scope>/<name>');
        }
        return `${name}@${this.assembly.version}.jsii.tgz`;
    }
    /**
     * Saves all generated files to an output directory, creating any subdirs if needed.
     */
    async save(outdir, tarball, { license, notice }) {
        const assemblyDir = this.getAssemblyOutputDir(this.assembly);
        if (assemblyDir) {
            const fullPath = path.resolve(path.join(outdir, assemblyDir, this.getAssemblyFileName()));
            await fs.mkdirp(path.dirname(fullPath));
            await fs.copy(tarball, fullPath, { overwrite: true });
            if (license) {
                await fs.writeFile(path.resolve(outdir, 'LICENSE'), license, {
                    encoding: 'utf8',
                });
            }
            if (notice) {
                await fs.writeFile(path.resolve(outdir, 'NOTICE'), notice, {
                    encoding: 'utf8',
                });
            }
        }
        return this.code.save(outdir);
    }
    //
    // Bundled assembly
    // jsii modules should bundle the assembly itself as a resource and use the load() kernel API to load it.
    //
    /**
     * Returns the destination directory for the assembly file.
     */
    getAssemblyOutputDir(_mod) {
        return undefined;
    }
    //
    // Assembly
    onBeginAssembly(_assm, _fingerprint) {
        /* noop */
    }
    onEndAssembly(_assm, _fingerprint) {
        /* noop */
    }
    //
    // Namespaces
    onBeginNamespace(_ns) {
        /* noop */
    }
    onEndNamespace(_ns) {
        /* noop */
    }
    //
    // Classes
    onBeginClass(_cls, _abstract) {
        /* noop */
    }
    onEndClass(_cls) {
        /* noop */
    }
    //
    // Initializers (constructos)
    onInitializer(_cls, _initializer) {
        /* noop */
    }
    onInitializerOverload(_cls, _overload, _originalInitializer) {
        /* noop */
    }
    //
    // Properties
    onBeginProperties(_cls) {
        /* noop */
    }
    onEndProperties(_cls) {
        /* noop */
    }
    onExpandedUnionProperty(_cls, _prop, _primaryName) {
        return;
    }
    //
    // Methods
    // onMethodOverload is triggered if the option `generateOverloadsForMethodWithOptionals` is enabled for each overload of the original method.
    // The original method will be emitted via onMethod.
    onBeginMethods(_cls) {
        /* noop */
    }
    onEndMethods(_cls) {
        /* noop */
    }
    //
    // Enums
    onBeginEnum(_enm) {
        /* noop */
    }
    onEndEnum(_enm) {
        /* noop */
    }
    onEnumMember(_enm, _member) {
        /* noop */
    }
    //
    // Fields
    // Can be used to implements properties backed by fields in cases where we want to generate "native" classes.
    // The default behavior is that properties do not have backing fields.
    hasField(_cls, _prop) {
        return false;
    }
    onField(_cls, _prop, _union) {
        /* noop */
    }
    visit(node, names = new Array()) {
        var _a;
        const namespace = !node.fqn && names.length > 0 ? names.join('.') : undefined;
        if (namespace) {
            this.onBeginNamespace(namespace);
        }
        const visitChildren = () => {
            Object.keys(node.children)
                .sort()
                .forEach((name) => {
                this.visit(node.children[name], names.concat(name));
            });
        };
        if (node.fqn) {
            const type = (_a = this.assembly.types) === null || _a === void 0 ? void 0 : _a[node.fqn];
            if (!type) {
                throw new Error(`Malformed jsii file. Cannot find type: ${node.fqn}`);
            }
            if (!this.shouldExcludeType(type.name)) {
                switch (type.kind) {
                    case spec.TypeKind.Class:
                        const classSpec = type;
                        const abstract = classSpec.abstract;
                        if (abstract && this.options.addBasePostfixToAbstractClassNames) {
                            this.addAbstractPostfixToClassName(classSpec);
                        }
                        this.onBeginClass(classSpec, abstract);
                        this.visitClass(classSpec);
                        visitChildren();
                        this.onEndClass(classSpec);
                        break;
                    case spec.TypeKind.Enum:
                        const enumSpec = type;
                        this.onBeginEnum(enumSpec);
                        this.visitEnum(enumSpec);
                        visitChildren();
                        this.onEndEnum(enumSpec);
                        break;
                    case spec.TypeKind.Interface:
                        const interfaceSpec = type;
                        this.onBeginInterface(interfaceSpec);
                        this.visitInterface(interfaceSpec);
                        visitChildren();
                        this.onEndInterface(interfaceSpec);
                        break;
                    default:
                        throw new Error(`Unsupported type kind: ${type.kind}`);
                }
            }
        }
        else {
            visitChildren();
        }
        if (namespace) {
            this.onEndNamespace(namespace);
        }
    }
    /**
     * Adds a postfix ("XxxBase") to the class name to indicate it is abstract.
     */
    addAbstractPostfixToClassName(cls) {
        cls.name = `${cls.name}Base`;
        const components = cls.fqn.split('.');
        cls.fqn = components
            .map((x, i) => (i < components.length - 1 ? x : `${x}Base`))
            .join('.');
    }
    excludeType(...names) {
        for (const n of names) {
            this.excludeTypes.push(n);
        }
    }
    shouldExcludeType(name) {
        return this.excludeTypes.includes(name);
    }
    /**
     * Returns all the method overloads needed to satisfy optional arguments.
     * For example, for the method `foo(bar: string, hello?: number, world?: number)`
     * this method will return:
     *  - foo(bar: string)
     *  - foo(bar: string, hello: number)
     *
     * Notice that the method that contains all the arguments will not be returned.
     */
    createOverloadsForOptionals(method) {
        const overloads = new Array();
        // if option disabled, just return the empty array.
        if (!this.options.generateOverloadsForMethodWithOptionals ||
            !method.parameters) {
            return overloads;
        }
        //
        // pop an argument from the end of the parameter list.
        // if it is an optional argument, clone the method without that parameter.
        // continue until we reach a non optional param or no parameters left.
        //
        const remaining = clone(method.parameters);
        let next;
        next = remaining.pop();
        // Parameter is optional if it's type is optional, and all subsequent parameters are optional/variadic
        while (next === null || next === void 0 ? void 0 : next.optional) {
            // clone the method but set the parameter list based on the remaining set of parameters
            const cloned = clone(method);
            cloned.parameters = clone(remaining);
            overloads.push(cloned);
            // pop the next parameter
            next = remaining.pop();
        }
        return overloads;
    }
    visitInterface(ifc) {
        if (ifc.properties) {
            ifc.properties.forEach((prop) => {
                this.onInterfaceProperty(ifc, prop);
            });
        }
        if (ifc.methods) {
            ifc.methods.forEach((method) => {
                this.onInterfaceMethod(ifc, method);
                for (const overload of this.createOverloadsForOptionals(method)) {
                    this.onInterfaceMethodOverload(ifc, overload, method);
                }
            });
        }
    }
    visitClass(cls) {
        const initializer = cls.initializer;
        if (initializer) {
            this.onInitializer(cls, initializer);
            // if method has optional arguments and
            for (const overload of this.createOverloadsForOptionals(initializer)) {
                this.onInitializerOverload(cls, overload, initializer);
            }
        }
        // if running in 'pure' mode and the class has methods, emit them as abstract methods.
        if (cls.methods) {
            this.onBeginMethods(cls);
            cls.methods.forEach((method) => {
                if (!method.static) {
                    this.onMethod(cls, method);
                    for (const overload of this.createOverloadsForOptionals(method)) {
                        this.onMethodOverload(cls, overload, method);
                    }
                }
                else {
                    this.onStaticMethod(cls, method);
                    for (const overload of this.createOverloadsForOptionals(method)) {
                        this.onStaticMethodOverload(cls, overload, method);
                    }
                }
            });
            this.onEndMethods(cls);
        }
        if (cls.properties) {
            this.onBeginProperties(cls);
            cls.properties.forEach((prop) => {
                if (this.hasField(cls, prop)) {
                    this.onField(cls, prop, spec.isUnionTypeReference(prop.type) ? prop.type : undefined);
                }
            });
            cls.properties.forEach((prop) => {
                if (!spec.isUnionTypeReference(prop.type)) {
                    if (!prop.static) {
                        this.onProperty(cls, prop);
                    }
                    else {
                        this.onStaticProperty(cls, prop);
                    }
                }
                else {
                    // okay, this is a union. some languages support unions (mostly the dynamic ones) and some will need some help
                    // if `expandUnionProperties` is set, we will "expand" each property that has a union type into multiple properties
                    // and postfix their name with the type name (i.e. FooAsToken).
                    // first, emit a property for the union, for languages that support unions.
                    this.onUnionProperty(cls, prop, prop.type);
                    // if require, we also "expand" the union for languages that don't support unions.
                    if (this.options.expandUnionProperties) {
                        for (const [index, type] of prop.type.union.types.entries()) {
                            // create a clone of this property
                            const propClone = clone(prop);
                            const primary = this.isPrimaryExpandedUnionProperty(prop.type, index);
                            const propertyName = primary
                                ? prop.name
                                : `${prop.name}As${this.displayNameForType(type)}`;
                            propClone.type = type;
                            propClone.optional = prop.optional;
                            propClone.name = propertyName;
                            this.onExpandedUnionProperty(cls, propClone, prop.name);
                        }
                    }
                }
            });
            this.onEndProperties(cls);
        }
    }
    /**
     * Magical heuristic to determine which type in a union is the primary type. The primary type will not have
     * a postfix with the name of the type attached to the expanded property name.
     *
     * The primary type is determined according to the following rules (first match):
     * 1. The first primitive type
     * 2. The first primitive collection
     * 3. No primary
     */
    isPrimaryExpandedUnionProperty(ref, index) {
        if (!ref) {
            return false;
        }
        return (index ===
            ref.union.types.findIndex((t) => {
                if (spec.isPrimitiveTypeReference(t)) {
                    return true;
                }
                return false;
            }));
    }
    visitEnum(enumSpec) {
        if (enumSpec.members) {
            enumSpec.members.forEach((spec) => this.onEnumMember(enumSpec, spec));
        }
    }
    displayNameForType(type) {
        // last name from FQN
        if (spec.isNamedTypeReference(type)) {
            const comps = type.fqn.split('.');
            const last = comps[comps.length - 1];
            return this.code.toPascalCase(last);
        }
        // primitive name
        if (spec.isPrimitiveTypeReference(type)) {
            return this.code.toPascalCase(type.primitive);
        }
        // ListOfX or MapOfX
        const coll = spec.isCollectionTypeReference(type) && type.collection;
        if (coll) {
            return `${this.code.toPascalCase(coll.kind)}Of${this.displayNameForType(coll.elementtype)}`;
        }
        const union = spec.isUnionTypeReference(type) && type.union;
        if (union) {
            return union.types.map((t) => this.displayNameForType(t)).join('Or');
        }
        throw new Error(`Cannot determine display name for type: ${JSON.stringify(type)}`);
    }
    /**
     * Looks up a jsii module in the dependency tree.
     * @param name The name of the jsii module to look up
     */
    findModule(name) {
        var _a;
        // if this is the current module, return it
        if (this.assembly.name === name) {
            return this.assembly;
        }
        const found = ((_a = this.assembly.dependencyClosure) !== null && _a !== void 0 ? _a : {})[name];
        if (found) {
            return found;
        }
        throw new Error(`Unable to find module ${name} as a dependency of ${this.assembly.name}`);
    }
    findType(fqn) {
        const ret = this.reflectAssembly.system.tryFindFqn(fqn);
        if (!ret) {
            throw new Error(`Cannot find type '${fqn}' either as internal or external type`);
        }
        return ret.spec;
    }
}
exports.Generator = Generator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZ2VuZXJhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLG1DQUFtQztBQUNuQywrQkFBK0I7QUFDL0IseUNBQXNDO0FBQ3RDLGlDQUFpQztBQUNqQywrQkFBK0I7QUFFL0IsNkJBQTZCO0FBRTdCLHVDQUF5QztBQXVFekM7OztHQUdHO0FBQ0gsTUFBc0IsU0FBUztJQU83QixZQUFvQyxVQUE0QixFQUFFO1FBQTlCLFlBQU8sR0FBUCxPQUFPLENBQXVCO1FBTmpELGlCQUFZLEdBQUcsSUFBSSxLQUFLLEVBQVUsQ0FBQztRQUNqQyxTQUFJLEdBQUcsSUFBSSxxQkFBUyxFQUFFLENBQUM7SUFLMkIsQ0FBQztJQUV0RSxJQUFjLFFBQVE7UUFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDbkIsTUFBTSxJQUFJLEtBQUssQ0FDYix1RUFBdUUsQ0FDeEUsQ0FBQztTQUNIO1FBQ0QsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO0lBQ3hCLENBQUM7SUFFRCxJQUFXLGVBQWU7UUFDeEIsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUMxQixNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7U0FDdEM7UUFDRCxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztJQUMvQixDQUFDO0lBRUQsSUFBVyxRQUFRO1FBQ2pCLE9BQU8sRUFBRSxXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQzNDLENBQUM7SUFFTSxLQUFLLENBQUMsSUFBSSxDQUNmLFlBQW9CLEVBQ3BCLFFBQTBCO1FBRTFCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxRQUFRLENBQUM7UUFDakMsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDO1FBRS9CLGlIQUFpSDtRQUNqSCxJQUFJLENBQUMsV0FBVyxHQUFHLE1BQU07YUFDdEIs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RUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFNUQsSUFBSSxLQUFLLEVBQUU7WUFDVCxPQUFPLEtBQUssQ0FBQztTQUNkO1FBRUQsTUFBTSxJQUFJLEtBQUssQ0FDYix5QkFBeUIsSUFBSSx1QkFBdUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FDekUsQ0FBQztJQUNKLENBQUM7SUFFUyxRQUFRLENBQUMsR0FBVztRQUM1QixNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDeEQsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNSLE1BQU0sSUFBSSxLQUFLLENBQ2IscUJBQXFCLEdBQUcsdUNBQXVDLENBQ2hFLENBQUM7U0FDSDtRQUVELE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQztJQUNsQixDQUFDO0NBQ0Y7QUE3bEJELDhCQTZsQkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBzcGVjIGZyb20gJ0Bqc2lpL3NwZWMnO1xuaW1wb3J0ICogYXMgY2xvbmUgZnJvbSAnY2xvbmUnO1xuaW1wb3J0IHsgQ29kZU1ha2VyIH0gZnJvbSAnY29kZW1ha2VyJztcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgcmVmbGVjdCBmcm9tICdqc2lpLXJlZmxlY3QnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHsgVkVSU0lPTl9ERVNDIH0gZnJvbSAnLi92ZXJzaW9uJztcblxuLyoqXG4gKiBPcHRpb25zIGZvciB0aGUgY29kZSBnZW5lcmF0b3IgZnJhbWV3b3JrLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdlbmVyYXRvck9wdGlvbnMge1xuICAvKipcbiAgICogSWYgdGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gJ3RydWUnLCB1bmlvbiBwcm9wZXJ0aWVzIGFyZSBcImV4cGFuZGVkXCIgaW50byBtdWx0aXBsZVxuICAgKiBwcm9wZXJ0aWVzLCBlYWNoIHdpdGggYSBkaWZmZXJlbnQgdHlwZSBhbmQgYSBwb3N0Zml4IGJhc2VkIG9uIHRoZSB0eXBlIG5hbWUuIFRoaXNcbiAgICogY2FuIGJlIHVzZWQgYnkgbGFuZ3VhZ2VzIHRoYXQgZG9uJ3QgaGF2ZSBzdXBwb3J0IGZvciB1bmlvbiB0eXBlcyAoZS5nLiBKYXZhKS5cbiAgICovXG4gIGV4cGFuZFVuaW9uUHJvcGVydGllcz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIElmIHRoaXMgcHJvcGVydHkgaXMgc2V0IHRvICd0cnVlJywgbWV0aG9kcyB0aGF0IGhhdmUgb3B0aW9uYWwgYXJndW1lbnRzIGFyZSBkdXBsaWNhdGVkXG4gICAqIGFuZCBvdmVybG9hZHMgYXJlIGNyZWF0ZWQgd2l0aCBhbGwgcGFyYW1ldGVycy5cbiAgICovXG4gIGdlbmVyYXRlT3ZlcmxvYWRzRm9yTWV0aG9kV2l0aE9wdGlvbmFscz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIElmIHRoaXMgcHJvcGVydHkgaXMgc2V0LCB0aGUgZ2VuZXJhdG9yIHdpbGwgYWRkIFwiQmFzZVwiIHRvIGFic3RyYWN0IGNsYXNzIG5hbWVzXG4gICAqL1xuICBhZGRCYXNlUG9zdGZpeFRvQWJzdHJhY3RDbGFzc05hbWVzPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJR2VuZXJhdG9yIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBmaW5nZXJwcmludFxuICAgKi9cbiAgZ2VuZXJhdGUoZmluZ2VycHJpbnQ6IGJvb2xlYW4pOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBMb2FkIGEgbW9kdWxlIGludG8gdGhlIGdlbmVyYXRvci5cbiAgICogQHBhcmFtIHBhY2thZ2VEaXIgaXMgdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoZSBtb2R1bGUuXG4gICAqL1xuICBsb2FkKHBhY2thZ2VEaXI6IHN0cmluZywgYXNzZW1ibHk6IHJlZmxlY3QuQXNzZW1ibHkpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIGdlbmVyYXRlZCBhcnRpZmFjdHMgZm9yIHRoaXMgZ2VuZXJhdG9yIGFyZSBhbHJlYWR5IHVwLXRvLWRhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBvdXREaXIgdGhlIGRpcmVjdG9yeSB3aGVyZSBnZW5lcmF0ZWQgYXJ0aWZhY3RzIHdvdWxkIGJlIHBsYWNlZC5cbiAgICogQHBhcmFtIHRhcmJhbGwgdGhlIHRhcmJhbGwgb2YgdGhlIGJ1bmRsZWQgbm9kZSBsaWJyYXJ5XG4gICAqIEBwYXJhbSBsZWdhbGVzZSB0aGUgbGljZW5zZSBhbmQgbm90aWNlIGZpbGUgY29udGVudHMgKGlmIGFueSlcbiAgICpcbiAgICogQHJldHVybiBgYHRydWVgYCBpZiBubyBnZW5lcmF0aW9uIGlzIG5lY2Vzc2FyeVxuICAgKi9cbiAgdXBUb0RhdGUob3V0RGlyOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+O1xuXG4gIC8qKlxuICAgKiBTYXZlcyB0aGUgZ2VuZXJhdGVkIGNvZGUgaW4gdGhlIHByb3ZpZGVkIG91dHB1dCBkaXJlY3RvcnkuXG4gICAqXG4gICAqIEBwYXJhbSBvdXRkaXIgdGhlIGRpcmVjdG9yeSBpbiB3aGljaCB0byBwbGFjZSBnZW5lcmF0ZWQgY29kZS5cbiAgICogQHBhcmFtIHRhcmJhbGwgdGhlIGJ1bmRsZWQgbnBtIGxpYnJhcnkgYmFja2luZyB0aGUgZ2VuZXJhdGVkIGNvZGUuXG4gICAqIEBwYXJhbSBsZWdhbGVzZSB0aGUgTElDRU5TRSAmIE5PVElDRSBjb250ZW50cyBmb3IgdGhpcyBwYWNrYWdlLlxuICAgKi9cbiAgc2F2ZShvdXRkaXI6IHN0cmluZywgdGFyYmFsbDogc3RyaW5nLCBsZWdhbGVzZTogTGVnYWxlc2UpOiBQcm9taXNlPGFueT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGVnYWxlc2Uge1xuICAvKipcbiAgICogVGhlIHRleHQgb2YgdGhlIFNQRFggbGljZW5zZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBwYWNrYWdlLCBpZiBhbnkuXG4gICAqL1xuICByZWFkb25seSBsaWNlbnNlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIE5PVElDRSBmaWxlIGZvciB0aGlzIHBhY2thZ2UsIGlmIGFueS5cbiAgICovXG4gIHJlYWRvbmx5IG5vdGljZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBqc2lpIHBhY2thZ2UgZ2VuZXJhdG9ycy5cbiAqIEdpdmVuIGEganNpaSBtb2R1bGUsIGl0IHdpbGwgaW52b2tlIFwiZXZlbnRzXCIgdG8gZW1pdCB2YXJpb3VzIGVsZW1lbnRzLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgR2VuZXJhdG9yIGltcGxlbWVudHMgSUdlbmVyYXRvciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgZXhjbHVkZVR5cGVzID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGNvZGUgPSBuZXcgQ29kZU1ha2VyKCk7XG4gIHByaXZhdGUgX2Fzc2VtYmx5Pzogc3BlYy5Bc3NlbWJseTtcbiAgcHJvdGVjdGVkIF9yZWZsZWN0QXNzZW1ibHk/OiByZWZsZWN0LkFzc2VtYmx5O1xuICBwcml2YXRlIGZpbmdlcnByaW50Pzogc3RyaW5nO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IG9wdGlvbnM6IEdlbmVyYXRvck9wdGlvbnMgPSB7fSkge31cblxuICBwcm90ZWN0ZWQgZ2V0IGFzc2VtYmx5KCk6IHNwZWMuQXNzZW1ibHkge1xuICAgIGlmICghdGhpcy5fYXNzZW1ibHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ05vIGFzc2VtYmx5IGhhcyBiZWVuIGxvYWRlZCEgVGhlICNsb2FkKCkgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGZpcnN0IScsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYXNzZW1ibHk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHJlZmxlY3RBc3NlbWJseSgpOiByZWZsZWN0LkFzc2VtYmx5IHtcbiAgICBpZiAoIXRoaXMuX3JlZmxlY3RBc3NlbWJseSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsIGxvYWQoKSBmaXJzdCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVmbGVjdEFzc2VtYmx5O1xuICB9XG5cbiAgcHVibGljIGdldCBtZXRhZGF0YSgpIHtcbiAgICByZXR1cm4geyBmaW5nZXJwcmludDogdGhpcy5maW5nZXJwcmludCB9O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGxvYWQoXG4gICAgX3BhY2thZ2VSb290OiBzdHJpbmcsXG4gICAgYXNzZW1ibHk6IHJlZmxlY3QuQXNzZW1ibHksXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuX3JlZmxlY3RBc3NlbWJseSA9IGFzc2VtYmx5O1xuICAgIHRoaXMuX2Fzc2VtYmx5ID0gYXNzZW1ibHkuc3BlYztcblxuICAgIC8vIEluY2x1ZGluZyB0aGUgdmVyc2lvbiBvZiBqc2lpLXBhY21hayBpbiB0aGUgZmluZ2VycHJpbnQsIGFzIGEgbmV3IHZlcnNpb24gbWF5IGltcGx5IGRpZmZlcmVudCBjb2RlIGdlbmVyYXRpb24uXG4gICAgdGhpcy5maW5nZXJwcmludCA9IGNyeXB0b1xuICAgICAgLmNyZWF0ZUhhc2goJ3NoYTI1NicpXG4gICAgICAudXBkYXRlKFZFUlNJT05fREVTQylcbiAgICAgIC51cGRhdGUoJ1xcMCcpXG4gICAgICAudXBkYXRlKHRoaXMuYXNzZW1ibHkuZmluZ2VycHJpbnQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIHRoZSBnZW5lcmF0b3IgKGluLW1lbW9yeSkuXG4gICAqL1xuICBwdWJsaWMgZ2VuZXJhdGUoZmluZ2VycHJpbnQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLm9uQmVnaW5Bc3NlbWJseSh0aGlzLmFzc2VtYmx5LCBmaW5nZXJwcmludCk7XG4gICAgdGhpcy52aXNpdChzcGVjLk5hbWVUcmVlLm9mKHRoaXMuYXNzZW1ibHkpKTtcbiAgICB0aGlzLm9uRW5kQXNzZW1ibHkodGhpcy5hc3NlbWJseSwgZmluZ2VycHJpbnQpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHVwVG9EYXRlKF86IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpbGUgbmFtZSBvZiB0aGUgYXNzZW1ibHkgcmVzb3VyY2UgYXMgaXQgaXMgZ29pbmcgdG8gYmUgc2F2ZWQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0QXNzZW1ibHlGaWxlTmFtZSgpIHtcbiAgICBsZXQgbmFtZSA9IHRoaXMuYXNzZW1ibHkubmFtZTtcbiAgICBjb25zdCBwYXJ0cyA9IG5hbWUuc3BsaXQoJy8nKTtcblxuICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIG5hbWUgPSBwYXJ0c1swXTtcbiAgICB9IGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMiAmJiBwYXJ0c1swXS5zdGFydHNXaXRoKCdAJykpIHtcbiAgICAgIG5hbWUgPSBwYXJ0c1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnTWFsZm9ybWVkIGFzc2VtYmx5IG5hbWUuIEV4cGVjdGluZyBlaXRoZXIgPG5hbWU+IG9yIEA8c2NvcGU+LzxuYW1lPicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBgJHtuYW1lfUAke3RoaXMuYXNzZW1ibHkudmVyc2lvbn0uanNpaS50Z3pgO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmVzIGFsbCBnZW5lcmF0ZWQgZmlsZXMgdG8gYW4gb3V0cHV0IGRpcmVjdG9yeSwgY3JlYXRpbmcgYW55IHN1YmRpcnMgaWYgbmVlZGVkLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNhdmUoXG4gICAgb3V0ZGlyOiBzdHJpbmcsXG4gICAgdGFyYmFsbDogc3RyaW5nLFxuICAgIHsgbGljZW5zZSwgbm90aWNlIH06IExlZ2FsZXNlLFxuICApIHtcbiAgICBjb25zdCBhc3NlbWJseURpciA9IHRoaXMuZ2V0QXNzZW1ibHlPdXRwdXREaXIodGhpcy5hc3NlbWJseSk7XG4gICAgaWYgKGFzc2VtYmx5RGlyKSB7XG4gICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGgucmVzb2x2ZShcbiAgICAgICAgcGF0aC5qb2luKG91dGRpciwgYXNzZW1ibHlEaXIsIHRoaXMuZ2V0QXNzZW1ibHlGaWxlTmFtZSgpKSxcbiAgICAgICk7XG4gICAgICBhd2FpdCBmcy5ta2RpcnAocGF0aC5kaXJuYW1lKGZ1bGxQYXRoKSk7XG4gICAgICBhd2FpdCBmcy5jb3B5KHRhcmJhbGwsIGZ1bGxQYXRoLCB7IG92ZXJ3cml0ZTogdHJ1ZSB9KTtcblxuICAgICAgaWYgKGxpY2Vuc2UpIHtcbiAgICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKHBhdGgucmVzb2x2ZShvdXRkaXIsICdMSUNFTlNFJyksIGxpY2Vuc2UsIHtcbiAgICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChub3RpY2UpIHtcbiAgICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKHBhdGgucmVzb2x2ZShvdXRkaXIsICdOT1RJQ0UnKSwgbm90aWNlLCB7XG4gICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29kZS5zYXZlKG91dGRpcik7XG4gIH1cblxuICAvL1xuICAvLyBCdW5kbGVkIGFzc2VtYmx5XG4gIC8vIGpzaWkgbW9kdWxlcyBzaG91bGQgYnVuZGxlIHRoZSBhc3NlbWJseSBpdHNlbGYgYXMgYSByZXNvdXJjZSBhbmQgdXNlIHRoZSBsb2FkKCkga2VybmVsIEFQSSB0byBsb2FkIGl0LlxuICAvL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBkaXJlY3RvcnkgZm9yIHRoZSBhc3NlbWJseSBmaWxlLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldEFzc2VtYmx5T3V0cHV0RGlyKF9tb2Q6IHNwZWMuQXNzZW1ibHkpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvL1xuICAvLyBBc3NlbWJseVxuXG4gIHByb3RlY3RlZCBvbkJlZ2luQXNzZW1ibHkoX2Fzc206IHNwZWMuQXNzZW1ibHksIF9maW5nZXJwcmludDogYm9vbGVhbikge1xuICAgIC8qIG5vb3AgKi9cbiAgfVxuICBwcm90ZWN0ZWQgb25FbmRBc3NlbWJseShfYXNzbTogc3BlYy5Bc3NlbWJseSwgX2ZpbmdlcnByaW50OiBib29sZWFuKSB7XG4gICAgLyogbm9vcCAqL1xuICB9XG5cbiAgLy9cbiAgLy8gTmFtZXNwYWNlc1xuXG4gIHByb3RlY3RlZCBvbkJlZ2luTmFtZXNwYWNlKF9uczogc3RyaW5nKSB7XG4gICAgLyogbm9vcCAqL1xuICB9XG4gIHByb3RlY3RlZCBvbkVuZE5hbWVzcGFjZShfbnM6IHN0cmluZykge1xuICAgIC8qIG5vb3AgKi9cbiAgfVxuXG4gIC8vXG4gIC8vIENsYXNzZXNcblxuICBwcm90ZWN0ZWQgb25CZWdpbkNsYXNzKF9jbHM6IHNwZWMuQ2xhc3NUeXBlLCBfYWJzdHJhY3Q6IGJvb2xlYW4gfCB1bmRlZmluZWQpIHtcbiAgICAvKiBub29wICovXG4gIH1cbiAgcHJvdGVjdGVkIG9uRW5kQ2xhc3MoX2Nsczogc3BlYy5DbGFzc1R5cGUpIHtcbiAgICAvKiBub29wICovXG4gIH1cblxuICAvL1xuICAvLyBJbnRlcmZhY2VzXG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IG9uQmVnaW5JbnRlcmZhY2UoaWZjOiBzcGVjLkludGVyZmFjZVR5cGUpOiB2b2lkO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3Qgb25FbmRJbnRlcmZhY2UoaWZjOiBzcGVjLkludGVyZmFjZVR5cGUpOiB2b2lkO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3Qgb25JbnRlcmZhY2VNZXRob2QoXG4gICAgaWZjOiBzcGVjLkludGVyZmFjZVR5cGUsXG4gICAgbWV0aG9kOiBzcGVjLk1ldGhvZCxcbiAgKTogdm9pZDtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IG9uSW50ZXJmYWNlTWV0aG9kT3ZlcmxvYWQoXG4gICAgaWZjOiBzcGVjLkludGVyZmFjZVR5cGUsXG4gICAgb3ZlcmxvYWQ6IHNwZWMuTWV0aG9kLFxuICAgIG9yaWdpbmFsTWV0aG9kOiBzcGVjLk1ldGhvZCxcbiAgKTogdm9pZDtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IG9uSW50ZXJmYWNlUHJvcGVydHkoXG4gICAgaWZjOiBzcGVjLkludGVyZmFjZVR5cGUsXG4gICAgcHJvcDogc3BlYy5Qcm9wZXJ0eSxcbiAgKTogdm9pZDtcblxuICAvL1xuICAvLyBJbml0aWFsaXplcnMgKGNvbnN0cnVjdG9zKVxuXG4gIHByb3RlY3RlZCBvbkluaXRpYWxpemVyKFxuICAgIF9jbHM6IHNwZWMuQ2xhc3NUeXBlLFxuICAgIF9pbml0aWFsaXplcjogc3BlYy5Jbml0aWFsaXplcixcbiAgKSB7XG4gICAgLyogbm9vcCAqL1xuICB9XG4gIHByb3RlY3RlZCBvbkluaXRpYWxpemVyT3ZlcmxvYWQoXG4gICAgX2Nsczogc3BlYy5DbGFzc1R5cGUsXG4gICAgX292ZXJsb2FkOiBzcGVjLkluaXRpYWxpemVyLFxuICAgIF9vcmlnaW5hbEluaXRpYWxpemVyOiBzcGVjLkluaXRpYWxpemVyLFxuICApIHtcbiAgICAvKiBub29wICovXG4gIH1cblxuICAvL1xuICAvLyBQcm9wZXJ0aWVzXG5cbiAgcHJvdGVjdGVkIG9uQmVnaW5Qcm9wZXJ0aWVzKF9jbHM6IHNwZWMuQ2xhc3NUeXBlKSB7XG4gICAgLyogbm9vcCAqL1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBvblByb3BlcnR5KGNsczogc3BlYy5DbGFzc1R5cGUsIHByb3A6IHNwZWMuUHJvcGVydHkpOiB2b2lkO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3Qgb25TdGF0aWNQcm9wZXJ0eShcbiAgICBjbHM6IHNwZWMuQ2xhc3NUeXBlLFxuICAgIHByb3A6IHNwZWMuUHJvcGVydHksXG4gICk6IHZvaWQ7XG4gIHByb3RlY3RlZCBvbkVuZFByb3BlcnRpZXMoX2Nsczogc3BlYy5DbGFzc1R5cGUpIHtcbiAgICAvKiBub29wICovXG4gIH1cblxuICAvL1xuICAvLyBVbmlvbiBQcm9wZXJ0aWVzXG4gIC8vIFRob3NlIGFyZSBwcm9wZXJ0aWVzIHRoYXQgY2FuIGFjY2VwdCBtb3JlIHRoYW4gYSBzaW5nbGUgdHlwZSAoaS5lLiBTdHJpbmcgfCBUb2tlbikuIElmIHRoZSBvcHRpb24gYGV4cGFuZFVuaW9uUHJvcGVydGllc2AgaXMgZW5hYmxlZFxuICAvLyBpbnN0ZWFkIG9mIG9uVW5pb25Qcm9wZXJ0eSwgdGhlIG1ldGhvZCBvbkV4cGFuZGVkVW5pb25Qcm9wZXJ0eSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBvZiB0aGUgdHlwZXMgZGVmaW5lZCBpbiB0aGUgcHJvcGVydHkuXG4gIC8vIGBwcmltYXJ5TmFtZWAgaW5kaWNhdGVzIHRoZSBvcmlnaW5hbCBuYW1lIG9mIHRoZSB1bmlvbiBwcm9wZXJ0eSAod2l0aG91dCB0aGUgJ0FzWHh4JyBwb3N0Zml4KS5cblxuICBwcm90ZWN0ZWQgYWJzdHJhY3Qgb25VbmlvblByb3BlcnR5KFxuICAgIGNsczogc3BlYy5DbGFzc1R5cGUsXG4gICAgcHJvcDogc3BlYy5Qcm9wZXJ0eSxcbiAgICB1bmlvbjogc3BlYy5VbmlvblR5cGVSZWZlcmVuY2UsXG4gICk6IHZvaWQ7XG4gIHByb3RlY3RlZCBvbkV4cGFuZGVkVW5pb25Qcm9wZXJ0eShcbiAgICBfY2xzOiBzcGVjLkNsYXNzVHlwZSxcbiAgICBfcHJvcDogc3BlYy5Qcm9wZXJ0eSxcbiAgICBfcHJpbWFyeU5hbWU6IHN0cmluZyxcbiAgKTogdm9pZCB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy9cbiAgLy8gTWV0aG9kc1xuICAvLyBvbk1ldGhvZE92ZXJsb2FkIGlzIHRyaWdnZXJlZCBpZiB0aGUgb3B0aW9uIGBnZW5lcmF0ZU92ZXJsb2Fkc0Zvck1ldGhvZFdpdGhPcHRpb25hbHNgIGlzIGVuYWJsZWQgZm9yIGVhY2ggb3ZlcmxvYWQgb2YgdGhlIG9yaWdpbmFsIG1ldGhvZC5cbiAgLy8gVGhlIG9yaWdpbmFsIG1ldGhvZCB3aWxsIGJlIGVtaXR0ZWQgdmlhIG9uTWV0aG9kLlxuXG4gIHByb3RlY3RlZCBvbkJlZ2luTWV0aG9kcyhfY2xzOiBzcGVjLkNsYXNzVHlwZSkge1xuICAgIC8qIG5vb3AgKi9cbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3Qgb25NZXRob2QoY2xzOiBzcGVjLkNsYXNzVHlwZSwgbWV0aG9kOiBzcGVjLk1ldGhvZCk6IHZvaWQ7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBvbk1ldGhvZE92ZXJsb2FkKFxuICAgIGNsczogc3BlYy5DbGFzc1R5cGUsXG4gICAgb3ZlcmxvYWQ6IHNwZWMuTWV0aG9kLFxuICAgIG9yaWdpbmFsTWV0aG9kOiBzcGVjLk1ldGhvZCxcbiAgKTogdm9pZDtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IG9uU3RhdGljTWV0aG9kKFxuICAgIGNsczogc3BlYy5DbGFzc1R5cGUsXG4gICAgbWV0aG9kOiBzcGVjLk1ldGhvZCxcbiAgKTogdm9pZDtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IG9uU3RhdGljTWV0aG9kT3ZlcmxvYWQoXG4gICAgY2xzOiBzcGVjLkNsYXNzVHlwZSxcbiAgICBvdmVybG9hZDogc3BlYy5NZXRob2QsXG4gICAgb3JpZ2luYWxNZXRob2Q6IHNwZWMuTWV0aG9kLFxuICApOiB2b2lkO1xuICBwcm90ZWN0ZWQgb25FbmRNZXRob2RzKF9jbHM6IHNwZWMuQ2xhc3NUeXBlKSB7XG4gICAgLyogbm9vcCAqL1xuICB9XG5cbiAgLy9cbiAgLy8gRW51bXNcblxuICBwcm90ZWN0ZWQgb25CZWdpbkVudW0oX2VubTogc3BlYy5FbnVtVHlwZSkge1xuICAgIC8qIG5vb3AgKi9cbiAgfVxuICBwcm90ZWN0ZWQgb25FbmRFbnVtKF9lbm06IHNwZWMuRW51bVR5cGUpIHtcbiAgICAvKiBub29wICovXG4gIH1cbiAgcHJvdGVjdGVkIG9uRW51bU1lbWJlcihfZW5tOiBzcGVjLkVudW1UeXBlLCBfbWVtYmVyOiBzcGVjLkVudW1NZW1iZXIpIHtcbiAgICAvKiBub29wICovXG4gIH1cblxuICAvL1xuICAvLyBGaWVsZHNcbiAgLy8gQ2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50cyBwcm9wZXJ0aWVzIGJhY2tlZCBieSBmaWVsZHMgaW4gY2FzZXMgd2hlcmUgd2Ugd2FudCB0byBnZW5lcmF0ZSBcIm5hdGl2ZVwiIGNsYXNzZXMuXG4gIC8vIFRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHRoYXQgcHJvcGVydGllcyBkbyBub3QgaGF2ZSBiYWNraW5nIGZpZWxkcy5cblxuICBwcm90ZWN0ZWQgaGFzRmllbGQoX2Nsczogc3BlYy5DbGFzc1R5cGUsIF9wcm9wOiBzcGVjLlByb3BlcnR5KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHByb3RlY3RlZCBvbkZpZWxkKFxuICAgIF9jbHM6IHNwZWMuQ2xhc3NUeXBlLFxuICAgIF9wcm9wOiBzcGVjLlByb3BlcnR5LFxuICAgIF91bmlvbj86IHNwZWMuVW5pb25UeXBlUmVmZXJlbmNlLFxuICApIHtcbiAgICAvKiBub29wICovXG4gIH1cblxuICBwcml2YXRlIHZpc2l0KG5vZGU6IHNwZWMuTmFtZVRyZWUsIG5hbWVzID0gbmV3IEFycmF5PHN0cmluZz4oKSkge1xuICAgIGNvbnN0IG5hbWVzcGFjZSA9XG4gICAgICAhbm9kZS5mcW4gJiYgbmFtZXMubGVuZ3RoID4gMCA/IG5hbWVzLmpvaW4oJy4nKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgIHRoaXMub25CZWdpbk5hbWVzcGFjZShuYW1lc3BhY2UpO1xuICAgIH1cblxuICAgIGNvbnN0IHZpc2l0Q2hpbGRyZW4gPSAoKSA9PiB7XG4gICAgICBPYmplY3Qua2V5cyhub2RlLmNoaWxkcmVuKVxuICAgICAgICAuc29ydCgpXG4gICAgICAgIC5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgdGhpcy52aXNpdChub2RlLmNoaWxkcmVuW25hbWVdLCBuYW1lcy5jb25jYXQobmFtZSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKG5vZGUuZnFuKSB7XG4gICAgICBjb25zdCB0eXBlID0gdGhpcy5hc3NlbWJseS50eXBlcz8uW25vZGUuZnFuXTtcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCBqc2lpIGZpbGUuIENhbm5vdCBmaW5kIHR5cGU6ICR7bm9kZS5mcW59YCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc2hvdWxkRXhjbHVkZVR5cGUodHlwZS5uYW1lKSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUua2luZCkge1xuICAgICAgICAgIGNhc2Ugc3BlYy5UeXBlS2luZC5DbGFzczpcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzU3BlYyA9IHR5cGUgYXMgc3BlYy5DbGFzc1R5cGU7XG4gICAgICAgICAgICBjb25zdCBhYnN0cmFjdCA9IGNsYXNzU3BlYy5hYnN0cmFjdDtcbiAgICAgICAgICAgIGlmIChhYnN0cmFjdCAmJiB0aGlzLm9wdGlvbnMuYWRkQmFzZVBvc3RmaXhUb0Fic3RyYWN0Q2xhc3NOYW1lcykge1xuICAgICAgICAgICAgICB0aGlzLmFkZEFic3RyYWN0UG9zdGZpeFRvQ2xhc3NOYW1lKGNsYXNzU3BlYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uQmVnaW5DbGFzcyhjbGFzc1NwZWMsIGFic3RyYWN0KTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRDbGFzcyhjbGFzc1NwZWMpO1xuICAgICAgICAgICAgdmlzaXRDaGlsZHJlbigpO1xuICAgICAgICAgICAgdGhpcy5vbkVuZENsYXNzKGNsYXNzU3BlYyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIHNwZWMuVHlwZUtpbmQuRW51bTpcbiAgICAgICAgICAgIGNvbnN0IGVudW1TcGVjID0gdHlwZSBhcyBzcGVjLkVudW1UeXBlO1xuICAgICAgICAgICAgdGhpcy5vbkJlZ2luRW51bShlbnVtU3BlYyk7XG4gICAgICAgICAgICB0aGlzLnZpc2l0RW51bShlbnVtU3BlYyk7XG4gICAgICAgICAgICB2aXNpdENoaWxkcmVuKCk7XG4gICAgICAgICAgICB0aGlzLm9uRW5kRW51bShlbnVtU3BlYyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIHNwZWMuVHlwZUtpbmQuSW50ZXJmYWNlOlxuICAgICAgICAgICAgY29uc3QgaW50ZXJmYWNlU3BlYyA9IHR5cGUgYXMgc3BlYy5JbnRlcmZhY2VUeXBlO1xuICAgICAgICAgICAgdGhpcy5vbkJlZ2luSW50ZXJmYWNlKGludGVyZmFjZVNwZWMpO1xuICAgICAgICAgICAgdGhpcy52aXNpdEludGVyZmFjZShpbnRlcmZhY2VTcGVjKTtcbiAgICAgICAgICAgIHZpc2l0Q2hpbGRyZW4oKTtcbiAgICAgICAgICAgIHRoaXMub25FbmRJbnRlcmZhY2UoaW50ZXJmYWNlU3BlYyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB0eXBlIGtpbmQ6ICR7KHR5cGUgYXMgYW55KS5raW5kfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpc2l0Q2hpbGRyZW4oKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICB0aGlzLm9uRW5kTmFtZXNwYWNlKG5hbWVzcGFjZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBwb3N0Zml4IChcIlh4eEJhc2VcIikgdG8gdGhlIGNsYXNzIG5hbWUgdG8gaW5kaWNhdGUgaXQgaXMgYWJzdHJhY3QuXG4gICAqL1xuICBwcml2YXRlIGFkZEFic3RyYWN0UG9zdGZpeFRvQ2xhc3NOYW1lKGNsczogc3BlYy5DbGFzc1R5cGUpIHtcbiAgICBjbHMubmFtZSA9IGAke2Nscy5uYW1lfUJhc2VgO1xuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBjbHMuZnFuLnNwbGl0KCcuJyk7XG4gICAgY2xzLmZxbiA9IGNvbXBvbmVudHNcbiAgICAgIC5tYXAoKHgsIGkpID0+IChpIDwgY29tcG9uZW50cy5sZW5ndGggLSAxID8geCA6IGAke3h9QmFzZWApKVxuICAgICAgLmpvaW4oJy4nKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBleGNsdWRlVHlwZSguLi5uYW1lczogc3RyaW5nW10pIHtcbiAgICBmb3IgKGNvbnN0IG4gb2YgbmFtZXMpIHtcbiAgICAgIHRoaXMuZXhjbHVkZVR5cGVzLnB1c2gobik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzaG91bGRFeGNsdWRlVHlwZShuYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5leGNsdWRlVHlwZXMuaW5jbHVkZXMobmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgdGhlIG1ldGhvZCBvdmVybG9hZHMgbmVlZGVkIHRvIHNhdGlzZnkgb3B0aW9uYWwgYXJndW1lbnRzLlxuICAgKiBGb3IgZXhhbXBsZSwgZm9yIHRoZSBtZXRob2QgYGZvbyhiYXI6IHN0cmluZywgaGVsbG8/OiBudW1iZXIsIHdvcmxkPzogbnVtYmVyKWBcbiAgICogdGhpcyBtZXRob2Qgd2lsbCByZXR1cm46XG4gICAqICAtIGZvbyhiYXI6IHN0cmluZylcbiAgICogIC0gZm9vKGJhcjogc3RyaW5nLCBoZWxsbzogbnVtYmVyKVxuICAgKlxuICAgKiBOb3RpY2UgdGhhdCB0aGUgbWV0aG9kIHRoYXQgY29udGFpbnMgYWxsIHRoZSBhcmd1bWVudHMgd2lsbCBub3QgYmUgcmV0dXJuZWQuXG4gICAqL1xuICBwcm90ZWN0ZWQgY3JlYXRlT3ZlcmxvYWRzRm9yT3B0aW9uYWxzPFxuICAgIFQgZXh0ZW5kcyBzcGVjLk1ldGhvZCB8IHNwZWMuSW5pdGlhbGl6ZXIsXG4gID4obWV0aG9kOiBUKSB7XG4gICAgY29uc3Qgb3ZlcmxvYWRzID0gbmV3IEFycmF5PFQ+KCk7XG5cbiAgICAvLyBpZiBvcHRpb24gZGlzYWJsZWQsIGp1c3QgcmV0dXJuIHRoZSBlbXB0eSBhcnJheS5cbiAgICBpZiAoXG4gICAgICAhdGhpcy5vcHRpb25zLmdlbmVyYXRlT3ZlcmxvYWRzRm9yTWV0aG9kV2l0aE9wdGlvbmFscyB8fFxuICAgICAgIW1ldGhvZC5wYXJhbWV0ZXJzXG4gICAgKSB7XG4gICAgICByZXR1cm4gb3ZlcmxvYWRzO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gcG9wIGFuIGFyZ3VtZW50IGZyb20gdGhlIGVuZCBvZiB0aGUgcGFyYW1ldGVyIGxpc3QuXG4gICAgLy8gaWYgaXQgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQsIGNsb25lIHRoZSBtZXRob2Qgd2l0aG91dCB0aGF0IHBhcmFtZXRlci5cbiAgICAvLyBjb250aW51ZSB1bnRpbCB3ZSByZWFjaCBhIG5vbiBvcHRpb25hbCBwYXJhbSBvciBubyBwYXJhbWV0ZXJzIGxlZnQuXG4gICAgLy9cblxuICAgIGNvbnN0IHJlbWFpbmluZzogc3BlYy5QYXJhbWV0ZXJbXSA9IGNsb25lKG1ldGhvZC5wYXJhbWV0ZXJzKTtcbiAgICBsZXQgbmV4dDogc3BlYy5QYXJhbWV0ZXIgfCB1bmRlZmluZWQ7XG5cbiAgICBuZXh0ID0gcmVtYWluaW5nLnBvcCgpO1xuICAgIC8vIFBhcmFtZXRlciBpcyBvcHRpb25hbCBpZiBpdCdzIHR5cGUgaXMgb3B0aW9uYWwsIGFuZCBhbGwgc3Vic2VxdWVudCBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbC92YXJpYWRpY1xuICAgIHdoaWxlIChuZXh0Py5vcHRpb25hbCkge1xuICAgICAgLy8gY2xvbmUgdGhlIG1ldGhvZCBidXQgc2V0IHRoZSBwYXJhbWV0ZXIgbGlzdCBiYXNlZCBvbiB0aGUgcmVtYWluaW5nIHNldCBvZiBwYXJhbWV0ZXJzXG4gICAgICBjb25zdCBjbG9uZWQ6IFQgPSBjbG9uZShtZXRob2QpO1xuICAgICAgY2xvbmVkLnBhcmFtZXRlcnMgPSBjbG9uZShyZW1haW5pbmcpO1xuICAgICAgb3ZlcmxvYWRzLnB1c2goY2xvbmVkKTtcblxuICAgICAgLy8gcG9wIHRoZSBuZXh0IHBhcmFtZXRlclxuICAgICAgbmV4dCA9IHJlbWFpbmluZy5wb3AoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3ZlcmxvYWRzO1xuICB9XG5cbiAgcHJpdmF0ZSB2aXNpdEludGVyZmFjZShpZmM6IHNwZWMuSW50ZXJmYWNlVHlwZSkge1xuICAgIGlmIChpZmMucHJvcGVydGllcykge1xuICAgICAgaWZjLnByb3BlcnRpZXMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICB0aGlzLm9uSW50ZXJmYWNlUHJvcGVydHkoaWZjLCBwcm9wKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpZmMubWV0aG9kcykge1xuICAgICAgaWZjLm1ldGhvZHMuZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gICAgICAgIHRoaXMub25JbnRlcmZhY2VNZXRob2QoaWZjLCBtZXRob2QpO1xuXG4gICAgICAgIGZvciAoY29uc3Qgb3ZlcmxvYWQgb2YgdGhpcy5jcmVhdGVPdmVybG9hZHNGb3JPcHRpb25hbHMobWV0aG9kKSkge1xuICAgICAgICAgIHRoaXMub25JbnRlcmZhY2VNZXRob2RPdmVybG9hZChpZmMsIG92ZXJsb2FkLCBtZXRob2QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHZpc2l0Q2xhc3MoY2xzOiBzcGVjLkNsYXNzVHlwZSkge1xuICAgIGNvbnN0IGluaXRpYWxpemVyID0gY2xzLmluaXRpYWxpemVyO1xuICAgIGlmIChpbml0aWFsaXplcikge1xuICAgICAgdGhpcy5vbkluaXRpYWxpemVyKGNscywgaW5pdGlhbGl6ZXIpO1xuXG4gICAgICAvLyBpZiBtZXRob2QgaGFzIG9wdGlvbmFsIGFyZ3VtZW50cyBhbmRcbiAgICAgIGZvciAoY29uc3Qgb3ZlcmxvYWQgb2YgdGhpcy5jcmVhdGVPdmVybG9hZHNGb3JPcHRpb25hbHMoaW5pdGlhbGl6ZXIpKSB7XG4gICAgICAgIHRoaXMub25Jbml0aWFsaXplck92ZXJsb2FkKGNscywgb3ZlcmxvYWQsIGluaXRpYWxpemVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBydW5uaW5nIGluICdwdXJlJyBtb2RlIGFuZCB0aGUgY2xhc3MgaGFzIG1ldGhvZHMsIGVtaXQgdGhlbSBhcyBhYnN0cmFjdCBtZXRob2RzLlxuICAgIGlmIChjbHMubWV0aG9kcykge1xuICAgICAgdGhpcy5vbkJlZ2luTWV0aG9kcyhjbHMpO1xuICAgICAgY2xzLm1ldGhvZHMuZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gICAgICAgIGlmICghbWV0aG9kLnN0YXRpYykge1xuICAgICAgICAgIHRoaXMub25NZXRob2QoY2xzLCBtZXRob2QpO1xuXG4gICAgICAgICAgZm9yIChjb25zdCBvdmVybG9hZCBvZiB0aGlzLmNyZWF0ZU92ZXJsb2Fkc0Zvck9wdGlvbmFscyhtZXRob2QpKSB7XG4gICAgICAgICAgICB0aGlzLm9uTWV0aG9kT3ZlcmxvYWQoY2xzLCBvdmVybG9hZCwgbWV0aG9kKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vblN0YXRpY01ldGhvZChjbHMsIG1ldGhvZCk7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IG92ZXJsb2FkIG9mIHRoaXMuY3JlYXRlT3ZlcmxvYWRzRm9yT3B0aW9uYWxzKG1ldGhvZCkpIHtcbiAgICAgICAgICAgIHRoaXMub25TdGF0aWNNZXRob2RPdmVybG9hZChjbHMsIG92ZXJsb2FkLCBtZXRob2QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLm9uRW5kTWV0aG9kcyhjbHMpO1xuICAgIH1cblxuICAgIGlmIChjbHMucHJvcGVydGllcykge1xuICAgICAgdGhpcy5vbkJlZ2luUHJvcGVydGllcyhjbHMpO1xuICAgICAgY2xzLnByb3BlcnRpZXMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5oYXNGaWVsZChjbHMsIHByb3ApKSB7XG4gICAgICAgICAgdGhpcy5vbkZpZWxkKFxuICAgICAgICAgICAgY2xzLFxuICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgIHNwZWMuaXNVbmlvblR5cGVSZWZlcmVuY2UocHJvcC50eXBlKSA/IHByb3AudHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY2xzLnByb3BlcnRpZXMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBpZiAoIXNwZWMuaXNVbmlvblR5cGVSZWZlcmVuY2UocHJvcC50eXBlKSkge1xuICAgICAgICAgIGlmICghcHJvcC5zdGF0aWMpIHtcbiAgICAgICAgICAgIHRoaXMub25Qcm9wZXJ0eShjbHMsIHByb3ApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uU3RhdGljUHJvcGVydHkoY2xzLCBwcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb2theSwgdGhpcyBpcyBhIHVuaW9uLiBzb21lIGxhbmd1YWdlcyBzdXBwb3J0IHVuaW9ucyAobW9zdGx5IHRoZSBkeW5hbWljIG9uZXMpIGFuZCBzb21lIHdpbGwgbmVlZCBzb21lIGhlbHBcbiAgICAgICAgICAvLyBpZiBgZXhwYW5kVW5pb25Qcm9wZXJ0aWVzYCBpcyBzZXQsIHdlIHdpbGwgXCJleHBhbmRcIiBlYWNoIHByb3BlcnR5IHRoYXQgaGFzIGEgdW5pb24gdHlwZSBpbnRvIG11bHRpcGxlIHByb3BlcnRpZXNcbiAgICAgICAgICAvLyBhbmQgcG9zdGZpeCB0aGVpciBuYW1lIHdpdGggdGhlIHR5cGUgbmFtZSAoaS5lLiBGb29Bc1Rva2VuKS5cblxuICAgICAgICAgIC8vIGZpcnN0LCBlbWl0IGEgcHJvcGVydHkgZm9yIHRoZSB1bmlvbiwgZm9yIGxhbmd1YWdlcyB0aGF0IHN1cHBvcnQgdW5pb25zLlxuICAgICAgICAgIHRoaXMub25VbmlvblByb3BlcnR5KGNscywgcHJvcCwgcHJvcC50eXBlKTtcblxuICAgICAgICAgIC8vIGlmIHJlcXVpcmUsIHdlIGFsc28gXCJleHBhbmRcIiB0aGUgdW5pb24gZm9yIGxhbmd1YWdlcyB0aGF0IGRvbid0IHN1cHBvcnQgdW5pb25zLlxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXhwYW5kVW5pb25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgdHlwZV0gb2YgcHJvcC50eXBlLnVuaW9uLnR5cGVzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBjbG9uZSBvZiB0aGlzIHByb3BlcnR5XG4gICAgICAgICAgICAgIGNvbnN0IHByb3BDbG9uZSA9IGNsb25lKHByb3ApO1xuICAgICAgICAgICAgICBjb25zdCBwcmltYXJ5ID0gdGhpcy5pc1ByaW1hcnlFeHBhbmRlZFVuaW9uUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgcHJvcC50eXBlLFxuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSBwcmltYXJ5XG4gICAgICAgICAgICAgICAgPyBwcm9wLm5hbWVcbiAgICAgICAgICAgICAgICA6IGAke3Byb3AubmFtZX1BcyR7dGhpcy5kaXNwbGF5TmFtZUZvclR5cGUodHlwZSl9YDtcbiAgICAgICAgICAgICAgcHJvcENsb25lLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICBwcm9wQ2xvbmUub3B0aW9uYWwgPSBwcm9wLm9wdGlvbmFsO1xuICAgICAgICAgICAgICBwcm9wQ2xvbmUubmFtZSA9IHByb3BlcnR5TmFtZTtcbiAgICAgICAgICAgICAgdGhpcy5vbkV4cGFuZGVkVW5pb25Qcm9wZXJ0eShjbHMsIHByb3BDbG9uZSwgcHJvcC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbkVuZFByb3BlcnRpZXMoY2xzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFnaWNhbCBoZXVyaXN0aWMgdG8gZGV0ZXJtaW5lIHdoaWNoIHR5cGUgaW4gYSB1bmlvbiBpcyB0aGUgcHJpbWFyeSB0eXBlLiBUaGUgcHJpbWFyeSB0eXBlIHdpbGwgbm90IGhhdmVcbiAgICogYSBwb3N0Zml4IHdpdGggdGhlIG5hbWUgb2YgdGhlIHR5cGUgYXR0YWNoZWQgdG8gdGhlIGV4cGFuZGVkIHByb3BlcnR5IG5hbWUuXG4gICAqXG4gICAqIFRoZSBwcmltYXJ5IHR5cGUgaXMgZGV0ZXJtaW5lZCBhY2NvcmRpbmcgdG8gdGhlIGZvbGxvd2luZyBydWxlcyAoZmlyc3QgbWF0Y2gpOlxuICAgKiAxLiBUaGUgZmlyc3QgcHJpbWl0aXZlIHR5cGVcbiAgICogMi4gVGhlIGZpcnN0IHByaW1pdGl2ZSBjb2xsZWN0aW9uXG4gICAqIDMuIE5vIHByaW1hcnlcbiAgICovXG4gIHByb3RlY3RlZCBpc1ByaW1hcnlFeHBhbmRlZFVuaW9uUHJvcGVydHkoXG4gICAgcmVmOiBzcGVjLlVuaW9uVHlwZVJlZmVyZW5jZSB8IHVuZGVmaW5lZCxcbiAgICBpbmRleDogbnVtYmVyLFxuICApIHtcbiAgICBpZiAoIXJlZikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICBpbmRleCA9PT1cbiAgICAgIHJlZi51bmlvbi50eXBlcy5maW5kSW5kZXgoKHQpID0+IHtcbiAgICAgICAgaWYgKHNwZWMuaXNQcmltaXRpdmVUeXBlUmVmZXJlbmNlKHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHZpc2l0RW51bShlbnVtU3BlYzogc3BlYy5FbnVtVHlwZSkge1xuICAgIGlmIChlbnVtU3BlYy5tZW1iZXJzKSB7XG4gICAgICBlbnVtU3BlYy5tZW1iZXJzLmZvckVhY2goKHNwZWMpID0+IHRoaXMub25FbnVtTWVtYmVyKGVudW1TcGVjLCBzcGVjKSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkaXNwbGF5TmFtZUZvclR5cGUodHlwZTogc3BlYy5UeXBlUmVmZXJlbmNlKTogc3RyaW5nIHtcbiAgICAvLyBsYXN0IG5hbWUgZnJvbSBGUU5cbiAgICBpZiAoc3BlYy5pc05hbWVkVHlwZVJlZmVyZW5jZSh0eXBlKSkge1xuICAgICAgY29uc3QgY29tcHMgPSB0eXBlLmZxbi5zcGxpdCgnLicpO1xuICAgICAgY29uc3QgbGFzdCA9IGNvbXBzW2NvbXBzLmxlbmd0aCAtIDFdO1xuICAgICAgcmV0dXJuIHRoaXMuY29kZS50b1Bhc2NhbENhc2UobGFzdCk7XG4gICAgfVxuXG4gICAgLy8gcHJpbWl0aXZlIG5hbWVcbiAgICBpZiAoc3BlYy5pc1ByaW1pdGl2ZVR5cGVSZWZlcmVuY2UodHlwZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvZGUudG9QYXNjYWxDYXNlKHR5cGUucHJpbWl0aXZlKTtcbiAgICB9XG5cbiAgICAvLyBMaXN0T2ZYIG9yIE1hcE9mWFxuICAgIGNvbnN0IGNvbGwgPSBzcGVjLmlzQ29sbGVjdGlvblR5cGVSZWZlcmVuY2UodHlwZSkgJiYgdHlwZS5jb2xsZWN0aW9uO1xuICAgIGlmIChjb2xsKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5jb2RlLnRvUGFzY2FsQ2FzZShjb2xsLmtpbmQpfU9mJHt0aGlzLmRpc3BsYXlOYW1lRm9yVHlwZShcbiAgICAgICAgY29sbC5lbGVtZW50dHlwZSxcbiAgICAgICl9YDtcbiAgICB9XG5cbiAgICBjb25zdCB1bmlvbiA9IHNwZWMuaXNVbmlvblR5cGVSZWZlcmVuY2UodHlwZSkgJiYgdHlwZS51bmlvbjtcbiAgICBpZiAodW5pb24pIHtcbiAgICAgIHJldHVybiB1bmlvbi50eXBlcy5tYXAoKHQpID0+IHRoaXMuZGlzcGxheU5hbWVGb3JUeXBlKHQpKS5qb2luKCdPcicpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3QgZGV0ZXJtaW5lIGRpc3BsYXkgbmFtZSBmb3IgdHlwZTogJHtKU09OLnN0cmluZ2lmeSh0eXBlKX1gLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogTG9va3MgdXAgYSBqc2lpIG1vZHVsZSBpbiB0aGUgZGVwZW5kZW5jeSB0cmVlLlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUganNpaSBtb2R1bGUgdG8gbG9vayB1cFxuICAgKi9cbiAgcHJvdGVjdGVkIGZpbmRNb2R1bGUobmFtZTogc3RyaW5nKTogc3BlYy5Bc3NlbWJseUNvbmZpZ3VyYXRpb24ge1xuICAgIC8vIGlmIHRoaXMgaXMgdGhlIGN1cnJlbnQgbW9kdWxlLCByZXR1cm4gaXRcbiAgICBpZiAodGhpcy5hc3NlbWJseS5uYW1lID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5hc3NlbWJseTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3VuZCA9ICh0aGlzLmFzc2VtYmx5LmRlcGVuZGVuY3lDbG9zdXJlID8/IHt9KVtuYW1lXTtcblxuICAgIGlmIChmb3VuZCkge1xuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBVbmFibGUgdG8gZmluZCBtb2R1bGUgJHtuYW1lfSBhcyBhIGRlcGVuZGVuY3kgb2YgJHt0aGlzLmFzc2VtYmx5Lm5hbWV9YCxcbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIGZpbmRUeXBlKGZxbjogc3RyaW5nKTogc3BlYy5UeXBlIHtcbiAgICBjb25zdCByZXQgPSB0aGlzLnJlZmxlY3RBc3NlbWJseS5zeXN0ZW0udHJ5RmluZEZxbihmcW4pO1xuICAgIGlmICghcmV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZmluZCB0eXBlICcke2Zxbn0nIGVpdGhlciBhcyBpbnRlcm5hbCBvciBleHRlcm5hbCB0eXBlYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldC5zcGVjO1xuICB9XG59XG4iXX0=