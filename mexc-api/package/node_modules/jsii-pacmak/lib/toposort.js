"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.topologicalSort = void 0;
/**
 * Return a topological sort of all elements of xs, according to the given dependency functions
 *
 * Returns tranches of packages that do not have a dependency on each other.
 *
 * Dependencies outside the referenced set are ignored.
 *
 * Not a stable sort, but in order to keep the order as stable as possible, we'll sort by key
 * among elements of equal precedence.
 *
 * @param xs - The elements to sort
 * @param keyFn - Return an element's identifier
 * @param depFn - Return the identifiers of an element's dependencies
 */
function topologicalSort(xs, keyFn, depFn) {
    const remaining = new Map();
    for (const element of xs) {
        const key = keyFn(element);
        remaining.set(key, { key, element, dependencies: depFn(element) });
    }
    const ret = new Array();
    while (remaining.size > 0) {
        // All elements with no more deps in the set can be ordered
        const selectable = Array.from(remaining.values()).filter((e) => e.dependencies.every((d) => !remaining.has(d)));
        selectable.sort((a, b) => (a.key < b.key ? -1 : b.key < a.key ? 1 : 0));
        ret.push(selectable.map((s) => s.element));
        for (const selected of selectable) {
            remaining.delete(selected.key);
        }
        // If we didn't make any progress, we got stuck
        if (selectable.length === 0) {
            throw new Error(`Could not determine ordering between: ${Array.from(remaining.keys()).join(', ')}`);
        }
    }
    return ret;
}
exports.topologicalSort = topologicalSort;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9wb3NvcnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ0b3Bvc29ydC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFHQTs7Ozs7Ozs7Ozs7OztHQWFHO0FBQ0gsU0FBZ0IsZUFBZSxDQUM3QixFQUFlLEVBQ2YsS0FBaUIsRUFDakIsS0FBaUI7SUFFakIsTUFBTSxTQUFTLEdBQUcsSUFBSSxHQUFHLEVBQTBCLENBQUM7SUFDcEQsS0FBSyxNQUFNLE9BQU8sSUFBSSxFQUFFLEVBQUU7UUFDeEIsTUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzNCLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxZQUFZLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUNwRTtJQUVELE1BQU0sR0FBRyxHQUFHLElBQUksS0FBSyxFQUFPLENBQUM7SUFDN0IsT0FBTyxTQUFTLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBRTtRQUN6QiwyREFBMkQ7UUFDM0QsTUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUM3RCxDQUFDLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQy9DLENBQUM7UUFFRixVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUV4RSxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBRTNDLEtBQUssTUFBTSxRQUFRLElBQUksVUFBVSxFQUFFO1lBQ2pDLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ2hDO1FBRUQsK0NBQStDO1FBQy9DLElBQUksVUFBVSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDM0IsTUFBTSxJQUFJLEtBQUssQ0FDYix5Q0FBeUMsS0FBSyxDQUFDLElBQUksQ0FDakQsU0FBUyxDQUFDLElBQUksRUFBRSxDQUNqQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUNmLENBQUM7U0FDSDtLQUNGO0lBRUQsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBckNELDBDQXFDQyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB0eXBlIEtleUZ1bmM8VD4gPSAoeDogVCkgPT4gc3RyaW5nO1xuZXhwb3J0IHR5cGUgRGVwRnVuYzxUPiA9ICh4OiBUKSA9PiBzdHJpbmdbXTtcblxuLyoqXG4gKiBSZXR1cm4gYSB0b3BvbG9naWNhbCBzb3J0IG9mIGFsbCBlbGVtZW50cyBvZiB4cywgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBkZXBlbmRlbmN5IGZ1bmN0aW9uc1xuICpcbiAqIFJldHVybnMgdHJhbmNoZXMgb2YgcGFja2FnZXMgdGhhdCBkbyBub3QgaGF2ZSBhIGRlcGVuZGVuY3kgb24gZWFjaCBvdGhlci5cbiAqXG4gKiBEZXBlbmRlbmNpZXMgb3V0c2lkZSB0aGUgcmVmZXJlbmNlZCBzZXQgYXJlIGlnbm9yZWQuXG4gKlxuICogTm90IGEgc3RhYmxlIHNvcnQsIGJ1dCBpbiBvcmRlciB0byBrZWVwIHRoZSBvcmRlciBhcyBzdGFibGUgYXMgcG9zc2libGUsIHdlJ2xsIHNvcnQgYnkga2V5XG4gKiBhbW9uZyBlbGVtZW50cyBvZiBlcXVhbCBwcmVjZWRlbmNlLlxuICpcbiAqIEBwYXJhbSB4cyAtIFRoZSBlbGVtZW50cyB0byBzb3J0XG4gKiBAcGFyYW0ga2V5Rm4gLSBSZXR1cm4gYW4gZWxlbWVudCdzIGlkZW50aWZpZXJcbiAqIEBwYXJhbSBkZXBGbiAtIFJldHVybiB0aGUgaWRlbnRpZmllcnMgb2YgYW4gZWxlbWVudCdzIGRlcGVuZGVuY2llc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdG9wb2xvZ2ljYWxTb3J0PFQ+KFxuICB4czogSXRlcmFibGU8VD4sXG4gIGtleUZuOiBLZXlGdW5jPFQ+LFxuICBkZXBGbjogRGVwRnVuYzxUPixcbik6IFRvcG9zb3J0ZWQ8VD4ge1xuICBjb25zdCByZW1haW5pbmcgPSBuZXcgTWFwPHN0cmluZywgVG9wb0VsZW1lbnQ8VD4+KCk7XG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiB4cykge1xuICAgIGNvbnN0IGtleSA9IGtleUZuKGVsZW1lbnQpO1xuICAgIHJlbWFpbmluZy5zZXQoa2V5LCB7IGtleSwgZWxlbWVudCwgZGVwZW5kZW5jaWVzOiBkZXBGbihlbGVtZW50KSB9KTtcbiAgfVxuXG4gIGNvbnN0IHJldCA9IG5ldyBBcnJheTxUW10+KCk7XG4gIHdoaWxlIChyZW1haW5pbmcuc2l6ZSA+IDApIHtcbiAgICAvLyBBbGwgZWxlbWVudHMgd2l0aCBubyBtb3JlIGRlcHMgaW4gdGhlIHNldCBjYW4gYmUgb3JkZXJlZFxuICAgIGNvbnN0IHNlbGVjdGFibGUgPSBBcnJheS5mcm9tKHJlbWFpbmluZy52YWx1ZXMoKSkuZmlsdGVyKChlKSA9PlxuICAgICAgZS5kZXBlbmRlbmNpZXMuZXZlcnkoKGQpID0+ICFyZW1haW5pbmcuaGFzKGQpKSxcbiAgICApO1xuXG4gICAgc2VsZWN0YWJsZS5zb3J0KChhLCBiKSA9PiAoYS5rZXkgPCBiLmtleSA/IC0xIDogYi5rZXkgPCBhLmtleSA/IDEgOiAwKSk7XG5cbiAgICByZXQucHVzaChzZWxlY3RhYmxlLm1hcCgocykgPT4gcy5lbGVtZW50KSk7XG5cbiAgICBmb3IgKGNvbnN0IHNlbGVjdGVkIG9mIHNlbGVjdGFibGUpIHtcbiAgICAgIHJlbWFpbmluZy5kZWxldGUoc2VsZWN0ZWQua2V5KTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBkaWRuJ3QgbWFrZSBhbnkgcHJvZ3Jlc3MsIHdlIGdvdCBzdHVja1xuICAgIGlmIChzZWxlY3RhYmxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ291bGQgbm90IGRldGVybWluZSBvcmRlcmluZyBiZXR3ZWVuOiAke0FycmF5LmZyb20oXG4gICAgICAgICAgcmVtYWluaW5nLmtleXMoKSxcbiAgICAgICAgKS5qb2luKCcsICcpfWAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmludGVyZmFjZSBUb3BvRWxlbWVudDxUPiB7XG4gIGtleTogc3RyaW5nO1xuICBkZXBlbmRlbmNpZXM6IHN0cmluZ1tdO1xuICBlbGVtZW50OiBUO1xufVxuXG4vKipcbiAqIEZvciBub3csIG1vZGVsIGEgdG9wb3NvcnRlZCBsaXN0IGFzIGEgbGlzdCBvZiB0cmFuY2hlcy5cbiAqXG4gKiBNb2RlbGluZyBpdCBsaWtlIHRoaXMgYWxsb3dzIGZvciBTT01FIHBhcmFsbGVsaXNtIGJldHdlZW4gbm9kZXMsXG4gKiBhbHRob3VnaCBub3QgbWF4aW11bS4gRm9yIGV4YW1wbGUsIGxldCdzIHNheSB3ZSBoYXZlIEEsIEIsIEMgd2l0aFxuICogQyBkZXBlbmRzLW9uIEEsIGFuZCB3ZSBzb3J0IHRvOlxuICpcbiAqICAgIFtbQSwgQl0sIFtDXV1cbiAqXG4gKiBOb3csIGxldCdzIHNheSBBIGZpbmlzaGVzIHF1aWNrbHkgYW5kIEIgdGFrZXMgYSBsb25nIHRpbWU6IHdlIHN0aWxsIGhhdmVcbiAqIHRvIHdhaXQgZm9yIEIgdG8gZmluaXNoIGJlZm9yZSB3ZSBjb3VsZCBzdGFydCBDIGluIHRoaXMgbW9kZWxpbmcuXG4gKlxuICogVGhlIGJldHRlciBhbHRlcm5hdGl2ZSB3b3VsZCBiZSB0byBtb2RlbCBhIGNsYXNzIHRoYXQga2VlcHMgdGhlIGRlcGVuZGVuY3lcbiAqIGdyYXBoIGFuZCB1bmxvY2tzIG5vZGVzIGFzIHdlIGdvIHRocm91Z2ggdGhlbS4gVGhhdCdzIGEgbG90IG9mIGVmZm9ydFxuICogZm9yIG5vdywgc28gd2UgZG9uJ3QgZG8gdGhhdCB5ZXQuXG4gKlxuICogV2UgZG8gZGVjbGFyZSB0aGUgdHlwZSBgVG9wb3NvcnRlZDxBPmAgaGVyZSBzbyB0aGF0IGlmIHdlIGV2ZXIgY2hhbmdlXG4gKiB0aGUgdHlwZSwgd2UgY2FuIGZpbmQgYWxsIHVzYWdlIHNpdGVzIHF1aWNrbHkuXG4gKi9cbmV4cG9ydCB0eXBlIFRvcG9zb3J0ZWQ8QT4gPSByZWFkb25seSBBW11bXTtcbiJdfQ==