"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findLocalBuildDirs = exports.Target = void 0;
const fs = require("fs-extra");
const path = require("path");
const spdx = require("spdx-license-list/full");
const dependency_graph_1 = require("./dependency-graph");
const logging = require("./logging");
class Target {
    constructor(options) {
        var _a, _b;
        this.packageDir = options.packageDir;
        this.assembly = options.assembly;
        this.rosetta = options.rosetta;
        this.fingerprint = (_a = options.fingerprint) !== null && _a !== void 0 ? _a : true;
        this.force = (_b = options.force) !== null && _b !== void 0 ? _b : false;
        this.arguments = options.arguments;
        this.targetName = options.targetName;
    }
    /**
     * Emits code artifacts.
     *
     * @param outDir the directory where the generated source will be placed.
     */
    async generateCode(outDir, tarball) {
        var _a;
        await this.generator.load(this.packageDir, this.assembly);
        if (this.force || !(await this.generator.upToDate(outDir))) {
            this.generator.generate(this.fingerprint);
            const licenseFile = path.join(this.packageDir, 'LICENSE');
            const license = (await fs.pathExists(licenseFile))
                ? await fs.readFile(licenseFile, 'utf8')
                : (_a = spdx[this.assembly.license]) === null || _a === void 0 ? void 0 : _a.licenseText;
            const noticeFile = path.join(this.packageDir, 'NOTICE');
            const notice = (await fs.pathExists(noticeFile))
                ? await fs.readFile(noticeFile, 'utf8')
                : undefined;
            await this.generator.save(outDir, tarball, { license, notice });
        }
        else {
            logging.info(`Generated code for ${this.targetName} was already up-to-date in ${outDir} (use --force to re-generate)`);
        }
    }
    /**
     * A utility to copy files from one directory to another.
     *
     * @param sourceDir the directory to copy from.
     * @param targetDir the directory to copy into.
     */
    async copyFiles(sourceDir, targetDir) {
        // Preemptively create target directory, to avoid unsafely racing on it's creation.
        await fs.mkdirp(targetDir);
        await fs.copy(sourceDir, targetDir, { recursive: true });
    }
    /**
     * Traverses the dep graph and returns a list of pacmak output directories
     * available locally for this specific target. This allows target builds to
     * take local dependencies in case a dependency is checked-out.
     *
     * @param packageDir The directory of the package to resolve from.
     */
    async findLocalDepsOutput(rootPackageDir) {
        return findLocalBuildDirs(rootPackageDir, this.targetName);
    }
}
exports.Target = Target;
/**
 * Traverses the dep graph and returns a list of pacmak output directories
 * available locally for this specific target. This allows target builds to
 * take local dependencies in case a dependency is checked-out.
 *
 * @param packageDir The directory of the package to resolve from.
 */
async function findLocalBuildDirs(rootPackageDir, targetName) {
    const results = new Set();
    await dependency_graph_1.traverseDependencyGraph(rootPackageDir, processPackage);
    return Array.from(results);
    async function processPackage(packageDir, pkg, isRoot) {
        // no jsii or jsii.outdir - either a misconfigured jsii package or a non-jsii dependency. either way, we are done here.
        if (!pkg.jsii || !pkg.jsii.outdir) {
            return false;
        }
        if (isRoot) {
            // This is the root package - no need to register it's outdir
            return true;
        }
        // if an output directory exists for this module, then we add it to our
        // list of results (unless it's the root package, which we are currently building)
        const outdir = path.join(packageDir, pkg.jsii.outdir, targetName);
        if (await fs.pathExists(outdir)) {
            logging.debug(`Found ${outdir} as a local dependency output`);
            results.add(outdir);
        }
        return true;
    }
}
exports.findLocalBuildDirs = findLocalBuildDirs;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFyZ2V0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidGFyZ2V0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLCtCQUErQjtBQUcvQiw2QkFBNkI7QUFDN0IsK0NBQStDO0FBRS9DLHlEQUE2RDtBQUU3RCxxQ0FBcUM7QUFFckMsTUFBc0IsTUFBTTtJQVcxQixZQUFtQixPQUFzQjs7UUFDdkMsSUFBSSxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQztRQUNqQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUM7UUFDL0IsSUFBSSxDQUFDLFdBQVcsU0FBRyxPQUFPLENBQUMsV0FBVyxtQ0FBSSxJQUFJLENBQUM7UUFDL0MsSUFBSSxDQUFDLEtBQUssU0FBRyxPQUFPLENBQUMsS0FBSyxtQ0FBSSxLQUFLLENBQUM7UUFDcEMsSUFBSSxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDO1FBQ25DLElBQUksQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQztJQUN2QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLEtBQUssQ0FBQyxZQUFZLENBQUMsTUFBYyxFQUFFLE9BQWU7O1FBQ3ZELE1BQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFMUQsSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUU7WUFDMUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBRTFDLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFD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XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyByZWZsZWN0IGZyb20gJ2pzaWktcmVmbGVjdCc7XG5pbXBvcnQgeyBSb3NldHRhIH0gZnJvbSAnanNpaS1yb3NldHRhJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBzcGR4IGZyb20gJ3NwZHgtbGljZW5zZS1saXN0L2Z1bGwnO1xuXG5pbXBvcnQgeyB0cmF2ZXJzZURlcGVuZGVuY3lHcmFwaCB9IGZyb20gJy4vZGVwZW5kZW5jeS1ncmFwaCc7XG5pbXBvcnQgeyBJR2VuZXJhdG9yIH0gZnJvbSAnLi9nZW5lcmF0b3InO1xuaW1wb3J0ICogYXMgbG9nZ2luZyBmcm9tICcuL2xvZ2dpbmcnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVGFyZ2V0IHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHBhY2thZ2VEaXI6IHN0cmluZztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGZpbmdlcnByaW50OiBib29sZWFuO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZm9yY2U6IGJvb2xlYW47XG4gIHByb3RlY3RlZCByZWFkb25seSBhcmd1bWVudHM6IHsgW25hbWU6IHN0cmluZ106IGFueSB9O1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgdGFyZ2V0TmFtZTogc3RyaW5nO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgYXNzZW1ibHk6IHJlZmxlY3QuQXNzZW1ibHk7XG4gIHByb3RlY3RlZCByZWFkb25seSByb3NldHRhOiBSb3NldHRhO1xuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCByZWFkb25seSBnZW5lcmF0b3I6IElHZW5lcmF0b3I7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFRhcmdldE9wdGlvbnMpIHtcbiAgICB0aGlzLnBhY2thZ2VEaXIgPSBvcHRpb25zLnBhY2thZ2VEaXI7XG4gICAgdGhpcy5hc3NlbWJseSA9IG9wdGlvbnMuYXNzZW1ibHk7XG4gICAgdGhpcy5yb3NldHRhID0gb3B0aW9ucy5yb3NldHRhO1xuICAgIHRoaXMuZmluZ2VycHJpbnQgPSBvcHRpb25zLmZpbmdlcnByaW50ID8/IHRydWU7XG4gICAgdGhpcy5mb3JjZSA9IG9wdGlvbnMuZm9yY2UgPz8gZmFsc2U7XG4gICAgdGhpcy5hcmd1bWVudHMgPSBvcHRpb25zLmFyZ3VtZW50cztcbiAgICB0aGlzLnRhcmdldE5hbWUgPSBvcHRpb25zLnRhcmdldE5hbWU7XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgY29kZSBhcnRpZmFjdHMuXG4gICAqXG4gICAqIEBwYXJhbSBvdXREaXIgdGhlIGRpcmVjdG9yeSB3aGVyZSB0aGUgZ2VuZXJhdGVkIHNvdXJjZSB3aWxsIGJlIHBsYWNlZC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZW5lcmF0ZUNvZGUob3V0RGlyOiBzdHJpbmcsIHRhcmJhbGw6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuZ2VuZXJhdG9yLmxvYWQodGhpcy5wYWNrYWdlRGlyLCB0aGlzLmFzc2VtYmx5KTtcblxuICAgIGlmICh0aGlzLmZvcmNlIHx8ICEoYXdhaXQgdGhpcy5nZW5lcmF0b3IudXBUb0RhdGUob3V0RGlyKSkpIHtcbiAgICAgIHRoaXMuZ2VuZXJhdG9yLmdlbmVyYXRlKHRoaXMuZmluZ2VycHJpbnQpO1xuXG4gICAgICBjb25zdCBsaWNlbnNlRmlsZSA9IHBhdGguam9pbih0aGlzLnBhY2thZ2VEaXIsICdMSUNFTlNFJyk7XG4gICAgICBjb25zdCBsaWNlbnNlID0gKGF3YWl0IGZzLnBhdGhFeGlzdHMobGljZW5zZUZpbGUpKVxuICAgICAgICA/IGF3YWl0IGZzLnJlYWRGaWxlKGxpY2Vuc2VGaWxlLCAndXRmOCcpXG4gICAgICAgIDogc3BkeFt0aGlzLmFzc2VtYmx5LmxpY2Vuc2VdPy5saWNlbnNlVGV4dDtcblxuICAgICAgY29uc3Qgbm90aWNlRmlsZSA9IHBhdGguam9pbih0aGlzLnBhY2thZ2VEaXIsICdOT1RJQ0UnKTtcbiAgICAgIGNvbnN0IG5vdGljZSA9IChhd2FpdCBmcy5wYXRoRXhpc3RzKG5vdGljZUZpbGUpKVxuICAgICAgICA/IGF3YWl0IGZzLnJlYWRGaWxlKG5vdGljZUZpbGUsICd1dGY4JylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGF3YWl0IHRoaXMuZ2VuZXJhdG9yLnNhdmUob3V0RGlyLCB0YXJiYWxsLCB7IGxpY2Vuc2UsIG5vdGljZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2luZy5pbmZvKFxuICAgICAgICBgR2VuZXJhdGVkIGNvZGUgZm9yICR7dGhpcy50YXJnZXROYW1lfSB3YXMgYWxyZWFkeSB1cC10by1kYXRlIGluICR7b3V0RGlyfSAodXNlIC0tZm9yY2UgdG8gcmUtZ2VuZXJhdGUpYCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZ2VuZXJhdGVkIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSBzb3VyY2VEaXIgdGhlIGRpcmVjdG9yeSB3aGVyZSB0aGUgZ2VuZXJhdGVkIHNvdXJjZSB3YXMgcHV0LlxuICAgKiBAcGFyYW0gb3V0RGlyICAgIHRoZSBkaXJlY3Rvcnkgd2hlcmUgdGhlIGJ1aWxkIGFydGlmYWN0cyB3aWxsIGJlIHBsYWNlZC5cbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBidWlsZChzb3VyY2VEaXI6IHN0cmluZywgb3V0RGlyOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBBIHV0aWxpdHkgdG8gY29weSBmaWxlcyBmcm9tIG9uZSBkaXJlY3RvcnkgdG8gYW5vdGhlci5cbiAgICpcbiAgICogQHBhcmFtIHNvdXJjZURpciB0aGUgZGlyZWN0b3J5IHRvIGNvcHkgZnJvbS5cbiAgICogQHBhcmFtIHRhcmdldERpciB0aGUgZGlyZWN0b3J5IHRvIGNvcHkgaW50by5cbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyBjb3B5RmlsZXMoc291cmNlRGlyOiBzdHJpbmcsIHRhcmdldERpcjogc3RyaW5nKSB7XG4gICAgLy8gUHJlZW1wdGl2ZWx5IGNyZWF0ZSB0YXJnZXQgZGlyZWN0b3J5LCB0byBhdm9pZCB1bnNhZmVseSByYWNpbmcgb24gaXQncyBjcmVhdGlvbi5cbiAgICBhd2FpdCBmcy5ta2RpcnAodGFyZ2V0RGlyKTtcbiAgICBhd2FpdCBmcy5jb3B5KHNvdXJjZURpciwgdGFyZ2V0RGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZXMgdGhlIGRlcCBncmFwaCBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgcGFjbWFrIG91dHB1dCBkaXJlY3Rvcmllc1xuICAgKiBhdmFpbGFibGUgbG9jYWxseSBmb3IgdGhpcyBzcGVjaWZpYyB0YXJnZXQuIFRoaXMgYWxsb3dzIHRhcmdldCBidWlsZHMgdG9cbiAgICogdGFrZSBsb2NhbCBkZXBlbmRlbmNpZXMgaW4gY2FzZSBhIGRlcGVuZGVuY3kgaXMgY2hlY2tlZC1vdXQuXG4gICAqXG4gICAqIEBwYXJhbSBwYWNrYWdlRGlyIFRoZSBkaXJlY3Rvcnkgb2YgdGhlIHBhY2thZ2UgdG8gcmVzb2x2ZSBmcm9tLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGZpbmRMb2NhbERlcHNPdXRwdXQocm9vdFBhY2thZ2VEaXI6IHN0cmluZykge1xuICAgIHJldHVybiBmaW5kTG9jYWxCdWlsZERpcnMocm9vdFBhY2thZ2VEaXIsIHRoaXMudGFyZ2V0TmFtZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgdGhlIGRlcCBncmFwaCBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgcGFjbWFrIG91dHB1dCBkaXJlY3Rvcmllc1xuICogYXZhaWxhYmxlIGxvY2FsbHkgZm9yIHRoaXMgc3BlY2lmaWMgdGFyZ2V0LiBUaGlzIGFsbG93cyB0YXJnZXQgYnVpbGRzIHRvXG4gKiB0YWtlIGxvY2FsIGRlcGVuZGVuY2llcyBpbiBjYXNlIGEgZGVwZW5kZW5jeSBpcyBjaGVja2VkLW91dC5cbiAqXG4gKiBAcGFyYW0gcGFja2FnZURpciBUaGUgZGlyZWN0b3J5IG9mIHRoZSBwYWNrYWdlIHRvIHJlc29sdmUgZnJvbS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZpbmRMb2NhbEJ1aWxkRGlycyhcbiAgcm9vdFBhY2thZ2VEaXI6IHN0cmluZyxcbiAgdGFyZ2V0TmFtZTogc3RyaW5nLFxuKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgYXdhaXQgdHJhdmVyc2VEZXBlbmRlbmN5R3JhcGgocm9vdFBhY2thZ2VEaXIsIHByb2Nlc3NQYWNrYWdlKTtcbiAgcmV0dXJuIEFycmF5LmZyb20ocmVzdWx0cyk7XG5cbiAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1BhY2thZ2UoXG4gICAgcGFja2FnZURpcjogc3RyaW5nLFxuICAgIHBrZzogYW55LFxuICAgIGlzUm9vdDogYm9vbGVhbixcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgLy8gbm8ganNpaSBvciBqc2lpLm91dGRpciAtIGVpdGhlciBhIG1pc2NvbmZpZ3VyZWQganNpaSBwYWNrYWdlIG9yIGEgbm9uLWpzaWkgZGVwZW5kZW5jeS4gZWl0aGVyIHdheSwgd2UgYXJlIGRvbmUgaGVyZS5cbiAgICBpZiAoIXBrZy5qc2lpIHx8ICFwa2cuanNpaS5vdXRkaXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaXNSb290KSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSByb290IHBhY2thZ2UgLSBubyBuZWVkIHRvIHJlZ2lzdGVyIGl0J3Mgb3V0ZGlyXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBpZiBhbiBvdXRwdXQgZGlyZWN0b3J5IGV4aXN0cyBmb3IgdGhpcyBtb2R1bGUsIHRoZW4gd2UgYWRkIGl0IHRvIG91clxuICAgIC8vIGxpc3Qgb2YgcmVzdWx0cyAodW5sZXNzIGl0J3MgdGhlIHJvb3QgcGFja2FnZSwgd2hpY2ggd2UgYXJlIGN1cnJlbnRseSBidWlsZGluZylcbiAgICBjb25zdCBvdXRkaXIgPSBwYXRoLmpvaW4ocGFja2FnZURpciwgcGtnLmpzaWkub3V0ZGlyLCB0YXJnZXROYW1lKTtcbiAgICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhvdXRkaXIpKSB7XG4gICAgICBsb2dnaW5nLmRlYnVnKGBGb3VuZCAke291dGRpcn0gYXMgYSBsb2NhbCBkZXBlbmRlbmN5IG91dHB1dGApO1xuICAgICAgcmVzdWx0cy5hZGQob3V0ZGlyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhcmdldENvbnN0cnVjdG9yIHtcbiAgLyoqXG4gICAqIFByb3ZpZGVzIGluZm9ybWF0aW9uIGFib3V0IGFuIGFzc2VtYmx5IGluIHRoZSB1c3VhbCBwYWNrYWdlIHJlcG9zaXRvcmllcyBmb3IgdGhlIHRhcmdldC4gVGhpcyBpbmNsdWRlcyBpbmZvcm1hdGlvblxuICAgKiBuZWNlc3NhcnkgdG8gbG9jYXRlIHRoZSBwYWNrYWdlIGluIHRoZSByZXBvc2l0b3JpZXMgKGEgVVJMIHRvIHRoZSByZXBvc2l0b3J5J3MgcHVibGljIGVuZHBvaW50KSwgYXMgd2VsbCBhcyB1c2FnZVxuICAgKiBpbnN0cnVjdGlvbnMgZm9yIHRoZSB2YXJpb3VzIGNvbmZpZ3J1YXRpb24gZmlsZXMgKGUuZzogTWF2ZW4gUE9NLCBHZW1maWxlLCAuLi4pIGFuZC9vciBpbnN0YWxsYXRpb24gaW5zdHJ1Y3Rpb25zXG4gICAqIHVzaW5nIHRoZSBzdGFuZGFyZCBjb21tYW5kIGxpbmUgdG9vbHMgKG5wbSwgeWFybiwgLi4uKS5cbiAgICpcbiAgICogQHBhcmFtIGFzc20gdGhlIGFzc2VtYmx5IGZvciB3aGljaCBjb29kaW5hdGVzIGFyZSByZXF1ZXN0ZWQuXG4gICAqXG4gICAqIEByZXR1cm4gSW5mb3JtYXRpb24gYWJvdXQgdGhlIGFzc2VtYmx5IGluIHRoZSB2YXJpb3VzIHBhY2thZ2UgbWFuYWdlcnMgc3VwcG9ydGVkIGZvciBhIGdpdmVuIGxhbmd1YWdlLiBUaGUgcmV0dXJuXG4gICAqICAgICAgICAgdmFsdWUgaXMgYSBoYXNoLCBhcyBzb21lIHBhY2thZ2VzIGNhbiBiZSB1c2VkIGFjcm9zcyBkaWZmZXJlbnQgbGFuZ3VhZ2VzICh0eXBlc2NyaXB0ICYgamF2YXNjcmlwdCwgamF2YSAmXG4gICAqICAgICAgICAgc2NhbGEgJiBjbG9qdXJlICYga290bGluLi4uKS5cbiAgICovXG4gIHRvUGFja2FnZUluZm9zPzogKGFzc206IHNwZWMuQXNzZW1ibHkpID0+IHsgW2xhbmd1YWdlOiBzdHJpbmddOiBQYWNrYWdlSW5mbyB9O1xuXG4gIC8qKlxuICAgKiBQcm92aWRlcyB0aGUgbmF0aXZlIHdheSB0byByZWZlcmVuY2UgYSBUeXBlLCBmb3IgZXhhbXBsZSBhIEphdmEgaW1wb3J0IHN0YXRlbWVudCwgb3IgYSBKYXZzY3JpcHQgcmVxdWlyZSBkaXJlY3RpdmUuXG4gICAqIFBhcnRpY3VsYXJseSB1c2VmdWwgd2hlbiBnZW5lcmF0aW5nIGRvY3VtZW50YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlICAgIHRoZSBKU0lJIHR5cGUgZm9yIHdoaWNoIGEgbmF0aXZlIHJlZmVyZW5jZSBpcyByZXF1ZXN0ZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIHRoZSB0YXJnZXQtc3BlY2lmaWMgb3B0aW9ucyBwcm92aWRlZC5cbiAgICpcbiAgICogQHJldHVybiB0aGUgbmF0aXZlIHJlZmVyZW5jZSBmb3IgdGhlIHRhcmdldCBmb3IgZWFjaCBzdXBwb3J0ZWQgbGFuZ3VhZ2UgKHRoZXJlIGNhbiBiZSBtdWx0aXBsZSBsYW5ndWFnZXNcbiAgICogICAgICAgICBzdXBwb3J0ZWQgYnkgYSBnaXZlbiB0YXJnZXQ6IHR5cGVzY3JpcHQgJiBqYXZhc2NyaXB0LCBqYXZhICYgc2NhbGEgJiBjbG9qdXJlICYga290bGluLCAuLi4pXG4gICAqL1xuICB0b05hdGl2ZVJlZmVyZW5jZT86IChcbiAgICB0eXBlOiBzcGVjLlR5cGUsXG4gICAgb3B0aW9uczogYW55LFxuICApID0+IHsgW2xhbmd1YWdlOiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQgfTtcblxuICBuZXcgKG9wdGlvbnM6IFRhcmdldE9wdGlvbnMpOiBUYXJnZXQ7XG59XG5cbi8qKlxuICogSW5mb3JtYXRpb24gYWJvdXQgYSBwYWNrYWdlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGFja2FnZUluZm8ge1xuICAvKiogVGhlIG5hbWUgYnkgd2hpY2ggdGhlIHBhY2thZ2UgcmVwb3NpdG9yeSBpcyBrbm93biAqL1xuICByZXBvc2l0b3J5OiBzdHJpbmc7XG5cbiAgLyoqIFRoZSBVUkwgdG8gdGhlIHBhY2thZ2Ugd2l0aGluIGl0J3MgcmVwb3NpdG9yeSAqL1xuICB1cmw6IHN0cmluZztcblxuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmcmFnbWVudHMgb3IgaW5zdGFsbGF0aW9uIGluc3RydWN0aW9ucywgYnkgY2xpZW50IHNjZW5hcmlvIChlLmc6IG1hdmVuICsgZ3JhZGxlKS4gVmFsdWVzIGNhbiBiZSBhXG4gICAqIHBsYWluIHN0cmluZyAoZG9jdW1lbnRhdGlvbiBzaG91bGQgcmVuZGVyIGFzIGEgcHJlLWZvcm1hdHRlZCBibG9jayBvZiB0ZXh0IHVzaW5nIG1vbm9zcGFjZSBmb250KSwgb3IgYW4gb2JqZWN0XG4gICAqIGRlc2NyaWJpbmcgYSBsYW5ndWFnZS10YWdnZWQgYmxvY2sgb2YgY29kZS5cbiAgICpcbiAgICogQGV4YW1wbGUge1xuICAgKiAgICAgICAgICAgICAgbWF2ZW46IHtcbiAgICogICAgICAgICAgICAgICAgICBsYW5ndWFnZTogJ3htbCcsXG4gICAqICAgICAgICAgICAgICAgICAgY29kZTogJzxkZXBlbmRlbmN5Pjxncm91cElkPmdycDwvZ3JvdXBJZD48YXJ0aWZhY3RJZD5hcnQ8L2FydGlmYWN0SWQ+PHZlcnNpb24+dmVyc2lvbjwvdmVyc2lvbj48L2RlcGVuZGVuY3k+J1xuICAgKiAgICAgICAgICAgICAgfSxcbiAgICogICAgICAgICAgICAgIGdyYWRsZTogXCJjb21waWxlICdncnA6YXJ0OnZlcnNpb24nXCIsXG4gICAqICAgICAgICAgIH1cbiAgICpcbiAgICogQGV4YW1wbGUge1xuICAgKiAgICAgICAgICAgICAgbnBtOiB7IGxhbmd1YWdlOiAnY29uc29sZScsIGNvZGU6ICckIG5wbSBpbnN0YWxsIHBrZycgfSxcbiAgICogICAgICAgICAgICAgIHlhcm46IHsgbGFuZ3VhZ2U6ICdjb25zb2xlJywgY29kZTogJyQgeWFybiBhZGQgcGtnJyB9LFxuICAgKiAgICAgICAgICAgICAgJ3BhY2thZ2UuanNvbic6IHsgbGFuZ3VhZ2U6IGpzb24sIGNvZGU6ICd7XCJwa2dcIjogXCJedmVyc2lvblwiIH0nIH1cbiAgICogICAgICAgICAgfVxuICAgKi9cbiAgdXNhZ2U6IHsgW2xhYmVsOiBzdHJpbmddOiBzdHJpbmcgfCB7IGxhbmd1YWdlOiBzdHJpbmc7IGNvZGU6IHN0cmluZyB9IH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFyZ2V0T3B0aW9ucyB7XG4gIC8qKiBUaGUgbmFtZSBvZiB0aGUgdGFyZ2V0IGxhbmd1YWdlIHdlIGFyZSBnZW5lcmF0aW5nICovXG4gIHRhcmdldE5hbWU6IHN0cmluZztcblxuICAvKiogVGhlIGRpcmVjdG9yeSB3aGVyZSB0aGUgSlNJSSBwYWNrYWdlIGlzIGxvY2F0ZWQgKi9cbiAgcGFja2FnZURpcjogc3RyaW5nO1xuXG4gIC8qKiBUaGUgSlNJSS1yZWZsZWN0IGFzc2VtYmx5IGZvciB0aGlzIEpTSUkgYXNzZW1ibHkgKi9cbiAgYXNzZW1ibHk6IHJlZmxlY3QuQXNzZW1ibHk7XG5cbiAgLyoqIFRoZSBSb3NldHRhIGluc3RhbmNlICovXG4gIHJvc2V0dGE6IFJvc2V0dGE7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZmluZ2VycHJpbnQgdGhlIHByb2R1Y2VkIGFydGlmYWN0cy5cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZmluZ2VycHJpbnQ/OiBib29sZWFuO1xuICAvKipcbiAgICogV2hldGhlciBhcnRpZmFjdHMgc2hvdWxkIGJlIHJlLWJ1aWxkIGV2ZW4gaWYgdGhlaXIgZmluZ2VycHJpbnRzIGxvb2sgdXAtdG8tZGF0ZS5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGZvcmNlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEFyZ3VtZW50cyBwcm92aWRlZCBieSB0aGUgdXNlciAoaG93IHRoZXkgYXJlIHVzZWQgaXMgdGFyZ2V0LWRlcGVuZGVudClcbiAgICovXG4gIGFyZ3VtZW50czogeyBbbmFtZTogc3RyaW5nXTogYW55IH07XG59XG4iXX0=