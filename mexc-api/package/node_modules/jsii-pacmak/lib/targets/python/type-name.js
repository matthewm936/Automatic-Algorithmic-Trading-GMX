"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _element, _element_1, _wrapped, _pythonType, _options, _fqn;
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergePythonImports = exports.toPackageName = exports.toTypeName = void 0;
const spec_1 = require("@jsii/spec");
const codemaker_1 = require("codemaker");
const crypto_1 = require("crypto");
const util_1 = require("./util");
function toTypeName(ref) {
    if (ref == null) {
        return Primitive.NONE;
    }
    const type = isOptionalValue(ref) ? ref.type : ref;
    const optional = isOptionalValue(ref) && ref.optional;
    let result = Primitive.ANY;
    if (spec_1.isPrimitiveTypeReference(type)) {
        result = Primitive.of(type);
    }
    else if (spec_1.isCollectionTypeReference(type)) {
        const elt = toTypeName(type.collection.elementtype);
        if (type.collection.kind === spec_1.CollectionKind.Array) {
            result = new List(elt);
        }
        else {
            result = new Dict(elt);
        }
    }
    else if (spec_1.isUnionTypeReference(type)) {
        result = new Union(type.union.types.map(toTypeName));
    }
    else if (spec_1.isNamedTypeReference(type)) {
        result = new UserType(type.fqn);
    }
    return optional ? new Optional(result) : result;
}
exports.toTypeName = toTypeName;
/**
 * Obtains the Python package name for a given submodule FQN.
 *
 * @param fqn      the submodule FQN for which a package name is needed.
 * @param rootAssm the assembly this FQN belongs to.
 */
function toPackageName(fqn, rootAssm) {
    return getPackageName(fqn, rootAssm).packageName;
}
exports.toPackageName = toPackageName;
function mergePythonImports(...pythonImports) {
    const result = {};
    for (const bag of pythonImports) {
        for (const [packageName, items] of Object.entries(bag)) {
            if (!(packageName in result)) {
                result[packageName] = new Set();
            }
            for (const item of items) {
                result[packageName].add(item);
            }
        }
    }
    return result;
}
exports.mergePythonImports = mergePythonImports;
function isOptionalValue(type) {
    return type.type != null;
}
class Dict {
    constructor(element) {
        // eslint-disable-next-line @typescript-eslint/explicit-member-accessibility
        _element.set(this, void 0);
        __classPrivateFieldSet(this, _element, element);
    }
    pythonType(context) {
        return `typing.Mapping[builtins.str, ${__classPrivateFieldGet(this, _element).pythonType(context)}]`;
    }
    requiredImports(context) {
        return __classPrivateFieldGet(this, _element).requiredImports(context);
    }
}
_element = new WeakMap();
class List {
    constructor(element) {
        // eslint-disable-next-line @typescript-eslint/explicit-member-accessibility
        _element_1.set(this, void 0);
        __classPrivateFieldSet(this, _element_1, element);
    }
    pythonType(context) {
        const type = context.parameterType ? 'Sequence' : 'List';
        return `typing.${type}[${__classPrivateFieldGet(this, _element_1).pythonType(context)}]`;
    }
    requiredImports(context) {
        return __classPrivateFieldGet(this, _element_1).requiredImports(context);
    }
}
_element_1 = new WeakMap();
class Optional {
    constructor(wrapped) {
        // eslint-disable-next-line @typescript-eslint/explicit-member-accessibility
        _wrapped.set(this, void 0);
        __classPrivateFieldSet(this, _wrapped, wrapped);
    }
    pythonType(context) {
        const optionalType = __classPrivateFieldGet(this, _wrapped).pythonType({
            ...context,
            ignoreOptional: true,
        });
        if (context.ignoreOptional || __classPrivateFieldGet(this, _wrapped) === Primitive.ANY) {
            return optionalType;
        }
        return `typing.Optional[${optionalType}]`;
    }
    requiredImports(context) {
        return __classPrivateFieldGet(this, _wrapped).requiredImports({ ...context, ignoreOptional: true });
    }
}
_wrapped = new WeakMap();
class Primitive {
    constructor(pythonType) {
        // eslint-disable-next-line @typescript-eslint/explicit-member-accessibility
        _pythonType.set(this, void 0);
        __classPrivateFieldSet(this, _pythonType, pythonType);
    }
    static of(type) {
        switch (type.primitive) {
            case spec_1.PrimitiveType.Boolean:
                return Primitive.BOOL;
            case spec_1.PrimitiveType.Date:
                return Primitive.DATE;
            case spec_1.PrimitiveType.Number:
                return Primitive.JSII_NUMBER;
            case spec_1.PrimitiveType.String:
                return Primitive.STR;
            case spec_1.PrimitiveType.Json:
                return Primitive.JSON;
            case spec_1.PrimitiveType.Any:
            default:
                return Primitive.ANY;
        }
    }
    pythonType() {
        return __classPrivateFieldGet(this, _pythonType);
    }
    requiredImports() {
        return {};
    }
}
_pythonType = new WeakMap();
Primitive.BOOL = new Primitive('builtins.bool');
Primitive.DATE = new Primitive('datetime.datetime');
Primitive.JSII_NUMBER = new Primitive('jsii.Number'); // "jsii" is always already imported!
Primitive.STR = new Primitive('builtins.str');
Primitive.JSON = new Primitive('typing.Mapping[typing.Any, typing.Any]');
Primitive.ANY = new Primitive('typing.Any');
Primitive.NONE = new Primitive('None');
class Union {
    constructor(options) {
        // eslint-disable-next-line @typescript-eslint/explicit-member-accessibility
        _options.set(this, void 0);
        __classPrivateFieldSet(this, _options, options);
    }
    pythonType(context) {
        return `typing.Union[${__classPrivateFieldGet(this, _options).map((o) => o.pythonType(context))
            .join(', ')}]`;
    }
    requiredImports(context) {
        return mergePythonImports(...__classPrivateFieldGet(this, _options).map((o) => o.requiredImports(context)));
    }
}
_options = new WeakMap();
class UserType {
    constructor(fqn) {
        // eslint-disable-next-line @typescript-eslint/explicit-member-accessibility
        _fqn.set(this, void 0);
        __classPrivateFieldSet(this, _fqn, fqn);
    }
    pythonType(context) {
        return this.resolve(context).pythonType;
    }
    requiredImports(context) {
        const requiredImport = this.resolve(context).requiredImport;
        if (requiredImport == null) {
            return {};
        }
        return { [requiredImport.sourcePackage]: new Set([requiredImport.item]) };
    }
    resolve({ assembly, emittedTypes, submodule, surroundingTypeFqns, typeAnnotation = true, }) {
        var _a, _b;
        const { assemblyName, packageName, pythonFqn } = toPythonFqn(__classPrivateFieldGet(this, _fqn), assembly);
        if (assemblyName !== assembly.name) {
            return {
                pythonType: pythonFqn,
                requiredImport: {
                    sourcePackage: packageName,
                    item: '',
                },
            };
        }
        const submodulePythonName = toPythonFqn(submodule, assembly).pythonFqn;
        const typeSubmodulePythonName = toPythonFqn(findParentSubmodule(assembly.types[__classPrivateFieldGet(this, _fqn)], assembly), assembly).pythonFqn;
        if (typeSubmodulePythonName === submodulePythonName) {
            // Identifiy declarations that are not yet initialized and hence cannot be
            // used as part of a type qualification. Since this is not a forward
            // reference, the type was already emitted and its un-qualified name must
            // be used instead of it's locally qualified name.
            const nestingParent = (_b = (_a = surroundingTypeFqns === null || surroundingTypeFqns === void 0 ? void 0 : surroundingTypeFqns.map((fqn) => toPythonFqn(fqn, assembly).pythonFqn)) === null || _a === void 0 ? void 0 : _a.reverse()) === null || _b === void 0 ? void 0 : _b.find((parent) => pythonFqn.startsWith(`${parent}.`));
            if (typeAnnotation &&
                (!emittedTypes.has(__classPrivateFieldGet(this, _fqn)) || nestingParent != null)) {
                // Possibly a forward reference, outputting the stringifierd python FQN
                return {
                    pythonType: JSON.stringify(pythonFqn.substring(submodulePythonName.length + 1)),
                };
            }
            if (!typeAnnotation && nestingParent) {
                // This is not for a type annotation, so we should be at a point in time
                // where the surrounding symbol has been defined entirely, so we can
                // refer to it "normally" now.
                return { pythonType: pythonFqn.substring(nestingParent.length + 1) };
            }
            // We'll just make a module-qualified reference at this point.
            return {
                pythonType: pythonFqn.substring(submodulePythonName.length + 1),
            };
        }
        const [toImport, ...nested] = pythonFqn
            .substring(typeSubmodulePythonName.length + 1)
            .split('.');
        const aliasSuffix = crypto_1.createHash('sha256')
            .update(typeSubmodulePythonName)
            .update('.')
            .update(toImport)
            .digest('hex')
            .substring(0, 8);
        const alias = `_${toImport}_${aliasSuffix}`;
        return {
            pythonType: [alias, ...nested].join('.'),
            requiredImport: {
                sourcePackage: relativeImportPath(submodulePythonName, typeSubmodulePythonName),
                item: `${toImport} as ${alias}`,
            },
        };
    }
}
_fqn = new WeakMap();
function toPythonFqn(fqn, rootAssm) {
    const { assemblyName, packageName, tail } = getPackageName(fqn, rootAssm);
    const fqnParts = [packageName];
    for (const part of tail) {
        fqnParts.push(util_1.toPythonIdentifier(part));
    }
    return { assemblyName, packageName, pythonFqn: fqnParts.join('.') };
}
/**
 * Computes the python relative import path from `fromModule` to `toModule`.
 *
 * @param fromPkg the package where the relative import statement is located.
 * @param toPkg   the package that needs to be relatively imported.
 *
 * @returns a relative import path.
 *
 * @example
 *  relativeImportPath('A.B.C.D', 'A.B.E') === '...E';
 *  relativeImportPath('A.B.C', 'A.B')     === '..';
 *  relativeImportPath('A.B', 'A.B.C')     === '.C';
 */
function relativeImportPath(fromPkg, toPkg) {
    if (toPkg.startsWith(fromPkg)) {
        // from A.B to A.B.C === .C
        return `.${toPkg.substring(fromPkg.length + 1)}`;
    }
    // from A.B.E to A.B.C === .<from A.B to A.B.C>
    const fromPkgParent = fromPkg.substring(0, fromPkg.lastIndexOf('.'));
    return `.${relativeImportPath(fromPkgParent, toPkg)}`;
}
function getPackageName(fqn, rootAssm) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const segments = fqn.split('.');
    const assemblyName = segments[0];
    const config = assemblyName === rootAssm.name
        ? rootAssm
        : (_b = (_a = rootAssm.dependencyClosure) === null || _a === void 0 ? void 0 : _a[assemblyName]) !== null && _b !== void 0 ? _b : util_1.die(`Unable to find configuration for assembly "${assemblyName}" in dependency closure`);
    const rootPkg = (_e = (_d = (_c = config.targets) === null || _c === void 0 ? void 0 : _c.python) === null || _d === void 0 ? void 0 : _d.module) !== null && _e !== void 0 ? _e : util_1.die(`No Python target was configured in assembly "${assemblyName}"`);
    const pkg = new Array();
    const tail = new Array();
    for (let len = segments.length; len > 0; len--) {
        const submodule = segments.slice(0, len).join('.');
        if (submodule === assemblyName) {
            pkg.unshift(rootPkg);
            break;
        }
        const submoduleConfig = (_f = config.submodules) === null || _f === void 0 ? void 0 : _f[submodule];
        if (submoduleConfig == null) {
            // Not in a submodule - so the current lead name is not a package name part.
            tail.unshift(segments[len - 1]);
            continue;
        }
        const subPackage = (_h = (_g = submoduleConfig.targets) === null || _g === void 0 ? void 0 : _g.python) === null || _h === void 0 ? void 0 : _h.module;
        if (subPackage != null) {
            // Found a sub-package. Confirm it's nested right in, and make this the head end of our package name.
            if (!subPackage.startsWith(`${rootPkg}.`)) {
                util_1.die(`Submodule "${submodule}" is mapped to Python sub-package "${subPackage}" which isn't nested under "${rootPkg}"!`);
            }
            pkg.unshift(subPackage);
            break;
        }
        // Just use whatever the default name is for this package name part.
        pkg.unshift(codemaker_1.toSnakeCase(util_1.toPythonIdentifier(segments[len - 1])));
    }
    return { assemblyName, packageName: pkg.join('.'), tail };
}
function findParentSubmodule(type, assm) {
    var _a, _b;
    if (type.namespace == null) {
        return assm.name;
    }
    const namespaceFqn = `${assm.name}.${type.namespace}`;
    if (((_a = assm.types) === null || _a === void 0 ? void 0 : _a[namespaceFqn]) != null) {
        return findParentSubmodule((_b = assm.types) === null || _b === void 0 ? void 0 : _b[namespaceFqn], assm);
    }
    return namespaceFqn;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS1uYW1lLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidHlwZS1uYW1lLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEscUNBWW9CO0FBQ3BCLHlDQUF3QztBQUN4QyxtQ0FBb0M7QUFFcEMsaUNBQWlEO0FBa0VqRCxTQUFnQixVQUFVLENBQUMsR0FBbUM7SUFDNUQsSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFO1FBQ2YsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDO0tBQ3ZCO0lBRUQsTUFBTSxJQUFJLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7SUFDbkQsTUFBTSxRQUFRLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxRQUFRLENBQUM7SUFFdEQsSUFBSSxNQUFNLEdBQWEsU0FBUyxDQUFDLEdBQUcsQ0FBQztJQUVyQyxJQUFJLCtCQUF3QixDQUFDLElBQUksQ0FBQyxFQUFFO1FBQ2xDLE1BQU0sR0FBRyxTQUFTLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQzdCO1NBQU0sSUFBSSxnQ0FBeUIsQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUMxQyxNQUFNLEdBQUcsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNwRCxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxLQUFLLHFCQUFjLENBQUMsS0FBSyxFQUFFO1lBQ2pELE1BQU0sR0FBRyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUN4QjthQUFNO1lBQ0wsTUFBTSxHQUFHLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3hCO0tBQ0Y7U0FBTSxJQUFJLDJCQUFvQixDQUFDLElBQUksQ0FBQyxFQUFFO1FBQ3JDLE1BQU0sR0FBRyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztLQUN0RDtTQUFNLElBQUksMkJBQW9CLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDckMsTUFBTSxHQUFHLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUNqQztJQUVELE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQ2xELENBQUM7QUExQkQsZ0NBMEJDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixhQUFhLENBQUMsR0FBVyxFQUFFLFFBQWtCO0lBQzNELE9BQU8sY0FBYyxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQyxXQUFXLENBQUM7QUFDbkQsQ0FBQztBQUZELHNDQUVDO0FBRUQsU0FBZ0Isa0JBQWtCLENBQ2hDLEdBQUcsYUFBdUM7SUFFMUMsTUFBTSxNQUFNLEdBQWdDLEVBQUUsQ0FBQztJQUMvQyxLQUFLLE1BQU0sR0FBRyxJQUFJLGFBQWEsRUFBRTtRQUMvQixLQUFLLE1BQU0sQ0FBQyxXQUFXLEVBQUUsS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUN0RCxJQUFJLENBQUMsQ0FBQyxXQUFXLElBQUksTUFBTSxDQUFDLEVBQUU7Z0JBQzVCLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO2FBQ2pDO1lBQ0QsS0FBSyxNQUFNLElBQUksSUFBSSxLQUFLLEVBQUU7Z0JBQ3hCLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDL0I7U0FDRjtLQUNGO0lBQ0QsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQWZELGdEQWVDO0FBRUQsU0FBUyxlQUFlLENBQ3RCLElBQW1DO0lBRW5DLE9BQVEsSUFBaUMsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDO0FBQ3pELENBQUM7QUFFRCxNQUFNLElBQUk7SUFJUixZQUFtQixPQUFpQjtRQUhwQyw0RUFBNEU7UUFDNUUsMkJBQTRCO1FBRzFCLHVCQUFBLElBQUksWUFBWSxPQUFPLEVBQUM7SUFDMUIsQ0FBQztJQUVNLFVBQVUsQ0FBQyxPQUFzQjtRQUN0QyxPQUFPLGdDQUFnQyx1Q0FBYyxVQUFVLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQztJQUM5RSxDQUFDO0lBRU0sZUFBZSxDQUFDLE9BQXNCO1FBQzNDLE9BQU8sdUNBQWMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2hELENBQUM7Q0FDRjs7QUFFRCxNQUFNLElBQUk7SUFJUixZQUFtQixPQUFpQjtRQUhwQyw0RUFBNEU7UUFDNUUsNkJBQTRCO1FBRzFCLHVCQUFBLElBQUksY0FBWSxPQUFPLEVBQUM7SUFDMUIsQ0FBQztJQUVNLFVBQVUsQ0FBQyxPQUFzQjtRQUN0QyxNQUFNLElBQUksR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztRQUN6RCxPQUFPLFVBQVUsSUFBSSxJQUFJLHlDQUFjLFVBQVUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO0lBQ2hFLENBQUM7SUFFTSxlQUFlLENBQUMsT0FBc0I7UUFDM0MsT0FBTyx5Q0FBYyxlQUFlLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDaEQsQ0FBQztDQUNGOztBQUVELE1BQU0sUUFBUTtJQUlaLFlBQW1CLE9BQWlCO1FBSHBDLDRFQUE0RTtRQUM1RSwyQkFBNEI7UUFHMUIsdUJBQUEsSUFBSSxZQUFZLE9BQU8sRUFBQztJQUMxQixDQUFDO0lBRU0sVUFBVSxDQUFDLE9BQXNCO1FBQ3RDLE1BQU0sWUFBWSxHQUFHLHVDQUFjLFVBQVUsQ0FBQztZQUM1QyxHQUFHLE9BQU87WUFDVixjQUFjLEVBQUUsSUFBSTtTQUNyQixDQUFDLENBQUM7UUFDSCxJQUFJLE9BQU8sQ0FBQyxjQUFjLElBQUksMkNBQWtCLFNBQVMsQ0FBQyxHQUFHLEVBQUU7WUFDN0QsT0FBTyxZQUFZLENBQUM7U0FDckI7UUFDRCxPQUFPLG1CQUFtQixZQUFZLEdBQUcsQ0FBQztJQUM1QyxDQUFDO0lBRU0sZUFBZSxDQUFDLE9BQXNCO1FBQzNDLE9BQU8sdUNBQWMsZUFBZSxDQUFDLEVBQUUsR0FBRyxPQUFPLEVBQUUsY0FBYyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7SUFDN0UsQ0FBQztDQUNGOztBQUVELE1BQU0sU0FBUztJQWlDYixZQUFvQixVQUFrQjtRQUh0Qyw0RUFBNEU7UUFDNUUsOEJBQTZCO1FBRzNCLHVCQUFBLElBQUksZUFBZSxVQUFVLEVBQUM7SUFDaEMsQ0FBQztJQXZCTSxNQUFNLENBQUMsRUFBRSxDQUFDLElBQTRCO1FBQzNDLFFBQVEsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUN0QixLQUFLLG9CQUFhLENBQUMsT0FBTztnQkFDeEIsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDO1lBQ3hCLEtBQUssb0JBQWEsQ0FBQyxJQUFJO2dCQUNyQixPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUM7WUFDeEIsS0FBSyxvQkFBYSxDQUFDLE1BQU07Z0JBQ3ZCLE9BQU8sU0FBUyxDQUFDLFdBQVcsQ0FBQztZQUMvQixLQUFLLG9CQUFhLENBQUMsTUFBTTtnQkFDdkIsT0FBTyxTQUFTLENBQUMsR0FBRyxDQUFDO1lBQ3ZCLEtBQUssb0JBQWEsQ0FBQyxJQUFJO2dCQUNyQixPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUM7WUFDeEIsS0FBSyxvQkFBYSxDQUFDLEdBQUcsQ0FBQztZQUN2QjtnQkFDRSxPQUFPLFNBQVMsQ0FBQyxHQUFHLENBQUM7U0FDeEI7SUFDSCxDQUFDO0lBU00sVUFBVTtRQUNmLGlEQUF3QjtJQUMxQixDQUFDO0lBRU0sZUFBZTtRQUNwQixPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7OztBQTFDdUIsY0FBSSxHQUFHLElBQUksU0FBUyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQ3RDLGNBQUksR0FBRyxJQUFJLFNBQVMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQzFDLHFCQUFXLEdBQUcsSUFBSSxTQUFTLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxxQ0FBcUM7QUFDakYsYUFBRyxHQUFHLElBQUksU0FBUyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQ3BDLGNBQUksR0FBRyxJQUFJLFNBQVMsQ0FDMUMsd0NBQXdDLENBQ3pDLENBQUM7QUFFcUIsYUFBRyxHQUFHLElBQUksU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ2xDLGNBQUksR0FBRyxJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQW9DdEQsTUFBTSxLQUFLO0lBSVQsWUFBbUIsT0FBNEI7UUFIL0MsNEVBQTRFO1FBQzVFLDJCQUF1QztRQUdyQyx1QkFBQSxJQUFJLFlBQVksT0FBTyxFQUFDO0lBQzFCLENBQUM7SUFFTSxVQUFVLENBQUMsT0FBc0I7UUFDdEMsT0FBTyxnQkFBZ0IsdUNBQ3BCLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUNqQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztJQUNuQixDQUFDO0lBRU0sZUFBZSxDQUFDLE9BQXNCO1FBQzNDLE9BQU8sa0JBQWtCLENBQ3ZCLEdBQUcsdUNBQWMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQ3hELENBQUM7SUFDSixDQUFDO0NBQ0Y7O0FBRUQsTUFBTSxRQUFRO0lBSVosWUFBbUIsR0FBVztRQUg5Qiw0RUFBNEU7UUFDNUUsdUJBQXNCO1FBR3BCLHVCQUFBLElBQUksUUFBUSxHQUFHLEVBQUM7SUFDbEIsQ0FBQztJQUVNLFVBQVUsQ0FBQyxPQUFzQjtRQUN0QyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsVUFBVSxDQUFDO0lBQzFDLENBQUM7SUFFTSxlQUFlLENBQUMsT0FBc0I7UUFDM0MsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxjQUFjLENBQUM7UUFDNUQsSUFBSSxjQUFjLElBQUksSUFBSSxFQUFFO1lBQzFCLE9BQU8sRUFBRSxDQUFDO1NBQ1g7UUFDRCxPQUFPLEVBQUUsQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDLEVBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQzVFLENBQUM7SUFFTyxPQUFPLENBQUMsRUFDZCxRQUFRLEVBQ1IsWUFBWSxFQUNaLFNBQVMsRUFDVCxtQkFBbUIsRUFDbkIsY0FBYyxHQUFHLElBQUksR0FDUDs7UUFDZCxNQUFNLEVBQUUsWUFBWSxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsR0FBRyxXQUFXLHFDQUUxRCxRQUFRLENBQ1QsQ0FBQztRQUNGLElBQUksWUFBWSxLQUFLLFFBQVEsQ0FBQyxJQUFJLEVBQUU7WUFDbEMsT0FBTztnQkFDTCxVQUFVLEVBQUUsU0FBUztnQkFDckIsY0FBYyxFQUFFO29CQUNkLGFBQWEsRUFBRSxXQUFXO29CQUMxQixJQUFJLEVBQUUsRUFBRTtpQkFDVDthQUNGLENBQUM7U0FDSDtRQUVELE1BQU0sbUJBQW1CLEdBQUcsV0FBVyxDQUFDLFNBQVMsRUFBRSxRQUFRLENBQUMsQ0FBQyxTQUFTLENBQUM7UUFDdkUsTUFBTSx1QkFBdUIsR0FBRyxXQUFXLENBQ3pDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxLQUFNLG9DQUFXLEVBQUUsUUFBUSxDQUFDLEVBQ3pELFFBQVEsQ0FDVCxDQUFDLFNBQVMsQ0FBQztRQUVaLElBQUksdUJBQXVCLEtBQUssbUJBQW1CLEVBQUU7WUFDbkQsMEVBQTBFO1lBQzFFLG9FQUFvRTtZQUNwRSx5RUFBeUU7WUFDekUsa0RBQWtEO1lBQ2xELE1BQU0sYUFBYSxlQUFHLG1CQUFtQixhQUFuQixtQkFBbUIsdUJBQW5CLG1CQUFtQixDQUNyQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUMsU0FBUywyQ0FDakQsT0FBTyw0Q0FDUCxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFFekQsSUFDRSxjQUFjO2dCQUNkLENBQUMsQ0FBQyxZQUFZLENBQUMsR0FBRyxvQ0FBVyxJQUFJLGFBQWEsSUFBSSxJQUFJLENBQUMsRUFDdkQ7Z0JBQ0EsdUVBQXVFO2dCQUN2RSxPQUFPO29CQUNMLFVBQVUsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUN4QixTQUFTLENBQUMsU0FBUyxDQUFDLG1CQUFtQixDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FDcEQ7aUJBQ0YsQ0FBQzthQUNIO1lBRUQsSUFBSSxDQUFDLGNBQWMsSUFBSSxhQUFhLEVBQUU7Z0JBQ3BDLHdFQUF3RTtnQkFDeEUsb0VBQW9FO2dCQUNwRSw4QkFBOEI7Z0JBQzlCLE9BQU8sRUFBRSxVQUFVLEVBQUUsU0FBUyxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUM7YUFDdEU7WUFFRCw4REFBOEQ7WUFDOUQsT0FBTztnQkFDTCxVQUFVLEVBQUUsU0FBUyxDQUFDLFNBQVMsQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO2FBQ2hFLENBQUM7U0FDSDtRQUVELE1BQU0sQ0FBQyxRQUFRLEVBQUUsR0FBRyxNQUFNLENBQUMsR0FBRyxTQUFTO2FBQ3BDLFNBQVMsQ0FBQyx1QkFBdUIsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO2FBQzdDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNkLE1BQU0sV0FBVyxHQUFHLG1CQUFVLENBQUMsUUFBUSxDQUFDO2FBQ3JDLE1BQU0sQ0FBQyx1QkFBdUIsQ0FBQzthQUMvQixNQUFNLENBQUMsR0FBRyxDQUFDO2FBQ1gsTUFBTSxDQUFDLFFBQVEsQ0FBQzthQUNoQixNQUFNLENBQUMsS0FBSyxDQUFDO2FBQ2IsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNuQixNQUFNLEtBQUssR0FBRyxJQUFJLFFBQVEsSUFBSSxXQUFXLEVBQUUsQ0FBQztRQUU1QyxPQUFPO1lBQ0wsVUFBVSxFQUFFLENBQUMsS0FBSyxFQUFFLEdBQUcsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztZQUN4QyxjQUFjLEVBQUU7Z0JBQ2QsYUFBYSxFQUFFLGtCQUFrQixDQUMvQixtQkFBbUIsRUFDbkIsdUJBQXVCLENBQ3hCO2dCQUNELElBQUksRUFBRSxHQUFHLFFBQVEsT0FBTyxLQUFLLEVBQUU7YUFDaEM7U0FDRixDQUFDO0lBQ0osQ0FBQztDQUNGOztBQUVELFNBQVMsV0FBVyxDQUFDLEdBQVcsRUFBRSxRQUFrQjtJQUNsRCxNQUFNLEVBQUUsWUFBWSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsR0FBRyxjQUFjLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQzFFLE1BQU0sUUFBUSxHQUFhLENBQUMsV0FBVyxDQUFDLENBQUM7SUFFekMsS0FBSyxNQUFNLElBQUksSUFBSSxJQUFJLEVBQUU7UUFDdkIsUUFBUSxDQUFDLElBQUksQ0FBQyx5QkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0tBQ3pDO0lBRUQsT0FBTyxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztBQUN0RSxDQUFDO0FBRUQ7Ozs7Ozs7Ozs7OztHQVlHO0FBQ0gsU0FBUyxrQkFBa0IsQ0FBQyxPQUFlLEVBQUUsS0FBYTtJQUN4RCxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEVBQUU7UUFDN0IsMkJBQTJCO1FBQzNCLE9BQU8sSUFBSSxLQUFLLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQztLQUNsRDtJQUNELCtDQUErQztJQUMvQyxNQUFNLGFBQWEsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDckUsT0FBTyxJQUFJLGtCQUFrQixDQUFDLGFBQWEsRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDO0FBQ3hELENBQUM7QUFFRCxTQUFTLGNBQWMsQ0FBQyxHQUFXLEVBQUUsUUFBa0I7O0lBQ3JELE1BQU0sUUFBUSxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDaEMsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pDLE1BQU0sTUFBTSxHQUNWLFlBQVksS0FBSyxRQUFRLENBQUMsSUFBSTtRQUM1QixDQUFDLENBQUMsUUFBUTtRQUNWLENBQUMsYUFBQyxRQUFRLENBQUMsaUJBQWlCLDBDQUFHLFlBQVksb0NBQ3pDLFVBQUcsQ0FDRCw4Q0FBOEMsWUFBWSx5QkFBeUIsQ0FDcEYsQ0FBQztJQUNSLE1BQU0sT0FBTyxxQkFDWCxNQUFNLENBQUMsT0FBTywwQ0FBRSxNQUFNLDBDQUFFLE1BQU0sbUNBQzlCLFVBQUcsQ0FBQyxnREFBZ0QsWUFBWSxHQUFHLENBQUMsQ0FBQztJQUV2RSxNQUFNLEdBQUcsR0FBRyxJQUFJLEtBQUssRUFBVSxDQUFDO0lBQ2hDLE1BQU0sSUFBSSxHQUFHLElBQUksS0FBSyxFQUFVLENBQUM7SUFFakMsS0FBSyxJQUFJLEdBQUcsR0FBRyxRQUFRLENBQUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUU7UUFDOUMsTUFBTSxTQUFTLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ25ELElBQUksU0FBUyxLQUFLLFlBQVksRUFBRTtZQUM5QixHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3JCLE1BQU07U0FDUDtRQUVELE1BQU0sZUFBZSxTQUFHLE1BQU0sQ0FBQyxVQUFVLDBDQUFHLFNBQVMsQ0FBQyxDQUFDO1FBQ3ZELElBQUksZUFBZSxJQUFJLElBQUksRUFBRTtZQUMzQiw0RUFBNEU7WUFDNUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDaEMsU0FBUztTQUNWO1FBRUQsTUFBTSxVQUFVLGVBQ2QsZUFBZSxDQUFDLE9BQU8sMENBQUUsTUFBTSwwQ0FBRSxNQUFNLENBQUM7UUFDMUMsSUFBSSxVQUFVLElBQUksSUFBSSxFQUFFO1lBQ3RCLHFHQUFxRztZQUNyRyxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxHQUFHLE9BQU8sR0FBRyxDQUFDLEVBQUU7Z0JBQ3pDLFVBQUcsQ0FDRCxjQUFjLFNBQVMsc0NBQXNDLFVBQVUsK0JBQStCLE9BQU8sSUFBSSxDQUNsSCxDQUFDO2FBQ0g7WUFDRCxHQUFHLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ3hCLE1BQU07U0FDUDtRQUVELG9FQUFvRTtRQUNwRSxHQUFHLENBQUMsT0FBTyxDQUFDLHVCQUFXLENBQUMseUJBQWtCLENBQUMsUUFBUSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNqRTtJQUVELE9BQU8sRUFBRSxZQUFZLEVBQUUsV0FBVyxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUM7QUFDNUQsQ0FBQztBQUVELFNBQVMsbUJBQW1CLENBQUMsSUFBVSxFQUFFLElBQWM7O0lBQ3JELElBQUksSUFBSSxDQUFDLFNBQVMsSUFBSSxJQUFJLEVBQUU7UUFDMUIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDO0tBQ2xCO0lBQ0QsTUFBTSxZQUFZLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUN0RCxJQUFJLE9BQUEsSUFBSSxDQUFDLEtBQUssMENBQUcsWUFBWSxNQUFLLElBQUksRUFBRTtRQUN0QyxPQUFPLG1CQUFtQixPQUFDLElBQUksQ0FBQyxLQUFLLDBDQUFHLFlBQVksR0FBRyxJQUFJLENBQUMsQ0FBQztLQUM5RDtJQUNELE9BQU8sWUFBWSxDQUFDO0FBQ3RCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBc3NlbWJseSxcbiAgT3B0aW9uYWxWYWx1ZSxcbiAgVHlwZVJlZmVyZW5jZSxcbiAgaXNDb2xsZWN0aW9uVHlwZVJlZmVyZW5jZSxcbiAgQ29sbGVjdGlvbktpbmQsXG4gIGlzTmFtZWRUeXBlUmVmZXJlbmNlLFxuICBpc1ByaW1pdGl2ZVR5cGVSZWZlcmVuY2UsXG4gIFByaW1pdGl2ZVR5cGUsXG4gIFByaW1pdGl2ZVR5cGVSZWZlcmVuY2UsXG4gIGlzVW5pb25UeXBlUmVmZXJlbmNlLFxuICBUeXBlLFxufSBmcm9tICdAanNpaS9zcGVjJztcbmltcG9ydCB7IHRvU25ha2VDYXNlIH0gZnJvbSAnY29kZW1ha2VyJztcbmltcG9ydCB7IGNyZWF0ZUhhc2ggfSBmcm9tICdjcnlwdG8nO1xuXG5pbXBvcnQgeyBkaWUsIHRvUHl0aG9uSWRlbnRpZmllciB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHlwZU5hbWUge1xuICBweXRob25UeXBlKGNvbnRleHQ6IE5hbWluZ0NvbnRleHQpOiBzdHJpbmc7XG4gIHJlcXVpcmVkSW1wb3J0cyhjb250ZXh0OiBOYW1pbmdDb250ZXh0KTogUHl0aG9uSW1wb3J0cztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQeXRob25JbXBvcnRzIHtcbiAgLyoqXG4gICAqIEZvciBhIGdpdmVuIHNvdXJjZSBtb2R1bGUsIHdoYXQgZWxlbWVudHMgdG8gaW1wb3J0LiBUaGUgZW1wdHkgc3RyaW5nIHZhbHVlXG4gICAqIGluZGljYXRlcyBhIG5lZWQgdG8gaW1wb3J0IHRoZSBtb2R1bGUgZnVsbHkgKFwiaW1wb3J0IDxuYW1lPlwiKSBpbnN0ZWFkIG9mXG4gICAqIGRvaW5nIGEgcGllY2VtZWFsIGltcG9ydCAoXCJmcm9tIDxuYW1lPiBpbXBvcnQgPGl0ZW0+XCIpLlxuICAgKi9cbiAgcmVhZG9ubHkgW3NvdXJjZVBhY2thZ2U6IHN0cmluZ106IFJlYWRvbmx5U2V0PHN0cmluZz47XG59XG5cbi8qKlxuICogVGhlIGNvbnRleHQgaW4gd2hpY2ggYSBQeXRob25UeXBlIGlzIGJlaW5nIGNvbnNpZGVyZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmFtaW5nQ29udGV4dCB7XG4gIC8qKiBUaGUgYXNzZW1ibHkgaW4gd2hpY2ggdGhlIFB5dGhvblR5cGUgaXMgZXhwcmVzc2VkLiAqL1xuICByZWFkb25seSBhc3NlbWJseTogQXNzZW1ibHk7XG5cbiAgLyoqIFRoZSBzdWJtb2R1bGUgb2YgdGhlIGFzc2VtYmx5IGluIHdoaWNoIHRoZSBQeXRob25UeXBlIGlzIGV4cHJlc3NlZCAoY291bGQgYmUgdGhlIG1vZHVsZSByb290KSAqL1xuICByZWFkb25seSBzdWJtb2R1bGU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGRlY2xhcmF0aW9uIGlzIG1hZGUgaW4gdGhlIGNvbnRleHQgb2YgYSB0eXBlIGFubm90YXRpb24gKHNvIGl0IGNhbiBiZSBxdW90ZWQpXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IHR5cGVBbm5vdGF0aW9uPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQSBhbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIHN0YWNrIG9mIGRlY2xhcmF0aW9ucyBjdXJyZW50bHkgYmVpbmdcbiAgICogaW5pdGlhbGl6ZWQuIEFsbCBvZiB0aGVzZSBuYW1lcyBjYW4gb25seSBiZSByZWZlcnJlZCB0byB1c2luZyBhIGZvcndhcmRcbiAgICogcmVmZXJlbmNlIChzdHJpbmdpZmllZCB0eXBlIG5hbWUpIGluIHRoZSBjb250ZXh0IG9mIHR5cGUgc2lnbmF0dXJlcyAoYnV0XG4gICAqIHRoZXkgY2FuIGJlIHVzZWQgc2FmZWx5IGZyb20gaW1wbGVtZW50YXRpb25zIHNvIGxvbmcgYXMgdGhvc2UgYXJlIG5vdCAqcnVuKlxuICAgKiBhcyBwYXJ0IG9mIHRoZSBkZWNsYXJhdGlvbikuXG4gICAqXG4gICAqIEBkZWZhdWx0IFtdXG4gICAqL1xuICByZWFkb25seSBzdXJyb3VuZGluZ1R5cGVGcW5zPzogcmVhZG9ubHkgc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIERpc2FibGVzIGdlbmVyYXRpbmcgdHlwaW5nLk9wdGlvbmFsIHdyYXBwZXJzXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVhZG9ubHkgaWdub3JlT3B0aW9uYWw/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUaGUgc2V0IG9mIGpzaWkgdHlwZSBGUU5zIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZW1pdHRlZCBzbyBmYXIuIFRoaXMgaXNcbiAgICogdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIHR5cGUgcmVmZXJlbmNlIGlzIGEgZm9yd2FyZCBkZWNsYXJhdGlvblxuICAgKiBvciBub3Qgd2hlbiBlbWl0dGluZyB0eXBlIHNpZ25hdHVyZXMuXG4gICAqL1xuICByZWFkb25seSBlbWl0dGVkVHlwZXM6IFNldDxzdHJpbmc+O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSB0eXBlIGlzIGVtaXR0ZWQgZm9yIGEgcGFyYW1ldGVyIG9yIG5vdC4gVGhpcyBtYXkgY2hhbmdlIHRoZVxuICAgKiBleGFjdCB0eXBlIHNpZ25hdHVyZSBiZWluZyBlbWl0dGVkIChlLmc6IEFycmF5cyBhcmUgdHlwaW5nLlNlcXVlbmNlW1RdIGZvclxuICAgKiBwYXJhbWV0ZXJzLCBhbmQgdHlwaW5nLkxpc3RbVF0gb3RoZXJ3aXNlKS5cbiAgICovXG4gIHJlYWRvbmx5IHBhcmFtZXRlclR5cGU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9UeXBlTmFtZShyZWY/OiBPcHRpb25hbFZhbHVlIHwgVHlwZVJlZmVyZW5jZSk6IFR5cGVOYW1lIHtcbiAgaWYgKHJlZiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFByaW1pdGl2ZS5OT05FO1xuICB9XG5cbiAgY29uc3QgdHlwZSA9IGlzT3B0aW9uYWxWYWx1ZShyZWYpID8gcmVmLnR5cGUgOiByZWY7XG4gIGNvbnN0IG9wdGlvbmFsID0gaXNPcHRpb25hbFZhbHVlKHJlZikgJiYgcmVmLm9wdGlvbmFsO1xuXG4gIGxldCByZXN1bHQ6IFR5cGVOYW1lID0gUHJpbWl0aXZlLkFOWTtcblxuICBpZiAoaXNQcmltaXRpdmVUeXBlUmVmZXJlbmNlKHR5cGUpKSB7XG4gICAgcmVzdWx0ID0gUHJpbWl0aXZlLm9mKHR5cGUpO1xuICB9IGVsc2UgaWYgKGlzQ29sbGVjdGlvblR5cGVSZWZlcmVuY2UodHlwZSkpIHtcbiAgICBjb25zdCBlbHQgPSB0b1R5cGVOYW1lKHR5cGUuY29sbGVjdGlvbi5lbGVtZW50dHlwZSk7XG4gICAgaWYgKHR5cGUuY29sbGVjdGlvbi5raW5kID09PSBDb2xsZWN0aW9uS2luZC5BcnJheSkge1xuICAgICAgcmVzdWx0ID0gbmV3IExpc3QoZWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gbmV3IERpY3QoZWx0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNVbmlvblR5cGVSZWZlcmVuY2UodHlwZSkpIHtcbiAgICByZXN1bHQgPSBuZXcgVW5pb24odHlwZS51bmlvbi50eXBlcy5tYXAodG9UeXBlTmFtZSkpO1xuICB9IGVsc2UgaWYgKGlzTmFtZWRUeXBlUmVmZXJlbmNlKHR5cGUpKSB7XG4gICAgcmVzdWx0ID0gbmV3IFVzZXJUeXBlKHR5cGUuZnFuKTtcbiAgfVxuXG4gIHJldHVybiBvcHRpb25hbCA/IG5ldyBPcHRpb25hbChyZXN1bHQpIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIE9idGFpbnMgdGhlIFB5dGhvbiBwYWNrYWdlIG5hbWUgZm9yIGEgZ2l2ZW4gc3VibW9kdWxlIEZRTi5cbiAqXG4gKiBAcGFyYW0gZnFuICAgICAgdGhlIHN1Ym1vZHVsZSBGUU4gZm9yIHdoaWNoIGEgcGFja2FnZSBuYW1lIGlzIG5lZWRlZC5cbiAqIEBwYXJhbSByb290QXNzbSB0aGUgYXNzZW1ibHkgdGhpcyBGUU4gYmVsb25ncyB0by5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUGFja2FnZU5hbWUoZnFuOiBzdHJpbmcsIHJvb3RBc3NtOiBBc3NlbWJseSk6IHN0cmluZyB7XG4gIHJldHVybiBnZXRQYWNrYWdlTmFtZShmcW4sIHJvb3RBc3NtKS5wYWNrYWdlTmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlUHl0aG9uSW1wb3J0cyhcbiAgLi4ucHl0aG9uSW1wb3J0czogcmVhZG9ubHkgUHl0aG9uSW1wb3J0c1tdXG4pOiBQeXRob25JbXBvcnRzIHtcbiAgY29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBTZXQ8c3RyaW5nPj4gPSB7fTtcbiAgZm9yIChjb25zdCBiYWcgb2YgcHl0aG9uSW1wb3J0cykge1xuICAgIGZvciAoY29uc3QgW3BhY2thZ2VOYW1lLCBpdGVtc10gb2YgT2JqZWN0LmVudHJpZXMoYmFnKSkge1xuICAgICAgaWYgKCEocGFja2FnZU5hbWUgaW4gcmVzdWx0KSkge1xuICAgICAgICByZXN1bHRbcGFja2FnZU5hbWVdID0gbmV3IFNldCgpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgIHJlc3VsdFtwYWNrYWdlTmFtZV0uYWRkKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc09wdGlvbmFsVmFsdWUoXG4gIHR5cGU6IE9wdGlvbmFsVmFsdWUgfCBUeXBlUmVmZXJlbmNlLFxuKTogdHlwZSBpcyBPcHRpb25hbFZhbHVlIHtcbiAgcmV0dXJuICh0eXBlIGFzIHVua25vd24gYXMgT3B0aW9uYWxWYWx1ZSkudHlwZSAhPSBudWxsO1xufVxuXG5jbGFzcyBEaWN0IGltcGxlbWVudHMgVHlwZU5hbWUge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1lbWJlci1hY2Nlc3NpYmlsaXR5XG4gIHJlYWRvbmx5ICNlbGVtZW50OiBUeXBlTmFtZTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoZWxlbWVudDogVHlwZU5hbWUpIHtcbiAgICB0aGlzLiNlbGVtZW50ID0gZWxlbWVudDtcbiAgfVxuXG4gIHB1YmxpYyBweXRob25UeXBlKGNvbnRleHQ6IE5hbWluZ0NvbnRleHQpIHtcbiAgICByZXR1cm4gYHR5cGluZy5NYXBwaW5nW2J1aWx0aW5zLnN0ciwgJHt0aGlzLiNlbGVtZW50LnB5dGhvblR5cGUoY29udGV4dCl9XWA7XG4gIH1cblxuICBwdWJsaWMgcmVxdWlyZWRJbXBvcnRzKGNvbnRleHQ6IE5hbWluZ0NvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy4jZWxlbWVudC5yZXF1aXJlZEltcG9ydHMoY29udGV4dCk7XG4gIH1cbn1cblxuY2xhc3MgTGlzdCBpbXBsZW1lbnRzIFR5cGVOYW1lIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tZW1iZXItYWNjZXNzaWJpbGl0eVxuICByZWFkb25seSAjZWxlbWVudDogVHlwZU5hbWU7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IFR5cGVOYW1lKSB7XG4gICAgdGhpcy4jZWxlbWVudCA9IGVsZW1lbnQ7XG4gIH1cblxuICBwdWJsaWMgcHl0aG9uVHlwZShjb250ZXh0OiBOYW1pbmdDb250ZXh0KSB7XG4gICAgY29uc3QgdHlwZSA9IGNvbnRleHQucGFyYW1ldGVyVHlwZSA/ICdTZXF1ZW5jZScgOiAnTGlzdCc7XG4gICAgcmV0dXJuIGB0eXBpbmcuJHt0eXBlfVske3RoaXMuI2VsZW1lbnQucHl0aG9uVHlwZShjb250ZXh0KX1dYDtcbiAgfVxuXG4gIHB1YmxpYyByZXF1aXJlZEltcG9ydHMoY29udGV4dDogTmFtaW5nQ29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLiNlbGVtZW50LnJlcXVpcmVkSW1wb3J0cyhjb250ZXh0KTtcbiAgfVxufVxuXG5jbGFzcyBPcHRpb25hbCBpbXBsZW1lbnRzIFR5cGVOYW1lIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tZW1iZXItYWNjZXNzaWJpbGl0eVxuICByZWFkb25seSAjd3JhcHBlZDogVHlwZU5hbWU7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHdyYXBwZWQ6IFR5cGVOYW1lKSB7XG4gICAgdGhpcy4jd3JhcHBlZCA9IHdyYXBwZWQ7XG4gIH1cblxuICBwdWJsaWMgcHl0aG9uVHlwZShjb250ZXh0OiBOYW1pbmdDb250ZXh0KSB7XG4gICAgY29uc3Qgb3B0aW9uYWxUeXBlID0gdGhpcy4jd3JhcHBlZC5weXRob25UeXBlKHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICBpZ25vcmVPcHRpb25hbDogdHJ1ZSxcbiAgICB9KTtcbiAgICBpZiAoY29udGV4dC5pZ25vcmVPcHRpb25hbCB8fCB0aGlzLiN3cmFwcGVkID09PSBQcmltaXRpdmUuQU5ZKSB7XG4gICAgICByZXR1cm4gb3B0aW9uYWxUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gYHR5cGluZy5PcHRpb25hbFske29wdGlvbmFsVHlwZX1dYDtcbiAgfVxuXG4gIHB1YmxpYyByZXF1aXJlZEltcG9ydHMoY29udGV4dDogTmFtaW5nQ29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLiN3cmFwcGVkLnJlcXVpcmVkSW1wb3J0cyh7IC4uLmNvbnRleHQsIGlnbm9yZU9wdGlvbmFsOiB0cnVlIH0pO1xuICB9XG59XG5cbmNsYXNzIFByaW1pdGl2ZSBpbXBsZW1lbnRzIFR5cGVOYW1lIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQk9PTCA9IG5ldyBQcmltaXRpdmUoJ2J1aWx0aW5zLmJvb2wnKTtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgREFURSA9IG5ldyBQcmltaXRpdmUoJ2RhdGV0aW1lLmRhdGV0aW1lJyk7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEpTSUlfTlVNQkVSID0gbmV3IFByaW1pdGl2ZSgnanNpaS5OdW1iZXInKTsgLy8gXCJqc2lpXCIgaXMgYWx3YXlzIGFscmVhZHkgaW1wb3J0ZWQhXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFNUUiA9IG5ldyBQcmltaXRpdmUoJ2J1aWx0aW5zLnN0cicpO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBKU09OID0gbmV3IFByaW1pdGl2ZShcbiAgICAndHlwaW5nLk1hcHBpbmdbdHlwaW5nLkFueSwgdHlwaW5nLkFueV0nLFxuICApO1xuXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQU5ZID0gbmV3IFByaW1pdGl2ZSgndHlwaW5nLkFueScpO1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE5PTkUgPSBuZXcgUHJpbWl0aXZlKCdOb25lJyk7XG5cbiAgcHVibGljIHN0YXRpYyBvZih0eXBlOiBQcmltaXRpdmVUeXBlUmVmZXJlbmNlKTogVHlwZU5hbWUge1xuICAgIHN3aXRjaCAodHlwZS5wcmltaXRpdmUpIHtcbiAgICAgIGNhc2UgUHJpbWl0aXZlVHlwZS5Cb29sZWFuOlxuICAgICAgICByZXR1cm4gUHJpbWl0aXZlLkJPT0w7XG4gICAgICBjYXNlIFByaW1pdGl2ZVR5cGUuRGF0ZTpcbiAgICAgICAgcmV0dXJuIFByaW1pdGl2ZS5EQVRFO1xuICAgICAgY2FzZSBQcmltaXRpdmVUeXBlLk51bWJlcjpcbiAgICAgICAgcmV0dXJuIFByaW1pdGl2ZS5KU0lJX05VTUJFUjtcbiAgICAgIGNhc2UgUHJpbWl0aXZlVHlwZS5TdHJpbmc6XG4gICAgICAgIHJldHVybiBQcmltaXRpdmUuU1RSO1xuICAgICAgY2FzZSBQcmltaXRpdmVUeXBlLkpzb246XG4gICAgICAgIHJldHVybiBQcmltaXRpdmUuSlNPTjtcbiAgICAgIGNhc2UgUHJpbWl0aXZlVHlwZS5Bbnk6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gUHJpbWl0aXZlLkFOWTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1lbWJlci1hY2Nlc3NpYmlsaXR5XG4gIHJlYWRvbmx5ICNweXRob25UeXBlOiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihweXRob25UeXBlOiBzdHJpbmcpIHtcbiAgICB0aGlzLiNweXRob25UeXBlID0gcHl0aG9uVHlwZTtcbiAgfVxuXG4gIHB1YmxpYyBweXRob25UeXBlKCkge1xuICAgIHJldHVybiB0aGlzLiNweXRob25UeXBlO1xuICB9XG5cbiAgcHVibGljIHJlcXVpcmVkSW1wb3J0cygpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cblxuY2xhc3MgVW5pb24gaW1wbGVtZW50cyBUeXBlTmFtZSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbWVtYmVyLWFjY2Vzc2liaWxpdHlcbiAgcmVhZG9ubHkgI29wdGlvbnM6IHJlYWRvbmx5IFR5cGVOYW1lW107XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKG9wdGlvbnM6IHJlYWRvbmx5IFR5cGVOYW1lW10pIHtcbiAgICB0aGlzLiNvcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIHB1YmxpYyBweXRob25UeXBlKGNvbnRleHQ6IE5hbWluZ0NvbnRleHQpIHtcbiAgICByZXR1cm4gYHR5cGluZy5Vbmlvblske3RoaXMuI29wdGlvbnNcbiAgICAgIC5tYXAoKG8pID0+IG8ucHl0aG9uVHlwZShjb250ZXh0KSlcbiAgICAgIC5qb2luKCcsICcpfV1gO1xuICB9XG5cbiAgcHVibGljIHJlcXVpcmVkSW1wb3J0cyhjb250ZXh0OiBOYW1pbmdDb250ZXh0KSB7XG4gICAgcmV0dXJuIG1lcmdlUHl0aG9uSW1wb3J0cyhcbiAgICAgIC4uLnRoaXMuI29wdGlvbnMubWFwKChvKSA9PiBvLnJlcXVpcmVkSW1wb3J0cyhjb250ZXh0KSksXG4gICAgKTtcbiAgfVxufVxuXG5jbGFzcyBVc2VyVHlwZSBpbXBsZW1lbnRzIFR5cGVOYW1lIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tZW1iZXItYWNjZXNzaWJpbGl0eVxuICByZWFkb25seSAjZnFuOiBzdHJpbmc7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKGZxbjogc3RyaW5nKSB7XG4gICAgdGhpcy4jZnFuID0gZnFuO1xuICB9XG5cbiAgcHVibGljIHB5dGhvblR5cGUoY29udGV4dDogTmFtaW5nQ29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmUoY29udGV4dCkucHl0aG9uVHlwZTtcbiAgfVxuXG4gIHB1YmxpYyByZXF1aXJlZEltcG9ydHMoY29udGV4dDogTmFtaW5nQ29udGV4dCkge1xuICAgIGNvbnN0IHJlcXVpcmVkSW1wb3J0ID0gdGhpcy5yZXNvbHZlKGNvbnRleHQpLnJlcXVpcmVkSW1wb3J0O1xuICAgIGlmIChyZXF1aXJlZEltcG9ydCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiB7IFtyZXF1aXJlZEltcG9ydC5zb3VyY2VQYWNrYWdlXTogbmV3IFNldChbcmVxdWlyZWRJbXBvcnQuaXRlbV0pIH07XG4gIH1cblxuICBwcml2YXRlIHJlc29sdmUoe1xuICAgIGFzc2VtYmx5LFxuICAgIGVtaXR0ZWRUeXBlcyxcbiAgICBzdWJtb2R1bGUsXG4gICAgc3Vycm91bmRpbmdUeXBlRnFucyxcbiAgICB0eXBlQW5ub3RhdGlvbiA9IHRydWUsXG4gIH06IE5hbWluZ0NvbnRleHQpIHtcbiAgICBjb25zdCB7IGFzc2VtYmx5TmFtZSwgcGFja2FnZU5hbWUsIHB5dGhvbkZxbiB9ID0gdG9QeXRob25GcW4oXG4gICAgICB0aGlzLiNmcW4sXG4gICAgICBhc3NlbWJseSxcbiAgICApO1xuICAgIGlmIChhc3NlbWJseU5hbWUgIT09IGFzc2VtYmx5Lm5hbWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHB5dGhvblR5cGU6IHB5dGhvbkZxbixcbiAgICAgICAgcmVxdWlyZWRJbXBvcnQ6IHtcbiAgICAgICAgICBzb3VyY2VQYWNrYWdlOiBwYWNrYWdlTmFtZSxcbiAgICAgICAgICBpdGVtOiAnJyxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3Qgc3VibW9kdWxlUHl0aG9uTmFtZSA9IHRvUHl0aG9uRnFuKHN1Ym1vZHVsZSwgYXNzZW1ibHkpLnB5dGhvbkZxbjtcbiAgICBjb25zdCB0eXBlU3VibW9kdWxlUHl0aG9uTmFtZSA9IHRvUHl0aG9uRnFuKFxuICAgICAgZmluZFBhcmVudFN1Ym1vZHVsZShhc3NlbWJseS50eXBlcyFbdGhpcy4jZnFuXSwgYXNzZW1ibHkpLFxuICAgICAgYXNzZW1ibHksXG4gICAgKS5weXRob25GcW47XG5cbiAgICBpZiAodHlwZVN1Ym1vZHVsZVB5dGhvbk5hbWUgPT09IHN1Ym1vZHVsZVB5dGhvbk5hbWUpIHtcbiAgICAgIC8vIElkZW50aWZpeSBkZWNsYXJhdGlvbnMgdGhhdCBhcmUgbm90IHlldCBpbml0aWFsaXplZCBhbmQgaGVuY2UgY2Fubm90IGJlXG4gICAgICAvLyB1c2VkIGFzIHBhcnQgb2YgYSB0eXBlIHF1YWxpZmljYXRpb24uIFNpbmNlIHRoaXMgaXMgbm90IGEgZm9yd2FyZFxuICAgICAgLy8gcmVmZXJlbmNlLCB0aGUgdHlwZSB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBpdHMgdW4tcXVhbGlmaWVkIG5hbWUgbXVzdFxuICAgICAgLy8gYmUgdXNlZCBpbnN0ZWFkIG9mIGl0J3MgbG9jYWxseSBxdWFsaWZpZWQgbmFtZS5cbiAgICAgIGNvbnN0IG5lc3RpbmdQYXJlbnQgPSBzdXJyb3VuZGluZ1R5cGVGcW5zXG4gICAgICAgID8ubWFwKChmcW4pID0+IHRvUHl0aG9uRnFuKGZxbiwgYXNzZW1ibHkpLnB5dGhvbkZxbilcbiAgICAgICAgPy5yZXZlcnNlKClcbiAgICAgICAgPy5maW5kKChwYXJlbnQpID0+IHB5dGhvbkZxbi5zdGFydHNXaXRoKGAke3BhcmVudH0uYCkpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVBbm5vdGF0aW9uICYmXG4gICAgICAgICghZW1pdHRlZFR5cGVzLmhhcyh0aGlzLiNmcW4pIHx8IG5lc3RpbmdQYXJlbnQgIT0gbnVsbClcbiAgICAgICkge1xuICAgICAgICAvLyBQb3NzaWJseSBhIGZvcndhcmQgcmVmZXJlbmNlLCBvdXRwdXR0aW5nIHRoZSBzdHJpbmdpZmllcmQgcHl0aG9uIEZRTlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHB5dGhvblR5cGU6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgcHl0aG9uRnFuLnN1YnN0cmluZyhzdWJtb2R1bGVQeXRob25OYW1lLmxlbmd0aCArIDEpLFxuICAgICAgICAgICksXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICghdHlwZUFubm90YXRpb24gJiYgbmVzdGluZ1BhcmVudCkge1xuICAgICAgICAvLyBUaGlzIGlzIG5vdCBmb3IgYSB0eXBlIGFubm90YXRpb24sIHNvIHdlIHNob3VsZCBiZSBhdCBhIHBvaW50IGluIHRpbWVcbiAgICAgICAgLy8gd2hlcmUgdGhlIHN1cnJvdW5kaW5nIHN5bWJvbCBoYXMgYmVlbiBkZWZpbmVkIGVudGlyZWx5LCBzbyB3ZSBjYW5cbiAgICAgICAgLy8gcmVmZXIgdG8gaXQgXCJub3JtYWxseVwiIG5vdy5cbiAgICAgICAgcmV0dXJuIHsgcHl0aG9uVHlwZTogcHl0aG9uRnFuLnN1YnN0cmluZyhuZXN0aW5nUGFyZW50Lmxlbmd0aCArIDEpIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFdlJ2xsIGp1c3QgbWFrZSBhIG1vZHVsZS1xdWFsaWZpZWQgcmVmZXJlbmNlIGF0IHRoaXMgcG9pbnQuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBweXRob25UeXBlOiBweXRob25GcW4uc3Vic3RyaW5nKHN1Ym1vZHVsZVB5dGhvbk5hbWUubGVuZ3RoICsgMSksXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IFt0b0ltcG9ydCwgLi4ubmVzdGVkXSA9IHB5dGhvbkZxblxuICAgICAgLnN1YnN0cmluZyh0eXBlU3VibW9kdWxlUHl0aG9uTmFtZS5sZW5ndGggKyAxKVxuICAgICAgLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgYWxpYXNTdWZmaXggPSBjcmVhdGVIYXNoKCdzaGEyNTYnKVxuICAgICAgLnVwZGF0ZSh0eXBlU3VibW9kdWxlUHl0aG9uTmFtZSlcbiAgICAgIC51cGRhdGUoJy4nKVxuICAgICAgLnVwZGF0ZSh0b0ltcG9ydClcbiAgICAgIC5kaWdlc3QoJ2hleCcpXG4gICAgICAuc3Vic3RyaW5nKDAsIDgpO1xuICAgIGNvbnN0IGFsaWFzID0gYF8ke3RvSW1wb3J0fV8ke2FsaWFzU3VmZml4fWA7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcHl0aG9uVHlwZTogW2FsaWFzLCAuLi5uZXN0ZWRdLmpvaW4oJy4nKSxcbiAgICAgIHJlcXVpcmVkSW1wb3J0OiB7XG4gICAgICAgIHNvdXJjZVBhY2thZ2U6IHJlbGF0aXZlSW1wb3J0UGF0aChcbiAgICAgICAgICBzdWJtb2R1bGVQeXRob25OYW1lLFxuICAgICAgICAgIHR5cGVTdWJtb2R1bGVQeXRob25OYW1lLFxuICAgICAgICApLFxuICAgICAgICBpdGVtOiBgJHt0b0ltcG9ydH0gYXMgJHthbGlhc31gLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvUHl0aG9uRnFuKGZxbjogc3RyaW5nLCByb290QXNzbTogQXNzZW1ibHkpIHtcbiAgY29uc3QgeyBhc3NlbWJseU5hbWUsIHBhY2thZ2VOYW1lLCB0YWlsIH0gPSBnZXRQYWNrYWdlTmFtZShmcW4sIHJvb3RBc3NtKTtcbiAgY29uc3QgZnFuUGFydHM6IHN0cmluZ1tdID0gW3BhY2thZ2VOYW1lXTtcblxuICBmb3IgKGNvbnN0IHBhcnQgb2YgdGFpbCkge1xuICAgIGZxblBhcnRzLnB1c2godG9QeXRob25JZGVudGlmaWVyKHBhcnQpKTtcbiAgfVxuXG4gIHJldHVybiB7IGFzc2VtYmx5TmFtZSwgcGFja2FnZU5hbWUsIHB5dGhvbkZxbjogZnFuUGFydHMuam9pbignLicpIH07XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHB5dGhvbiByZWxhdGl2ZSBpbXBvcnQgcGF0aCBmcm9tIGBmcm9tTW9kdWxlYCB0byBgdG9Nb2R1bGVgLlxuICpcbiAqIEBwYXJhbSBmcm9tUGtnIHRoZSBwYWNrYWdlIHdoZXJlIHRoZSByZWxhdGl2ZSBpbXBvcnQgc3RhdGVtZW50IGlzIGxvY2F0ZWQuXG4gKiBAcGFyYW0gdG9Qa2cgICB0aGUgcGFja2FnZSB0aGF0IG5lZWRzIHRvIGJlIHJlbGF0aXZlbHkgaW1wb3J0ZWQuXG4gKlxuICogQHJldHVybnMgYSByZWxhdGl2ZSBpbXBvcnQgcGF0aC5cbiAqXG4gKiBAZXhhbXBsZVxuICogIHJlbGF0aXZlSW1wb3J0UGF0aCgnQS5CLkMuRCcsICdBLkIuRScpID09PSAnLi4uRSc7XG4gKiAgcmVsYXRpdmVJbXBvcnRQYXRoKCdBLkIuQycsICdBLkInKSAgICAgPT09ICcuLic7XG4gKiAgcmVsYXRpdmVJbXBvcnRQYXRoKCdBLkInLCAnQS5CLkMnKSAgICAgPT09ICcuQyc7XG4gKi9cbmZ1bmN0aW9uIHJlbGF0aXZlSW1wb3J0UGF0aChmcm9tUGtnOiBzdHJpbmcsIHRvUGtnOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAodG9Qa2cuc3RhcnRzV2l0aChmcm9tUGtnKSkge1xuICAgIC8vIGZyb20gQS5CIHRvIEEuQi5DID09PSAuQ1xuICAgIHJldHVybiBgLiR7dG9Qa2cuc3Vic3RyaW5nKGZyb21Qa2cubGVuZ3RoICsgMSl9YDtcbiAgfVxuICAvLyBmcm9tIEEuQi5FIHRvIEEuQi5DID09PSAuPGZyb20gQS5CIHRvIEEuQi5DPlxuICBjb25zdCBmcm9tUGtnUGFyZW50ID0gZnJvbVBrZy5zdWJzdHJpbmcoMCwgZnJvbVBrZy5sYXN0SW5kZXhPZignLicpKTtcbiAgcmV0dXJuIGAuJHtyZWxhdGl2ZUltcG9ydFBhdGgoZnJvbVBrZ1BhcmVudCwgdG9Qa2cpfWA7XG59XG5cbmZ1bmN0aW9uIGdldFBhY2thZ2VOYW1lKGZxbjogc3RyaW5nLCByb290QXNzbTogQXNzZW1ibHkpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBmcW4uc3BsaXQoJy4nKTtcbiAgY29uc3QgYXNzZW1ibHlOYW1lID0gc2VnbWVudHNbMF07XG4gIGNvbnN0IGNvbmZpZyA9XG4gICAgYXNzZW1ibHlOYW1lID09PSByb290QXNzbS5uYW1lXG4gICAgICA/IHJvb3RBc3NtXG4gICAgICA6IHJvb3RBc3NtLmRlcGVuZGVuY3lDbG9zdXJlPy5bYXNzZW1ibHlOYW1lXSA/P1xuICAgICAgICBkaWUoXG4gICAgICAgICAgYFVuYWJsZSB0byBmaW5kIGNvbmZpZ3VyYXRpb24gZm9yIGFzc2VtYmx5IFwiJHthc3NlbWJseU5hbWV9XCIgaW4gZGVwZW5kZW5jeSBjbG9zdXJlYCxcbiAgICAgICAgKTtcbiAgY29uc3Qgcm9vdFBrZyA9XG4gICAgY29uZmlnLnRhcmdldHM/LnB5dGhvbj8ubW9kdWxlID8/XG4gICAgZGllKGBObyBQeXRob24gdGFyZ2V0IHdhcyBjb25maWd1cmVkIGluIGFzc2VtYmx5IFwiJHthc3NlbWJseU5hbWV9XCJgKTtcblxuICBjb25zdCBwa2cgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuICBjb25zdCB0YWlsID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICBmb3IgKGxldCBsZW4gPSBzZWdtZW50cy5sZW5ndGg7IGxlbiA+IDA7IGxlbi0tKSB7XG4gICAgY29uc3Qgc3VibW9kdWxlID0gc2VnbWVudHMuc2xpY2UoMCwgbGVuKS5qb2luKCcuJyk7XG4gICAgaWYgKHN1Ym1vZHVsZSA9PT0gYXNzZW1ibHlOYW1lKSB7XG4gICAgICBwa2cudW5zaGlmdChyb290UGtnKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNvbnN0IHN1Ym1vZHVsZUNvbmZpZyA9IGNvbmZpZy5zdWJtb2R1bGVzPy5bc3VibW9kdWxlXTtcbiAgICBpZiAoc3VibW9kdWxlQ29uZmlnID09IG51bGwpIHtcbiAgICAgIC8vIE5vdCBpbiBhIHN1Ym1vZHVsZSAtIHNvIHRoZSBjdXJyZW50IGxlYWQgbmFtZSBpcyBub3QgYSBwYWNrYWdlIG5hbWUgcGFydC5cbiAgICAgIHRhaWwudW5zaGlmdChzZWdtZW50c1tsZW4gLSAxXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBzdWJQYWNrYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQgPVxuICAgICAgc3VibW9kdWxlQ29uZmlnLnRhcmdldHM/LnB5dGhvbj8ubW9kdWxlO1xuICAgIGlmIChzdWJQYWNrYWdlICE9IG51bGwpIHtcbiAgICAgIC8vIEZvdW5kIGEgc3ViLXBhY2thZ2UuIENvbmZpcm0gaXQncyBuZXN0ZWQgcmlnaHQgaW4sIGFuZCBtYWtlIHRoaXMgdGhlIGhlYWQgZW5kIG9mIG91ciBwYWNrYWdlIG5hbWUuXG4gICAgICBpZiAoIXN1YlBhY2thZ2Uuc3RhcnRzV2l0aChgJHtyb290UGtnfS5gKSkge1xuICAgICAgICBkaWUoXG4gICAgICAgICAgYFN1Ym1vZHVsZSBcIiR7c3VibW9kdWxlfVwiIGlzIG1hcHBlZCB0byBQeXRob24gc3ViLXBhY2thZ2UgXCIke3N1YlBhY2thZ2V9XCIgd2hpY2ggaXNuJ3QgbmVzdGVkIHVuZGVyIFwiJHtyb290UGtnfVwiIWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwa2cudW5zaGlmdChzdWJQYWNrYWdlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIEp1c3QgdXNlIHdoYXRldmVyIHRoZSBkZWZhdWx0IG5hbWUgaXMgZm9yIHRoaXMgcGFja2FnZSBuYW1lIHBhcnQuXG4gICAgcGtnLnVuc2hpZnQodG9TbmFrZUNhc2UodG9QeXRob25JZGVudGlmaWVyKHNlZ21lbnRzW2xlbiAtIDFdKSkpO1xuICB9XG5cbiAgcmV0dXJuIHsgYXNzZW1ibHlOYW1lLCBwYWNrYWdlTmFtZTogcGtnLmpvaW4oJy4nKSwgdGFpbCB9O1xufVxuXG5mdW5jdGlvbiBmaW5kUGFyZW50U3VibW9kdWxlKHR5cGU6IFR5cGUsIGFzc206IEFzc2VtYmx5KTogc3RyaW5nIHtcbiAgaWYgKHR5cGUubmFtZXNwYWNlID09IG51bGwpIHtcbiAgICByZXR1cm4gYXNzbS5uYW1lO1xuICB9XG4gIGNvbnN0IG5hbWVzcGFjZUZxbiA9IGAke2Fzc20ubmFtZX0uJHt0eXBlLm5hbWVzcGFjZX1gO1xuICBpZiAoYXNzbS50eXBlcz8uW25hbWVzcGFjZUZxbl0gIT0gbnVsbCkge1xuICAgIHJldHVybiBmaW5kUGFyZW50U3VibW9kdWxlKGFzc20udHlwZXM/LltuYW1lc3BhY2VGcW5dLCBhc3NtKTtcbiAgfVxuICByZXR1cm4gbmFtZXNwYWNlRnFuO1xufVxuIl19