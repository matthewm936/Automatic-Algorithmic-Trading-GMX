"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DotNetGenerator = void 0;
const spec = require("@jsii/spec");
const clone = require("clone");
const fs = require("fs-extra");
const path = require("path");
const generator_1 = require("../../generator");
const dotnetdocgenerator_1 = require("./dotnetdocgenerator");
const dotnetruntimegenerator_1 = require("./dotnetruntimegenerator");
const dotnettyperesolver_1 = require("./dotnettyperesolver");
const filegenerator_1 = require("./filegenerator");
const nameutils_1 = require("./nameutils");
/**
 * CODE GENERATOR V2
 */
class DotNetGenerator extends generator_1.Generator {
    constructor(assembliesCurrentlyBeingCompiled, rosetta) {
        super();
        this.assembliesCurrentlyBeingCompiled = assembliesCurrentlyBeingCompiled;
        this.rosetta = rosetta;
        // Flags that tracks if we have already wrote the first member of the class
        this.firstMemberWritten = false;
        this.nameutils = new nameutils_1.DotNetNameUtils();
        // Override the openBlock to get a correct C# looking code block with the curly brace after the line
        this.code.openBlock = function (text) {
            this.line(text);
            this.open('{');
        };
    }
    async load(packageRoot, assembly) {
        await super.load(packageRoot, assembly);
    }
    /**
     * Runs the generator (in-memory).
     */
    generate(fingerprint) {
        this.typeresolver = new dotnettyperesolver_1.DotNetTypeResolver(this.assembly, (fqn) => this.findModule(fqn), (fqn) => this.findType(fqn), this.assembliesCurrentlyBeingCompiled);
        this.dotnetRuntimeGenerator = new dotnetruntimegenerator_1.DotNetRuntimeGenerator(this.code, this.typeresolver);
        this.dotnetDocGenerator = new dotnetdocgenerator_1.DotNetDocGenerator(this.code, this.rosetta, this.assembly);
        this.emitAssemblyDocs();
        // We need to resolve the dependency tree
        this.typeresolver.resolveNamespacesDependencies();
        super.generate(fingerprint);
    }
    async save(outdir, tarball, { license, notice }) {
        // Generating the csproj and AssemblyInfo.cs files
        const tarballFileName = path.basename(tarball);
        const filegen = new filegenerator_1.FileGenerator(this.assembly, tarballFileName, this.code);
        filegen.generateAssemblyInfoFile();
        filegen.generateProjectFile(this.typeresolver.namespaceDependencies);
        // Calling super.save() dumps the tarball in the format name@version.jsii.tgz.
        // This is not in sync with the Old .NET generator where the name is scope-name-version.tgz.
        // Hence we are saving the files ourselves here:
        const assm = this.assembly;
        const packageId = assm.targets.dotnet.packageId;
        if (!packageId) {
            throw new Error(`The module ${assm.name} does not have a dotnet.packageId setting`);
        }
        await fs.mkdirp(path.join(outdir, packageId));
        await fs.copyFile(tarball, path.join(outdir, packageId, tarballFileName));
        // Create an anchor file for the current model
        this.generateDependencyAnchorFile();
        if (license) {
            await fs.writeFile(path.join(outdir, packageId, 'LICENSE'), license, {
                encoding: 'utf8',
            });
        }
        if (notice) {
            await fs.writeFile(path.join(outdir, packageId, 'NOTICE'), notice, {
                encoding: 'utf8',
            });
        }
        // Saving the generated code.
        return this.code.save(outdir);
    }
    /**
     * Generates the anchor file
     */
    generateDependencyAnchorFile() {
        const namespace = `${this.assembly.targets.dotnet.namespace}.Internal.DependencyResolution`;
        this.openFileIfNeeded('Anchor', namespace, false, false);
        this.code.openBlock('public sealed class Anchor');
        this.code.openBlock('public Anchor()');
        this.typeresolver.namespaceDependencies.forEach((value) => this.code.line(`new ${value.namespace}.Internal.DependencyResolution.Anchor();`));
        this.code.closeBlock();
        this.code.closeBlock();
        this.closeFileIfNeeded('Anchor', namespace, false);
    }
    /**
     * Not used as we override the save() method
     */
    getAssemblyOutputDir(mod) {
        return this.nameutils.convertPackageName(mod.name);
    }
    /**
     * Namespaces are handled implicitly by openFileIfNeeded().
     *
     * Do generate docs if this is for a submodule though.
     */
    onBeginNamespace(jsiiNs) {
        var _a;
        const submodule = (_a = this.assembly.submodules) === null || _a === void 0 ? void 0 : _a[jsiiNs];
        if (submodule) {
            const dotnetNs = this.typeresolver.resolveNamespace(this.assembly, this.assembly.name, jsiiNs);
            this.emitNamespaceDocs(dotnetNs, jsiiNs, submodule);
        }
    }
    onEndNamespace(_ns) {
        /* noop */
    }
    onBeginInterface(ifc) {
        const implementations = this.typeresolver.resolveImplementedInterfaces(ifc);
        const interfaceName = this.nameutils.convertInterfaceName(ifc);
        const namespace = this.namespaceFor(this.assembly, ifc);
        this.openFileIfNeeded(interfaceName, namespace, this.isNested(ifc));
        this.dotnetDocGenerator.emitDocs(ifc, { api: 'type', fqn: ifc.fqn });
        this.dotnetRuntimeGenerator.emitAttributesForInterface(ifc);
        if (implementations.length > 0) {
            this.code.openBlock(`public interface ${interfaceName} : ${implementations.join(', ')}`);
        }
        else {
            this.code.openBlock(`public interface ${interfaceName}`);
        }
        this.flagFirstMemberWritten(false);
    }
    onEndInterface(ifc) {
        // emit interface proxy class
        this.emitInterfaceProxy(ifc);
        const interfaceName = this.nameutils.convertInterfaceName(ifc);
        this.code.closeBlock();
        const namespace = this.namespaceFor(this.assembly, ifc);
        this.closeFileIfNeeded(interfaceName, namespace, this.isNested(ifc));
        // emit implementation class
        // TODO: If datatype then we may not need the interface proxy to be created, We could do with just the interface impl?
        if (ifc.datatype) {
            this.emitInterfaceDataType(ifc);
        }
    }
    onInterfaceMethod(ifc, method) {
        var _a;
        this.dotnetDocGenerator.emitDocs(method, {
            api: 'member',
            fqn: ifc.fqn,
            memberName: method.name,
        });
        this.dotnetRuntimeGenerator.emitAttributesForMethod(ifc, method);
        const returnType = method.returns
            ? this.typeresolver.toDotNetType(method.returns.type)
            : 'void';
        const nullable = ((_a = method.returns) === null || _a === void 0 ? void 0 : _a.optional) ? '?' : '';
        this.code.line(`${returnType}${nullable} ${this.nameutils.convertMethodName(method.name)}(${this.renderMethodParameters(method)});`);
    }
    onInterfaceMethodOverload(ifc, overload, _originalMethod) {
        this.onInterfaceMethod(ifc, overload);
    }
    onInterfaceProperty(ifc, prop) {
        if (!prop.abstract) {
            throw new Error(`Interface properties must be abstract: ${prop.name}`);
        }
        if (prop.protected) {
            throw new Error(`Protected properties are not allowed on interfaces: ${prop.name}`);
        }
        if (prop.static) {
            throw new Error(`Property ${ifc.name}.${prop.name} is marked as static, but interfaces must not contain static members.`);
        }
        this.emitNewLineIfNecessary();
        this.dotnetDocGenerator.emitDocs(prop, {
            api: 'member',
            fqn: ifc.fqn,
            memberName: prop.name,
        });
        this.dotnetRuntimeGenerator.emitAttributesForProperty(prop);
        const propType = this.typeresolver.toDotNetType(prop.type);
        const propName = this.nameutils.convertPropertyName(prop.name);
        if (prop.optional) {
            this.code.line('[Amazon.JSII.Runtime.Deputy.JsiiOptional]');
        }
        // Specifying that a type is nullable is only required for primitive value types
        const isOptional = prop.optional ? '?' : '';
        this.code.openBlock(`${propType}${isOptional} ${propName}`);
        if (prop.optional) {
            this.code.openBlock('get');
            this.code.line('return null;');
            this.code.closeBlock();
            if (!prop.immutable) {
                this.code.openBlock('set');
                this.code.line(`throw new System.NotSupportedException("'set' for '${propName}' is not implemented");`);
                this.code.closeBlock();
            }
        }
        else {
            this.code.line('get;');
            if (!prop.immutable) {
                this.code.line('set;');
            }
        }
        this.code.closeBlock();
        this.flagFirstMemberWritten(true);
    }
    onBeginClass(cls, abstract) {
        let baseTypeNames = [];
        const namespace = this.namespaceFor(this.assembly, cls);
        // A class can derive from only one base class
        // But can implement multiple interfaces
        if (!cls.base) {
            baseTypeNames.push('DeputyBase');
        }
        else {
            const classBase = this.typeresolver.toDotNetType({ fqn: cls.base });
            baseTypeNames.push(classBase);
        }
        if (cls.interfaces && cls.interfaces.length > 0) {
            const implementations = this.typeresolver.resolveImplementedInterfaces(cls);
            baseTypeNames = baseTypeNames.concat(implementations);
        }
        const className = this.nameutils.convertClassName(cls);
        // Nested classes will be dealt with during calc code generation
        const nested = this.isNested(cls);
        const absPrefix = abstract ? ' abstract' : '';
        this.openFileIfNeeded(className, namespace, nested);
        const implementsExpr = ` : ${baseTypeNames.join(', ')}`;
        this.dotnetDocGenerator.emitDocs(cls, {
            api: 'type',
            fqn: cls.fqn,
        });
        this.dotnetRuntimeGenerator.emitAttributesForClass(cls);
        this.code.openBlock(`public${absPrefix} class ${className}${implementsExpr}`);
        // Compute the class parameters
        let parametersDefinition = '';
        let parametersBase = '';
        const initializer = cls.initializer;
        if (initializer) {
            this.dotnetDocGenerator.emitDocs(initializer, {
                api: 'initializer',
                fqn: cls.fqn,
            });
            this.dotnetRuntimeGenerator.emitDeprecatedAttributeIfNecessary(initializer);
            if (initializer.parameters) {
                parametersDefinition = this.renderParametersString(initializer.parameters);
                for (const p of initializer.parameters) {
                    parametersBase += `${this.nameutils.convertParameterName(p.name)}`;
                    // If this is not the last parameter, append ,
                    if (initializer.parameters.indexOf(p) !==
                        initializer.parameters.length - 1) {
                        parametersBase += ', ';
                    }
                }
            }
            // Create the constructors:
            // Abstract classes have protected constructors.
            const visibility = cls.abstract ? 'protected' : 'public';
            const args = parametersBase.length > 0
                ? `new object?[]{${parametersBase}}`
                : `System.Array.Empty<object?>()`;
            this.code.openBlock(`${visibility} ${className}(${parametersDefinition}): base(new DeputyProps(${args}))`);
            this.code.closeBlock();
            this.code.line();
        }
        this.code.line('/// <summary>Used by jsii to construct an instance of this class from a Javascript-owned object reference</summary>');
        this.code.line('/// <param name="reference">The Javascript-owned object reference</param>');
        this.dotnetRuntimeGenerator.emitDeprecatedAttributeIfNecessary(initializer);
        this.emitHideAttribute();
        this.code.openBlock(`protected ${className}(ByRefValue reference): base(reference)`);
        this.code.closeBlock();
        this.code.line();
        this.code.line('/// <summary>Used by jsii to construct an instance of this class from DeputyProps</summary>');
        this.code.line('/// <param name="props">The deputy props</param>');
        this.dotnetRuntimeGenerator.emitDeprecatedAttributeIfNecessary(initializer);
        this.emitHideAttribute();
        this.code.openBlock(`protected ${className}(DeputyProps props): base(props)`);
        this.code.closeBlock();
        // We have already outputted members (constructors), setting the flag to true
        this.flagFirstMemberWritten(true);
    }
    onEndClass(cls) {
        if (cls.abstract) {
            this.emitInterfaceProxy(cls);
        }
        this.code.closeBlock();
        const className = this.nameutils.convertClassName(cls);
        const namespace = this.namespaceFor(this.assembly, cls);
        this.closeFileIfNeeded(className, namespace, this.isNested(cls));
    }
    onField(_cls, _prop, _union) {
        /* noop */
    }
    onMethod(cls, method) {
        this.emitMethod(cls, method, cls);
    }
    onMethodOverload(cls, overload, _originalMethod) {
        this.onMethod(cls, overload);
    }
    onProperty(cls, prop) {
        this.emitProperty(cls, prop, cls);
    }
    onStaticMethod(cls, method) {
        this.emitMethod(cls, method, cls);
    }
    onStaticMethodOverload(cls, overload, _originalMethod) {
        this.emitMethod(cls, overload, cls);
    }
    onStaticProperty(cls, prop) {
        if (prop.const) {
            this.emitConstProperty(cls, prop);
        }
        else {
            this.emitProperty(cls, prop, cls);
        }
    }
    onUnionProperty(cls, prop, _union) {
        this.emitProperty(cls, prop, cls);
    }
    onBeginEnum(enm) {
        const enumName = this.nameutils.convertTypeName(enm.name);
        const namespace = this.namespaceFor(this.assembly, enm);
        this.openFileIfNeeded(enumName, namespace, this.isNested(enm));
        this.emitNewLineIfNecessary();
        this.dotnetDocGenerator.emitDocs(enm, {
            api: 'type',
            fqn: enm.fqn,
        });
        this.dotnetRuntimeGenerator.emitAttributesForEnum(enm, enumName);
        this.code.openBlock(`public enum ${enm.name}`);
    }
    onEndEnum(enm) {
        this.code.closeBlock();
        const enumName = this.nameutils.convertTypeName(enm.name);
        const namespace = this.namespaceFor(this.assembly, enm);
        this.closeFileIfNeeded(enumName, namespace, this.isNested(enm));
    }
    onEnumMember(enm, member) {
        this.dotnetDocGenerator.emitDocs(member, {
            api: 'member',
            fqn: enm.fqn,
            memberName: member.name,
        });
        const enumMemberName = this.nameutils.convertEnumMemberName(member.name);
        this.dotnetRuntimeGenerator.emitAttributesForEnumMember(enumMemberName, member);
        // If we are on the last enum member, we don't need a comma
        if (enm.members.indexOf(member) !== enm.members.length - 1) {
            this.code.line(`${enumMemberName},`);
        }
        else {
            this.code.line(`${enumMemberName}`);
        }
    }
    namespaceFor(assm, type) {
        var _a;
        let ns = type.namespace;
        while (ns != null && ((_a = assm.types) === null || _a === void 0 ? void 0 : _a[`${assm.name}.${ns}`]) != null) {
            const nesting = assm.types[`${assm.name}.${ns}`];
            ns = nesting.namespace;
        }
        if (ns != null) {
            return this.typeresolver.resolveNamespace(assm, assm.name, ns);
        }
        return assm.targets.dotnet.namespace;
    }
    emitMethod(cls, method, definingType, emitForProxyOrDatatype = false) {
        this.emitNewLineIfNecessary();
        const returnType = method.returns
            ? this.typeresolver.toDotNetType(method.returns.type)
            : 'void';
        const staticKeyWord = method.static ? 'static ' : '';
        let overrideKeyWord = '';
        let virtualKeyWord = '';
        let definedOnAncestor = false;
        // In the case of the source being a class, we check if it is already defined on an ancestor
        if (spec.isClassType(cls)) {
            definedOnAncestor = this.isMemberDefinedOnAncestor(cls, method);
        }
        // The method is an override if it's defined on the ancestor, or if the parent is a class and we are generating a proxy or datatype class
        let overrides = definedOnAncestor || (spec.isClassType(cls) && emitForProxyOrDatatype);
        // We also inspect the jsii model to see if it overrides a class member.
        if (method.overrides) {
            const overrideType = this.findType(method.overrides);
            if (spec.isClassType(overrideType)) {
                // Overrides a class, needs overrides keyword
                overrides = true;
            }
        }
        if (overrides) {
            // Add the override key word if the method is emitted for a proxy or data type or is defined on an ancestor. If
            // the member is static, use the "new" keyword instead, to indicate we are intentionally hiding the ancestor
            // declaration (as C# does not inherit statics, they can be hidden but not overridden). The "new" keyword is
            // optional in this context, but helps clarify intention.
            overrideKeyWord = method.static ? 'new ' : 'override ';
        }
        else if (!method.static &&
            (method.abstract || !definedOnAncestor) &&
            !emitForProxyOrDatatype) {
            // Add the virtual key word if the method is abstract or not defined on an ancestor and we are NOT generating a proxy or datatype class
            // Methods should always be virtual when possible
            virtualKeyWord = 'virtual ';
        }
        const access = this.renderAccessLevel(method);
        const methodName = this.nameutils.convertMethodName(method.name);
        const isOptional = method.returns && method.returns.optional ? '?' : '';
        const signature = `${returnType}${isOptional} ${methodName}(${this.renderMethodParameters(method)})`;
        this.dotnetDocGenerator.emitDocs(method, {
            api: 'member',
            fqn: definingType.fqn,
            memberName: method.name,
        });
        this.dotnetRuntimeGenerator.emitAttributesForMethod(cls, method /*, emitForProxyOrDatatype*/);
        if (method.abstract) {
            this.code.line(`${access} ${overrideKeyWord}abstract ${signature};`);
            this.code.line();
        }
        else {
            this.code.openBlock(`${access} ${staticKeyWord}${overrideKeyWord}${virtualKeyWord}${signature}`);
            this.code.line(this.dotnetRuntimeGenerator.createInvokeMethodIdentifier(method, cls));
            this.code.closeBlock();
        }
    }
    /**
     * Founds out if a member (property or method) is already defined in one of the base classes
     *
     * Used to figure out if the override or virtual keywords are necessary.
     */
    isMemberDefinedOnAncestor(cls, member) {
        if (member) {
            const objectMethods = ['ToString', 'GetHashCode', 'Equals'];
            // Methods defined on the Object class should be overridden, return true;
            if (objectMethods.includes(this.nameutils.convertMethodName(member.name))) {
                return true;
            }
        }
        const base = cls.base;
        if (base) {
            const baseType = this.findType(base);
            if (member) {
                if (baseType.properties) {
                    if (baseType.properties.filter((property) => property.name === member.name).length > 0) {
                        // property found in base parent
                        return true;
                    }
                }
                return this.isMemberDefinedOnAncestor(baseType, member);
            }
            else if (member) {
                if (baseType.methods) {
                    const myMethod = member;
                    // If the name, parameters and returns are similar then it is the same method in .NET
                    for (const m of baseType.methods) {
                        if (m.name === myMethod.name &&
                            m.parameters === myMethod.parameters &&
                            m.returns === myMethod.returns) {
                            return true;
                        }
                    }
                }
                return this.isMemberDefinedOnAncestor(baseType, member);
            }
            return false;
        }
        return false;
    }
    /**
     * Renders method parameters string
     */
    renderMethodParameters(method) {
        return this.renderParametersString(method.parameters);
    }
    /**
     * Renders parameters string for methods or constructors
     */
    renderParametersString(parameters) {
        const params = [];
        if (parameters) {
            for (const p of parameters) {
                let optionalPrimitive = '';
                let optionalKeyword = '';
                let type = this.typeresolver.toDotNetType(p.type);
                if (p.optional) {
                    optionalKeyword = ' = null';
                    if (p.optional) {
                        optionalPrimitive = '?';
                    }
                }
                else if (p.variadic) {
                    type = `params ${type}[]`;
                }
                const st = `${type}${optionalPrimitive} ${this.nameutils.convertParameterName(p.name)}${optionalKeyword}`;
                params.push(st);
            }
        }
        return params.join(', ');
    }
    /**
     * Emits an interface proxy for an interface or an abstract class.
     */
    emitInterfaceProxy(ifc) {
        const name = '_Proxy';
        const namespace = this.namespaceFor(this.assembly, ifc);
        const isNested = true;
        this.openFileIfNeeded(name, namespace, isNested);
        this.code.line();
        this.dotnetDocGenerator.emitDocs(ifc, {
            api: 'type',
            fqn: ifc.fqn,
        });
        this.dotnetRuntimeGenerator.emitAttributesForInterfaceProxy(ifc);
        const interfaceFqn = this.typeresolver.toNativeFqn(ifc.fqn);
        const suffix = spec.isInterfaceType(ifc)
            ? `: DeputyBase, ${interfaceFqn}`
            : `: ${interfaceFqn}`;
        const newModifier = this.proxyMustUseNewModifier(ifc) ? 'new ' : '';
        this.code.openBlock(`${newModifier}internal sealed class ${name} ${suffix}`);
        // Create the private constructor
        this.code.openBlock(`private ${name}(ByRefValue reference): base(reference)`);
        this.code.closeBlock();
        // We have already output a member (constructor), setting the first member flag to true
        this.flagFirstMemberWritten(true);
        const datatype = false;
        const proxy = true;
        this.emitInterfaceMembersForProxyOrDatatype(ifc, datatype, proxy);
        this.code.closeBlock();
        this.closeFileIfNeeded(name, namespace, isNested);
    }
    /**
     * Determines whether any ancestor of the given type must use the `new`
     * modifier when introducing it's own proxy.
     *
     * If the type is a `class`, then it must use `new` if it extends another
     * abstract class defined in the same assembly (since proxies are internal,
     * external types' proxies are not visible in that context).
     *
     * If the type is an `interface`, then it must use `new` if it extends another
     * interface from the same assembly.
     *
     * @param type the tested proxy-able type (an abstract class or an interface).
     *
     * @returns true if any ancestor of this type has a visible proxy.
     */
    proxyMustUseNewModifier(type) {
        var _a;
        if (spec.isClassType(type)) {
            if (type.base == null) {
                return false;
            }
            const base = this.findType(type.base);
            return (base.assembly === type.assembly &&
                (base.abstract
                    ? true
                    : // An abstract class could extend a concrete class... We must walk up the inheritance tree in this case...
                        this.proxyMustUseNewModifier(base)));
        }
        return (((_a = type.interfaces) === null || _a === void 0 ? void 0 : _a.find((fqn) => this.findType(fqn).assembly === type.assembly)) != null);
    }
    /**
     * Emits an Interface Datatype class
     *
     * This is used to emit a class implementing an interface when the datatype property is true in the jsii model
     * The generation of the interface proxy may not be needed if the interface is also set as a datatype
     */
    emitInterfaceDataType(ifc) {
        var _a;
        // Interface datatypes do not need to be prefixed by I, we can call convertClassName
        const name = this.nameutils.convertClassName(ifc);
        const namespace = this.namespaceFor(this.assembly, ifc);
        const isNested = this.isNested(ifc);
        this.openFileIfNeeded(name, namespace, isNested);
        if (((_a = ifc.properties) === null || _a === void 0 ? void 0 : _a.find((prop) => !prop.optional)) != null) {
            // We don't want to be annoyed by the lack of initialization of non-nullable fields in this case.
            this.code.line('#pragma warning disable CS8618');
            this.code.line();
        }
        this.dotnetDocGenerator.emitDocs(ifc, {
            api: 'type',
            fqn: ifc.fqn,
        });
        const suffix = `: ${this.typeresolver.toNativeFqn(ifc.fqn)}`;
        this.dotnetRuntimeGenerator.emitAttributesForInterfaceDatatype(ifc);
        this.code.openBlock(`public class ${name} ${suffix}`);
        this.flagFirstMemberWritten(false);
        const datatype = true;
        const proxy = false;
        this.emitInterfaceMembersForProxyOrDatatype(ifc, datatype, proxy);
        this.code.closeBlock();
        this.closeFileIfNeeded(name, namespace, isNested);
    }
    /**
     * Generates the body of the interface proxy or data type class
     *
     * This loops through all the member and generates them
     */
    emitInterfaceMembersForProxyOrDatatype(ifc, datatype, proxy) {
        // The key is in the form 'method.name;parameter1;parameter2;' etc
        const methods = new Map();
        /*
              Only get the first declaration encountered, and keep it if it is abstract. The list contains ALL
              methods and properties encountered, in the order encountered. An abstract class can have concrete
              implementations. Therefore, we only generate methods/properties if the first member encountered
              is unimplemented.
            */
        const excludedMethod = []; // Keeps track of the methods we already ran into and don't want to emit
        const excludedProperties = []; // Keeps track of the properties we already ran into and don't want to emit
        const properties = {};
        const collectAbstractMembers = (currentType) => {
            var _a, _b, _c;
            for (const prop of (_a = currentType.properties) !== null && _a !== void 0 ? _a : []) {
                if (!excludedProperties.includes(prop.name)) {
                    // If we have never run into this property before and it is abstract, we keep it
                    if (prop.abstract) {
                        properties[prop.name] = { prop, definingType: currentType };
                    }
                    excludedProperties.push(prop.name);
                }
            }
            for (const method of (_b = currentType.methods) !== null && _b !== void 0 ? _b : []) {
                let methodParameters = '';
                if (method.parameters) {
                    method.parameters.forEach((param) => {
                        methodParameters += `;${this.typeresolver.toDotNetType(param.type)}`;
                    });
                }
                if (!excludedMethod.includes(`${method.name}${methodParameters}`)) {
                    // If we have never run into this method before and it is abstract, we keep it
                    if (method.abstract) {
                        methods.set(`${method.name}${methodParameters}`, {
                            method,
                            definingType: currentType,
                        });
                    }
                    excludedMethod.push(`${method.name}${methodParameters}`);
                }
            }
            const bases = new Array();
            bases.push(...((_c = currentType.interfaces) !== null && _c !== void 0 ? _c : []).map((iface) => this.findType(iface)));
            if (spec.isClassType(currentType) && currentType.base) {
                bases.push(this.findType(currentType.base));
            }
            for (const base of bases) {
                const type = this.findType(base.fqn);
                if (type.kind !== spec.TypeKind.Interface &&
                    type.kind !== spec.TypeKind.Class) {
                    throw new Error(`Base interfaces of an interface must be an interface or a class (${base.fqn} is of type ${type.kind})`);
                }
                collectAbstractMembers(type);
            }
        };
        collectAbstractMembers(ifc);
        // emit all properties
        for (const propName of Object.keys(properties)) {
            const prop = clone(properties[propName]);
            prop.prop.abstract = false;
            this.emitProperty(ifc, prop.prop, prop.definingType, datatype, proxy);
        }
        // emit all the methods
        for (const methodNameAndParameters of methods.keys()) {
            const originalMethod = methods.get(methodNameAndParameters);
            if (originalMethod) {
                const method = clone(originalMethod);
                method.method.abstract = false;
                this.emitMethod(ifc, method.method, method.definingType, 
                /* emitForProxyOrDatatype */ true);
                for (const overloadedMethod of this.createOverloadsForOptionals(method.method)) {
                    overloadedMethod.abstract = false;
                    this.emitMethod(ifc, overloadedMethod, method.definingType, 
                    /* emitForProxyOrDatatype */ true);
                }
            }
        }
    }
    /**
     * Emits a property
     */
    emitProperty(cls, prop, definingType, datatype = false, proxy = false) {
        this.emitNewLineIfNecessary();
        const className = this.typeresolver.toNativeFqn(cls.fqn);
        const access = this.renderAccessLevel(prop);
        const staticKeyWord = prop.static ? 'static ' : '';
        const propName = this.nameutils.convertPropertyName(prop.name);
        this.dotnetDocGenerator.emitDocs(prop, {
            api: 'member',
            fqn: definingType.fqn,
            memberName: prop.name,
        });
        if (prop.optional) {
            this.code.line('[JsiiOptional]');
        }
        this.dotnetRuntimeGenerator.emitAttributesForProperty(prop, datatype);
        let isOverrideKeyWord = '';
        let isVirtualKeyWord = '';
        let isAbstractKeyword = '';
        // If the prop parent is a class
        if (spec.isClassType(cls)) {
            const implementedInBase = this.isMemberDefinedOnAncestor(cls, prop);
            if (implementedInBase || datatype || proxy) {
                // Override if the property is in a datatype or proxy class or declared in a parent class. If the member is
                // static, use the "new" keyword instead, to indicate we are intentionally hiding the ancestor declaration (as
                // C# does not inherit statics, they can be hidden but not overridden).The "new" keyword is optional in this
                // context, but helps clarify intention.
                isOverrideKeyWord = prop.static ? 'new ' : 'override ';
            }
            else if (prop.abstract) {
                // Abstract members get decorated as such
                isAbstractKeyword = 'abstract ';
            }
            else if (!prop.static && !implementedInBase) {
                // Virtual if the prop is not static, and is not implemented in base member, this way we can later override it.
                isVirtualKeyWord = 'virtual ';
            }
        }
        const propTypeFQN = this.typeresolver.toDotNetType(prop.type);
        const isOptional = prop.optional ? '?' : '';
        const statement = `${access} ${isAbstractKeyword}${isVirtualKeyWord}${staticKeyWord}${isOverrideKeyWord}${propTypeFQN}${isOptional} ${propName}`;
        this.code.openBlock(statement);
        // Emit getters
        if (datatype || prop.const || prop.abstract) {
            this.code.line('get;');
        }
        else {
            // If the property is non-optional, add a bang to silence compiler warning
            const bang = prop.optional ? '' : '!';
            if (prop.static) {
                this.code.line(`get => GetStaticProperty<${propTypeFQN}${isOptional}>(typeof(${className}))${bang};`);
            }
            else {
                this.code.line(`get => GetInstanceProperty<${propTypeFQN}${isOptional}>()${bang};`);
            }
        }
        // Emit setters
        if (datatype || (!prop.immutable && prop.abstract)) {
            this.code.line('set;');
        }
        else {
            if (!prop.immutable) {
                if (prop.static) {
                    this.code.line(`set => SetStaticProperty(typeof(${className}), value);`);
                }
                else {
                    this.code.line('set => SetInstanceProperty(value);');
                }
            }
        }
        this.code.closeBlock();
        this.flagFirstMemberWritten(true);
    }
    /**
     * Emits a constant property
     */
    emitConstProperty(cls, prop) {
        this.emitNewLineIfNecessary();
        this.flagFirstMemberWritten(true);
        const propType = this.typeresolver.toDotNetType(prop.type);
        const isOptional = prop.optional ? '?' : '';
        this.dotnetDocGenerator.emitDocs(prop, {
            api: 'member',
            fqn: cls.fqn,
            memberName: prop.name,
        });
        this.dotnetRuntimeGenerator.emitAttributesForProperty(prop);
        const access = this.renderAccessLevel(prop);
        const propName = this.nameutils.convertPropertyName(prop.name);
        const staticKeyword = prop.static ? 'static ' : '';
        this.code.openBlock(`${access} ${staticKeyword}${propType}${isOptional} ${propName}`);
        this.code.line('get;');
        this.code.closeBlock();
        const className = this.typeresolver.toNativeFqn(cls.fqn);
        // If the property is non-optional, add a bang to silence the compiler warning
        const bang = prop.optional ? '' : '!';
        const initializer = prop.static
            ? `= GetStaticProperty<${propType}>(typeof(${className}))${bang};`
            : `= GetInstanceProperty<${propType}>(typeof(${className}))${bang};`;
        this.code.line(initializer);
    }
    renderAccessLevel(method) {
        return method.protected ? 'protected' : 'public';
    }
    isNested(type) {
        if (!this.assembly.types || !type.namespace) {
            return false;
        }
        const parent = `${type.assembly}.${type.namespace}`;
        return parent in this.assembly.types;
    }
    toCSharpFilePath(type) {
        return `${type}.cs`;
    }
    openFileIfNeeded(typeName, namespace, isNested, usingDeputy = true) {
        var _a, _b;
        // If Nested type, we shouldn't open/close a file
        if (isNested) {
            return;
        }
        const dotnetPackageId = (_b = (_a = this.assembly.targets) === null || _a === void 0 ? void 0 : _a.dotnet) === null || _b === void 0 ? void 0 : _b.packageId;
        if (!dotnetPackageId) {
            throw new Error(`The module ${this.assembly.name} does not have a dotnet.packageId setting`);
        }
        const filePath = namespace.replace(/[.]/g, '/');
        this.code.openFile(path.join(dotnetPackageId, filePath, this.toCSharpFilePath(typeName)));
        if (usingDeputy) {
            this.code.line('using Amazon.JSII.Runtime.Deputy;');
            this.code.line();
        }
        // Suppress warnings about missing XMLDoc, Obsolete inconsistencies
        this.code.line('#pragma warning disable CS0672,CS0809,CS1591');
        this.code.line();
        this.code.openBlock(`namespace ${namespace}`);
    }
    closeFileIfNeeded(typeName, namespace, isNested) {
        var _a, _b;
        if (isNested) {
            return;
        }
        this.code.closeBlock();
        const dotnetPackageId = (_b = (_a = this.assembly.targets) === null || _a === void 0 ? void 0 : _a.dotnet) === null || _b === void 0 ? void 0 : _b.packageId;
        if (!dotnetPackageId) {
            throw new Error(`The module ${this.assembly.name} does not have a dotnet.packageId setting`);
        }
        const filePath = namespace.replace(/[.]/g, '/');
        this.code.closeFile(path.join(dotnetPackageId, filePath, this.toCSharpFilePath(typeName)));
    }
    /**
     * Resets the firstMember boolean flag to keep track of the first member of a new file
     *
     * This avoids unnecessary white lines
     */
    flagFirstMemberWritten(first) {
        this.firstMemberWritten = first;
    }
    /**
     * Emits a new line prior to writing a new property, method, if the property is not the first one in the class
     *
     * This avoids unnecessary white lines.
     */
    emitNewLineIfNecessary() {
        // If the first member has already been written, it is safe to write a new line
        if (this.firstMemberWritten) {
            this.code.line();
        }
        else {
            this.firstMemberWritten = false;
        }
    }
    emitAssemblyDocs() {
        this.emitNamespaceDocs(this.assembly.targets.dotnet.namespace, this.assembly.name, this.assembly);
    }
    /**
     * Emit an unused, empty class called `NamespaceDoc` to attach the module README to
     *
     * There is no way to attach doc comments to a namespace in C#, and this trick has been
     * semi-standardized by NDoc and Sandcastle Help File Builder.
     *
     * DocFX doesn't support it out of the box, but we should be able to get there with a
     * bit of hackery.
     *
     * In any case, we need a place to attach the docs where they can be transported around,
     * might as well be this method.
     */
    emitNamespaceDocs(namespace, jsiiFqn, docSource) {
        if (!docSource.readme) {
            return;
        }
        const className = 'NamespaceDoc';
        this.openFileIfNeeded(className, namespace, false, false);
        this.dotnetDocGenerator.emitMarkdownAsRemarks(docSource.readme.markdown, {
            api: 'moduleReadme',
            moduleFqn: jsiiFqn,
        });
        this.emitHideAttribute();
        // Traditionally this class is made 'internal', but that interacts poorly with DocFX's default filters
        // which aren't overridable. So we make it public, but use attributes to hide it from users' IntelliSense,
        // so that we can access the class in DocFX.
        this.code.openBlock(`public class ${className}`);
        this.code.closeBlock();
        this.closeFileIfNeeded(className, namespace, false);
    }
    /**
     * Emit an attribute that will hide the subsequent API element from users
     */
    emitHideAttribute() {
        this.code.line('[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]');
    }
}
exports.DotNetGenerator = DotNetGenerator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG90bmV0Z2VuZXJhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZG90bmV0Z2VuZXJhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLG1DQUFtQztBQUNuQywrQkFBK0I7QUFDL0IsK0JBQStCO0FBRy9CLDZCQUE2QjtBQUU3QiwrQ0FBc0Q7QUFFdEQsNkRBQTBEO0FBQzFELHFFQUFrRTtBQUNsRSw2REFBMEQ7QUFDMUQsbURBQWdEO0FBQ2hELDJDQUE4QztBQUU5Qzs7R0FFRztBQUNILE1BQWEsZUFBZ0IsU0FBUSxxQkFBUztJQVk1QyxZQUNtQixnQ0FBMEMsRUFDMUMsT0FBZ0I7UUFFakMsS0FBSyxFQUFFLENBQUM7UUFIUyxxQ0FBZ0MsR0FBaEMsZ0NBQWdDLENBQVU7UUFDMUMsWUFBTyxHQUFQLE9BQU8sQ0FBUztRQWJuQywyRUFBMkU7UUFDbkUsdUJBQWtCLEdBQUcsS0FBSyxDQUFDO1FBSWxCLGNBQVMsR0FBb0IsSUFBSSwyQkFBZSxFQUFFLENBQUM7UUFZbEUsb0dBQW9HO1FBQ3BHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLFVBQVUsSUFBSTtZQUNsQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2hCLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDakIsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVNLEtBQUssQ0FBQyxJQUFJLENBQ2YsV0FBbUIsRUFDbkIsUUFBMEI7UUFFMUIsTUFBTSxLQUFLLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxRQUFRLENBQUMsV0FBb0I7UUFDbEMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLHVDQUFrQixDQUN4QyxJQUFJLENBQUMsUUFBUSxFQUNiLENBQUMsR0FBVyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUNyQyxDQUFDLEdBQVcsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFDbkMsSUFBSSxDQUFDLGdDQUFnQyxDQUN0QyxDQUFDO1FBRUYsSUFBSSxDQUFDLHNCQUFzQixHQUFHLElBQUksK0NBQXNCLENBQ3RELElBQUksQ0FBQyxJQUFJLEVBQ1QsSUFBSSxDQUFDLFlBQVksQ0FDbEIsQ0FBQztRQUNGLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLHVDQUFrQixDQUM5QyxJQUFJLENBQUMsSUFBSSxFQUNULElBQUksQ0FBQyxPQUFPLEVBQ1osSUFBSSxDQUFDLFFBQVEsQ0FDZCxDQUFDO1FBRUYsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFFeEIseUNBQXlDO1FBQ3pDLElBQUksQ0FBQyxZQUFZLENBQUMsNkJBQTZCLEVBQUUsQ0FBQztRQUNsRCxLQUFLLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFTSxLQUFLLENBQUMsSUFBSSxDQUNmLE1BQWMsRUFDZCxPQUFlLEVBQ2YsRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFZO1FBRTdCLGtEQUFrRDtRQUNsRCxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQy9DLE1BQU0sT0FBTyxHQUFHLElBQUksNkJBQWEsQ0FDL0IsSUFBSSxDQUFDLFFBQVEsRUFDYixlQUFlLEVBQ2YsSUFBSSxDQUFDLElBQUksQ0FDVixDQUFDO1FBQ0YsT0FBTyxDQUFDLHdCQUF3QixFQUFFLENBQUM7UUFDbkMsT0FBTyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMscUJBQXFCLENBQUMsQ0FBQztRQUNyRSw4RUFBOEU7UUFDOUUsNEZBQTRGO1FBQzVGLGdEQUFnRDtRQUNoRCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQzNCLE1BQU0sU0FBUyxHQUFXLElBQUksQ0FBQyxPQUFRLENBQUMsTUFBTyxDQUFDLFNBQVMsQ0FBQztRQUMxRCxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2QsTUFBTSxJQUFJLEtBQUssQ0FDYixjQUFjLElBQUksQ0FBQyxJQUFJLDJDQUEyQyxDQUNuRSxDQUFDO1NBQ0g7UUFDRCxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQztRQUM5QyxNQUFNLEVBQUUsQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFNBQVMsRUFBRSxlQUFlLENBQUMsQ0FBQyxDQUFDO1FBRTFFLDhDQUE4QztRQUM5QyxJQUFJLENBQUMsNEJBQTRCLEVBQUUsQ0FBQztRQUVwQyxJQUFJLE9BQU8sRUFBRTtZQUNYLE1BQU0sRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLEVBQUUsT0FBTyxFQUFFO2dCQUNuRSxRQUFRLEVBQUUsTUFBTTthQUNqQixDQUFDLENBQUM7U0FDSjtRQUNELElBQUksTUFBTSxFQUFFO1lBQ1YsTUFBTSxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFNBQVMsRUFBRSxRQUFRLENBQUMsRUFBRSxNQUFNLEVBQUU7Z0JBQ2pFLFFBQVEsRUFBRSxNQUFNO2FBQ2pCLENBQUMsQ0FBQztTQUNKO1FBRUQsNkJBQTZCO1FBQzdCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVEOztPQUVHO0lBQ08sNEJBQTRCO1FBQ3BDLE1BQU0sU0FBUyxHQUFHLEdBQ2hCLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBUSxDQUFDLE1BQU8sQ0FBQyxTQUNqQyxnQ0FBZ0MsQ0FBQztRQUNqQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDekQsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsNEJBQTRCLENBQUMsQ0FBQztRQUNsRCxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxZQUFZLENBQUMscUJBQXFCLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FDeEQsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQ1osT0FBTyxLQUFLLENBQUMsU0FBUywwQ0FBMEMsQ0FDakUsQ0FDRixDQUFDO1FBQ0YsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFFRDs7T0FFRztJQUNPLG9CQUFvQixDQUFDLEdBQWtCO1FBQy9DLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDckQsQ0FBQztJQUVEOzs7O09BSUc7SUFDTyxnQkFBZ0IsQ0FBQyxNQUFjOztRQUN2QyxNQUFNLFNBQVMsU0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsMENBQUcsTUFBTSxDQUFDLENBQUM7UUFDckQsSUFBSSxTQUFTLEVBQUU7WUFDYixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLGdCQUFnQixDQUNqRCxJQUFJLENBQUMsUUFBUSxFQUNiLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUNsQixNQUFNLENBQ1AsQ0FBQztZQUNGLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLEVBQUUsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1NBQ3JEO0lBQ0gsQ0FBQztJQUVTLGNBQWMsQ0FBQyxHQUFXO1FBQ2xDLFVBQVU7SUFDWixDQUFDO0lBRVMsZ0JBQWdCLENBQUMsR0FBdUI7UUFDaEQsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyw0QkFBNEIsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM1RSxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLG9CQUFvQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQy9ELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUN4RCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFFcEUsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUNyRSxJQUFJLENBQUMsc0JBQXNCLENBQUMsMEJBQTBCLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFNUQsSUFBSSxlQUFlLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FDakIsb0JBQW9CLGFBQWEsTUFBTSxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQ3BFLENBQUM7U0FDSDthQUFNO1lBQ0wsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsb0JBQW9CLGFBQWEsRUFBRSxDQUFDLENBQUM7U0FDMUQ7UUFDRCxJQUFJLENBQUMsc0JBQXNCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVTLGNBQWMsQ0FBQyxHQUF1QjtRQUM5Qyw2QkFBNkI7UUFDN0IsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRTdCLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsb0JBQW9CLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDL0QsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUN2QixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDeEQsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRXJFLDRCQUE0QjtRQUM1QixzSEFBc0g7UUFDdEgsSUFBSSxHQUFHLENBQUMsUUFBUSxFQUFFO1lBQ2hCLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNqQztJQUNILENBQUM7SUFFUyxpQkFBaUIsQ0FBQyxHQUF1QixFQUFFLE1BQW1COztRQUN0RSxJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRTtZQUN2QyxHQUFHLEVBQUUsUUFBUTtZQUNiLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRztZQUNaLFVBQVUsRUFBRSxNQUFNLENBQUMsSUFBSTtTQUN4QixDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsc0JBQXNCLENBQUMsdUJBQXVCLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ2pFLE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxPQUFPO1lBQy9CLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztZQUNyRCxDQUFDLENBQUMsTUFBTSxDQUFDO1FBQ1gsTUFBTSxRQUFRLEdBQUcsT0FBQSxNQUFNLENBQUMsT0FBTywwQ0FBRSxRQUFRLEVBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ3JELElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUNaLEdBQUcsVUFBVSxHQUFHLFFBQVEsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLGlCQUFpQixDQUMxRCxNQUFNLENBQUMsSUFBSSxDQUNaLElBQUksSUFBSSxDQUFDLHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQzdDLENBQUM7SUFDSixDQUFDO0lBRVMseUJBQXlCLENBQ2pDLEdBQXVCLEVBQ3ZCLFFBQXFCLEVBQ3JCLGVBQTRCO1FBRTVCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVTLG1CQUFtQixDQUFDLEdBQXVCLEVBQUUsSUFBbUI7UUFDeEUsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDbEIsTUFBTSxJQUFJLEtBQUssQ0FBQywwQ0FBMEMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7U0FDeEU7UUFFRCxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDbEIsTUFBTSxJQUFJLEtBQUssQ0FDYix1REFBdUQsSUFBSSxDQUFDLElBQUksRUFBRSxDQUNuRSxDQUFDO1NBQ0g7UUFFRCxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDZixNQUFNLElBQUksS0FBSyxDQUNiLFlBQVksR0FBRyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSx1RUFBdUUsQ0FDekcsQ0FBQztTQUNIO1FBRUQsSUFBSSxDQUFDLHNCQUFzQixFQUFFLENBQUM7UUFDOUIsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUU7WUFDckMsR0FBRyxFQUFFLFFBQVE7WUFDYixHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUc7WUFDWixVQUFVLEVBQUUsSUFBSSxDQUFDLElBQUk7U0FDdEIsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLHNCQUFzQixDQUFDLHlCQUF5QixDQUFDLElBQUksQ0FBQyxDQUFDO1FBRTVELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMzRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUUvRCxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDakIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsMkNBQTJDLENBQUMsQ0FBQztTQUM3RDtRQUVELGdGQUFnRjtRQUNoRixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUM1QyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLFFBQVEsR0FBRyxVQUFVLElBQUksUUFBUSxFQUFFLENBQUMsQ0FBQztRQUU1RCxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDakIsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDM0IsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDL0IsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRTtnQkFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQzNCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUNaLHNEQUFzRCxRQUFRLHlCQUF5QixDQUN4RixDQUFDO2dCQUNGLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7YUFDeEI7U0FDRjthQUFNO1lBQ0wsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUU7Z0JBQ25CLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ3hCO1NBQ0Y7UUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRVMsWUFBWSxDQUFDLEdBQW1CLEVBQUUsUUFBaUI7UUFDM0QsSUFBSSxhQUFhLEdBQWEsRUFBRSxDQUFDO1FBQ2pDLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUV4RCw4Q0FBOEM7UUFDOUMsd0NBQXdDO1FBQ3hDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFO1lBQ2IsYUFBYSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztTQUNsQzthQUFNO1lBQ0wsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7WUFDcEUsYUFBYSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUMvQjtRQUVELElBQUksR0FBRyxDQUFDLFVBQVUsSUFBSSxHQUFHLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDL0MsTUFBTSxlQUFlLEdBQ25CLElBQUksQ0FBQyxZQUFZLENBQUMsNEJBQTRCLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDdEQsYUFBYSxHQUFHLGFBQWEsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUM7U0FDdkQ7UUFFRCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXZELGdFQUFnRTtRQUNoRSxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2xDLE1BQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFFOUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFcEQsTUFBTSxjQUFjLEdBQUcsTUFBTSxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7UUFFeEQsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUU7WUFDcEMsR0FBRyxFQUFFLE1BQU07WUFDWCxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUc7U0FDYixDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsc0JBQXNCLENBQUMsc0JBQXNCLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFeEQsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQ2pCLFNBQVMsU0FBUyxVQUFVLFNBQVMsR0FBRyxjQUFjLEVBQUUsQ0FDekQsQ0FBQztRQUVGLCtCQUErQjtRQUMvQixJQUFJLG9CQUFvQixHQUFHLEVBQUUsQ0FBQztRQUM5QixJQUFJLGNBQWMsR0FBRyxFQUFFLENBQUM7UUFDeEIsTUFBTSxXQUFXLEdBQUcsR0FBRyxDQUFDLFdBQVcsQ0FBQztRQUNwQyxJQUFJLFdBQVcsRUFBRTtZQUNmLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFO2dCQUM1QyxHQUFHLEVBQUUsYUFBYTtnQkFDbEIsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHO2FBQ2IsQ0FBQyxDQUFDO1lBQ0gsSUFBSSxDQUFDLHNCQUFzQixDQUFDLGtDQUFrQyxDQUM1RCxXQUFXLENBQ1osQ0FBQztZQUNGLElBQUksV0FBVyxDQUFDLFVBQVUsRUFBRTtnQkFDMUIsb0JBQW9CLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixDQUNoRCxXQUFXLENBQUMsVUFBVSxDQUN2QixDQUFDO2dCQUNGLEtBQUssTUFBTSxDQUFDLElBQUksV0FBVyxDQUFDLFVBQVUsRUFBRTtvQkFDdEMsY0FBYyxJQUFJLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztvQkFDbkUsOENBQThDO29CQUM5QyxJQUNFLFdBQVcsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQzt3QkFDakMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUNqQzt3QkFDQSxjQUFjLElBQUksSUFBSSxDQUFDO3FCQUN4QjtpQkFDRjthQUNGO1lBRUQsMkJBQTJCO1lBQzNCLGdEQUFnRDtZQUNoRCxNQUFNLFVBQVUsR0FBRyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQztZQUV6RCxNQUFNLElBQUksR0FDUixjQUFjLENBQUMsTUFBTSxHQUFHLENBQUM7Z0JBQ3ZCLENBQUMsQ0FBQyxpQkFBaUIsY0FBYyxHQUFHO2dCQUNwQyxDQUFDLENBQUMsK0JBQStCLENBQUM7WUFDdEMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQ2pCLEdBQUcsVUFBVSxJQUFJLFNBQVMsSUFBSSxvQkFBb0IsMkJBQTJCLElBQUksSUFBSSxDQUN0RixDQUFDO1lBQ0YsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1NBQ2xCO1FBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQ1oscUhBQXFILENBQ3RILENBQUM7UUFDRixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FDWiwyRUFBMkUsQ0FDNUUsQ0FBQztRQUNGLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxrQ0FBa0MsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUM1RSxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN6QixJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FDakIsYUFBYSxTQUFTLHlDQUF5QyxDQUNoRSxDQUFDO1FBQ0YsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1FBRWpCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUNaLDZGQUE2RixDQUM5RixDQUFDO1FBQ0YsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsa0RBQWtELENBQUMsQ0FBQztRQUNuRSxJQUFJLENBQUMsc0JBQXNCLENBQUMsa0NBQWtDLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDNUUsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQ2pCLGFBQWEsU0FBUyxrQ0FBa0MsQ0FDekQsQ0FBQztRQUNGLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFFdkIsNkVBQTZFO1FBQzdFLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRVMsVUFBVSxDQUFDLEdBQW1CO1FBQ3RDLElBQUksR0FBRyxDQUFDLFFBQVEsRUFBRTtZQUNoQixJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDOUI7UUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ3ZCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdkQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ3hELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNuRSxDQUFDO0lBRVMsT0FBTyxDQUNmLElBQW9CLEVBQ3BCLEtBQW9CLEVBQ3BCLE1BQWdDO1FBRWhDLFVBQVU7SUFDWixDQUFDO0lBRVMsUUFBUSxDQUFDLEdBQW1CLEVBQUUsTUFBbUI7UUFDekQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFUyxnQkFBZ0IsQ0FDeEIsR0FBbUIsRUFDbkIsUUFBcUIsRUFDckIsZUFBNEI7UUFFNUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUVTLFVBQVUsQ0FBQyxHQUFtQixFQUFFLElBQW1CO1FBQzNELElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRVMsY0FBYyxDQUFDLEdBQW1CLEVBQUUsTUFBbUI7UUFDL0QsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFUyxzQkFBc0IsQ0FDOUIsR0FBbUIsRUFDbkIsUUFBcUIsRUFDckIsZUFBNEI7UUFFNUIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFUyxnQkFBZ0IsQ0FBQyxHQUFtQixFQUFFLElBQW1CO1FBQ2pFLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNkLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDbkM7YUFBTTtZQUNMLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztTQUNuQztJQUNILENBQUM7SUFFUyxlQUFlLENBQ3ZCLEdBQW1CLEVBQ25CLElBQW1CLEVBQ25CLE1BQStCO1FBRS9CLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRVMsV0FBVyxDQUFDLEdBQWtCO1FBQ3RDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMxRCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDeEQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQy9ELElBQUksQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO1FBQzlCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFO1lBQ3BDLEdBQUcsRUFBRSxNQUFNO1lBQ1gsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHO1NBQ2IsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLHNCQUFzQixDQUFDLHFCQUFxQixDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUNqRSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxlQUFlLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFUyxTQUFTLENBQUMsR0FBa0I7UUFDcEMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUN2QixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDMUQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ3hELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNsRSxDQUFDO0lBRVMsWUFBWSxDQUFDLEdBQWtCLEVBQUUsTUFBdUI7UUFDaEUsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUU7WUFDdkMsR0FBRyxFQUFFLFFBQVE7WUFDYixHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUc7WUFDWixVQUFVLEVBQUUsTUFBTSxDQUFDLElBQUk7U0FDeEIsQ0FBQyxDQUFDO1FBQ0gsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxxQkFBcUIsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDekUsSUFBSSxDQUFDLHNCQUFzQixDQUFDLDJCQUEyQixDQUNyRCxjQUFjLEVBQ2QsTUFBTSxDQUNQLENBQUM7UUFDRiwyREFBMkQ7UUFDM0QsSUFBSSxHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDMUQsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxjQUFjLEdBQUcsQ0FBQyxDQUFDO1NBQ3RDO2FBQU07WUFDTCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLGNBQWMsRUFBRSxDQUFDLENBQUM7U0FDckM7SUFDSCxDQUFDO0lBRU8sWUFBWSxDQUFDLElBQW1CLEVBQUUsSUFBZTs7UUFDdkQsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUN4QixPQUFPLEVBQUUsSUFBSSxJQUFJLElBQUksT0FBQSxJQUFJLENBQUMsS0FBSywwQ0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLElBQUksRUFBRSxFQUFFLE1BQUssSUFBSSxFQUFFO1lBQy9ELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDakQsRUFBRSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUM7U0FDeEI7UUFDRCxJQUFJLEVBQUUsSUFBSSxJQUFJLEVBQUU7WUFDZCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7U0FDaEU7UUFDRCxPQUFPLElBQUksQ0FBQyxPQUFRLENBQUMsTUFBTyxDQUFDLFNBQVMsQ0FBQztJQUN6QyxDQUFDO0lBRU8sVUFBVSxDQUNoQixHQUF3QyxFQUN4QyxNQUFtQixFQUNuQixZQUF1QixFQUN2QixzQkFBc0IsR0FBRyxLQUFLO1FBRTlCLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO1FBQzlCLE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxPQUFPO1lBQy9CLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztZQUNyRCxDQUFDLENBQUMsTUFBTSxDQUFDO1FBQ1gsTUFBTSxhQUFhLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDckQsSUFBSSxlQUFlLEdBQUcsRUFBRSxDQUFDO1FBQ3pCLElBQUksY0FBYyxHQUFHLEVBQUUsQ0FBQztRQUV4QixJQUFJLGlCQUFpQixHQUFHLEtBQUssQ0FBQztRQUM5Qiw0RkFBNEY7UUFDNUYsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3pCLGlCQUFpQixHQUFHLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDakU7UUFDRCx5SUFBeUk7UUFDekksSUFBSSxTQUFTLEdBQ1gsaUJBQWlCLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxJQUFJLHNCQUFzQixDQUFDLENBQUM7UUFDekUsd0VBQXdFO1FBQ3hFLElBQUksTUFBTSxDQUFDLFNBQVMsRUFBRTtZQUNwQixNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNyRCxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLEVBQUU7Z0JBQ2xDLDZDQUE2QztnQkFDN0MsU0FBUyxHQUFHLElBQUksQ0FBQzthQUNsQjtTQUNGO1FBQ0QsSUFBSSxTQUFTLEVBQUU7WUFDYiwrR0FBK0c7WUFDL0csNEdBQTRHO1lBQzVHLDRHQUE0RztZQUM1Ryx5REFBeUQ7WUFDekQsZUFBZSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDO1NBQ3hEO2FBQU0sSUFDTCxDQUFDLE1BQU0sQ0FBQyxNQUFNO1lBQ2QsQ0FBQyxNQUFNLENBQUMsUUFBUSxJQUFJLENBQUMsaUJBQWlCLENBQUM7WUFDdkMsQ0FBQyxzQkFBc0IsRUFDdkI7WUFDQSx1SUFBdUk7WUFDdkksaURBQWlEO1lBQ2pELGNBQWMsR0FBRyxVQUFVLENBQUM7U0FDN0I7UUFFRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDOUMsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFakUsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLE9BQU8sSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDeEUsTUFBTSxTQUFTLEdBQUcsR0FBRyxVQUFVLEdBQUcsVUFBVSxJQUFJLFVBQVUsSUFBSSxJQUFJLENBQUMsc0JBQXNCLENBQ3ZGLE1BQU0sQ0FDUCxHQUFHLENBQUM7UUFFTCxJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRTtZQUN2QyxHQUFHLEVBQUUsUUFBUTtZQUNiLEdBQUcsRUFBRSxZQUFZLENBQUMsR0FBRztZQUNyQixVQUFVLEVBQUUsTUFBTSxDQUFDLElBQUk7U0FDeEIsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLHNCQUFzQixDQUFDLHVCQUF1QixDQUNqRCxHQUFHLEVBQ0gsTUFBTSxDQUFDLDRCQUE0QixDQUNwQyxDQUFDO1FBRUYsSUFBSSxNQUFNLENBQUMsUUFBUSxFQUFFO1lBQ25CLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxJQUFJLGVBQWUsWUFBWSxTQUFTLEdBQUcsQ0FBQyxDQUFDO1lBQ3JFLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDbEI7YUFBTTtZQUNMLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUNqQixHQUFHLE1BQU0sSUFBSSxhQUFhLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxTQUFTLEVBQUUsQ0FDNUUsQ0FBQztZQUNGLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUNaLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyw0QkFBNEIsQ0FDdEQsTUFBTSxFQUNOLEdBQXFCLENBQ3RCLENBQ0YsQ0FBQztZQUNGLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7U0FDeEI7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLHlCQUF5QixDQUMvQixHQUFtQixFQUNuQixNQUFtQztRQUVuQyxJQUFJLE1BQXFCLEVBQUU7WUFDekIsTUFBTSxhQUFhLEdBQUcsQ0FBQyxVQUFVLEVBQUUsYUFBYSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQzVELHlFQUF5RTtZQUN6RSxJQUNFLGFBQWEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFDckU7Z0JBQ0EsT0FBTyxJQUFJLENBQUM7YUFDYjtTQUNGO1FBRUQsTUFBTSxJQUFJLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQztRQUN0QixJQUFJLElBQUksRUFBRTtZQUNSLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFtQixDQUFDO1lBRXZELElBQUksTUFBdUIsRUFBRTtnQkFDM0IsSUFBSSxRQUFRLENBQUMsVUFBVSxFQUFFO29CQUN2QixJQUNFLFFBQVEsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUN4QixDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxNQUFNLENBQUMsSUFBSSxDQUM1QyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQ1o7d0JBQ0EsZ0NBQWdDO3dCQUNoQyxPQUFPLElBQUksQ0FBQztxQkFDYjtpQkFDRjtnQkFDRCxPQUFPLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7YUFDekQ7aUJBQU0sSUFBSSxNQUFxQixFQUFFO2dCQUNoQyxJQUFJLFFBQVEsQ0FBQyxPQUFPLEVBQUU7b0JBQ3BCLE1BQU0sUUFBUSxHQUFHLE1BQXFCLENBQUM7b0JBQ3ZDLHFGQUFxRjtvQkFDckYsS0FBSyxNQUFNLENBQUMsSUFBSSxRQUFRLENBQUMsT0FBTyxFQUFFO3dCQUNoQyxJQUNFLENBQUMsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLElBQUk7NEJBQ3hCLENBQUMsQ0FBQyxVQUFVLEtBQUssUUFBUSxDQUFDLFVBQVU7NEJBQ3BDLENBQUMsQ0FBQyxPQUFPLEtBQUssUUFBUSxDQUFDLE9BQU8sRUFDOUI7NEJBQ0EsT0FBTyxJQUFJLENBQUM7eUJBQ2I7cUJBQ0Y7aUJBQ0Y7Z0JBQ0QsT0FBTyxJQUFJLENBQUMseUJBQXlCLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO2FBQ3pEO1lBQ0QsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVEOztPQUVHO0lBQ0ssc0JBQXNCLENBQUMsTUFBbUI7UUFDaEQsT0FBTyxJQUFJLENBQUMsc0JBQXNCLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFFRDs7T0FFRztJQUNLLHNCQUFzQixDQUM1QixVQUF3QztRQUV4QyxNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUM7UUFDbEIsSUFBSSxVQUFVLEVBQUU7WUFDZCxLQUFLLE1BQU0sQ0FBQyxJQUFJLFVBQVUsRUFBRTtnQkFDMUIsSUFBSSxpQkFBaUIsR0FBRyxFQUFFLENBQUM7Z0JBQzNCLElBQUksZUFBZSxHQUFHLEVBQUUsQ0FBQztnQkFDekIsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNsRCxJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUU7b0JBQ2QsZUFBZSxHQUFHLFNBQVMsQ0FBQztvQkFDNUIsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFO3dCQUNkLGlCQUFpQixHQUFHLEdBQUcsQ0FBQztxQkFDekI7aUJBQ0Y7cUJBQU0sSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFO29CQUNyQixJQUFJLEdBQUcsVUFBVSxJQUFJLElBQUksQ0FBQztpQkFDM0I7Z0JBQ0QsTUFBTSxFQUFFLEdBQUcsR0FBRyxJQUFJLEdBQUcsaUJBQWlCLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxvQkFBb0IsQ0FDM0UsQ0FBQyxDQUFDLElBQUksQ0FDUCxHQUFHLGVBQWUsRUFBRSxDQUFDO2dCQUN0QixNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQ2pCO1NBQ0Y7UUFDRCxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEOztPQUVHO0lBQ0ssa0JBQWtCLENBQUMsR0FBd0M7UUFDakUsTUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDO1FBQ3RCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUN4RCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDdEIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFFakQsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNqQixJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRTtZQUNwQyxHQUFHLEVBQUUsTUFBTTtZQUNYLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRztTQUNiLENBQUMsQ0FBQztRQUNILElBQUksQ0FBQyxzQkFBc0IsQ0FBQywrQkFBK0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVqRSxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDNUQsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUM7WUFDdEMsQ0FBQyxDQUFDLGlCQUFpQixZQUFZLEVBQUU7WUFDakMsQ0FBQyxDQUFDLEtBQUssWUFBWSxFQUFFLENBQUM7UUFDeEIsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLHVCQUF1QixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUVwRSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FDakIsR0FBRyxXQUFXLHlCQUF5QixJQUFJLElBQUksTUFBTSxFQUFFLENBQ3hELENBQUM7UUFFRixpQ0FBaUM7UUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQ2pCLFdBQVcsSUFBSSx5Q0FBeUMsQ0FDekQsQ0FBQztRQUNGLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFFdkIsdUZBQXVGO1FBQ3ZGLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVsQyxNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUM7UUFDdkIsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDO1FBQ25CLElBQUksQ0FBQyxzQ0FBc0MsQ0FBQyxHQUFHLEVBQUUsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRWxFLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDdkIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7OztPQWNHO0lBQ0ssdUJBQXVCLENBQzdCLElBQXlDOztRQUV6QyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDMUIsSUFBSSxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksRUFBRTtnQkFDckIsT0FBTyxLQUFLLENBQUM7YUFDZDtZQUVELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBbUIsQ0FBQztZQUN4RCxPQUFPLENBQ0wsSUFBSSxDQUFDLFFBQVEsS0FBSyxJQUFJLENBQUMsUUFBUTtnQkFDL0IsQ0FBQyxJQUFJLENBQUMsUUFBUTtvQkFDWixDQUFDLENBQUMsSUFBSTtvQkFDTixDQUFDLENBQUMsMEdBQTBHO3dCQUMxRyxJQUFJLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FDeEMsQ0FBQztTQUNIO1FBRUQsT0FBTyxDQUNMLE9BQUEsSUFBSSxDQUFDLFVBQVUsMENBQUUsSUFBSSxDQUNuQixDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLEtBQUssSUFBSSxDQUFDLFFBQVEsTUFDbkQsSUFBSSxDQUNWLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSyxxQkFBcUIsQ0FBQyxHQUF1Qjs7UUFDbkQsb0ZBQW9GO1FBQ3BGLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbEQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ3hELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDcEMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFFakQsSUFBSSxPQUFBLEdBQUcsQ0FBQyxVQUFVLDBDQUFFLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxNQUFLLElBQUksRUFBRTtZQUMxRCxpR0FBaUc7WUFDakcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztZQUNqRCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1NBQ2xCO1FBRUQsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUU7WUFDcEMsR0FBRyxFQUFFLE1BQU07WUFDWCxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUc7U0FDYixDQUFDLENBQUM7UUFDSCxNQUFNLE1BQU0sR0FBRyxLQUFLLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO1FBQzdELElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxrQ0FBa0MsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNwRSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsSUFBSSxJQUFJLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFDdEQsSUFBSSxDQUFDLHNCQUFzQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ25DLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQztRQUN0QixNQUFNLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDcEIsSUFBSSxDQUFDLHNDQUFzQyxDQUFDLEdBQUcsRUFBRSxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDbEUsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLHNDQUFzQyxDQUM1QyxHQUF3QyxFQUN4QyxRQUFpQixFQUNqQixLQUFjO1FBRWQsa0VBQWtFO1FBQ2xFLE1BQU0sT0FBTyxHQUFHLElBQUksR0FBRyxFQUE0QixDQUFDO1FBQ3BEOzs7OztjQUtNO1FBQ04sTUFBTSxjQUFjLEdBQWEsRUFBRSxDQUFDLENBQUMsd0VBQXdFO1FBQzdHLE1BQU0sa0JBQWtCLEdBQWEsRUFBRSxDQUFDLENBQUMsMkVBQTJFO1FBQ3BILE1BQU0sVUFBVSxHQUEyQyxFQUFFLENBQUM7UUFDOUQsTUFBTSxzQkFBc0IsR0FBRyxDQUM3QixXQUFnRCxFQUNoRCxFQUFFOztZQUNGLEtBQUssTUFBTSxJQUFJLFVBQUksV0FBVyxDQUFDLFVBQVUsbUNBQUksRUFBRSxFQUFFO2dCQUMvQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRTtvQkFDM0MsZ0ZBQWdGO29CQUNoRixJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7d0JBQ2pCLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLFdBQVcsRUFBRSxDQUFDO3FCQUM3RDtvQkFDRCxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUNwQzthQUNGO1lBRUQsS0FBSyxNQUFNLE1BQU0sVUFBSSxXQUFXLENBQUMsT0FBTyxtQ0FBSSxFQUFFLEVBQUU7Z0JBQzlDLElBQUksZ0JBQWdCLEdBQUcsRUFBRSxDQUFDO2dCQUMxQixJQUFJLE1BQU0sQ0FBQyxVQUFVLEVBQUU7b0JBQ3JCLE1BQU0sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUU7d0JBQ2xDLGdCQUFnQixJQUFJLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxZQUFZLENBQ3BELEtBQUssQ0FBQyxJQUFJLENBQ1gsRUFBRSxDQUFDO29CQUNOLENBQUMsQ0FBQyxDQUFDO2lCQUNKO2dCQUNELElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksR0FBRyxnQkFBZ0IsRUFBRSxDQUFDLEVBQUU7b0JBQ2pFLDhFQUE4RTtvQkFDOUUsSUFBSSxNQUFNLENBQUMsUUFBUSxFQUFFO3dCQUNuQixPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksR0FBRyxnQkFBZ0IsRUFBRSxFQUFFOzRCQUMvQyxNQUFNOzRCQUNOLFlBQVksRUFBRSxXQUFXO3lCQUMxQixDQUFDLENBQUM7cUJBQ0o7b0JBQ0QsY0FBYyxDQUFDLElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLEdBQUcsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDO2lCQUMxRDthQUNGO1lBRUQsTUFBTSxLQUFLLEdBQUcsSUFBSSxLQUFLLEVBQTJCLENBQUM7WUFDbkQsS0FBSyxDQUFDLElBQUksQ0FDUixHQUFHLE9BQUMsV0FBVyxDQUFDLFVBQVUsbUNBQUksRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQ3ZFLENBQUM7WUFDRixJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLElBQUksV0FBVyxDQUFDLElBQUksRUFBRTtnQkFDckQsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO2FBQzdDO1lBQ0QsS0FBSyxNQUFNLElBQUksSUFBSSxLQUFLLEVBQUU7Z0JBQ3hCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUNyQyxJQUNFLElBQUksQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTO29CQUNyQyxJQUFJLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUNqQztvQkFDQSxNQUFNLElBQUksS0FBSyxDQUNiLG9FQUFvRSxJQUFJLENBQUMsR0FBRyxlQUFlLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FDeEcsQ0FBQztpQkFDSDtnQkFDRCxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUM5QjtRQUNILENBQUMsQ0FBQztRQUNGLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRTVCLHNCQUFzQjtRQUN0QixLQUFLLE1BQU0sUUFBUSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDOUMsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ3pDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztZQUMzQixJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUUsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQ3ZFO1FBQ0QsdUJBQXVCO1FBQ3ZCLEtBQUssTUFBTSx1QkFBdUIsSUFBSSxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDcEQsTUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1lBQzVELElBQUksY0FBYyxFQUFFO2dCQUNsQixNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUM7Z0JBQ3JDLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztnQkFDL0IsSUFBSSxDQUFDLFVBQVUsQ0FDYixHQUFHLEVBQ0gsTUFBTSxDQUFDLE1BQU0sRUFDYixNQUFNLENBQUMsWUFBWTtnQkFDbkIsNEJBQTRCLENBQUMsSUFBSSxDQUNsQyxDQUFDO2dCQUVGLEtBQUssTUFBTSxnQkFBZ0IsSUFBSSxJQUFJLENBQUMsMkJBQTJCLENBQzdELE1BQU0sQ0FBQyxNQUFNLENBQ2QsRUFBRTtvQkFDRCxnQkFBZ0IsQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO29CQUNsQyxJQUFJLENBQUMsVUFBVSxDQUNiLEdBQUcsRUFDSCxnQkFBZ0IsRUFDaEIsTUFBTSxDQUFDLFlBQVk7b0JBQ25CLDRCQUE0QixDQUFDLElBQUksQ0FDbEMsQ0FBQztpQkFDSDthQUNGO1NBQ0Y7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSyxZQUFZLENBQ2xCLEdBQWMsRUFDZCxJQUFtQixFQUNuQixZQUF1QixFQUN2QixRQUFRLEdBQUcsS0FBSyxFQUNoQixLQUFLLEdBQUcsS0FBSztRQUViLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO1FBRTlCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN6RCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDNUMsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDbkQsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFL0QsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUU7WUFDckMsR0FBRyxFQUFFLFFBQVE7WUFDYixHQUFHLEVBQUUsWUFBWSxDQUFDLEdBQUc7WUFDckIsVUFBVSxFQUFFLElBQUksQ0FBQyxJQUFJO1NBQ3RCLENBQUMsQ0FBQztRQUNILElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNqQixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1NBQ2xDO1FBQ0QsSUFBSSxDQUFDLHNCQUFzQixDQUFDLHlCQUF5QixDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztRQUV0RSxJQUFJLGlCQUFpQixHQUFHLEVBQUUsQ0FBQztRQUMzQixJQUFJLGdCQUFnQixHQUFHLEVBQUUsQ0FBQztRQUMxQixJQUFJLGlCQUFpQixHQUFHLEVBQUUsQ0FBQztRQUUzQixnQ0FBZ0M7UUFDaEMsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3pCLE1BQU0saUJBQWlCLEdBQUcsSUFBSSxDQUFDLHlCQUF5QixDQUN0RCxHQUFxQixFQUNyQixJQUFJLENBQ0wsQ0FBQztZQUNGLElBQUksaUJBQWlCLElBQUksUUFBUSxJQUFJLEtBQUssRUFBRTtnQkFDMUMsMkdBQTJHO2dCQUMzRyw4R0FBOEc7Z0JBQzlHLDRHQUE0RztnQkFDNUcsd0NBQXdDO2dCQUN4QyxpQkFBaUIsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQzthQUN4RDtpQkFBTSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQ3hCLHlDQUF5QztnQkFDekMsaUJBQWlCLEdBQUcsV0FBVyxDQUFDO2FBQ2pDO2lCQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7Z0JBQzdDLCtHQUErRztnQkFDL0csZ0JBQWdCLEdBQUcsVUFBVSxDQUFDO2FBQy9CO1NBQ0Y7UUFFRCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDOUQsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDNUMsTUFBTSxTQUFTLEdBQUcsR0FBRyxNQUFNLElBQUksaUJBQWlCLEdBQUcsZ0JBQWdCLEdBQUcsYUFBYSxHQUFHLGlCQUFpQixHQUFHLFdBQVcsR0FBRyxVQUFVLElBQUksUUFBUSxFQUFFLENBQUM7UUFDakosSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFL0IsZUFBZTtRQUNmLElBQUksUUFBUSxJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUMzQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUN4QjthQUFNO1lBQ0wsMEVBQTBFO1lBQzFFLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO1lBQ3RDLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDZixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FDWiw0QkFBNEIsV0FBVyxHQUFHLFVBQVUsWUFBWSxTQUFTLEtBQUssSUFBSSxHQUFHLENBQ3RGLENBQUM7YUFDSDtpQkFBTTtnQkFDTCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FDWiw4QkFBOEIsV0FBVyxHQUFHLFVBQVUsTUFBTSxJQUFJLEdBQUcsQ0FDcEUsQ0FBQzthQUNIO1NBQ0Y7UUFFRCxlQUFlO1FBQ2YsSUFBSSxRQUFRLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ2xELElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ3hCO2FBQU07WUFDTCxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRTtnQkFDbkIsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO29CQUNmLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUNaLG1DQUFtQyxTQUFTLFlBQVksQ0FDekQsQ0FBQztpQkFDSDtxQkFBTTtvQkFDTCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO2lCQUN0RDthQUNGO1NBQ0Y7UUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBRXZCLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUQ7O09BRUc7SUFDSyxpQkFBaUIsQ0FBQyxHQUFtQixFQUFFLElBQW1CO1FBQ2hFLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO1FBQzlCLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNsQyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDM0QsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDNUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUU7WUFDckMsR0FBRyxFQUFFLFFBQVE7WUFDYixHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUc7WUFDWixVQUFVLEVBQUUsSUFBSSxDQUFDLElBQUk7U0FDdEIsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLHNCQUFzQixDQUFDLHlCQUF5QixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzVELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1QyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMvRCxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUVuRCxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FDakIsR0FBRyxNQUFNLElBQUksYUFBYSxHQUFHLFFBQVEsR0FBRyxVQUFVLElBQUksUUFBUSxFQUFFLENBQ2pFLENBQUM7UUFDRixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ3ZCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN6RCw4RUFBOEU7UUFDOUUsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7UUFDdEMsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLE1BQU07WUFDN0IsQ0FBQyxDQUFDLHVCQUF1QixRQUFRLFlBQVksU0FBUyxLQUFLLElBQUksR0FBRztZQUNsRSxDQUFDLENBQUMseUJBQXlCLFFBQVEsWUFBWSxTQUFTLEtBQUssSUFBSSxHQUFHLENBQUM7UUFDdkUsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVPLGlCQUFpQixDQUFDLE1BQW1DO1FBQzNELE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7SUFDbkQsQ0FBQztJQUVPLFFBQVEsQ0FBQyxJQUFlO1FBQzlCLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDM0MsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUNELE1BQU0sTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDcEQsT0FBTyxNQUFNLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUM7SUFDdkMsQ0FBQztJQUVPLGdCQUFnQixDQUFDLElBQVk7UUFDbkMsT0FBTyxHQUFHLElBQUksS0FBSyxDQUFDO0lBQ3RCLENBQUM7SUFFTyxnQkFBZ0IsQ0FDdEIsUUFBZ0IsRUFDaEIsU0FBaUIsRUFDakIsUUFBaUIsRUFDakIsV0FBVyxHQUFHLElBQUk7O1FBRWxCLGlEQUFpRDtRQUNqRCxJQUFJLFFBQVEsRUFBRTtZQUNaLE9BQU87U0FDUjtRQUVELE1BQU0sZUFBZSxlQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTywwQ0FBRSxNQUFNLDBDQUFFLFNBQVMsQ0FBQztRQUNqRSxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3BCLE1BQU0sSUFBSSxLQUFLLENBQ2IsY0FBYyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksMkNBQTJDLENBQzVFLENBQUM7U0FDSDtRQUNELE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ2hELElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUNoQixJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQ3RFLENBQUM7UUFDRixJQUFJLFdBQVcsRUFBRTtZQUNmLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLG1DQUFtQyxDQUFDLENBQUM7WUFDcEQsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUNsQjtRQUVELG1FQUFtRTtRQUNuRSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyw4Q0FBOEMsQ0FBQyxDQUFDO1FBQy9ELElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7UUFFakIsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxTQUFTLEVBQUUsQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFTyxpQkFBaUIsQ0FDdkIsUUFBZ0IsRUFDaEIsU0FBaUIsRUFDakIsUUFBaUI7O1FBRWpCLElBQUksUUFBUSxFQUFFO1lBQ1osT0FBTztTQUNSO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUV2QixNQUFNLGVBQWUsZUFBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sMENBQUUsTUFBTSwwQ0FBRSxTQUFTLENBQUM7UUFDakUsSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUNwQixNQUFNLElBQUksS0FBSyxDQUNiLGNBQWMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLDJDQUEyQyxDQUM1RSxDQUFDO1NBQ0g7UUFDRCxNQUFNLFFBQVEsR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztRQUNoRCxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FDakIsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUN0RSxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxzQkFBc0IsQ0FBQyxLQUFjO1FBQzNDLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxLQUFLLENBQUM7SUFDbEMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxzQkFBc0I7UUFDNUIsK0VBQStFO1FBQy9FLElBQUksSUFBSSxDQUFDLGtCQUFrQixFQUFFO1lBQzNCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDbEI7YUFBTTtZQUNMLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxLQUFLLENBQUM7U0FDakM7SUFDSCxDQUFDO0lBRU8sZ0JBQWdCO1FBQ3RCLElBQUksQ0FBQyxpQkFBaUIsQ0FDcEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFRLENBQUMsTUFBTyxDQUFDLFNBQVMsRUFDeEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQ2xCLElBQUksQ0FBQyxRQUFRLENBQ2QsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7T0FXRztJQUNLLGlCQUFpQixDQUN2QixTQUFpQixFQUNqQixPQUFlLEVBQ2YsU0FBMEI7UUFFMUIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUU7WUFDckIsT0FBTztTQUNSO1FBRUQsTUFBTSxTQUFTLEdBQUcsY0FBYyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztRQUUxRCxJQUFJLENBQUMsa0JBQWtCLENBQUMscUJBQXFCLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUU7WUFDdkUsR0FBRyxFQUFFLGNBQWM7WUFDbkIsU0FBUyxFQUFFLE9BQU87U0FDbkIsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDekIsc0dBQXNHO1FBQ3RHLDBHQUEwRztRQUMxRyw0Q0FBNEM7UUFDNUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLFNBQVMsRUFBRSxDQUFDLENBQUM7UUFDakQsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsaUJBQWlCLENBQUMsU0FBUyxFQUFFLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRUQ7O09BRUc7SUFDSyxpQkFBaUI7UUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQ1osMkZBQTJGLENBQzVGLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUFwcENELDBDQW9wQ0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBzcGVjIGZyb20gJ0Bqc2lpL3NwZWMnO1xuaW1wb3J0ICogYXMgY2xvbmUgZnJvbSAnY2xvbmUnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgcmVmbGVjdCBmcm9tICdqc2lpLXJlZmxlY3QnO1xuaW1wb3J0IHsgUm9zZXR0YSB9IGZyb20gJ2pzaWktcm9zZXR0YSc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyBHZW5lcmF0b3IsIExlZ2FsZXNlIH0gZnJvbSAnLi4vLi4vZ2VuZXJhdG9yJztcbmltcG9ydCB7IE1ldGhvZERlZmluaXRpb24sIFByb3BlcnR5RGVmaW5pdGlvbiB9IGZyb20gJy4uL191dGlscyc7XG5pbXBvcnQgeyBEb3ROZXREb2NHZW5lcmF0b3IgfSBmcm9tICcuL2RvdG5ldGRvY2dlbmVyYXRvcic7XG5pbXBvcnQgeyBEb3ROZXRSdW50aW1lR2VuZXJhdG9yIH0gZnJvbSAnLi9kb3RuZXRydW50aW1lZ2VuZXJhdG9yJztcbmltcG9ydCB7IERvdE5ldFR5cGVSZXNvbHZlciB9IGZyb20gJy4vZG90bmV0dHlwZXJlc29sdmVyJztcbmltcG9ydCB7IEZpbGVHZW5lcmF0b3IgfSBmcm9tICcuL2ZpbGVnZW5lcmF0b3InO1xuaW1wb3J0IHsgRG90TmV0TmFtZVV0aWxzIH0gZnJvbSAnLi9uYW1ldXRpbHMnO1xuXG4vKipcbiAqIENPREUgR0VORVJBVE9SIFYyXG4gKi9cbmV4cG9ydCBjbGFzcyBEb3ROZXRHZW5lcmF0b3IgZXh0ZW5kcyBHZW5lcmF0b3Ige1xuICAvLyBGbGFncyB0aGF0IHRyYWNrcyBpZiB3ZSBoYXZlIGFscmVhZHkgd3JvdGUgdGhlIGZpcnN0IG1lbWJlciBvZiB0aGUgY2xhc3NcbiAgcHJpdmF0ZSBmaXJzdE1lbWJlcldyaXR0ZW4gPSBmYWxzZTtcblxuICBwcml2YXRlIHR5cGVyZXNvbHZlciE6IERvdE5ldFR5cGVSZXNvbHZlcjtcblxuICBwcml2YXRlIHJlYWRvbmx5IG5hbWV1dGlsczogRG90TmV0TmFtZVV0aWxzID0gbmV3IERvdE5ldE5hbWVVdGlscygpO1xuXG4gIHByaXZhdGUgZG90bmV0UnVudGltZUdlbmVyYXRvciE6IERvdE5ldFJ1bnRpbWVHZW5lcmF0b3I7XG5cbiAgcHJpdmF0ZSBkb3RuZXREb2NHZW5lcmF0b3IhOiBEb3ROZXREb2NHZW5lcmF0b3I7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYXNzZW1ibGllc0N1cnJlbnRseUJlaW5nQ29tcGlsZWQ6IHN0cmluZ1tdLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcm9zZXR0YTogUm9zZXR0YSxcbiAgKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8vIE92ZXJyaWRlIHRoZSBvcGVuQmxvY2sgdG8gZ2V0IGEgY29ycmVjdCBDIyBsb29raW5nIGNvZGUgYmxvY2sgd2l0aCB0aGUgY3VybHkgYnJhY2UgYWZ0ZXIgdGhlIGxpbmVcbiAgICB0aGlzLmNvZGUub3BlbkJsb2NrID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgIHRoaXMubGluZSh0ZXh0KTtcbiAgICAgIHRoaXMub3BlbigneycpO1xuICAgIH07XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgbG9hZChcbiAgICBwYWNrYWdlUm9vdDogc3RyaW5nLFxuICAgIGFzc2VtYmx5OiByZWZsZWN0LkFzc2VtYmx5LFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCBzdXBlci5sb2FkKHBhY2thZ2VSb290LCBhc3NlbWJseSk7XG4gIH1cblxuICAvKipcbiAgICogUnVucyB0aGUgZ2VuZXJhdG9yIChpbi1tZW1vcnkpLlxuICAgKi9cbiAgcHVibGljIGdlbmVyYXRlKGZpbmdlcnByaW50OiBib29sZWFuKSB7XG4gICAgdGhpcy50eXBlcmVzb2x2ZXIgPSBuZXcgRG90TmV0VHlwZVJlc29sdmVyKFxuICAgICAgdGhpcy5hc3NlbWJseSxcbiAgICAgIChmcW46IHN0cmluZykgPT4gdGhpcy5maW5kTW9kdWxlKGZxbiksXG4gICAgICAoZnFuOiBzdHJpbmcpID0+IHRoaXMuZmluZFR5cGUoZnFuKSxcbiAgICAgIHRoaXMuYXNzZW1ibGllc0N1cnJlbnRseUJlaW5nQ29tcGlsZWQsXG4gICAgKTtcblxuICAgIHRoaXMuZG90bmV0UnVudGltZUdlbmVyYXRvciA9IG5ldyBEb3ROZXRSdW50aW1lR2VuZXJhdG9yKFxuICAgICAgdGhpcy5jb2RlLFxuICAgICAgdGhpcy50eXBlcmVzb2x2ZXIsXG4gICAgKTtcbiAgICB0aGlzLmRvdG5ldERvY0dlbmVyYXRvciA9IG5ldyBEb3ROZXREb2NHZW5lcmF0b3IoXG4gICAgICB0aGlzLmNvZGUsXG4gICAgICB0aGlzLnJvc2V0dGEsXG4gICAgICB0aGlzLmFzc2VtYmx5LFxuICAgICk7XG5cbiAgICB0aGlzLmVtaXRBc3NlbWJseURvY3MoKTtcblxuICAgIC8vIFdlIG5lZWQgdG8gcmVzb2x2ZSB0aGUgZGVwZW5kZW5jeSB0cmVlXG4gICAgdGhpcy50eXBlcmVzb2x2ZXIucmVzb2x2ZU5hbWVzcGFjZXNEZXBlbmRlbmNpZXMoKTtcbiAgICBzdXBlci5nZW5lcmF0ZShmaW5nZXJwcmludCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc2F2ZShcbiAgICBvdXRkaXI6IHN0cmluZyxcbiAgICB0YXJiYWxsOiBzdHJpbmcsXG4gICAgeyBsaWNlbnNlLCBub3RpY2UgfTogTGVnYWxlc2UsXG4gICk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAvLyBHZW5lcmF0aW5nIHRoZSBjc3Byb2ogYW5kIEFzc2VtYmx5SW5mby5jcyBmaWxlc1xuICAgIGNvbnN0IHRhcmJhbGxGaWxlTmFtZSA9IHBhdGguYmFzZW5hbWUodGFyYmFsbCk7XG4gICAgY29uc3QgZmlsZWdlbiA9IG5ldyBGaWxlR2VuZXJhdG9yKFxuICAgICAgdGhpcy5hc3NlbWJseSxcbiAgICAgIHRhcmJhbGxGaWxlTmFtZSxcbiAgICAgIHRoaXMuY29kZSxcbiAgICApO1xuICAgIGZpbGVnZW4uZ2VuZXJhdGVBc3NlbWJseUluZm9GaWxlKCk7XG4gICAgZmlsZWdlbi5nZW5lcmF0ZVByb2plY3RGaWxlKHRoaXMudHlwZXJlc29sdmVyLm5hbWVzcGFjZURlcGVuZGVuY2llcyk7XG4gICAgLy8gQ2FsbGluZyBzdXBlci5zYXZlKCkgZHVtcHMgdGhlIHRhcmJhbGwgaW4gdGhlIGZvcm1hdCBuYW1lQHZlcnNpb24uanNpaS50Z3ouXG4gICAgLy8gVGhpcyBpcyBub3QgaW4gc3luYyB3aXRoIHRoZSBPbGQgLk5FVCBnZW5lcmF0b3Igd2hlcmUgdGhlIG5hbWUgaXMgc2NvcGUtbmFtZS12ZXJzaW9uLnRnei5cbiAgICAvLyBIZW5jZSB3ZSBhcmUgc2F2aW5nIHRoZSBmaWxlcyBvdXJzZWx2ZXMgaGVyZTpcbiAgICBjb25zdCBhc3NtID0gdGhpcy5hc3NlbWJseTtcbiAgICBjb25zdCBwYWNrYWdlSWQ6IHN0cmluZyA9IGFzc20udGFyZ2V0cyEuZG90bmV0IS5wYWNrYWdlSWQ7XG4gICAgaWYgKCFwYWNrYWdlSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRoZSBtb2R1bGUgJHthc3NtLm5hbWV9IGRvZXMgbm90IGhhdmUgYSBkb3RuZXQucGFja2FnZUlkIHNldHRpbmdgLFxuICAgICAgKTtcbiAgICB9XG4gICAgYXdhaXQgZnMubWtkaXJwKHBhdGguam9pbihvdXRkaXIsIHBhY2thZ2VJZCkpO1xuICAgIGF3YWl0IGZzLmNvcHlGaWxlKHRhcmJhbGwsIHBhdGguam9pbihvdXRkaXIsIHBhY2thZ2VJZCwgdGFyYmFsbEZpbGVOYW1lKSk7XG5cbiAgICAvLyBDcmVhdGUgYW4gYW5jaG9yIGZpbGUgZm9yIHRoZSBjdXJyZW50IG1vZGVsXG4gICAgdGhpcy5nZW5lcmF0ZURlcGVuZGVuY3lBbmNob3JGaWxlKCk7XG5cbiAgICBpZiAobGljZW5zZSkge1xuICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKHBhdGguam9pbihvdXRkaXIsIHBhY2thZ2VJZCwgJ0xJQ0VOU0UnKSwgbGljZW5zZSwge1xuICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChub3RpY2UpIHtcbiAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShwYXRoLmpvaW4ob3V0ZGlyLCBwYWNrYWdlSWQsICdOT1RJQ0UnKSwgbm90aWNlLCB7XG4gICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTYXZpbmcgdGhlIGdlbmVyYXRlZCBjb2RlLlxuICAgIHJldHVybiB0aGlzLmNvZGUuc2F2ZShvdXRkaXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgYW5jaG9yIGZpbGVcbiAgICovXG4gIHByb3RlY3RlZCBnZW5lcmF0ZURlcGVuZGVuY3lBbmNob3JGaWxlKCkge1xuICAgIGNvbnN0IG5hbWVzcGFjZSA9IGAke1xuICAgICAgdGhpcy5hc3NlbWJseS50YXJnZXRzIS5kb3RuZXQhLm5hbWVzcGFjZVxuICAgIH0uSW50ZXJuYWwuRGVwZW5kZW5jeVJlc29sdXRpb25gO1xuICAgIHRoaXMub3BlbkZpbGVJZk5lZWRlZCgnQW5jaG9yJywgbmFtZXNwYWNlLCBmYWxzZSwgZmFsc2UpO1xuICAgIHRoaXMuY29kZS5vcGVuQmxvY2soJ3B1YmxpYyBzZWFsZWQgY2xhc3MgQW5jaG9yJyk7XG4gICAgdGhpcy5jb2RlLm9wZW5CbG9jaygncHVibGljIEFuY2hvcigpJyk7XG4gICAgdGhpcy50eXBlcmVzb2x2ZXIubmFtZXNwYWNlRGVwZW5kZW5jaWVzLmZvckVhY2goKHZhbHVlKSA9PlxuICAgICAgdGhpcy5jb2RlLmxpbmUoXG4gICAgICAgIGBuZXcgJHt2YWx1ZS5uYW1lc3BhY2V9LkludGVybmFsLkRlcGVuZGVuY3lSZXNvbHV0aW9uLkFuY2hvcigpO2AsXG4gICAgICApLFxuICAgICk7XG4gICAgdGhpcy5jb2RlLmNsb3NlQmxvY2soKTtcbiAgICB0aGlzLmNvZGUuY2xvc2VCbG9jaygpO1xuICAgIHRoaXMuY2xvc2VGaWxlSWZOZWVkZWQoJ0FuY2hvcicsIG5hbWVzcGFjZSwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vdCB1c2VkIGFzIHdlIG92ZXJyaWRlIHRoZSBzYXZlKCkgbWV0aG9kXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0QXNzZW1ibHlPdXRwdXREaXIobW9kOiBzcGVjLkFzc2VtYmx5KTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5uYW1ldXRpbHMuY29udmVydFBhY2thZ2VOYW1lKG1vZC5uYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOYW1lc3BhY2VzIGFyZSBoYW5kbGVkIGltcGxpY2l0bHkgYnkgb3BlbkZpbGVJZk5lZWRlZCgpLlxuICAgKlxuICAgKiBEbyBnZW5lcmF0ZSBkb2NzIGlmIHRoaXMgaXMgZm9yIGEgc3VibW9kdWxlIHRob3VnaC5cbiAgICovXG4gIHByb3RlY3RlZCBvbkJlZ2luTmFtZXNwYWNlKGpzaWlOczogc3RyaW5nKSB7XG4gICAgY29uc3Qgc3VibW9kdWxlID0gdGhpcy5hc3NlbWJseS5zdWJtb2R1bGVzPy5banNpaU5zXTtcbiAgICBpZiAoc3VibW9kdWxlKSB7XG4gICAgICBjb25zdCBkb3RuZXROcyA9IHRoaXMudHlwZXJlc29sdmVyLnJlc29sdmVOYW1lc3BhY2UoXG4gICAgICAgIHRoaXMuYXNzZW1ibHksXG4gICAgICAgIHRoaXMuYXNzZW1ibHkubmFtZSxcbiAgICAgICAganNpaU5zLFxuICAgICAgKTtcbiAgICAgIHRoaXMuZW1pdE5hbWVzcGFjZURvY3MoZG90bmV0TnMsIGpzaWlOcywgc3VibW9kdWxlKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25FbmROYW1lc3BhY2UoX25zOiBzdHJpbmcpIHtcbiAgICAvKiBub29wICovXG4gIH1cblxuICBwcm90ZWN0ZWQgb25CZWdpbkludGVyZmFjZShpZmM6IHNwZWMuSW50ZXJmYWNlVHlwZSkge1xuICAgIGNvbnN0IGltcGxlbWVudGF0aW9ucyA9IHRoaXMudHlwZXJlc29sdmVyLnJlc29sdmVJbXBsZW1lbnRlZEludGVyZmFjZXMoaWZjKTtcbiAgICBjb25zdCBpbnRlcmZhY2VOYW1lID0gdGhpcy5uYW1ldXRpbHMuY29udmVydEludGVyZmFjZU5hbWUoaWZjKTtcbiAgICBjb25zdCBuYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZUZvcih0aGlzLmFzc2VtYmx5LCBpZmMpO1xuICAgIHRoaXMub3BlbkZpbGVJZk5lZWRlZChpbnRlcmZhY2VOYW1lLCBuYW1lc3BhY2UsIHRoaXMuaXNOZXN0ZWQoaWZjKSk7XG5cbiAgICB0aGlzLmRvdG5ldERvY0dlbmVyYXRvci5lbWl0RG9jcyhpZmMsIHsgYXBpOiAndHlwZScsIGZxbjogaWZjLmZxbiB9KTtcbiAgICB0aGlzLmRvdG5ldFJ1bnRpbWVHZW5lcmF0b3IuZW1pdEF0dHJpYnV0ZXNGb3JJbnRlcmZhY2UoaWZjKTtcblxuICAgIGlmIChpbXBsZW1lbnRhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5jb2RlLm9wZW5CbG9jayhcbiAgICAgICAgYHB1YmxpYyBpbnRlcmZhY2UgJHtpbnRlcmZhY2VOYW1lfSA6ICR7aW1wbGVtZW50YXRpb25zLmpvaW4oJywgJyl9YCxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29kZS5vcGVuQmxvY2soYHB1YmxpYyBpbnRlcmZhY2UgJHtpbnRlcmZhY2VOYW1lfWApO1xuICAgIH1cbiAgICB0aGlzLmZsYWdGaXJzdE1lbWJlcldyaXR0ZW4oZmFsc2UpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uRW5kSW50ZXJmYWNlKGlmYzogc3BlYy5JbnRlcmZhY2VUeXBlKSB7XG4gICAgLy8gZW1pdCBpbnRlcmZhY2UgcHJveHkgY2xhc3NcbiAgICB0aGlzLmVtaXRJbnRlcmZhY2VQcm94eShpZmMpO1xuXG4gICAgY29uc3QgaW50ZXJmYWNlTmFtZSA9IHRoaXMubmFtZXV0aWxzLmNvbnZlcnRJbnRlcmZhY2VOYW1lKGlmYyk7XG4gICAgdGhpcy5jb2RlLmNsb3NlQmxvY2soKTtcbiAgICBjb25zdCBuYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZUZvcih0aGlzLmFzc2VtYmx5LCBpZmMpO1xuICAgIHRoaXMuY2xvc2VGaWxlSWZOZWVkZWQoaW50ZXJmYWNlTmFtZSwgbmFtZXNwYWNlLCB0aGlzLmlzTmVzdGVkKGlmYykpO1xuXG4gICAgLy8gZW1pdCBpbXBsZW1lbnRhdGlvbiBjbGFzc1xuICAgIC8vIFRPRE86IElmIGRhdGF0eXBlIHRoZW4gd2UgbWF5IG5vdCBuZWVkIHRoZSBpbnRlcmZhY2UgcHJveHkgdG8gYmUgY3JlYXRlZCwgV2UgY291bGQgZG8gd2l0aCBqdXN0IHRoZSBpbnRlcmZhY2UgaW1wbD9cbiAgICBpZiAoaWZjLmRhdGF0eXBlKSB7XG4gICAgICB0aGlzLmVtaXRJbnRlcmZhY2VEYXRhVHlwZShpZmMpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBvbkludGVyZmFjZU1ldGhvZChpZmM6IHNwZWMuSW50ZXJmYWNlVHlwZSwgbWV0aG9kOiBzcGVjLk1ldGhvZCkge1xuICAgIHRoaXMuZG90bmV0RG9jR2VuZXJhdG9yLmVtaXREb2NzKG1ldGhvZCwge1xuICAgICAgYXBpOiAnbWVtYmVyJyxcbiAgICAgIGZxbjogaWZjLmZxbixcbiAgICAgIG1lbWJlck5hbWU6IG1ldGhvZC5uYW1lLFxuICAgIH0pO1xuICAgIHRoaXMuZG90bmV0UnVudGltZUdlbmVyYXRvci5lbWl0QXR0cmlidXRlc0Zvck1ldGhvZChpZmMsIG1ldGhvZCk7XG4gICAgY29uc3QgcmV0dXJuVHlwZSA9IG1ldGhvZC5yZXR1cm5zXG4gICAgICA/IHRoaXMudHlwZXJlc29sdmVyLnRvRG90TmV0VHlwZShtZXRob2QucmV0dXJucy50eXBlKVxuICAgICAgOiAndm9pZCc7XG4gICAgY29uc3QgbnVsbGFibGUgPSBtZXRob2QucmV0dXJucz8ub3B0aW9uYWwgPyAnPycgOiAnJztcbiAgICB0aGlzLmNvZGUubGluZShcbiAgICAgIGAke3JldHVyblR5cGV9JHtudWxsYWJsZX0gJHt0aGlzLm5hbWV1dGlscy5jb252ZXJ0TWV0aG9kTmFtZShcbiAgICAgICAgbWV0aG9kLm5hbWUsXG4gICAgICApfSgke3RoaXMucmVuZGVyTWV0aG9kUGFyYW1ldGVycyhtZXRob2QpfSk7YCxcbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uSW50ZXJmYWNlTWV0aG9kT3ZlcmxvYWQoXG4gICAgaWZjOiBzcGVjLkludGVyZmFjZVR5cGUsXG4gICAgb3ZlcmxvYWQ6IHNwZWMuTWV0aG9kLFxuICAgIF9vcmlnaW5hbE1ldGhvZDogc3BlYy5NZXRob2QsXG4gICkge1xuICAgIHRoaXMub25JbnRlcmZhY2VNZXRob2QoaWZjLCBvdmVybG9hZCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25JbnRlcmZhY2VQcm9wZXJ0eShpZmM6IHNwZWMuSW50ZXJmYWNlVHlwZSwgcHJvcDogc3BlYy5Qcm9wZXJ0eSkge1xuICAgIGlmICghcHJvcC5hYnN0cmFjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcmZhY2UgcHJvcGVydGllcyBtdXN0IGJlIGFic3RyYWN0OiAke3Byb3AubmFtZX1gKTtcbiAgICB9XG5cbiAgICBpZiAocHJvcC5wcm90ZWN0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFByb3RlY3RlZCBwcm9wZXJ0aWVzIGFyZSBub3QgYWxsb3dlZCBvbiBpbnRlcmZhY2VzOiAke3Byb3AubmFtZX1gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAocHJvcC5zdGF0aWMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFByb3BlcnR5ICR7aWZjLm5hbWV9LiR7cHJvcC5uYW1lfSBpcyBtYXJrZWQgYXMgc3RhdGljLCBidXQgaW50ZXJmYWNlcyBtdXN0IG5vdCBjb250YWluIHN0YXRpYyBtZW1iZXJzLmAsXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdE5ld0xpbmVJZk5lY2Vzc2FyeSgpO1xuICAgIHRoaXMuZG90bmV0RG9jR2VuZXJhdG9yLmVtaXREb2NzKHByb3AsIHtcbiAgICAgIGFwaTogJ21lbWJlcicsXG4gICAgICBmcW46IGlmYy5mcW4sXG4gICAgICBtZW1iZXJOYW1lOiBwcm9wLm5hbWUsXG4gICAgfSk7XG4gICAgdGhpcy5kb3RuZXRSdW50aW1lR2VuZXJhdG9yLmVtaXRBdHRyaWJ1dGVzRm9yUHJvcGVydHkocHJvcCk7XG5cbiAgICBjb25zdCBwcm9wVHlwZSA9IHRoaXMudHlwZXJlc29sdmVyLnRvRG90TmV0VHlwZShwcm9wLnR5cGUpO1xuICAgIGNvbnN0IHByb3BOYW1lID0gdGhpcy5uYW1ldXRpbHMuY29udmVydFByb3BlcnR5TmFtZShwcm9wLm5hbWUpO1xuXG4gICAgaWYgKHByb3Aub3B0aW9uYWwpIHtcbiAgICAgIHRoaXMuY29kZS5saW5lKCdbQW1hem9uLkpTSUkuUnVudGltZS5EZXB1dHkuSnNpaU9wdGlvbmFsXScpO1xuICAgIH1cblxuICAgIC8vIFNwZWNpZnlpbmcgdGhhdCBhIHR5cGUgaXMgbnVsbGFibGUgaXMgb25seSByZXF1aXJlZCBmb3IgcHJpbWl0aXZlIHZhbHVlIHR5cGVzXG4gICAgY29uc3QgaXNPcHRpb25hbCA9IHByb3Aub3B0aW9uYWwgPyAnPycgOiAnJztcbiAgICB0aGlzLmNvZGUub3BlbkJsb2NrKGAke3Byb3BUeXBlfSR7aXNPcHRpb25hbH0gJHtwcm9wTmFtZX1gKTtcblxuICAgIGlmIChwcm9wLm9wdGlvbmFsKSB7XG4gICAgICB0aGlzLmNvZGUub3BlbkJsb2NrKCdnZXQnKTtcbiAgICAgIHRoaXMuY29kZS5saW5lKCdyZXR1cm4gbnVsbDsnKTtcbiAgICAgIHRoaXMuY29kZS5jbG9zZUJsb2NrKCk7XG4gICAgICBpZiAoIXByb3AuaW1tdXRhYmxlKSB7XG4gICAgICAgIHRoaXMuY29kZS5vcGVuQmxvY2soJ3NldCcpO1xuICAgICAgICB0aGlzLmNvZGUubGluZShcbiAgICAgICAgICBgdGhyb3cgbmV3IFN5c3RlbS5Ob3RTdXBwb3J0ZWRFeGNlcHRpb24oXCInc2V0JyBmb3IgJyR7cHJvcE5hbWV9JyBpcyBub3QgaW1wbGVtZW50ZWRcIik7YCxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jb2RlLmNsb3NlQmxvY2soKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb2RlLmxpbmUoJ2dldDsnKTtcbiAgICAgIGlmICghcHJvcC5pbW11dGFibGUpIHtcbiAgICAgICAgdGhpcy5jb2RlLmxpbmUoJ3NldDsnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvZGUuY2xvc2VCbG9jaygpO1xuICAgIHRoaXMuZmxhZ0ZpcnN0TWVtYmVyV3JpdHRlbih0cnVlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkJlZ2luQ2xhc3MoY2xzOiBzcGVjLkNsYXNzVHlwZSwgYWJzdHJhY3Q6IGJvb2xlYW4pIHtcbiAgICBsZXQgYmFzZVR5cGVOYW1lczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCBuYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZUZvcih0aGlzLmFzc2VtYmx5LCBjbHMpO1xuXG4gICAgLy8gQSBjbGFzcyBjYW4gZGVyaXZlIGZyb20gb25seSBvbmUgYmFzZSBjbGFzc1xuICAgIC8vIEJ1dCBjYW4gaW1wbGVtZW50IG11bHRpcGxlIGludGVyZmFjZXNcbiAgICBpZiAoIWNscy5iYXNlKSB7XG4gICAgICBiYXNlVHlwZU5hbWVzLnB1c2goJ0RlcHV0eUJhc2UnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2xhc3NCYXNlID0gdGhpcy50eXBlcmVzb2x2ZXIudG9Eb3ROZXRUeXBlKHsgZnFuOiBjbHMuYmFzZSB9KTtcbiAgICAgIGJhc2VUeXBlTmFtZXMucHVzaChjbGFzc0Jhc2UpO1xuICAgIH1cblxuICAgIGlmIChjbHMuaW50ZXJmYWNlcyAmJiBjbHMuaW50ZXJmYWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBpbXBsZW1lbnRhdGlvbnMgPVxuICAgICAgICB0aGlzLnR5cGVyZXNvbHZlci5yZXNvbHZlSW1wbGVtZW50ZWRJbnRlcmZhY2VzKGNscyk7XG4gICAgICBiYXNlVHlwZU5hbWVzID0gYmFzZVR5cGVOYW1lcy5jb25jYXQoaW1wbGVtZW50YXRpb25zKTtcbiAgICB9XG5cbiAgICBjb25zdCBjbGFzc05hbWUgPSB0aGlzLm5hbWV1dGlscy5jb252ZXJ0Q2xhc3NOYW1lKGNscyk7XG5cbiAgICAvLyBOZXN0ZWQgY2xhc3NlcyB3aWxsIGJlIGRlYWx0IHdpdGggZHVyaW5nIGNhbGMgY29kZSBnZW5lcmF0aW9uXG4gICAgY29uc3QgbmVzdGVkID0gdGhpcy5pc05lc3RlZChjbHMpO1xuICAgIGNvbnN0IGFic1ByZWZpeCA9IGFic3RyYWN0ID8gJyBhYnN0cmFjdCcgOiAnJztcblxuICAgIHRoaXMub3BlbkZpbGVJZk5lZWRlZChjbGFzc05hbWUsIG5hbWVzcGFjZSwgbmVzdGVkKTtcblxuICAgIGNvbnN0IGltcGxlbWVudHNFeHByID0gYCA6ICR7YmFzZVR5cGVOYW1lcy5qb2luKCcsICcpfWA7XG5cbiAgICB0aGlzLmRvdG5ldERvY0dlbmVyYXRvci5lbWl0RG9jcyhjbHMsIHtcbiAgICAgIGFwaTogJ3R5cGUnLFxuICAgICAgZnFuOiBjbHMuZnFuLFxuICAgIH0pO1xuXG4gICAgdGhpcy5kb3RuZXRSdW50aW1lR2VuZXJhdG9yLmVtaXRBdHRyaWJ1dGVzRm9yQ2xhc3MoY2xzKTtcblxuICAgIHRoaXMuY29kZS5vcGVuQmxvY2soXG4gICAgICBgcHVibGljJHthYnNQcmVmaXh9IGNsYXNzICR7Y2xhc3NOYW1lfSR7aW1wbGVtZW50c0V4cHJ9YCxcbiAgICApO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgY2xhc3MgcGFyYW1ldGVyc1xuICAgIGxldCBwYXJhbWV0ZXJzRGVmaW5pdGlvbiA9ICcnO1xuICAgIGxldCBwYXJhbWV0ZXJzQmFzZSA9ICcnO1xuICAgIGNvbnN0IGluaXRpYWxpemVyID0gY2xzLmluaXRpYWxpemVyO1xuICAgIGlmIChpbml0aWFsaXplcikge1xuICAgICAgdGhpcy5kb3RuZXREb2NHZW5lcmF0b3IuZW1pdERvY3MoaW5pdGlhbGl6ZXIsIHtcbiAgICAgICAgYXBpOiAnaW5pdGlhbGl6ZXInLFxuICAgICAgICBmcW46IGNscy5mcW4sXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZG90bmV0UnVudGltZUdlbmVyYXRvci5lbWl0RGVwcmVjYXRlZEF0dHJpYnV0ZUlmTmVjZXNzYXJ5KFxuICAgICAgICBpbml0aWFsaXplcixcbiAgICAgICk7XG4gICAgICBpZiAoaW5pdGlhbGl6ZXIucGFyYW1ldGVycykge1xuICAgICAgICBwYXJhbWV0ZXJzRGVmaW5pdGlvbiA9IHRoaXMucmVuZGVyUGFyYW1ldGVyc1N0cmluZyhcbiAgICAgICAgICBpbml0aWFsaXplci5wYXJhbWV0ZXJzLFxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgaW5pdGlhbGl6ZXIucGFyYW1ldGVycykge1xuICAgICAgICAgIHBhcmFtZXRlcnNCYXNlICs9IGAke3RoaXMubmFtZXV0aWxzLmNvbnZlcnRQYXJhbWV0ZXJOYW1lKHAubmFtZSl9YDtcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCB0aGUgbGFzdCBwYXJhbWV0ZXIsIGFwcGVuZCAsXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgaW5pdGlhbGl6ZXIucGFyYW1ldGVycy5pbmRleE9mKHApICE9PVxuICAgICAgICAgICAgaW5pdGlhbGl6ZXIucGFyYW1ldGVycy5sZW5ndGggLSAxXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzQmFzZSArPSAnLCAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgdGhlIGNvbnN0cnVjdG9yczpcbiAgICAgIC8vIEFic3RyYWN0IGNsYXNzZXMgaGF2ZSBwcm90ZWN0ZWQgY29uc3RydWN0b3JzLlxuICAgICAgY29uc3QgdmlzaWJpbGl0eSA9IGNscy5hYnN0cmFjdCA/ICdwcm90ZWN0ZWQnIDogJ3B1YmxpYyc7XG5cbiAgICAgIGNvbnN0IGFyZ3MgPVxuICAgICAgICBwYXJhbWV0ZXJzQmFzZS5sZW5ndGggPiAwXG4gICAgICAgICAgPyBgbmV3IG9iamVjdD9bXXske3BhcmFtZXRlcnNCYXNlfX1gXG4gICAgICAgICAgOiBgU3lzdGVtLkFycmF5LkVtcHR5PG9iamVjdD8+KClgO1xuICAgICAgdGhpcy5jb2RlLm9wZW5CbG9jayhcbiAgICAgICAgYCR7dmlzaWJpbGl0eX0gJHtjbGFzc05hbWV9KCR7cGFyYW1ldGVyc0RlZmluaXRpb259KTogYmFzZShuZXcgRGVwdXR5UHJvcHMoJHthcmdzfSkpYCxcbiAgICAgICk7XG4gICAgICB0aGlzLmNvZGUuY2xvc2VCbG9jaygpO1xuICAgICAgdGhpcy5jb2RlLmxpbmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvZGUubGluZShcbiAgICAgICcvLy8gPHN1bW1hcnk+VXNlZCBieSBqc2lpIHRvIGNvbnN0cnVjdCBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGZyb20gYSBKYXZhc2NyaXB0LW93bmVkIG9iamVjdCByZWZlcmVuY2U8L3N1bW1hcnk+JyxcbiAgICApO1xuICAgIHRoaXMuY29kZS5saW5lKFxuICAgICAgJy8vLyA8cGFyYW0gbmFtZT1cInJlZmVyZW5jZVwiPlRoZSBKYXZhc2NyaXB0LW93bmVkIG9iamVjdCByZWZlcmVuY2U8L3BhcmFtPicsXG4gICAgKTtcbiAgICB0aGlzLmRvdG5ldFJ1bnRpbWVHZW5lcmF0b3IuZW1pdERlcHJlY2F0ZWRBdHRyaWJ1dGVJZk5lY2Vzc2FyeShpbml0aWFsaXplcik7XG4gICAgdGhpcy5lbWl0SGlkZUF0dHJpYnV0ZSgpO1xuICAgIHRoaXMuY29kZS5vcGVuQmxvY2soXG4gICAgICBgcHJvdGVjdGVkICR7Y2xhc3NOYW1lfShCeVJlZlZhbHVlIHJlZmVyZW5jZSk6IGJhc2UocmVmZXJlbmNlKWAsXG4gICAgKTtcbiAgICB0aGlzLmNvZGUuY2xvc2VCbG9jaygpO1xuICAgIHRoaXMuY29kZS5saW5lKCk7XG5cbiAgICB0aGlzLmNvZGUubGluZShcbiAgICAgICcvLy8gPHN1bW1hcnk+VXNlZCBieSBqc2lpIHRvIGNvbnN0cnVjdCBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGZyb20gRGVwdXR5UHJvcHM8L3N1bW1hcnk+JyxcbiAgICApO1xuICAgIHRoaXMuY29kZS5saW5lKCcvLy8gPHBhcmFtIG5hbWU9XCJwcm9wc1wiPlRoZSBkZXB1dHkgcHJvcHM8L3BhcmFtPicpO1xuICAgIHRoaXMuZG90bmV0UnVudGltZUdlbmVyYXRvci5lbWl0RGVwcmVjYXRlZEF0dHJpYnV0ZUlmTmVjZXNzYXJ5KGluaXRpYWxpemVyKTtcbiAgICB0aGlzLmVtaXRIaWRlQXR0cmlidXRlKCk7XG4gICAgdGhpcy5jb2RlLm9wZW5CbG9jayhcbiAgICAgIGBwcm90ZWN0ZWQgJHtjbGFzc05hbWV9KERlcHV0eVByb3BzIHByb3BzKTogYmFzZShwcm9wcylgLFxuICAgICk7XG4gICAgdGhpcy5jb2RlLmNsb3NlQmxvY2soKTtcblxuICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBvdXRwdXR0ZWQgbWVtYmVycyAoY29uc3RydWN0b3JzKSwgc2V0dGluZyB0aGUgZmxhZyB0byB0cnVlXG4gICAgdGhpcy5mbGFnRmlyc3RNZW1iZXJXcml0dGVuKHRydWUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uRW5kQ2xhc3MoY2xzOiBzcGVjLkNsYXNzVHlwZSkge1xuICAgIGlmIChjbHMuYWJzdHJhY3QpIHtcbiAgICAgIHRoaXMuZW1pdEludGVyZmFjZVByb3h5KGNscyk7XG4gICAgfVxuXG4gICAgdGhpcy5jb2RlLmNsb3NlQmxvY2soKTtcbiAgICBjb25zdCBjbGFzc05hbWUgPSB0aGlzLm5hbWV1dGlscy5jb252ZXJ0Q2xhc3NOYW1lKGNscyk7XG4gICAgY29uc3QgbmFtZXNwYWNlID0gdGhpcy5uYW1lc3BhY2VGb3IodGhpcy5hc3NlbWJseSwgY2xzKTtcbiAgICB0aGlzLmNsb3NlRmlsZUlmTmVlZGVkKGNsYXNzTmFtZSwgbmFtZXNwYWNlLCB0aGlzLmlzTmVzdGVkKGNscykpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uRmllbGQoXG4gICAgX2Nsczogc3BlYy5DbGFzc1R5cGUsXG4gICAgX3Byb3A6IHNwZWMuUHJvcGVydHksXG4gICAgX3VuaW9uPzogc3BlYy5VbmlvblR5cGVSZWZlcmVuY2UsXG4gICkge1xuICAgIC8qIG5vb3AgKi9cbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1ldGhvZChjbHM6IHNwZWMuQ2xhc3NUeXBlLCBtZXRob2Q6IHNwZWMuTWV0aG9kKSB7XG4gICAgdGhpcy5lbWl0TWV0aG9kKGNscywgbWV0aG9kLCBjbHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uTWV0aG9kT3ZlcmxvYWQoXG4gICAgY2xzOiBzcGVjLkNsYXNzVHlwZSxcbiAgICBvdmVybG9hZDogc3BlYy5NZXRob2QsXG4gICAgX29yaWdpbmFsTWV0aG9kOiBzcGVjLk1ldGhvZCxcbiAgKSB7XG4gICAgdGhpcy5vbk1ldGhvZChjbHMsIG92ZXJsb2FkKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvblByb3BlcnR5KGNsczogc3BlYy5DbGFzc1R5cGUsIHByb3A6IHNwZWMuUHJvcGVydHkpIHtcbiAgICB0aGlzLmVtaXRQcm9wZXJ0eShjbHMsIHByb3AsIGNscyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25TdGF0aWNNZXRob2QoY2xzOiBzcGVjLkNsYXNzVHlwZSwgbWV0aG9kOiBzcGVjLk1ldGhvZCkge1xuICAgIHRoaXMuZW1pdE1ldGhvZChjbHMsIG1ldGhvZCwgY2xzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvblN0YXRpY01ldGhvZE92ZXJsb2FkKFxuICAgIGNsczogc3BlYy5DbGFzc1R5cGUsXG4gICAgb3ZlcmxvYWQ6IHNwZWMuTWV0aG9kLFxuICAgIF9vcmlnaW5hbE1ldGhvZDogc3BlYy5NZXRob2QsXG4gICkge1xuICAgIHRoaXMuZW1pdE1ldGhvZChjbHMsIG92ZXJsb2FkLCBjbHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uU3RhdGljUHJvcGVydHkoY2xzOiBzcGVjLkNsYXNzVHlwZSwgcHJvcDogc3BlYy5Qcm9wZXJ0eSkge1xuICAgIGlmIChwcm9wLmNvbnN0KSB7XG4gICAgICB0aGlzLmVtaXRDb25zdFByb3BlcnR5KGNscywgcHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW1pdFByb3BlcnR5KGNscywgcHJvcCwgY2xzKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25VbmlvblByb3BlcnR5KFxuICAgIGNsczogc3BlYy5DbGFzc1R5cGUsXG4gICAgcHJvcDogc3BlYy5Qcm9wZXJ0eSxcbiAgICBfdW5pb246IHNwZWMuVW5pb25UeXBlUmVmZXJlbmNlLFxuICApIHtcbiAgICB0aGlzLmVtaXRQcm9wZXJ0eShjbHMsIHByb3AsIGNscyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25CZWdpbkVudW0oZW5tOiBzcGVjLkVudW1UeXBlKSB7XG4gICAgY29uc3QgZW51bU5hbWUgPSB0aGlzLm5hbWV1dGlscy5jb252ZXJ0VHlwZU5hbWUoZW5tLm5hbWUpO1xuICAgIGNvbnN0IG5hbWVzcGFjZSA9IHRoaXMubmFtZXNwYWNlRm9yKHRoaXMuYXNzZW1ibHksIGVubSk7XG4gICAgdGhpcy5vcGVuRmlsZUlmTmVlZGVkKGVudW1OYW1lLCBuYW1lc3BhY2UsIHRoaXMuaXNOZXN0ZWQoZW5tKSk7XG4gICAgdGhpcy5lbWl0TmV3TGluZUlmTmVjZXNzYXJ5KCk7XG4gICAgdGhpcy5kb3RuZXREb2NHZW5lcmF0b3IuZW1pdERvY3MoZW5tLCB7XG4gICAgICBhcGk6ICd0eXBlJyxcbiAgICAgIGZxbjogZW5tLmZxbixcbiAgICB9KTtcbiAgICB0aGlzLmRvdG5ldFJ1bnRpbWVHZW5lcmF0b3IuZW1pdEF0dHJpYnV0ZXNGb3JFbnVtKGVubSwgZW51bU5hbWUpO1xuICAgIHRoaXMuY29kZS5vcGVuQmxvY2soYHB1YmxpYyBlbnVtICR7ZW5tLm5hbWV9YCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25FbmRFbnVtKGVubTogc3BlYy5FbnVtVHlwZSkge1xuICAgIHRoaXMuY29kZS5jbG9zZUJsb2NrKCk7XG4gICAgY29uc3QgZW51bU5hbWUgPSB0aGlzLm5hbWV1dGlscy5jb252ZXJ0VHlwZU5hbWUoZW5tLm5hbWUpO1xuICAgIGNvbnN0IG5hbWVzcGFjZSA9IHRoaXMubmFtZXNwYWNlRm9yKHRoaXMuYXNzZW1ibHksIGVubSk7XG4gICAgdGhpcy5jbG9zZUZpbGVJZk5lZWRlZChlbnVtTmFtZSwgbmFtZXNwYWNlLCB0aGlzLmlzTmVzdGVkKGVubSkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uRW51bU1lbWJlcihlbm06IHNwZWMuRW51bVR5cGUsIG1lbWJlcjogc3BlYy5FbnVtTWVtYmVyKSB7XG4gICAgdGhpcy5kb3RuZXREb2NHZW5lcmF0b3IuZW1pdERvY3MobWVtYmVyLCB7XG4gICAgICBhcGk6ICdtZW1iZXInLFxuICAgICAgZnFuOiBlbm0uZnFuLFxuICAgICAgbWVtYmVyTmFtZTogbWVtYmVyLm5hbWUsXG4gICAgfSk7XG4gICAgY29uc3QgZW51bU1lbWJlck5hbWUgPSB0aGlzLm5hbWV1dGlscy5jb252ZXJ0RW51bU1lbWJlck5hbWUobWVtYmVyLm5hbWUpO1xuICAgIHRoaXMuZG90bmV0UnVudGltZUdlbmVyYXRvci5lbWl0QXR0cmlidXRlc0ZvckVudW1NZW1iZXIoXG4gICAgICBlbnVtTWVtYmVyTmFtZSxcbiAgICAgIG1lbWJlcixcbiAgICApO1xuICAgIC8vIElmIHdlIGFyZSBvbiB0aGUgbGFzdCBlbnVtIG1lbWJlciwgd2UgZG9uJ3QgbmVlZCBhIGNvbW1hXG4gICAgaWYgKGVubS5tZW1iZXJzLmluZGV4T2YobWVtYmVyKSAhPT0gZW5tLm1lbWJlcnMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5jb2RlLmxpbmUoYCR7ZW51bU1lbWJlck5hbWV9LGApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvZGUubGluZShgJHtlbnVtTWVtYmVyTmFtZX1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG5hbWVzcGFjZUZvcihhc3NtOiBzcGVjLkFzc2VtYmx5LCB0eXBlOiBzcGVjLlR5cGUpOiBzdHJpbmcge1xuICAgIGxldCBucyA9IHR5cGUubmFtZXNwYWNlO1xuICAgIHdoaWxlIChucyAhPSBudWxsICYmIGFzc20udHlwZXM/LltgJHthc3NtLm5hbWV9LiR7bnN9YF0gIT0gbnVsbCkge1xuICAgICAgY29uc3QgbmVzdGluZyA9IGFzc20udHlwZXNbYCR7YXNzbS5uYW1lfS4ke25zfWBdO1xuICAgICAgbnMgPSBuZXN0aW5nLm5hbWVzcGFjZTtcbiAgICB9XG4gICAgaWYgKG5zICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGVyZXNvbHZlci5yZXNvbHZlTmFtZXNwYWNlKGFzc20sIGFzc20ubmFtZSwgbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYXNzbS50YXJnZXRzIS5kb3RuZXQhLm5hbWVzcGFjZTtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdE1ldGhvZChcbiAgICBjbHM6IHNwZWMuQ2xhc3NUeXBlIHwgc3BlYy5JbnRlcmZhY2VUeXBlLFxuICAgIG1ldGhvZDogc3BlYy5NZXRob2QsXG4gICAgZGVmaW5pbmdUeXBlOiBzcGVjLlR5cGUsXG4gICAgZW1pdEZvclByb3h5T3JEYXRhdHlwZSA9IGZhbHNlLFxuICApOiB2b2lkIHtcbiAgICB0aGlzLmVtaXROZXdMaW5lSWZOZWNlc3NhcnkoKTtcbiAgICBjb25zdCByZXR1cm5UeXBlID0gbWV0aG9kLnJldHVybnNcbiAgICAgID8gdGhpcy50eXBlcmVzb2x2ZXIudG9Eb3ROZXRUeXBlKG1ldGhvZC5yZXR1cm5zLnR5cGUpXG4gICAgICA6ICd2b2lkJztcbiAgICBjb25zdCBzdGF0aWNLZXlXb3JkID0gbWV0aG9kLnN0YXRpYyA/ICdzdGF0aWMgJyA6ICcnO1xuICAgIGxldCBvdmVycmlkZUtleVdvcmQgPSAnJztcbiAgICBsZXQgdmlydHVhbEtleVdvcmQgPSAnJztcblxuICAgIGxldCBkZWZpbmVkT25BbmNlc3RvciA9IGZhbHNlO1xuICAgIC8vIEluIHRoZSBjYXNlIG9mIHRoZSBzb3VyY2UgYmVpbmcgYSBjbGFzcywgd2UgY2hlY2sgaWYgaXQgaXMgYWxyZWFkeSBkZWZpbmVkIG9uIGFuIGFuY2VzdG9yXG4gICAgaWYgKHNwZWMuaXNDbGFzc1R5cGUoY2xzKSkge1xuICAgICAgZGVmaW5lZE9uQW5jZXN0b3IgPSB0aGlzLmlzTWVtYmVyRGVmaW5lZE9uQW5jZXN0b3IoY2xzLCBtZXRob2QpO1xuICAgIH1cbiAgICAvLyBUaGUgbWV0aG9kIGlzIGFuIG92ZXJyaWRlIGlmIGl0J3MgZGVmaW5lZCBvbiB0aGUgYW5jZXN0b3IsIG9yIGlmIHRoZSBwYXJlbnQgaXMgYSBjbGFzcyBhbmQgd2UgYXJlIGdlbmVyYXRpbmcgYSBwcm94eSBvciBkYXRhdHlwZSBjbGFzc1xuICAgIGxldCBvdmVycmlkZXMgPVxuICAgICAgZGVmaW5lZE9uQW5jZXN0b3IgfHwgKHNwZWMuaXNDbGFzc1R5cGUoY2xzKSAmJiBlbWl0Rm9yUHJveHlPckRhdGF0eXBlKTtcbiAgICAvLyBXZSBhbHNvIGluc3BlY3QgdGhlIGpzaWkgbW9kZWwgdG8gc2VlIGlmIGl0IG92ZXJyaWRlcyBhIGNsYXNzIG1lbWJlci5cbiAgICBpZiAobWV0aG9kLm92ZXJyaWRlcykge1xuICAgICAgY29uc3Qgb3ZlcnJpZGVUeXBlID0gdGhpcy5maW5kVHlwZShtZXRob2Qub3ZlcnJpZGVzKTtcbiAgICAgIGlmIChzcGVjLmlzQ2xhc3NUeXBlKG92ZXJyaWRlVHlwZSkpIHtcbiAgICAgICAgLy8gT3ZlcnJpZGVzIGEgY2xhc3MsIG5lZWRzIG92ZXJyaWRlcyBrZXl3b3JkXG4gICAgICAgIG92ZXJyaWRlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvdmVycmlkZXMpIHtcbiAgICAgIC8vIEFkZCB0aGUgb3ZlcnJpZGUga2V5IHdvcmQgaWYgdGhlIG1ldGhvZCBpcyBlbWl0dGVkIGZvciBhIHByb3h5IG9yIGRhdGEgdHlwZSBvciBpcyBkZWZpbmVkIG9uIGFuIGFuY2VzdG9yLiBJZlxuICAgICAgLy8gdGhlIG1lbWJlciBpcyBzdGF0aWMsIHVzZSB0aGUgXCJuZXdcIiBrZXl3b3JkIGluc3RlYWQsIHRvIGluZGljYXRlIHdlIGFyZSBpbnRlbnRpb25hbGx5IGhpZGluZyB0aGUgYW5jZXN0b3JcbiAgICAgIC8vIGRlY2xhcmF0aW9uIChhcyBDIyBkb2VzIG5vdCBpbmhlcml0IHN0YXRpY3MsIHRoZXkgY2FuIGJlIGhpZGRlbiBidXQgbm90IG92ZXJyaWRkZW4pLiBUaGUgXCJuZXdcIiBrZXl3b3JkIGlzXG4gICAgICAvLyBvcHRpb25hbCBpbiB0aGlzIGNvbnRleHQsIGJ1dCBoZWxwcyBjbGFyaWZ5IGludGVudGlvbi5cbiAgICAgIG92ZXJyaWRlS2V5V29yZCA9IG1ldGhvZC5zdGF0aWMgPyAnbmV3ICcgOiAnb3ZlcnJpZGUgJztcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgIW1ldGhvZC5zdGF0aWMgJiZcbiAgICAgIChtZXRob2QuYWJzdHJhY3QgfHwgIWRlZmluZWRPbkFuY2VzdG9yKSAmJlxuICAgICAgIWVtaXRGb3JQcm94eU9yRGF0YXR5cGVcbiAgICApIHtcbiAgICAgIC8vIEFkZCB0aGUgdmlydHVhbCBrZXkgd29yZCBpZiB0aGUgbWV0aG9kIGlzIGFic3RyYWN0IG9yIG5vdCBkZWZpbmVkIG9uIGFuIGFuY2VzdG9yIGFuZCB3ZSBhcmUgTk9UIGdlbmVyYXRpbmcgYSBwcm94eSBvciBkYXRhdHlwZSBjbGFzc1xuICAgICAgLy8gTWV0aG9kcyBzaG91bGQgYWx3YXlzIGJlIHZpcnR1YWwgd2hlbiBwb3NzaWJsZVxuICAgICAgdmlydHVhbEtleVdvcmQgPSAndmlydHVhbCAnO1xuICAgIH1cblxuICAgIGNvbnN0IGFjY2VzcyA9IHRoaXMucmVuZGVyQWNjZXNzTGV2ZWwobWV0aG9kKTtcbiAgICBjb25zdCBtZXRob2ROYW1lID0gdGhpcy5uYW1ldXRpbHMuY29udmVydE1ldGhvZE5hbWUobWV0aG9kLm5hbWUpO1xuXG4gICAgY29uc3QgaXNPcHRpb25hbCA9IG1ldGhvZC5yZXR1cm5zICYmIG1ldGhvZC5yZXR1cm5zLm9wdGlvbmFsID8gJz8nIDogJyc7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYCR7cmV0dXJuVHlwZX0ke2lzT3B0aW9uYWx9ICR7bWV0aG9kTmFtZX0oJHt0aGlzLnJlbmRlck1ldGhvZFBhcmFtZXRlcnMoXG4gICAgICBtZXRob2QsXG4gICAgKX0pYDtcblxuICAgIHRoaXMuZG90bmV0RG9jR2VuZXJhdG9yLmVtaXREb2NzKG1ldGhvZCwge1xuICAgICAgYXBpOiAnbWVtYmVyJyxcbiAgICAgIGZxbjogZGVmaW5pbmdUeXBlLmZxbixcbiAgICAgIG1lbWJlck5hbWU6IG1ldGhvZC5uYW1lLFxuICAgIH0pO1xuICAgIHRoaXMuZG90bmV0UnVudGltZUdlbmVyYXRvci5lbWl0QXR0cmlidXRlc0Zvck1ldGhvZChcbiAgICAgIGNscyxcbiAgICAgIG1ldGhvZCAvKiwgZW1pdEZvclByb3h5T3JEYXRhdHlwZSovLFxuICAgICk7XG5cbiAgICBpZiAobWV0aG9kLmFic3RyYWN0KSB7XG4gICAgICB0aGlzLmNvZGUubGluZShgJHthY2Nlc3N9ICR7b3ZlcnJpZGVLZXlXb3JkfWFic3RyYWN0ICR7c2lnbmF0dXJlfTtgKTtcbiAgICAgIHRoaXMuY29kZS5saW5lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29kZS5vcGVuQmxvY2soXG4gICAgICAgIGAke2FjY2Vzc30gJHtzdGF0aWNLZXlXb3JkfSR7b3ZlcnJpZGVLZXlXb3JkfSR7dmlydHVhbEtleVdvcmR9JHtzaWduYXR1cmV9YCxcbiAgICAgICk7XG4gICAgICB0aGlzLmNvZGUubGluZShcbiAgICAgICAgdGhpcy5kb3RuZXRSdW50aW1lR2VuZXJhdG9yLmNyZWF0ZUludm9rZU1ldGhvZElkZW50aWZpZXIoXG4gICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgIGNscyBhcyBzcGVjLkNsYXNzVHlwZSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgICB0aGlzLmNvZGUuY2xvc2VCbG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb3VuZHMgb3V0IGlmIGEgbWVtYmVyIChwcm9wZXJ0eSBvciBtZXRob2QpIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBvbmUgb2YgdGhlIGJhc2UgY2xhc3Nlc1xuICAgKlxuICAgKiBVc2VkIHRvIGZpZ3VyZSBvdXQgaWYgdGhlIG92ZXJyaWRlIG9yIHZpcnR1YWwga2V5d29yZHMgYXJlIG5lY2Vzc2FyeS5cbiAgICovXG4gIHByaXZhdGUgaXNNZW1iZXJEZWZpbmVkT25BbmNlc3RvcihcbiAgICBjbHM6IHNwZWMuQ2xhc3NUeXBlLFxuICAgIG1lbWJlcjogc3BlYy5Qcm9wZXJ0eSB8IHNwZWMuTWV0aG9kLFxuICApOiBib29sZWFuIHtcbiAgICBpZiAobWVtYmVyIGFzIHNwZWMuTWV0aG9kKSB7XG4gICAgICBjb25zdCBvYmplY3RNZXRob2RzID0gWydUb1N0cmluZycsICdHZXRIYXNoQ29kZScsICdFcXVhbHMnXTtcbiAgICAgIC8vIE1ldGhvZHMgZGVmaW5lZCBvbiB0aGUgT2JqZWN0IGNsYXNzIHNob3VsZCBiZSBvdmVycmlkZGVuLCByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChcbiAgICAgICAgb2JqZWN0TWV0aG9kcy5pbmNsdWRlcyh0aGlzLm5hbWV1dGlscy5jb252ZXJ0TWV0aG9kTmFtZShtZW1iZXIubmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYmFzZSA9IGNscy5iYXNlO1xuICAgIGlmIChiYXNlKSB7XG4gICAgICBjb25zdCBiYXNlVHlwZSA9IHRoaXMuZmluZFR5cGUoYmFzZSkgYXMgc3BlYy5DbGFzc1R5cGU7XG5cbiAgICAgIGlmIChtZW1iZXIgYXMgc3BlYy5Qcm9wZXJ0eSkge1xuICAgICAgICBpZiAoYmFzZVR5cGUucHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGJhc2VUeXBlLnByb3BlcnRpZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAocHJvcGVydHkpID0+IHByb3BlcnR5Lm5hbWUgPT09IG1lbWJlci5uYW1lLFxuICAgICAgICAgICAgKS5sZW5ndGggPiAwXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBwcm9wZXJ0eSBmb3VuZCBpbiBiYXNlIHBhcmVudFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmlzTWVtYmVyRGVmaW5lZE9uQW5jZXN0b3IoYmFzZVR5cGUsIG1lbWJlcik7XG4gICAgICB9IGVsc2UgaWYgKG1lbWJlciBhcyBzcGVjLk1ldGhvZCkge1xuICAgICAgICBpZiAoYmFzZVR5cGUubWV0aG9kcykge1xuICAgICAgICAgIGNvbnN0IG15TWV0aG9kID0gbWVtYmVyIGFzIHNwZWMuTWV0aG9kO1xuICAgICAgICAgIC8vIElmIHRoZSBuYW1lLCBwYXJhbWV0ZXJzIGFuZCByZXR1cm5zIGFyZSBzaW1pbGFyIHRoZW4gaXQgaXMgdGhlIHNhbWUgbWV0aG9kIGluIC5ORVRcbiAgICAgICAgICBmb3IgKGNvbnN0IG0gb2YgYmFzZVR5cGUubWV0aG9kcykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBtLm5hbWUgPT09IG15TWV0aG9kLm5hbWUgJiZcbiAgICAgICAgICAgICAgbS5wYXJhbWV0ZXJzID09PSBteU1ldGhvZC5wYXJhbWV0ZXJzICYmXG4gICAgICAgICAgICAgIG0ucmV0dXJucyA9PT0gbXlNZXRob2QucmV0dXJuc1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pc01lbWJlckRlZmluZWRPbkFuY2VzdG9yKGJhc2VUeXBlLCBtZW1iZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBtZXRob2QgcGFyYW1ldGVycyBzdHJpbmdcbiAgICovXG4gIHByaXZhdGUgcmVuZGVyTWV0aG9kUGFyYW1ldGVycyhtZXRob2Q6IHNwZWMuTWV0aG9kKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJQYXJhbWV0ZXJzU3RyaW5nKG1ldGhvZC5wYXJhbWV0ZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHBhcmFtZXRlcnMgc3RyaW5nIGZvciBtZXRob2RzIG9yIGNvbnN0cnVjdG9yc1xuICAgKi9cbiAgcHJpdmF0ZSByZW5kZXJQYXJhbWV0ZXJzU3RyaW5nKFxuICAgIHBhcmFtZXRlcnM6IHNwZWMuUGFyYW1ldGVyW10gfCB1bmRlZmluZWQsXG4gICk6IHN0cmluZyB7XG4gICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgaWYgKHBhcmFtZXRlcnMpIHtcbiAgICAgIGZvciAoY29uc3QgcCBvZiBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGxldCBvcHRpb25hbFByaW1pdGl2ZSA9ICcnO1xuICAgICAgICBsZXQgb3B0aW9uYWxLZXl3b3JkID0gJyc7XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy50eXBlcmVzb2x2ZXIudG9Eb3ROZXRUeXBlKHAudHlwZSk7XG4gICAgICAgIGlmIChwLm9wdGlvbmFsKSB7XG4gICAgICAgICAgb3B0aW9uYWxLZXl3b3JkID0gJyA9IG51bGwnO1xuICAgICAgICAgIGlmIChwLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICBvcHRpb25hbFByaW1pdGl2ZSA9ICc/JztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocC52YXJpYWRpYykge1xuICAgICAgICAgIHR5cGUgPSBgcGFyYW1zICR7dHlwZX1bXWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3QgPSBgJHt0eXBlfSR7b3B0aW9uYWxQcmltaXRpdmV9ICR7dGhpcy5uYW1ldXRpbHMuY29udmVydFBhcmFtZXRlck5hbWUoXG4gICAgICAgICAgcC5uYW1lLFxuICAgICAgICApfSR7b3B0aW9uYWxLZXl3b3JkfWA7XG4gICAgICAgIHBhcmFtcy5wdXNoKHN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcy5qb2luKCcsICcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGFuIGludGVyZmFjZSBwcm94eSBmb3IgYW4gaW50ZXJmYWNlIG9yIGFuIGFic3RyYWN0IGNsYXNzLlxuICAgKi9cbiAgcHJpdmF0ZSBlbWl0SW50ZXJmYWNlUHJveHkoaWZjOiBzcGVjLkludGVyZmFjZVR5cGUgfCBzcGVjLkNsYXNzVHlwZSk6IHZvaWQge1xuICAgIGNvbnN0IG5hbWUgPSAnX1Byb3h5JztcbiAgICBjb25zdCBuYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZUZvcih0aGlzLmFzc2VtYmx5LCBpZmMpO1xuICAgIGNvbnN0IGlzTmVzdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wZW5GaWxlSWZOZWVkZWQobmFtZSwgbmFtZXNwYWNlLCBpc05lc3RlZCk7XG5cbiAgICB0aGlzLmNvZGUubGluZSgpO1xuICAgIHRoaXMuZG90bmV0RG9jR2VuZXJhdG9yLmVtaXREb2NzKGlmYywge1xuICAgICAgYXBpOiAndHlwZScsXG4gICAgICBmcW46IGlmYy5mcW4sXG4gICAgfSk7XG4gICAgdGhpcy5kb3RuZXRSdW50aW1lR2VuZXJhdG9yLmVtaXRBdHRyaWJ1dGVzRm9ySW50ZXJmYWNlUHJveHkoaWZjKTtcblxuICAgIGNvbnN0IGludGVyZmFjZUZxbiA9IHRoaXMudHlwZXJlc29sdmVyLnRvTmF0aXZlRnFuKGlmYy5mcW4pO1xuICAgIGNvbnN0IHN1ZmZpeCA9IHNwZWMuaXNJbnRlcmZhY2VUeXBlKGlmYylcbiAgICAgID8gYDogRGVwdXR5QmFzZSwgJHtpbnRlcmZhY2VGcW59YFxuICAgICAgOiBgOiAke2ludGVyZmFjZUZxbn1gO1xuICAgIGNvbnN0IG5ld01vZGlmaWVyID0gdGhpcy5wcm94eU11c3RVc2VOZXdNb2RpZmllcihpZmMpID8gJ25ldyAnIDogJyc7XG5cbiAgICB0aGlzLmNvZGUub3BlbkJsb2NrKFxuICAgICAgYCR7bmV3TW9kaWZpZXJ9aW50ZXJuYWwgc2VhbGVkIGNsYXNzICR7bmFtZX0gJHtzdWZmaXh9YCxcbiAgICApO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBwcml2YXRlIGNvbnN0cnVjdG9yXG4gICAgdGhpcy5jb2RlLm9wZW5CbG9jayhcbiAgICAgIGBwcml2YXRlICR7bmFtZX0oQnlSZWZWYWx1ZSByZWZlcmVuY2UpOiBiYXNlKHJlZmVyZW5jZSlgLFxuICAgICk7XG4gICAgdGhpcy5jb2RlLmNsb3NlQmxvY2soKTtcblxuICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBvdXRwdXQgYSBtZW1iZXIgKGNvbnN0cnVjdG9yKSwgc2V0dGluZyB0aGUgZmlyc3QgbWVtYmVyIGZsYWcgdG8gdHJ1ZVxuICAgIHRoaXMuZmxhZ0ZpcnN0TWVtYmVyV3JpdHRlbih0cnVlKTtcblxuICAgIGNvbnN0IGRhdGF0eXBlID0gZmFsc2U7XG4gICAgY29uc3QgcHJveHkgPSB0cnVlO1xuICAgIHRoaXMuZW1pdEludGVyZmFjZU1lbWJlcnNGb3JQcm94eU9yRGF0YXR5cGUoaWZjLCBkYXRhdHlwZSwgcHJveHkpO1xuXG4gICAgdGhpcy5jb2RlLmNsb3NlQmxvY2soKTtcbiAgICB0aGlzLmNsb3NlRmlsZUlmTmVlZGVkKG5hbWUsIG5hbWVzcGFjZSwgaXNOZXN0ZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBhbnkgYW5jZXN0b3Igb2YgdGhlIGdpdmVuIHR5cGUgbXVzdCB1c2UgdGhlIGBuZXdgXG4gICAqIG1vZGlmaWVyIHdoZW4gaW50cm9kdWNpbmcgaXQncyBvd24gcHJveHkuXG4gICAqXG4gICAqIElmIHRoZSB0eXBlIGlzIGEgYGNsYXNzYCwgdGhlbiBpdCBtdXN0IHVzZSBgbmV3YCBpZiBpdCBleHRlbmRzIGFub3RoZXJcbiAgICogYWJzdHJhY3QgY2xhc3MgZGVmaW5lZCBpbiB0aGUgc2FtZSBhc3NlbWJseSAoc2luY2UgcHJveGllcyBhcmUgaW50ZXJuYWwsXG4gICAqIGV4dGVybmFsIHR5cGVzJyBwcm94aWVzIGFyZSBub3QgdmlzaWJsZSBpbiB0aGF0IGNvbnRleHQpLlxuICAgKlxuICAgKiBJZiB0aGUgdHlwZSBpcyBhbiBgaW50ZXJmYWNlYCwgdGhlbiBpdCBtdXN0IHVzZSBgbmV3YCBpZiBpdCBleHRlbmRzIGFub3RoZXJcbiAgICogaW50ZXJmYWNlIGZyb20gdGhlIHNhbWUgYXNzZW1ibHkuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIHRoZSB0ZXN0ZWQgcHJveHktYWJsZSB0eXBlIChhbiBhYnN0cmFjdCBjbGFzcyBvciBhbiBpbnRlcmZhY2UpLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIGFueSBhbmNlc3RvciBvZiB0aGlzIHR5cGUgaGFzIGEgdmlzaWJsZSBwcm94eS5cbiAgICovXG4gIHByaXZhdGUgcHJveHlNdXN0VXNlTmV3TW9kaWZpZXIoXG4gICAgdHlwZTogc3BlYy5DbGFzc1R5cGUgfCBzcGVjLkludGVyZmFjZVR5cGUsXG4gICk6IGJvb2xlYW4ge1xuICAgIGlmIChzcGVjLmlzQ2xhc3NUeXBlKHR5cGUpKSB7XG4gICAgICBpZiAodHlwZS5iYXNlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBiYXNlID0gdGhpcy5maW5kVHlwZSh0eXBlLmJhc2UpIGFzIHNwZWMuQ2xhc3NUeXBlO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgYmFzZS5hc3NlbWJseSA9PT0gdHlwZS5hc3NlbWJseSAmJlxuICAgICAgICAoYmFzZS5hYnN0cmFjdFxuICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgIDogLy8gQW4gYWJzdHJhY3QgY2xhc3MgY291bGQgZXh0ZW5kIGEgY29uY3JldGUgY2xhc3MuLi4gV2UgbXVzdCB3YWxrIHVwIHRoZSBpbmhlcml0YW5jZSB0cmVlIGluIHRoaXMgY2FzZS4uLlxuICAgICAgICAgICAgdGhpcy5wcm94eU11c3RVc2VOZXdNb2RpZmllcihiYXNlKSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGUuaW50ZXJmYWNlcz8uZmluZChcbiAgICAgICAgKGZxbikgPT4gdGhpcy5maW5kVHlwZShmcW4pLmFzc2VtYmx5ID09PSB0eXBlLmFzc2VtYmx5LFxuICAgICAgKSAhPSBudWxsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhbiBJbnRlcmZhY2UgRGF0YXR5cGUgY2xhc3NcbiAgICpcbiAgICogVGhpcyBpcyB1c2VkIHRvIGVtaXQgYSBjbGFzcyBpbXBsZW1lbnRpbmcgYW4gaW50ZXJmYWNlIHdoZW4gdGhlIGRhdGF0eXBlIHByb3BlcnR5IGlzIHRydWUgaW4gdGhlIGpzaWkgbW9kZWxcbiAgICogVGhlIGdlbmVyYXRpb24gb2YgdGhlIGludGVyZmFjZSBwcm94eSBtYXkgbm90IGJlIG5lZWRlZCBpZiB0aGUgaW50ZXJmYWNlIGlzIGFsc28gc2V0IGFzIGEgZGF0YXR5cGVcbiAgICovXG4gIHByaXZhdGUgZW1pdEludGVyZmFjZURhdGFUeXBlKGlmYzogc3BlYy5JbnRlcmZhY2VUeXBlKTogdm9pZCB7XG4gICAgLy8gSW50ZXJmYWNlIGRhdGF0eXBlcyBkbyBub3QgbmVlZCB0byBiZSBwcmVmaXhlZCBieSBJLCB3ZSBjYW4gY2FsbCBjb252ZXJ0Q2xhc3NOYW1lXG4gICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZXV0aWxzLmNvbnZlcnRDbGFzc05hbWUoaWZjKTtcbiAgICBjb25zdCBuYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZUZvcih0aGlzLmFzc2VtYmx5LCBpZmMpO1xuICAgIGNvbnN0IGlzTmVzdGVkID0gdGhpcy5pc05lc3RlZChpZmMpO1xuICAgIHRoaXMub3BlbkZpbGVJZk5lZWRlZChuYW1lLCBuYW1lc3BhY2UsIGlzTmVzdGVkKTtcblxuICAgIGlmIChpZmMucHJvcGVydGllcz8uZmluZCgocHJvcCkgPT4gIXByb3Aub3B0aW9uYWwpICE9IG51bGwpIHtcbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gYmUgYW5ub3llZCBieSB0aGUgbGFjayBvZiBpbml0aWFsaXphdGlvbiBvZiBub24tbnVsbGFibGUgZmllbGRzIGluIHRoaXMgY2FzZS5cbiAgICAgIHRoaXMuY29kZS5saW5lKCcjcHJhZ21hIHdhcm5pbmcgZGlzYWJsZSBDUzg2MTgnKTtcbiAgICAgIHRoaXMuY29kZS5saW5lKCk7XG4gICAgfVxuXG4gICAgdGhpcy5kb3RuZXREb2NHZW5lcmF0b3IuZW1pdERvY3MoaWZjLCB7XG4gICAgICBhcGk6ICd0eXBlJyxcbiAgICAgIGZxbjogaWZjLmZxbixcbiAgICB9KTtcbiAgICBjb25zdCBzdWZmaXggPSBgOiAke3RoaXMudHlwZXJlc29sdmVyLnRvTmF0aXZlRnFuKGlmYy5mcW4pfWA7XG4gICAgdGhpcy5kb3RuZXRSdW50aW1lR2VuZXJhdG9yLmVtaXRBdHRyaWJ1dGVzRm9ySW50ZXJmYWNlRGF0YXR5cGUoaWZjKTtcbiAgICB0aGlzLmNvZGUub3BlbkJsb2NrKGBwdWJsaWMgY2xhc3MgJHtuYW1lfSAke3N1ZmZpeH1gKTtcbiAgICB0aGlzLmZsYWdGaXJzdE1lbWJlcldyaXR0ZW4oZmFsc2UpO1xuICAgIGNvbnN0IGRhdGF0eXBlID0gdHJ1ZTtcbiAgICBjb25zdCBwcm94eSA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdEludGVyZmFjZU1lbWJlcnNGb3JQcm94eU9yRGF0YXR5cGUoaWZjLCBkYXRhdHlwZSwgcHJveHkpO1xuICAgIHRoaXMuY29kZS5jbG9zZUJsb2NrKCk7XG4gICAgdGhpcy5jbG9zZUZpbGVJZk5lZWRlZChuYW1lLCBuYW1lc3BhY2UsIGlzTmVzdGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIGJvZHkgb2YgdGhlIGludGVyZmFjZSBwcm94eSBvciBkYXRhIHR5cGUgY2xhc3NcbiAgICpcbiAgICogVGhpcyBsb29wcyB0aHJvdWdoIGFsbCB0aGUgbWVtYmVyIGFuZCBnZW5lcmF0ZXMgdGhlbVxuICAgKi9cbiAgcHJpdmF0ZSBlbWl0SW50ZXJmYWNlTWVtYmVyc0ZvclByb3h5T3JEYXRhdHlwZShcbiAgICBpZmM6IHNwZWMuSW50ZXJmYWNlVHlwZSB8IHNwZWMuQ2xhc3NUeXBlLFxuICAgIGRhdGF0eXBlOiBib29sZWFuLFxuICAgIHByb3h5OiBib29sZWFuLFxuICApOiB2b2lkIHtcbiAgICAvLyBUaGUga2V5IGlzIGluIHRoZSBmb3JtICdtZXRob2QubmFtZTtwYXJhbWV0ZXIxO3BhcmFtZXRlcjI7JyBldGNcbiAgICBjb25zdCBtZXRob2RzID0gbmV3IE1hcDxzdHJpbmcsIE1ldGhvZERlZmluaXRpb24+KCk7XG4gICAgLypcbiAgICAgICAgICBPbmx5IGdldCB0aGUgZmlyc3QgZGVjbGFyYXRpb24gZW5jb3VudGVyZWQsIGFuZCBrZWVwIGl0IGlmIGl0IGlzIGFic3RyYWN0LiBUaGUgbGlzdCBjb250YWlucyBBTExcbiAgICAgICAgICBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIGVuY291bnRlcmVkLCBpbiB0aGUgb3JkZXIgZW5jb3VudGVyZWQuIEFuIGFic3RyYWN0IGNsYXNzIGNhbiBoYXZlIGNvbmNyZXRlXG4gICAgICAgICAgaW1wbGVtZW50YXRpb25zLiBUaGVyZWZvcmUsIHdlIG9ubHkgZ2VuZXJhdGUgbWV0aG9kcy9wcm9wZXJ0aWVzIGlmIHRoZSBmaXJzdCBtZW1iZXIgZW5jb3VudGVyZWRcbiAgICAgICAgICBpcyB1bmltcGxlbWVudGVkLlxuICAgICAgICAqL1xuICAgIGNvbnN0IGV4Y2x1ZGVkTWV0aG9kOiBzdHJpbmdbXSA9IFtdOyAvLyBLZWVwcyB0cmFjayBvZiB0aGUgbWV0aG9kcyB3ZSBhbHJlYWR5IHJhbiBpbnRvIGFuZCBkb24ndCB3YW50IHRvIGVtaXRcbiAgICBjb25zdCBleGNsdWRlZFByb3BlcnRpZXM6IHN0cmluZ1tdID0gW107IC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBwcm9wZXJ0aWVzIHdlIGFscmVhZHkgcmFuIGludG8gYW5kIGRvbid0IHdhbnQgdG8gZW1pdFxuICAgIGNvbnN0IHByb3BlcnRpZXM6IHsgW25hbWU6IHN0cmluZ106IFByb3BlcnR5RGVmaW5pdGlvbiB9ID0ge307XG4gICAgY29uc3QgY29sbGVjdEFic3RyYWN0TWVtYmVycyA9IChcbiAgICAgIGN1cnJlbnRUeXBlOiBzcGVjLkludGVyZmFjZVR5cGUgfCBzcGVjLkNsYXNzVHlwZSxcbiAgICApID0+IHtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBjdXJyZW50VHlwZS5wcm9wZXJ0aWVzID8/IFtdKSB7XG4gICAgICAgIGlmICghZXhjbHVkZWRQcm9wZXJ0aWVzLmluY2x1ZGVzKHByb3AubmFtZSkpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG5ldmVyIHJ1biBpbnRvIHRoaXMgcHJvcGVydHkgYmVmb3JlIGFuZCBpdCBpcyBhYnN0cmFjdCwgd2Uga2VlcCBpdFxuICAgICAgICAgIGlmIChwcm9wLmFic3RyYWN0KSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzW3Byb3AubmFtZV0gPSB7IHByb3AsIGRlZmluaW5nVHlwZTogY3VycmVudFR5cGUgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhjbHVkZWRQcm9wZXJ0aWVzLnB1c2gocHJvcC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBjdXJyZW50VHlwZS5tZXRob2RzID8/IFtdKSB7XG4gICAgICAgIGxldCBtZXRob2RQYXJhbWV0ZXJzID0gJyc7XG4gICAgICAgIGlmIChtZXRob2QucGFyYW1ldGVycykge1xuICAgICAgICAgIG1ldGhvZC5wYXJhbWV0ZXJzLmZvckVhY2goKHBhcmFtKSA9PiB7XG4gICAgICAgICAgICBtZXRob2RQYXJhbWV0ZXJzICs9IGA7JHt0aGlzLnR5cGVyZXNvbHZlci50b0RvdE5ldFR5cGUoXG4gICAgICAgICAgICAgIHBhcmFtLnR5cGUsXG4gICAgICAgICAgICApfWA7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFleGNsdWRlZE1ldGhvZC5pbmNsdWRlcyhgJHttZXRob2QubmFtZX0ke21ldGhvZFBhcmFtZXRlcnN9YCkpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG5ldmVyIHJ1biBpbnRvIHRoaXMgbWV0aG9kIGJlZm9yZSBhbmQgaXQgaXMgYWJzdHJhY3QsIHdlIGtlZXAgaXRcbiAgICAgICAgICBpZiAobWV0aG9kLmFic3RyYWN0KSB7XG4gICAgICAgICAgICBtZXRob2RzLnNldChgJHttZXRob2QubmFtZX0ke21ldGhvZFBhcmFtZXRlcnN9YCwge1xuICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgIGRlZmluaW5nVHlwZTogY3VycmVudFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhjbHVkZWRNZXRob2QucHVzaChgJHttZXRob2QubmFtZX0ke21ldGhvZFBhcmFtZXRlcnN9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgYmFzZXMgPSBuZXcgQXJyYXk8c3BlYy5OYW1lZFR5cGVSZWZlcmVuY2U+KCk7XG4gICAgICBiYXNlcy5wdXNoKFxuICAgICAgICAuLi4oY3VycmVudFR5cGUuaW50ZXJmYWNlcyA/PyBbXSkubWFwKChpZmFjZSkgPT4gdGhpcy5maW5kVHlwZShpZmFjZSkpLFxuICAgICAgKTtcbiAgICAgIGlmIChzcGVjLmlzQ2xhc3NUeXBlKGN1cnJlbnRUeXBlKSAmJiBjdXJyZW50VHlwZS5iYXNlKSB7XG4gICAgICAgIGJhc2VzLnB1c2godGhpcy5maW5kVHlwZShjdXJyZW50VHlwZS5iYXNlKSk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGJhc2Ugb2YgYmFzZXMpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuZmluZFR5cGUoYmFzZS5mcW4pO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdHlwZS5raW5kICE9PSBzcGVjLlR5cGVLaW5kLkludGVyZmFjZSAmJlxuICAgICAgICAgIHR5cGUua2luZCAhPT0gc3BlYy5UeXBlS2luZC5DbGFzc1xuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQmFzZSBpbnRlcmZhY2VzIG9mIGFuIGludGVyZmFjZSBtdXN0IGJlIGFuIGludGVyZmFjZSBvciBhIGNsYXNzICgke2Jhc2UuZnFufSBpcyBvZiB0eXBlICR7dHlwZS5raW5kfSlgLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29sbGVjdEFic3RyYWN0TWVtYmVycyh0eXBlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbGxlY3RBYnN0cmFjdE1lbWJlcnMoaWZjKTtcblxuICAgIC8vIGVtaXQgYWxsIHByb3BlcnRpZXNcbiAgICBmb3IgKGNvbnN0IHByb3BOYW1lIG9mIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpKSB7XG4gICAgICBjb25zdCBwcm9wID0gY2xvbmUocHJvcGVydGllc1twcm9wTmFtZV0pO1xuICAgICAgcHJvcC5wcm9wLmFic3RyYWN0ID0gZmFsc2U7XG4gICAgICB0aGlzLmVtaXRQcm9wZXJ0eShpZmMsIHByb3AucHJvcCwgcHJvcC5kZWZpbmluZ1R5cGUsIGRhdGF0eXBlLCBwcm94eSk7XG4gICAgfVxuICAgIC8vIGVtaXQgYWxsIHRoZSBtZXRob2RzXG4gICAgZm9yIChjb25zdCBtZXRob2ROYW1lQW5kUGFyYW1ldGVycyBvZiBtZXRob2RzLmtleXMoKSkge1xuICAgICAgY29uc3Qgb3JpZ2luYWxNZXRob2QgPSBtZXRob2RzLmdldChtZXRob2ROYW1lQW5kUGFyYW1ldGVycyk7XG4gICAgICBpZiAob3JpZ2luYWxNZXRob2QpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gY2xvbmUob3JpZ2luYWxNZXRob2QpO1xuICAgICAgICBtZXRob2QubWV0aG9kLmFic3RyYWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdE1ldGhvZChcbiAgICAgICAgICBpZmMsXG4gICAgICAgICAgbWV0aG9kLm1ldGhvZCxcbiAgICAgICAgICBtZXRob2QuZGVmaW5pbmdUeXBlLFxuICAgICAgICAgIC8qIGVtaXRGb3JQcm94eU9yRGF0YXR5cGUgKi8gdHJ1ZSxcbiAgICAgICAgKTtcblxuICAgICAgICBmb3IgKGNvbnN0IG92ZXJsb2FkZWRNZXRob2Qgb2YgdGhpcy5jcmVhdGVPdmVybG9hZHNGb3JPcHRpb25hbHMoXG4gICAgICAgICAgbWV0aG9kLm1ldGhvZCxcbiAgICAgICAgKSkge1xuICAgICAgICAgIG92ZXJsb2FkZWRNZXRob2QuYWJzdHJhY3QgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmVtaXRNZXRob2QoXG4gICAgICAgICAgICBpZmMsXG4gICAgICAgICAgICBvdmVybG9hZGVkTWV0aG9kLFxuICAgICAgICAgICAgbWV0aG9kLmRlZmluaW5nVHlwZSxcbiAgICAgICAgICAgIC8qIGVtaXRGb3JQcm94eU9yRGF0YXR5cGUgKi8gdHJ1ZSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgcHJvcGVydHlcbiAgICovXG4gIHByaXZhdGUgZW1pdFByb3BlcnR5KFxuICAgIGNsczogc3BlYy5UeXBlLFxuICAgIHByb3A6IHNwZWMuUHJvcGVydHksXG4gICAgZGVmaW5pbmdUeXBlOiBzcGVjLlR5cGUsXG4gICAgZGF0YXR5cGUgPSBmYWxzZSxcbiAgICBwcm94eSA9IGZhbHNlLFxuICApOiB2b2lkIHtcbiAgICB0aGlzLmVtaXROZXdMaW5lSWZOZWNlc3NhcnkoKTtcblxuICAgIGNvbnN0IGNsYXNzTmFtZSA9IHRoaXMudHlwZXJlc29sdmVyLnRvTmF0aXZlRnFuKGNscy5mcW4pO1xuICAgIGNvbnN0IGFjY2VzcyA9IHRoaXMucmVuZGVyQWNjZXNzTGV2ZWwocHJvcCk7XG4gICAgY29uc3Qgc3RhdGljS2V5V29yZCA9IHByb3Auc3RhdGljID8gJ3N0YXRpYyAnIDogJyc7XG4gICAgY29uc3QgcHJvcE5hbWUgPSB0aGlzLm5hbWV1dGlscy5jb252ZXJ0UHJvcGVydHlOYW1lKHByb3AubmFtZSk7XG5cbiAgICB0aGlzLmRvdG5ldERvY0dlbmVyYXRvci5lbWl0RG9jcyhwcm9wLCB7XG4gICAgICBhcGk6ICdtZW1iZXInLFxuICAgICAgZnFuOiBkZWZpbmluZ1R5cGUuZnFuLFxuICAgICAgbWVtYmVyTmFtZTogcHJvcC5uYW1lLFxuICAgIH0pO1xuICAgIGlmIChwcm9wLm9wdGlvbmFsKSB7XG4gICAgICB0aGlzLmNvZGUubGluZSgnW0pzaWlPcHRpb25hbF0nKTtcbiAgICB9XG4gICAgdGhpcy5kb3RuZXRSdW50aW1lR2VuZXJhdG9yLmVtaXRBdHRyaWJ1dGVzRm9yUHJvcGVydHkocHJvcCwgZGF0YXR5cGUpO1xuXG4gICAgbGV0IGlzT3ZlcnJpZGVLZXlXb3JkID0gJyc7XG4gICAgbGV0IGlzVmlydHVhbEtleVdvcmQgPSAnJztcbiAgICBsZXQgaXNBYnN0cmFjdEtleXdvcmQgPSAnJztcblxuICAgIC8vIElmIHRoZSBwcm9wIHBhcmVudCBpcyBhIGNsYXNzXG4gICAgaWYgKHNwZWMuaXNDbGFzc1R5cGUoY2xzKSkge1xuICAgICAgY29uc3QgaW1wbGVtZW50ZWRJbkJhc2UgPSB0aGlzLmlzTWVtYmVyRGVmaW5lZE9uQW5jZXN0b3IoXG4gICAgICAgIGNscyBhcyBzcGVjLkNsYXNzVHlwZSxcbiAgICAgICAgcHJvcCxcbiAgICAgICk7XG4gICAgICBpZiAoaW1wbGVtZW50ZWRJbkJhc2UgfHwgZGF0YXR5cGUgfHwgcHJveHkpIHtcbiAgICAgICAgLy8gT3ZlcnJpZGUgaWYgdGhlIHByb3BlcnR5IGlzIGluIGEgZGF0YXR5cGUgb3IgcHJveHkgY2xhc3Mgb3IgZGVjbGFyZWQgaW4gYSBwYXJlbnQgY2xhc3MuIElmIHRoZSBtZW1iZXIgaXNcbiAgICAgICAgLy8gc3RhdGljLCB1c2UgdGhlIFwibmV3XCIga2V5d29yZCBpbnN0ZWFkLCB0byBpbmRpY2F0ZSB3ZSBhcmUgaW50ZW50aW9uYWxseSBoaWRpbmcgdGhlIGFuY2VzdG9yIGRlY2xhcmF0aW9uIChhc1xuICAgICAgICAvLyBDIyBkb2VzIG5vdCBpbmhlcml0IHN0YXRpY3MsIHRoZXkgY2FuIGJlIGhpZGRlbiBidXQgbm90IG92ZXJyaWRkZW4pLlRoZSBcIm5ld1wiIGtleXdvcmQgaXMgb3B0aW9uYWwgaW4gdGhpc1xuICAgICAgICAvLyBjb250ZXh0LCBidXQgaGVscHMgY2xhcmlmeSBpbnRlbnRpb24uXG4gICAgICAgIGlzT3ZlcnJpZGVLZXlXb3JkID0gcHJvcC5zdGF0aWMgPyAnbmV3ICcgOiAnb3ZlcnJpZGUgJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcC5hYnN0cmFjdCkge1xuICAgICAgICAvLyBBYnN0cmFjdCBtZW1iZXJzIGdldCBkZWNvcmF0ZWQgYXMgc3VjaFxuICAgICAgICBpc0Fic3RyYWN0S2V5d29yZCA9ICdhYnN0cmFjdCAnO1xuICAgICAgfSBlbHNlIGlmICghcHJvcC5zdGF0aWMgJiYgIWltcGxlbWVudGVkSW5CYXNlKSB7XG4gICAgICAgIC8vIFZpcnR1YWwgaWYgdGhlIHByb3AgaXMgbm90IHN0YXRpYywgYW5kIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBiYXNlIG1lbWJlciwgdGhpcyB3YXkgd2UgY2FuIGxhdGVyIG92ZXJyaWRlIGl0LlxuICAgICAgICBpc1ZpcnR1YWxLZXlXb3JkID0gJ3ZpcnR1YWwgJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwcm9wVHlwZUZRTiA9IHRoaXMudHlwZXJlc29sdmVyLnRvRG90TmV0VHlwZShwcm9wLnR5cGUpO1xuICAgIGNvbnN0IGlzT3B0aW9uYWwgPSBwcm9wLm9wdGlvbmFsID8gJz8nIDogJyc7XG4gICAgY29uc3Qgc3RhdGVtZW50ID0gYCR7YWNjZXNzfSAke2lzQWJzdHJhY3RLZXl3b3JkfSR7aXNWaXJ0dWFsS2V5V29yZH0ke3N0YXRpY0tleVdvcmR9JHtpc092ZXJyaWRlS2V5V29yZH0ke3Byb3BUeXBlRlFOfSR7aXNPcHRpb25hbH0gJHtwcm9wTmFtZX1gO1xuICAgIHRoaXMuY29kZS5vcGVuQmxvY2soc3RhdGVtZW50KTtcblxuICAgIC8vIEVtaXQgZ2V0dGVyc1xuICAgIGlmIChkYXRhdHlwZSB8fCBwcm9wLmNvbnN0IHx8IHByb3AuYWJzdHJhY3QpIHtcbiAgICAgIHRoaXMuY29kZS5saW5lKCdnZXQ7Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBpcyBub24tb3B0aW9uYWwsIGFkZCBhIGJhbmcgdG8gc2lsZW5jZSBjb21waWxlciB3YXJuaW5nXG4gICAgICBjb25zdCBiYW5nID0gcHJvcC5vcHRpb25hbCA/ICcnIDogJyEnO1xuICAgICAgaWYgKHByb3Auc3RhdGljKSB7XG4gICAgICAgIHRoaXMuY29kZS5saW5lKFxuICAgICAgICAgIGBnZXQgPT4gR2V0U3RhdGljUHJvcGVydHk8JHtwcm9wVHlwZUZRTn0ke2lzT3B0aW9uYWx9Pih0eXBlb2YoJHtjbGFzc05hbWV9KSkke2Jhbmd9O2AsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvZGUubGluZShcbiAgICAgICAgICBgZ2V0ID0+IEdldEluc3RhbmNlUHJvcGVydHk8JHtwcm9wVHlwZUZRTn0ke2lzT3B0aW9uYWx9PigpJHtiYW5nfTtgLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVtaXQgc2V0dGVyc1xuICAgIGlmIChkYXRhdHlwZSB8fCAoIXByb3AuaW1tdXRhYmxlICYmIHByb3AuYWJzdHJhY3QpKSB7XG4gICAgICB0aGlzLmNvZGUubGluZSgnc2V0OycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXByb3AuaW1tdXRhYmxlKSB7XG4gICAgICAgIGlmIChwcm9wLnN0YXRpYykge1xuICAgICAgICAgIHRoaXMuY29kZS5saW5lKFxuICAgICAgICAgICAgYHNldCA9PiBTZXRTdGF0aWNQcm9wZXJ0eSh0eXBlb2YoJHtjbGFzc05hbWV9KSwgdmFsdWUpO2AsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvZGUubGluZSgnc2V0ID0+IFNldEluc3RhbmNlUHJvcGVydHkodmFsdWUpOycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb2RlLmNsb3NlQmxvY2soKTtcblxuICAgIHRoaXMuZmxhZ0ZpcnN0TWVtYmVyV3JpdHRlbih0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIGNvbnN0YW50IHByb3BlcnR5XG4gICAqL1xuICBwcml2YXRlIGVtaXRDb25zdFByb3BlcnR5KGNsczogc3BlYy5DbGFzc1R5cGUsIHByb3A6IHNwZWMuUHJvcGVydHkpOiB2b2lkIHtcbiAgICB0aGlzLmVtaXROZXdMaW5lSWZOZWNlc3NhcnkoKTtcbiAgICB0aGlzLmZsYWdGaXJzdE1lbWJlcldyaXR0ZW4odHJ1ZSk7XG4gICAgY29uc3QgcHJvcFR5cGUgPSB0aGlzLnR5cGVyZXNvbHZlci50b0RvdE5ldFR5cGUocHJvcC50eXBlKTtcbiAgICBjb25zdCBpc09wdGlvbmFsID0gcHJvcC5vcHRpb25hbCA/ICc/JyA6ICcnO1xuICAgIHRoaXMuZG90bmV0RG9jR2VuZXJhdG9yLmVtaXREb2NzKHByb3AsIHtcbiAgICAgIGFwaTogJ21lbWJlcicsXG4gICAgICBmcW46IGNscy5mcW4sXG4gICAgICBtZW1iZXJOYW1lOiBwcm9wLm5hbWUsXG4gICAgfSk7XG4gICAgdGhpcy5kb3RuZXRSdW50aW1lR2VuZXJhdG9yLmVtaXRBdHRyaWJ1dGVzRm9yUHJvcGVydHkocHJvcCk7XG4gICAgY29uc3QgYWNjZXNzID0gdGhpcy5yZW5kZXJBY2Nlc3NMZXZlbChwcm9wKTtcbiAgICBjb25zdCBwcm9wTmFtZSA9IHRoaXMubmFtZXV0aWxzLmNvbnZlcnRQcm9wZXJ0eU5hbWUocHJvcC5uYW1lKTtcbiAgICBjb25zdCBzdGF0aWNLZXl3b3JkID0gcHJvcC5zdGF0aWMgPyAnc3RhdGljICcgOiAnJztcblxuICAgIHRoaXMuY29kZS5vcGVuQmxvY2soXG4gICAgICBgJHthY2Nlc3N9ICR7c3RhdGljS2V5d29yZH0ke3Byb3BUeXBlfSR7aXNPcHRpb25hbH0gJHtwcm9wTmFtZX1gLFxuICAgICk7XG4gICAgdGhpcy5jb2RlLmxpbmUoJ2dldDsnKTtcbiAgICB0aGlzLmNvZGUuY2xvc2VCbG9jaygpO1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IHRoaXMudHlwZXJlc29sdmVyLnRvTmF0aXZlRnFuKGNscy5mcW4pO1xuICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBpcyBub24tb3B0aW9uYWwsIGFkZCBhIGJhbmcgdG8gc2lsZW5jZSB0aGUgY29tcGlsZXIgd2FybmluZ1xuICAgIGNvbnN0IGJhbmcgPSBwcm9wLm9wdGlvbmFsID8gJycgOiAnISc7XG4gICAgY29uc3QgaW5pdGlhbGl6ZXIgPSBwcm9wLnN0YXRpY1xuICAgICAgPyBgPSBHZXRTdGF0aWNQcm9wZXJ0eTwke3Byb3BUeXBlfT4odHlwZW9mKCR7Y2xhc3NOYW1lfSkpJHtiYW5nfTtgXG4gICAgICA6IGA9IEdldEluc3RhbmNlUHJvcGVydHk8JHtwcm9wVHlwZX0+KHR5cGVvZigke2NsYXNzTmFtZX0pKSR7YmFuZ307YDtcbiAgICB0aGlzLmNvZGUubGluZShpbml0aWFsaXplcik7XG4gIH1cblxuICBwcml2YXRlIHJlbmRlckFjY2Vzc0xldmVsKG1ldGhvZDogc3BlYy5NZXRob2QgfCBzcGVjLlByb3BlcnR5KTogc3RyaW5nIHtcbiAgICByZXR1cm4gbWV0aG9kLnByb3RlY3RlZCA/ICdwcm90ZWN0ZWQnIDogJ3B1YmxpYyc7XG4gIH1cblxuICBwcml2YXRlIGlzTmVzdGVkKHR5cGU6IHNwZWMuVHlwZSk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5hc3NlbWJseS50eXBlcyB8fCAhdHlwZS5uYW1lc3BhY2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50ID0gYCR7dHlwZS5hc3NlbWJseX0uJHt0eXBlLm5hbWVzcGFjZX1gO1xuICAgIHJldHVybiBwYXJlbnQgaW4gdGhpcy5hc3NlbWJseS50eXBlcztcbiAgfVxuXG4gIHByaXZhdGUgdG9DU2hhcnBGaWxlUGF0aCh0eXBlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0eXBlfS5jc2A7XG4gIH1cblxuICBwcml2YXRlIG9wZW5GaWxlSWZOZWVkZWQoXG4gICAgdHlwZU5hbWU6IHN0cmluZyxcbiAgICBuYW1lc3BhY2U6IHN0cmluZyxcbiAgICBpc05lc3RlZDogYm9vbGVhbixcbiAgICB1c2luZ0RlcHV0eSA9IHRydWUsXG4gICk6IHZvaWQge1xuICAgIC8vIElmIE5lc3RlZCB0eXBlLCB3ZSBzaG91bGRuJ3Qgb3Blbi9jbG9zZSBhIGZpbGVcbiAgICBpZiAoaXNOZXN0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkb3RuZXRQYWNrYWdlSWQgPSB0aGlzLmFzc2VtYmx5LnRhcmdldHM/LmRvdG5ldD8ucGFja2FnZUlkO1xuICAgIGlmICghZG90bmV0UGFja2FnZUlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUaGUgbW9kdWxlICR7dGhpcy5hc3NlbWJseS5uYW1lfSBkb2VzIG5vdCBoYXZlIGEgZG90bmV0LnBhY2thZ2VJZCBzZXR0aW5nYCxcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGZpbGVQYXRoID0gbmFtZXNwYWNlLnJlcGxhY2UoL1suXS9nLCAnLycpO1xuICAgIHRoaXMuY29kZS5vcGVuRmlsZShcbiAgICAgIHBhdGguam9pbihkb3RuZXRQYWNrYWdlSWQsIGZpbGVQYXRoLCB0aGlzLnRvQ1NoYXJwRmlsZVBhdGgodHlwZU5hbWUpKSxcbiAgICApO1xuICAgIGlmICh1c2luZ0RlcHV0eSkge1xuICAgICAgdGhpcy5jb2RlLmxpbmUoJ3VzaW5nIEFtYXpvbi5KU0lJLlJ1bnRpbWUuRGVwdXR5OycpO1xuICAgICAgdGhpcy5jb2RlLmxpbmUoKTtcbiAgICB9XG5cbiAgICAvLyBTdXBwcmVzcyB3YXJuaW5ncyBhYm91dCBtaXNzaW5nIFhNTERvYywgT2Jzb2xldGUgaW5jb25zaXN0ZW5jaWVzXG4gICAgdGhpcy5jb2RlLmxpbmUoJyNwcmFnbWEgd2FybmluZyBkaXNhYmxlIENTMDY3MixDUzA4MDksQ1MxNTkxJyk7XG4gICAgdGhpcy5jb2RlLmxpbmUoKTtcblxuICAgIHRoaXMuY29kZS5vcGVuQmxvY2soYG5hbWVzcGFjZSAke25hbWVzcGFjZX1gKTtcbiAgfVxuXG4gIHByaXZhdGUgY2xvc2VGaWxlSWZOZWVkZWQoXG4gICAgdHlwZU5hbWU6IHN0cmluZyxcbiAgICBuYW1lc3BhY2U6IHN0cmluZyxcbiAgICBpc05lc3RlZDogYm9vbGVhbixcbiAgKTogdm9pZCB7XG4gICAgaWYgKGlzTmVzdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY29kZS5jbG9zZUJsb2NrKCk7XG5cbiAgICBjb25zdCBkb3RuZXRQYWNrYWdlSWQgPSB0aGlzLmFzc2VtYmx5LnRhcmdldHM/LmRvdG5ldD8ucGFja2FnZUlkO1xuICAgIGlmICghZG90bmV0UGFja2FnZUlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUaGUgbW9kdWxlICR7dGhpcy5hc3NlbWJseS5uYW1lfSBkb2VzIG5vdCBoYXZlIGEgZG90bmV0LnBhY2thZ2VJZCBzZXR0aW5nYCxcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGZpbGVQYXRoID0gbmFtZXNwYWNlLnJlcGxhY2UoL1suXS9nLCAnLycpO1xuICAgIHRoaXMuY29kZS5jbG9zZUZpbGUoXG4gICAgICBwYXRoLmpvaW4oZG90bmV0UGFja2FnZUlkLCBmaWxlUGF0aCwgdGhpcy50b0NTaGFycEZpbGVQYXRoKHR5cGVOYW1lKSksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGZpcnN0TWVtYmVyIGJvb2xlYW4gZmxhZyB0byBrZWVwIHRyYWNrIG9mIHRoZSBmaXJzdCBtZW1iZXIgb2YgYSBuZXcgZmlsZVxuICAgKlxuICAgKiBUaGlzIGF2b2lkcyB1bm5lY2Vzc2FyeSB3aGl0ZSBsaW5lc1xuICAgKi9cbiAgcHJpdmF0ZSBmbGFnRmlyc3RNZW1iZXJXcml0dGVuKGZpcnN0OiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5maXJzdE1lbWJlcldyaXR0ZW4gPSBmaXJzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIG5ldyBsaW5lIHByaW9yIHRvIHdyaXRpbmcgYSBuZXcgcHJvcGVydHksIG1ldGhvZCwgaWYgdGhlIHByb3BlcnR5IGlzIG5vdCB0aGUgZmlyc3Qgb25lIGluIHRoZSBjbGFzc1xuICAgKlxuICAgKiBUaGlzIGF2b2lkcyB1bm5lY2Vzc2FyeSB3aGl0ZSBsaW5lcy5cbiAgICovXG4gIHByaXZhdGUgZW1pdE5ld0xpbmVJZk5lY2Vzc2FyeSgpOiB2b2lkIHtcbiAgICAvLyBJZiB0aGUgZmlyc3QgbWVtYmVyIGhhcyBhbHJlYWR5IGJlZW4gd3JpdHRlbiwgaXQgaXMgc2FmZSB0byB3cml0ZSBhIG5ldyBsaW5lXG4gICAgaWYgKHRoaXMuZmlyc3RNZW1iZXJXcml0dGVuKSB7XG4gICAgICB0aGlzLmNvZGUubGluZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpcnN0TWVtYmVyV3JpdHRlbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZW1pdEFzc2VtYmx5RG9jcygpIHtcbiAgICB0aGlzLmVtaXROYW1lc3BhY2VEb2NzKFxuICAgICAgdGhpcy5hc3NlbWJseS50YXJnZXRzIS5kb3RuZXQhLm5hbWVzcGFjZSxcbiAgICAgIHRoaXMuYXNzZW1ibHkubmFtZSxcbiAgICAgIHRoaXMuYXNzZW1ibHksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGFuIHVudXNlZCwgZW1wdHkgY2xhc3MgY2FsbGVkIGBOYW1lc3BhY2VEb2NgIHRvIGF0dGFjaCB0aGUgbW9kdWxlIFJFQURNRSB0b1xuICAgKlxuICAgKiBUaGVyZSBpcyBubyB3YXkgdG8gYXR0YWNoIGRvYyBjb21tZW50cyB0byBhIG5hbWVzcGFjZSBpbiBDIywgYW5kIHRoaXMgdHJpY2sgaGFzIGJlZW5cbiAgICogc2VtaS1zdGFuZGFyZGl6ZWQgYnkgTkRvYyBhbmQgU2FuZGNhc3RsZSBIZWxwIEZpbGUgQnVpbGRlci5cbiAgICpcbiAgICogRG9jRlggZG9lc24ndCBzdXBwb3J0IGl0IG91dCBvZiB0aGUgYm94LCBidXQgd2Ugc2hvdWxkIGJlIGFibGUgdG8gZ2V0IHRoZXJlIHdpdGggYVxuICAgKiBiaXQgb2YgaGFja2VyeS5cbiAgICpcbiAgICogSW4gYW55IGNhc2UsIHdlIG5lZWQgYSBwbGFjZSB0byBhdHRhY2ggdGhlIGRvY3Mgd2hlcmUgdGhleSBjYW4gYmUgdHJhbnNwb3J0ZWQgYXJvdW5kLFxuICAgKiBtaWdodCBhcyB3ZWxsIGJlIHRoaXMgbWV0aG9kLlxuICAgKi9cbiAgcHJpdmF0ZSBlbWl0TmFtZXNwYWNlRG9jcyhcbiAgICBuYW1lc3BhY2U6IHN0cmluZyxcbiAgICBqc2lpRnFuOiBzdHJpbmcsXG4gICAgZG9jU291cmNlOiBzcGVjLlRhcmdldGFibGUsXG4gICkge1xuICAgIGlmICghZG9jU291cmNlLnJlYWRtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNsYXNzTmFtZSA9ICdOYW1lc3BhY2VEb2MnO1xuICAgIHRoaXMub3BlbkZpbGVJZk5lZWRlZChjbGFzc05hbWUsIG5hbWVzcGFjZSwgZmFsc2UsIGZhbHNlKTtcblxuICAgIHRoaXMuZG90bmV0RG9jR2VuZXJhdG9yLmVtaXRNYXJrZG93bkFzUmVtYXJrcyhkb2NTb3VyY2UucmVhZG1lLm1hcmtkb3duLCB7XG4gICAgICBhcGk6ICdtb2R1bGVSZWFkbWUnLFxuICAgICAgbW9kdWxlRnFuOiBqc2lpRnFuLFxuICAgIH0pO1xuICAgIHRoaXMuZW1pdEhpZGVBdHRyaWJ1dGUoKTtcbiAgICAvLyBUcmFkaXRpb25hbGx5IHRoaXMgY2xhc3MgaXMgbWFkZSAnaW50ZXJuYWwnLCBidXQgdGhhdCBpbnRlcmFjdHMgcG9vcmx5IHdpdGggRG9jRlgncyBkZWZhdWx0IGZpbHRlcnNcbiAgICAvLyB3aGljaCBhcmVuJ3Qgb3ZlcnJpZGFibGUuIFNvIHdlIG1ha2UgaXQgcHVibGljLCBidXQgdXNlIGF0dHJpYnV0ZXMgdG8gaGlkZSBpdCBmcm9tIHVzZXJzJyBJbnRlbGxpU2Vuc2UsXG4gICAgLy8gc28gdGhhdCB3ZSBjYW4gYWNjZXNzIHRoZSBjbGFzcyBpbiBEb2NGWC5cbiAgICB0aGlzLmNvZGUub3BlbkJsb2NrKGBwdWJsaWMgY2xhc3MgJHtjbGFzc05hbWV9YCk7XG4gICAgdGhpcy5jb2RlLmNsb3NlQmxvY2soKTtcbiAgICB0aGlzLmNsb3NlRmlsZUlmTmVlZGVkKGNsYXNzTmFtZSwgbmFtZXNwYWNlLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogRW1pdCBhbiBhdHRyaWJ1dGUgdGhhdCB3aWxsIGhpZGUgdGhlIHN1YnNlcXVlbnQgQVBJIGVsZW1lbnQgZnJvbSB1c2Vyc1xuICAgKi9cbiAgcHJpdmF0ZSBlbWl0SGlkZUF0dHJpYnV0ZSgpIHtcbiAgICB0aGlzLmNvZGUubGluZShcbiAgICAgICdbU3lzdGVtLkNvbXBvbmVudE1vZGVsLkVkaXRvckJyb3dzYWJsZShTeXN0ZW0uQ29tcG9uZW50TW9kZWwuRWRpdG9yQnJvd3NhYmxlU3RhdGUuTmV2ZXIpXScsXG4gICAgKTtcbiAgfVxufVxuIl19