"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toReleaseVersion = exports.toPythonVersionRange = exports.toNuGetVersionRange = exports.toMavenVersionRange = void 0;
const semver_1 = require("semver");
const util_1 = require("util");
const _1 = require(".");
/**
 * Converts a SemVer range expression to a Maven version range expression.
 *
 * @param semverRange the SemVer range expression to convert.
 * @param suffix      the suffix to add to versions in the range.
 *
 * @see https://cwiki.apache.org/confluence/display/MAVENOLD/Dependency+Mediation+and+Conflict+Resolution
 */
function toMavenVersionRange(semverRange, suffix) {
    return toBracketNotation(semverRange, suffix, {
        semver: false,
        target: _1.TargetName.JAVA,
    });
}
exports.toMavenVersionRange = toMavenVersionRange;
/**
 * Converts a SemVer range expression to a NuGet version range expression.
 *
 * @param semverRange the SemVer range expression to convert.
 *
 * @see https://docs.microsoft.com/en-us/nuget/concepts/package-versioning#version-ranges-and-wildcards
 */
function toNuGetVersionRange(semverRange) {
    return toBracketNotation(semverRange, undefined, {
        semver: false,
        target: _1.TargetName.DOTNET,
    });
}
exports.toNuGetVersionRange = toNuGetVersionRange;
/**
 * Converts a SemVer range expression to a Python setuptools compatible version
 * constraint expression.
 *
 * @param semverRange the SemVer range expression to convert.
 */
function toPythonVersionRange(semverRange) {
    const range = new semver_1.Range(semverRange);
    return range.set
        .map((set) => set
        .map((comp) => {
        var _a, _b;
        const versionId = toReleaseVersion((_b = (_a = comp.semver.raw) === null || _a === void 0 ? void 0 : _a.replace(/-0$/, '')) !== null && _b !== void 0 ? _b : '0.0.0', _1.TargetName.PYTHON);
        switch (comp.operator) {
            case '':
                // With ^0.0.0, somehow we get a left entry with an empty operator and value, we'll fix this up
                return comp.value === '' ? '>=0.0.0' : `==${versionId}`;
            case '=':
                return `==${versionId}`;
            default:
                // >, >=, <, <= are all valid expressions
                return `${comp.operator}${versionId}`;
        }
    })
        .join(', '))
        .join(', ');
}
exports.toPythonVersionRange = toPythonVersionRange;
/**
 * Converts an original version number from the NPM convention to the target
 * language's convention for expressing the same. For versions that do not
 * include a prerelease identifier, this always returns the assembly version
 * unmodified.
 *
 * @param assemblyVersion the assembly version being released
 * @param target          the target language for which the version is destined
 *
 * @returns the version that should be serialized
 */
function toReleaseVersion(assemblyVersion, target) {
    const version = semver_1.parse(assemblyVersion, { includePrerelease: true });
    if (version == null) {
        throw new Error(`Unable to parse the provided assembly version: "${assemblyVersion}"`);
    }
    if (version.prerelease.length === 0) {
        return assemblyVersion;
    }
    switch (target) {
        case _1.TargetName.PYTHON:
            // Python supports a limited set of identifiers... And we have a mapping table...
            // https://packaging.python.org/guides/distributing-packages-using-setuptools/#pre-release-versioning
            const [label, sequence, ...rest] = version.prerelease;
            if (rest.filter((elt) => elt !== 0).length > 0 || sequence == null) {
                throw new Error(`Unable to map prerelease identifier (in: ${assemblyVersion}) components to python: ${util_1.inspect(version.prerelease)}. The format should be 'X.Y.Z-label.sequence', where sequence is a positive integer, and label is "dev", "pre", "alpha", beta", or "rc"`);
            }
            if (!Number.isInteger(sequence)) {
                throw new Error(`Unable to map prerelease identifier (in: ${assemblyVersion}) to python, as sequence ${util_1.inspect(sequence)} is not an integer`);
            }
            const baseVersion = `${version.major}.${version.minor}.${version.patch}`;
            // See PEP 440: https://www.python.org/dev/peps/pep-0440/#pre-releases
            switch (label) {
                case 'dev':
                case 'pre':
                    return `${baseVersion}.dev${sequence}`;
                case 'alpha':
                    return `${baseVersion}.a${sequence}`;
                case 'beta':
                    return `${baseVersion}.b${sequence}`;
                case 'rc':
                    return `${baseVersion}.rc${sequence}`;
                default:
                    throw new Error(`Unable to map prerelease identifier (in: ${assemblyVersion}) to python, as label ${util_1.inspect(label)} is not mapped (only "dev", "pre", "alpha", "beta" and "rc" are)`);
            }
        case _1.TargetName.DOTNET:
        case _1.TargetName.GO:
        case _1.TargetName.JAVA:
        case _1.TargetName.JAVASCRIPT:
            // Not touching - the NPM version number should be usable as-is
            break;
    }
    return assemblyVersion;
}
exports.toReleaseVersion = toReleaseVersion;
/**
 * Converts a semantic version range to the kind of bracket notation used by
 * Maven and NuGet. For example, this turns `^1.2.3` into `[1.2.3,2.0.0)`.
 *
 * @param semverRange The semantic version range to be converted.
 * @param suffix A version suffix to apply to versions in the resulting expression.
 * @param semver Whether the target supports full semantic versioning (including
 *               `-0` as the lowest possible prerelease identifier)
 *
 * @returns a bracket-notation version range.
 */
function toBracketNotation(semverRange, suffix, { semver = true, target = _1.TargetName.JAVASCRIPT, } = {}) {
    if (semverRange === '*' || semverRange === '^0.0.0') {
        semverRange = '>=0.0.0';
    }
    const range = new semver_1.Range(semverRange);
    return range.set
        .map((set) => {
        if (set.length === 1) {
            const version = set[0].semver.raw;
            if (!version && range.raw === '>=0.0.0') {
                // Case where version is '*'
                return `[0.0.0,)`;
            }
            switch (set[0].operator || '=') {
                // "[version]" => means exactly version
                case '=':
                    return `[${addSuffix(version)}]`;
                // "(version,]" => means greater than version
                case '>':
                    return `(${addSuffix(version)},)`;
                // "[version,]" => means greater than or equal to that version
                case '>=':
                    return `[${addSuffix(version)},)`;
                // "[,version)" => means less than version
                case '<':
                    return `(,${addSuffix(version, !semver)})`;
                // "[,version]" => means less than or equal to version
                case '<=':
                    return `(,${addSuffix(version)}]`;
            }
        }
        else if (set.length === 2) {
            const nugetRange = toBracketRange(set[0], set[1]);
            if (nugetRange) {
                return nugetRange;
            }
        }
        throw new Error(`Unsupported SemVer range set in ${semverRange}: ${set
            .map((comp) => comp.value)
            .join(', ')}`);
    })
        .join(', ');
    function toBracketRange(left, right) {
        if (left.operator.startsWith('<') && right.operator.startsWith('>')) {
            // Order isn't ideal, swap around..
            [left, right] = [right, left];
        }
        // With ^0.0.0, somehow we get a left entry with an empty operator and value, we'll fix this up
        if (left.operator === '' && left.value === '') {
            left = new semver_1.Comparator('>=0.0.0', left.options);
        }
        if (!left.operator.startsWith('>') || !right.operator.startsWith('<')) {
            // We only support ranges defined like "> (or >=) left, < (or <=) right"
            return undefined;
        }
        const leftBrace = left.operator.endsWith('=') ? '[' : '(';
        const rightBrace = right.operator.endsWith('=') ? ']' : ')';
        return `${leftBrace}${addSuffix(left.semver.raw)},${addSuffix(right.semver.raw, right.operator === '<' && !semver)}${rightBrace}`;
    }
    function addSuffix(str, trimDashZero = false) {
        if (!str) {
            return '';
        }
        if (trimDashZero) {
            str = str.replace(/-0$/, '');
        }
        return suffix ? `${str}${suffix}` : toReleaseVersion(str, target);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVyc2lvbi11dGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInZlcnNpb24tdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsbUNBQWtEO0FBQ2xELCtCQUErQjtBQUUvQix3QkFBK0I7QUFFL0I7Ozs7Ozs7R0FPRztBQUNILFNBQWdCLG1CQUFtQixDQUNqQyxXQUFtQixFQUNuQixNQUFlO0lBRWYsT0FBTyxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsTUFBTSxFQUFFO1FBQzVDLE1BQU0sRUFBRSxLQUFLO1FBQ2IsTUFBTSxFQUFFLGFBQVUsQ0FBQyxJQUFJO0tBQ3hCLENBQUMsQ0FBQztBQUNMLENBQUM7QUFSRCxrREFRQztBQUVEOzs7Ozs7R0FNRztBQUNILFNBQWdCLG1CQUFtQixDQUFDLFdBQW1CO0lBQ3JELE9BQU8saUJBQWlCLENBQUMsV0FBVyxFQUFFLFNBQVMsRUFBRTtRQUMvQyxNQUFNLEVBQUUsS0FBSztRQUNiLE1BQU0sRUFBRSxhQUFVLENBQUMsTUFBTTtLQUMxQixDQUFDLENBQUM7QUFDTCxDQUFDO0FBTEQsa0RBS0M7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLG9CQUFvQixDQUFDLFdBQW1CO0lBQ3RELE1BQU0sS0FBSyxHQUFHLElBQUksY0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3JDLE9BQU8sS0FBSyxDQUFDLEdBQUc7U0FDYixHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUNYLEdBQUc7U0FDQSxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTs7UUFDWixNQUFNLFNBQVMsR0FBRyxnQkFBZ0IsYUFDaEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLDBDQUFFLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRSxvQ0FBSyxPQUFPLEVBQzlDLGFBQVUsQ0FBQyxNQUFNLENBQ2xCLENBQUM7UUFDRixRQUFRLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDckIsS0FBSyxFQUFFO2dCQUNMLCtG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LENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDckUsd0VBQXdFO1lBQ3hFLE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBRUQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO1FBQzFELE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztRQUM1RCxPQUFPLEdBQUcsU0FBUyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLFNBQVMsQ0FDM0QsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQ2hCLEtBQUssQ0FBQyxRQUFRLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUNsQyxHQUFHLFVBQVUsRUFBRSxDQUFDO0lBQ25CLENBQUM7SUFFRCxTQUFTLFNBQVMsQ0FBQyxHQUF1QixFQUFFLFlBQVksR0FBRyxLQUFLO1FBQzlELElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDUixPQUFPLEVBQUUsQ0FBQztTQUNYO1FBQ0QsSUFBSSxZQUFZLEVBQUU7WUFDaEIsR0FBRyxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1NBQzlCO1FBQ0QsT0FBTyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDcEUsQ0FBQztBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wYXJhdG9yLCBSYW5nZSwgcGFyc2UgfSBmcm9tICdzZW12ZXInO1xuaW1wb3J0IHsgaW5zcGVjdCB9IGZyb20gJ3V0aWwnO1xuXG5pbXBvcnQgeyBUYXJnZXROYW1lIH0gZnJvbSAnLic7XG5cbi8qKlxuICogQ29udmVydHMgYSBTZW1WZXIgcmFuZ2UgZXhwcmVzc2lvbiB0byBhIE1hdmVuIHZlcnNpb24gcmFuZ2UgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0gc2VtdmVyUmFuZ2UgdGhlIFNlbVZlciByYW5nZSBleHByZXNzaW9uIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gc3VmZml4ICAgICAgdGhlIHN1ZmZpeCB0byBhZGQgdG8gdmVyc2lvbnMgaW4gdGhlIHJhbmdlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9NQVZFTk9MRC9EZXBlbmRlbmN5K01lZGlhdGlvbithbmQrQ29uZmxpY3QrUmVzb2x1dGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9NYXZlblZlcnNpb25SYW5nZShcbiAgc2VtdmVyUmFuZ2U6IHN0cmluZyxcbiAgc3VmZml4Pzogc3RyaW5nLFxuKTogc3RyaW5nIHtcbiAgcmV0dXJuIHRvQnJhY2tldE5vdGF0aW9uKHNlbXZlclJhbmdlLCBzdWZmaXgsIHtcbiAgICBzZW12ZXI6IGZhbHNlLFxuICAgIHRhcmdldDogVGFyZ2V0TmFtZS5KQVZBLFxuICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIFNlbVZlciByYW5nZSBleHByZXNzaW9uIHRvIGEgTnVHZXQgdmVyc2lvbiByYW5nZSBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSBzZW12ZXJSYW5nZSB0aGUgU2VtVmVyIHJhbmdlIGV4cHJlc3Npb24gdG8gY29udmVydC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL251Z2V0L2NvbmNlcHRzL3BhY2thZ2UtdmVyc2lvbmluZyN2ZXJzaW9uLXJhbmdlcy1hbmQtd2lsZGNhcmRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b051R2V0VmVyc2lvblJhbmdlKHNlbXZlclJhbmdlOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gdG9CcmFja2V0Tm90YXRpb24oc2VtdmVyUmFuZ2UsIHVuZGVmaW5lZCwge1xuICAgIHNlbXZlcjogZmFsc2UsXG4gICAgdGFyZ2V0OiBUYXJnZXROYW1lLkRPVE5FVCxcbiAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBTZW1WZXIgcmFuZ2UgZXhwcmVzc2lvbiB0byBhIFB5dGhvbiBzZXR1cHRvb2xzIGNvbXBhdGlibGUgdmVyc2lvblxuICogY29uc3RyYWludCBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSBzZW12ZXJSYW5nZSB0aGUgU2VtVmVyIHJhbmdlIGV4cHJlc3Npb24gdG8gY29udmVydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUHl0aG9uVmVyc2lvblJhbmdlKHNlbXZlclJhbmdlOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCByYW5nZSA9IG5ldyBSYW5nZShzZW12ZXJSYW5nZSk7XG4gIHJldHVybiByYW5nZS5zZXRcbiAgICAubWFwKChzZXQpID0+XG4gICAgICBzZXRcbiAgICAgICAgLm1hcCgoY29tcCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHZlcnNpb25JZCA9IHRvUmVsZWFzZVZlcnNpb24oXG4gICAgICAgICAgICBjb21wLnNlbXZlci5yYXc/LnJlcGxhY2UoLy0wJC8sICcnKSA/PyAnMC4wLjAnLFxuICAgICAgICAgICAgVGFyZ2V0TmFtZS5QWVRIT04sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzd2l0Y2ggKGNvbXAub3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgJyc6XG4gICAgICAgICAgICAgIC8vIFdpdGggXjAuMC4wLCBzb21laG93IHdlIGdldCBhIGxlZnQgZW50cnkgd2l0aCBhbiBlbXB0eSBvcGVyYXRvciBhbmQgdmFsdWUsIHdlJ2xsIGZpeCB0aGlzIHVwXG4gICAgICAgICAgICAgIHJldHVybiBjb21wLnZhbHVlID09PSAnJyA/ICc+PTAuMC4wJyA6IGA9PSR7dmVyc2lvbklkfWA7XG4gICAgICAgICAgICBjYXNlICc9JzpcbiAgICAgICAgICAgICAgcmV0dXJuIGA9PSR7dmVyc2lvbklkfWA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyA+LCA+PSwgPCwgPD0gYXJlIGFsbCB2YWxpZCBleHByZXNzaW9uc1xuICAgICAgICAgICAgICByZXR1cm4gYCR7Y29tcC5vcGVyYXRvcn0ke3ZlcnNpb25JZH1gO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oJywgJyksXG4gICAgKVxuICAgIC5qb2luKCcsICcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9yaWdpbmFsIHZlcnNpb24gbnVtYmVyIGZyb20gdGhlIE5QTSBjb252ZW50aW9uIHRvIHRoZSB0YXJnZXRcbiAqIGxhbmd1YWdlJ3MgY29udmVudGlvbiBmb3IgZXhwcmVzc2luZyB0aGUgc2FtZS4gRm9yIHZlcnNpb25zIHRoYXQgZG8gbm90XG4gKiBpbmNsdWRlIGEgcHJlcmVsZWFzZSBpZGVudGlmaWVyLCB0aGlzIGFsd2F5cyByZXR1cm5zIHRoZSBhc3NlbWJseSB2ZXJzaW9uXG4gKiB1bm1vZGlmaWVkLlxuICpcbiAqIEBwYXJhbSBhc3NlbWJseVZlcnNpb24gdGhlIGFzc2VtYmx5IHZlcnNpb24gYmVpbmcgcmVsZWFzZWRcbiAqIEBwYXJhbSB0YXJnZXQgICAgICAgICAgdGhlIHRhcmdldCBsYW5ndWFnZSBmb3Igd2hpY2ggdGhlIHZlcnNpb24gaXMgZGVzdGluZWRcbiAqXG4gKiBAcmV0dXJucyB0aGUgdmVyc2lvbiB0aGF0IHNob3VsZCBiZSBzZXJpYWxpemVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JlbGVhc2VWZXJzaW9uKFxuICBhc3NlbWJseVZlcnNpb246IHN0cmluZyxcbiAgdGFyZ2V0OiBUYXJnZXROYW1lLFxuKTogc3RyaW5nIHtcbiAgY29uc3QgdmVyc2lvbiA9IHBhcnNlKGFzc2VtYmx5VmVyc2lvbiwgeyBpbmNsdWRlUHJlcmVsZWFzZTogdHJ1ZSB9KTtcbiAgaWYgKHZlcnNpb24gPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBVbmFibGUgdG8gcGFyc2UgdGhlIHByb3ZpZGVkIGFzc2VtYmx5IHZlcnNpb246IFwiJHthc3NlbWJseVZlcnNpb259XCJgLFxuICAgICk7XG4gIH1cbiAgaWYgKHZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gYXNzZW1ibHlWZXJzaW9uO1xuICB9XG4gIHN3aXRjaCAodGFyZ2V0KSB7XG4gICAgY2FzZSBUYXJnZXROYW1lLlBZVEhPTjpcbiAgICAgIC8vIFB5dGhvbiBzdXBwb3J0cyBhIGxpbWl0ZWQgc2V0IG9mIGlkZW50aWZpZXJzLi4uIEFuZCB3ZSBoYXZlIGEgbWFwcGluZyB0YWJsZS4uLlxuICAgICAgLy8gaHR0cHM6Ly9wYWNrYWdpbmcucHl0aG9uLm9yZy9ndWlkZXMvZGlzdHJpYnV0aW5nLXBhY2thZ2VzLXVzaW5nLXNldHVwdG9vbHMvI3ByZS1yZWxlYXNlLXZlcnNpb25pbmdcbiAgICAgIGNvbnN0IFtsYWJlbCwgc2VxdWVuY2UsIC4uLnJlc3RdID0gdmVyc2lvbi5wcmVyZWxlYXNlO1xuICAgICAgaWYgKHJlc3QuZmlsdGVyKChlbHQpID0+IGVsdCAhPT0gMCkubGVuZ3RoID4gMCB8fCBzZXF1ZW5jZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVW5hYmxlIHRvIG1hcCBwcmVyZWxlYXNlIGlkZW50aWZpZXIgKGluOiAke2Fzc2VtYmx5VmVyc2lvbn0pIGNvbXBvbmVudHMgdG8gcHl0aG9uOiAke2luc3BlY3QoXG4gICAgICAgICAgICB2ZXJzaW9uLnByZXJlbGVhc2UsXG4gICAgICAgICAgKX0uIFRoZSBmb3JtYXQgc2hvdWxkIGJlICdYLlkuWi1sYWJlbC5zZXF1ZW5jZScsIHdoZXJlIHNlcXVlbmNlIGlzIGEgcG9zaXRpdmUgaW50ZWdlciwgYW5kIGxhYmVsIGlzIFwiZGV2XCIsIFwicHJlXCIsIFwiYWxwaGFcIiwgYmV0YVwiLCBvciBcInJjXCJgLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHNlcXVlbmNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFVuYWJsZSB0byBtYXAgcHJlcmVsZWFzZSBpZGVudGlmaWVyIChpbjogJHthc3NlbWJseVZlcnNpb259KSB0byBweXRob24sIGFzIHNlcXVlbmNlICR7aW5zcGVjdChcbiAgICAgICAgICAgIHNlcXVlbmNlLFxuICAgICAgICAgICl9IGlzIG5vdCBhbiBpbnRlZ2VyYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJhc2VWZXJzaW9uID0gYCR7dmVyc2lvbi5tYWpvcn0uJHt2ZXJzaW9uLm1pbm9yfS4ke3ZlcnNpb24ucGF0Y2h9YDtcbiAgICAgIC8vIFNlZSBQRVAgNDQwOiBodHRwczovL3d3dy5weXRob24ub3JnL2Rldi9wZXBzL3BlcC0wNDQwLyNwcmUtcmVsZWFzZXNcbiAgICAgIHN3aXRjaCAobGFiZWwpIHtcbiAgICAgICAgY2FzZSAnZGV2JzpcbiAgICAgICAgY2FzZSAncHJlJzpcbiAgICAgICAgICByZXR1cm4gYCR7YmFzZVZlcnNpb259LmRldiR7c2VxdWVuY2V9YDtcbiAgICAgICAgY2FzZSAnYWxwaGEnOlxuICAgICAgICAgIHJldHVybiBgJHtiYXNlVmVyc2lvbn0uYSR7c2VxdWVuY2V9YDtcbiAgICAgICAgY2FzZSAnYmV0YSc6XG4gICAgICAgICAgcmV0dXJuIGAke2Jhc2VWZXJzaW9ufS5iJHtzZXF1ZW5jZX1gO1xuICAgICAgICBjYXNlICdyYyc6XG4gICAgICAgICAgcmV0dXJuIGAke2Jhc2VWZXJzaW9ufS5yYyR7c2VxdWVuY2V9YDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVW5hYmxlIHRvIG1hcCBwcmVyZWxlYXNlIGlkZW50aWZpZXIgKGluOiAke2Fzc2VtYmx5VmVyc2lvbn0pIHRvIHB5dGhvbiwgYXMgbGFiZWwgJHtpbnNwZWN0KFxuICAgICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgICl9IGlzIG5vdCBtYXBwZWQgKG9ubHkgXCJkZXZcIiwgXCJwcmVcIiwgXCJhbHBoYVwiLCBcImJldGFcIiBhbmQgXCJyY1wiIGFyZSlgLFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgY2FzZSBUYXJnZXROYW1lLkRPVE5FVDpcbiAgICBjYXNlIFRhcmdldE5hbWUuR086XG4gICAgY2FzZSBUYXJnZXROYW1lLkpBVkE6XG4gICAgY2FzZSBUYXJnZXROYW1lLkpBVkFTQ1JJUFQ6XG4gICAgICAvLyBOb3QgdG91Y2hpbmcgLSB0aGUgTlBNIHZlcnNpb24gbnVtYmVyIHNob3VsZCBiZSB1c2FibGUgYXMtaXNcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBhc3NlbWJseVZlcnNpb247XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzZW1hbnRpYyB2ZXJzaW9uIHJhbmdlIHRvIHRoZSBraW5kIG9mIGJyYWNrZXQgbm90YXRpb24gdXNlZCBieVxuICogTWF2ZW4gYW5kIE51R2V0LiBGb3IgZXhhbXBsZSwgdGhpcyB0dXJucyBgXjEuMi4zYCBpbnRvIGBbMS4yLjMsMi4wLjApYC5cbiAqXG4gKiBAcGFyYW0gc2VtdmVyUmFuZ2UgVGhlIHNlbWFudGljIHZlcnNpb24gcmFuZ2UgdG8gYmUgY29udmVydGVkLlxuICogQHBhcmFtIHN1ZmZpeCBBIHZlcnNpb24gc3VmZml4IHRvIGFwcGx5IHRvIHZlcnNpb25zIGluIHRoZSByZXN1bHRpbmcgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSBzZW12ZXIgV2hldGhlciB0aGUgdGFyZ2V0IHN1cHBvcnRzIGZ1bGwgc2VtYW50aWMgdmVyc2lvbmluZyAoaW5jbHVkaW5nXG4gKiAgICAgICAgICAgICAgIGAtMGAgYXMgdGhlIGxvd2VzdCBwb3NzaWJsZSBwcmVyZWxlYXNlIGlkZW50aWZpZXIpXG4gKlxuICogQHJldHVybnMgYSBicmFja2V0LW5vdGF0aW9uIHZlcnNpb24gcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHRvQnJhY2tldE5vdGF0aW9uKFxuICBzZW12ZXJSYW5nZTogc3RyaW5nLFxuICBzdWZmaXg/OiBzdHJpbmcsXG4gIHtcbiAgICBzZW12ZXIgPSB0cnVlLFxuICAgIHRhcmdldCA9IFRhcmdldE5hbWUuSkFWQVNDUklQVCxcbiAgfTogeyBzZW12ZXI/OiBib29sZWFuOyB0YXJnZXQ/OiBUYXJnZXROYW1lIH0gPSB7fSxcbik6IHN0cmluZyB7XG4gIGlmIChzZW12ZXJSYW5nZSA9PT0gJyonIHx8IHNlbXZlclJhbmdlID09PSAnXjAuMC4wJykge1xuICAgIHNlbXZlclJhbmdlID0gJz49MC4wLjAnO1xuICB9XG4gIGNvbnN0IHJhbmdlID0gbmV3IFJhbmdlKHNlbXZlclJhbmdlKTtcbiAgcmV0dXJuIHJhbmdlLnNldFxuICAgIC5tYXAoKHNldCkgPT4ge1xuICAgICAgaWYgKHNldC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHNldFswXS5zZW12ZXIucmF3O1xuICAgICAgICBpZiAoIXZlcnNpb24gJiYgcmFuZ2UucmF3ID09PSAnPj0wLjAuMCcpIHtcbiAgICAgICAgICAvLyBDYXNlIHdoZXJlIHZlcnNpb24gaXMgJyonXG4gICAgICAgICAgcmV0dXJuIGBbMC4wLjAsKWA7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChzZXRbMF0ub3BlcmF0b3IgfHwgJz0nKSB7XG4gICAgICAgICAgLy8gXCJbdmVyc2lvbl1cIiA9PiBtZWFucyBleGFjdGx5IHZlcnNpb25cbiAgICAgICAgICBjYXNlICc9JzpcbiAgICAgICAgICAgIHJldHVybiBgWyR7YWRkU3VmZml4KHZlcnNpb24pfV1gO1xuICAgICAgICAgIC8vIFwiKHZlcnNpb24sXVwiID0+IG1lYW5zIGdyZWF0ZXIgdGhhbiB2ZXJzaW9uXG4gICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICByZXR1cm4gYCgke2FkZFN1ZmZpeCh2ZXJzaW9uKX0sKWA7XG4gICAgICAgICAgLy8gXCJbdmVyc2lvbixdXCIgPT4gbWVhbnMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoYXQgdmVyc2lvblxuICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgIHJldHVybiBgWyR7YWRkU3VmZml4KHZlcnNpb24pfSwpYDtcbiAgICAgICAgICAvLyBcIlssdmVyc2lvbilcIiA9PiBtZWFucyBsZXNzIHRoYW4gdmVyc2lvblxuICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgcmV0dXJuIGAoLCR7YWRkU3VmZml4KHZlcnNpb24sICFzZW12ZXIpfSlgO1xuICAgICAgICAgIC8vIFwiWyx2ZXJzaW9uXVwiID0+IG1lYW5zIGxlc3MgdGhhbiBvciBlcXVhbCB0byB2ZXJzaW9uXG4gICAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgcmV0dXJuIGAoLCR7YWRkU3VmZml4KHZlcnNpb24pfV1gO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNldC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgY29uc3QgbnVnZXRSYW5nZSA9IHRvQnJhY2tldFJhbmdlKHNldFswXSwgc2V0WzFdKTtcbiAgICAgICAgaWYgKG51Z2V0UmFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gbnVnZXRSYW5nZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVW5zdXBwb3J0ZWQgU2VtVmVyIHJhbmdlIHNldCBpbiAke3NlbXZlclJhbmdlfTogJHtzZXRcbiAgICAgICAgICAubWFwKChjb21wKSA9PiBjb21wLnZhbHVlKVxuICAgICAgICAgIC5qb2luKCcsICcpfWAsXG4gICAgICApO1xuICAgIH0pXG4gICAgLmpvaW4oJywgJyk7XG5cbiAgZnVuY3Rpb24gdG9CcmFja2V0UmFuZ2UoXG4gICAgbGVmdDogQ29tcGFyYXRvcixcbiAgICByaWdodDogQ29tcGFyYXRvcixcbiAgKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAobGVmdC5vcGVyYXRvci5zdGFydHNXaXRoKCc8JykgJiYgcmlnaHQub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPicpKSB7XG4gICAgICAvLyBPcmRlciBpc24ndCBpZGVhbCwgc3dhcCBhcm91bmQuLlxuICAgICAgW2xlZnQsIHJpZ2h0XSA9IFtyaWdodCwgbGVmdF07XG4gICAgfVxuXG4gICAgLy8gV2l0aCBeMC4wLjAsIHNvbWVob3cgd2UgZ2V0IGEgbGVmdCBlbnRyeSB3aXRoIGFuIGVtcHR5IG9wZXJhdG9yIGFuZCB2YWx1ZSwgd2UnbGwgZml4IHRoaXMgdXBcbiAgICBpZiAobGVmdC5vcGVyYXRvciA9PT0gJycgJiYgbGVmdC52YWx1ZSA9PT0gJycpIHtcbiAgICAgIGxlZnQgPSBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcsIGxlZnQub3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKCFsZWZ0Lm9wZXJhdG9yLnN0YXJ0c1dpdGgoJz4nKSB8fCAhcmlnaHQub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPCcpKSB7XG4gICAgICAvLyBXZSBvbmx5IHN1cHBvcnQgcmFuZ2VzIGRlZmluZWQgbGlrZSBcIj4gKG9yID49KSBsZWZ0LCA8IChvciA8PSkgcmlnaHRcIlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBsZWZ0QnJhY2UgPSBsZWZ0Lm9wZXJhdG9yLmVuZHNXaXRoKCc9JykgPyAnWycgOiAnKCc7XG4gICAgY29uc3QgcmlnaHRCcmFjZSA9IHJpZ2h0Lm9wZXJhdG9yLmVuZHNXaXRoKCc9JykgPyAnXScgOiAnKSc7XG4gICAgcmV0dXJuIGAke2xlZnRCcmFjZX0ke2FkZFN1ZmZpeChsZWZ0LnNlbXZlci5yYXcpfSwke2FkZFN1ZmZpeChcbiAgICAgIHJpZ2h0LnNlbXZlci5yYXcsXG4gICAgICByaWdodC5vcGVyYXRvciA9PT0gJzwnICYmICFzZW12ZXIsXG4gICAgKX0ke3JpZ2h0QnJhY2V9YDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFN1ZmZpeChzdHI6IHN0cmluZyB8IHVuZGVmaW5lZCwgdHJpbURhc2haZXJvID0gZmFsc2UpIHtcbiAgICBpZiAoIXN0cikge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAodHJpbURhc2haZXJvKSB7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgvLTAkLywgJycpO1xuICAgIH1cbiAgICByZXR1cm4gc3VmZml4ID8gYCR7c3RyfSR7c3VmZml4fWAgOiB0b1JlbGVhc2VWZXJzaW9uKHN0ciwgdGFyZ2V0KTtcbiAgfVxufVxuIl19