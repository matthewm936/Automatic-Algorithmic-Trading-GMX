"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Golang = void 0;
const codemaker_1 = require("codemaker");
const fs = require("fs-extra");
const path = require("path");
const logging = require("../logging");
const target_1 = require("../target");
const util_1 = require("../util");
const documentation_1 = require("./go/documentation");
const package_1 = require("./go/package");
const runtime_1 = require("./go/runtime");
const util_2 = require("./go/util");
class Golang extends target_1.Target {
    constructor(options) {
        super(options);
        this.goGenerator = new GoGenerator(options.rosetta);
    }
    get generator() {
        return this.goGenerator;
    }
    /**
     * Generates a publishable artifact in `outDir`.
     *
     * @param sourceDir the directory where the generated source is located.
     * @param outDir    the directory where the publishable artifact should be placed.
     */
    async build(sourceDir, outDir) {
        // copy generated sources to the output directory
        await this.copyFiles(sourceDir, outDir);
        const pkgDir = path.join(outDir, this.goGenerator.rootPackage.packageName);
        // write `local.go.mod` with "replace" directives for local modules
        const localGoMod = await this.writeLocalGoMod(pkgDir);
        try {
            // run `go build` with local.go.mod, go 1.16 requires that we download
            // modules explicit so go.sum is updated. We'd normally want to use
            // `go mod download`, but because of a bug in go 1.16, we have to use
            // `go mod tidy` instead.
            //
            // See: https://github.com/golang/go/issues/44129
            await go('mod', ['tidy', '-modfile', localGoMod.path], {
                cwd: pkgDir,
            });
        }
        catch (e) {
            logging.info(`[${pkgDir}] Content of ${localGoMod.path} file:\n${localGoMod.content}`);
            return Promise.reject(e);
        }
        await go('build', ['-modfile', localGoMod.path, './...'], { cwd: pkgDir });
        // delete local.go.mod and local.go.sum from the output directory so it doesn't get published
        const localGoSum = `${path.basename(localGoMod.path, '.mod')}.sum`;
        await fs.remove(path.join(pkgDir, localGoMod.path));
        return fs.remove(path.join(pkgDir, localGoSum));
    }
    /**
     * Creates a copy of the `go.mod` file called `local.go.mod` with added
     * `replace` directives for local mono-repo dependencies. This is required in
     * order to run `go fmt` and `go build`.
     *
     * @param pkgDir The directory which contains the generated go code
     */
    async writeLocalGoMod(pkgDir) {
        const replace = {};
        // find local deps by check if `<jsii.outdir>/go` exists for dependencies
        // and also consider `outDir` in case pacmak is executed using `--outdir
        // --recurse` (in which case all go code will be generated there).
        const dirs = [
            path.dirname(pkgDir),
            ...(await target_1.findLocalBuildDirs(this.packageDir, 'go')),
        ];
        // try to resolve @jsii/go-runtime (only exists as a devDependency)
        const localModules = tryFindLocalRuntime();
        if (localModules != null) {
            for (const [name, localPath] of Object.entries(localModules)) {
                replace[name] = localPath;
            }
        }
        // iterate (recursively) on all package dependencies and check if we have a
        // local build directory for this module. if
        // we do, add a "replace" directive to point to it instead of download from
        // the network.
        const visit = async (pkg) => {
            for (const dep of pkg.packageDependencies) {
                for (const baseDir of dirs) {
                    // eslint-disable-next-line no-await-in-loop
                    const moduleDir = await tryFindLocalModule(baseDir, dep);
                    if (moduleDir) {
                        replace[dep.goModuleName] = moduleDir;
                        // we found a replacement for this dep, we can stop searching
                        break;
                    }
                }
                // recurse to transitive deps ("replace" is only considered at the top level go.mod)
                // eslint-disable-next-line no-await-in-loop
                await visit(dep);
            }
        };
        await visit(this.goGenerator.rootPackage);
        // write `local.go.mod`
        // read existing content
        const goMod = path.join(pkgDir, package_1.GOMOD_FILENAME);
        const lines = [await fs.readFile(goMod, 'utf-8'), '', '// Local packages:'];
        for (const [from, to] of Object.entries(replace)) {
            logging.info(`[${pkgDir}] Local replace: ${from} => ${to}`);
            lines.push(`replace ${from} => ${to}`);
        }
        const localGoMod = `local.${package_1.GOMOD_FILENAME}`;
        const content = lines.join('\n');
        await fs.writeFile(path.join(pkgDir, localGoMod), content, {
            encoding: 'utf-8',
        });
        return { path: localGoMod, content };
    }
}
exports.Golang = Golang;
class GoGenerator {
    constructor(rosetta) {
        this.rosetta = rosetta;
        this.code = new codemaker_1.CodeMaker({
            indentCharacter: '\t',
            indentationLevel: 1,
        });
        this.documenter = new documentation_1.Documentation(this.code, this.rosetta);
    }
    async load(_, assembly) {
        this.assembly = assembly;
        return Promise.resolve();
    }
    async upToDate(_outDir) {
        return Promise.resolve(false);
    }
    generate() {
        this.rootPackage = new package_1.RootPackage(this.assembly);
        return this.rootPackage.emit({
            code: this.code,
            documenter: this.documenter,
        });
    }
    async save(outDir, tarball, { license, notice }) {
        const output = path.join(outDir, this.rootPackage.packageName);
        await this.code.save(output);
        await fs.copyFile(tarball, path.join(output, runtime_1.JSII_INIT_PACKAGE, util_2.tarballName(this.assembly)));
        if (license) {
            await fs.writeFile(path.join(output, 'LICENSE'), license, {
                encoding: 'utf8',
            });
        }
        if (notice) {
            await fs.writeFile(path.join(output, 'NOTICE'), notice, {
                encoding: 'utf8',
            });
        }
    }
}
/**
 * Checks if `buildDir` includes a local go build version (with "replace"
 * directives).
 * @param baseDir the `dist/go` directory
 * @returns `undefined` if not or the module directory otherwise.
 */
async function tryFindLocalModule(baseDir, pkg) {
    const gomodPath = path.join(baseDir, pkg.packageName, package_1.GOMOD_FILENAME);
    if (!(await fs.pathExists(gomodPath))) {
        return undefined;
    }
    // read `go.mod` and check that it is for the correct module
    const gomod = (await fs.readFile(gomodPath, 'utf-8')).split('\n');
    const isExpectedModule = gomod.find((line) => line.trim() === `module ${pkg.goModuleName}`);
    if (!isExpectedModule) {
        return undefined;
    }
    return path.resolve(path.dirname(gomodPath));
}
/**
 * Check if we are running from inside the jsii repository, and then we want to
 * use the local runtime instead of download from a released version.
 *
 * This is a generator that procudes an entry for each local module that
 * is identified under the local module path exposed by `@jsii/go-runtime` .
 */
function tryFindLocalRuntime() {
    try {
        // eslint-disable-next-line @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports, import/no-extraneous-dependencies
        const localRuntime = require('@jsii/go-runtime');
        logging.debug(`Using @jsii/go-runtime from ${localRuntime.runtimePath}`);
        return localRuntime.runtimeModules;
    }
    catch {
        return undefined;
    }
}
/**
 * Executes a go CLI command.
 *
 *
 * @param command The `go` command to execute (e.g. `build`)
 * @param args Additional args
 * @param options Options
 */
async function go(command, args, options) {
    const { cwd } = options;
    return util_1.shell('go', [command, ...args], {
        cwd,
        env: {
            // disable the use of sumdb to reduce eventual consistency issues when new modules are published
            GOSUMDB: 'off',
        },
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ28uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJnby50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSx5Q0FBc0M7QUFDdEMsK0JBQStCO0FBRy9CLDZCQUE2QjtBQUc3QixzQ0FBc0M7QUFDdEMsc0NBQXNFO0FBQ3RFLGtDQUFnQztBQUNoQyxzREFBbUQ7QUFDbkQsMENBQTJEO0FBQzNELDBDQUFpRDtBQUNqRCxvQ0FBd0M7QUFFeEMsTUFBYSxNQUFPLFNBQVEsZUFBTTtJQUdoQyxZQUFtQixPQUFzQjtRQUN2QyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDZixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksV0FBVyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRUQsSUFBVyxTQUFTO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztJQUMxQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxLQUFLLENBQUMsS0FBSyxDQUFDLFNBQWlCLEVBQUUsTUFBYztRQUNsRCxpREFBaUQ7UUFDakQsTUFBTSxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUV4QyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUUzRSxtRUFBbUU7UUFDbkUsTUFBTSxVQUFVLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXRELElBQUk7WUFDRixzRUFBc0U7WUFDdEUsbUVBQW1FO1lBQ25FLHFFQUFxRTtZQUNyRSx5QkFBeUI7WUFDekIsRUFBRTtZQUNGLGlEQUFpRDtZQUNqRCxNQUFNLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDckQsR0FBRyxF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LENBQUMsT0FBZSxFQUFFLElBQWMsRUFBRSxPQUF3QjtJQUN6RSxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsT0FBTyxDQUFDO0lBQ3hCLE9BQU8sWUFBSyxDQUFDLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFO1FBQ3JDLEdBQUc7UUFDSCxHQUFHLEVBQUU7WUFDSCxnR0FBZ0c7WUFDaEcsT0FBTyxFQUFFLEtBQUs7U0FDZjtLQUNGLENBQUMsQ0FBQztBQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2RlTWFrZXIgfSBmcm9tICdjb2RlbWFrZXInO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHsgQXNzZW1ibHkgfSBmcm9tICdqc2lpLXJlZmxlY3QnO1xuaW1wb3J0IHsgUm9zZXR0YSB9IGZyb20gJ2pzaWktcm9zZXR0YSc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyBJR2VuZXJhdG9yLCBMZWdhbGVzZSB9IGZyb20gJy4uL2dlbmVyYXRvcic7XG5pbXBvcnQgKiBhcyBsb2dnaW5nIGZyb20gJy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgZmluZExvY2FsQnVpbGREaXJzLCBUYXJnZXQsIFRhcmdldE9wdGlvbnMgfSBmcm9tICcuLi90YXJnZXQnO1xuaW1wb3J0IHsgc2hlbGwgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCB7IERvY3VtZW50YXRpb24gfSBmcm9tICcuL2dvL2RvY3VtZW50YXRpb24nO1xuaW1wb3J0IHsgR09NT0RfRklMRU5BTUUsIFJvb3RQYWNrYWdlIH0gZnJvbSAnLi9nby9wYWNrYWdlJztcbmltcG9ydCB7IEpTSUlfSU5JVF9QQUNLQUdFIH0gZnJvbSAnLi9nby9ydW50aW1lJztcbmltcG9ydCB7IHRhcmJhbGxOYW1lIH0gZnJvbSAnLi9nby91dGlsJztcblxuZXhwb3J0IGNsYXNzIEdvbGFuZyBleHRlbmRzIFRhcmdldCB7XG4gIHByaXZhdGUgcmVhZG9ubHkgZ29HZW5lcmF0b3I6IEdvR2VuZXJhdG9yO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihvcHRpb25zOiBUYXJnZXRPcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy5nb0dlbmVyYXRvciA9IG5ldyBHb0dlbmVyYXRvcihvcHRpb25zLnJvc2V0dGEpO1xuICB9XG5cbiAgcHVibGljIGdldCBnZW5lcmF0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ29HZW5lcmF0b3I7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgcHVibGlzaGFibGUgYXJ0aWZhY3QgaW4gYG91dERpcmAuXG4gICAqXG4gICAqIEBwYXJhbSBzb3VyY2VEaXIgdGhlIGRpcmVjdG9yeSB3aGVyZSB0aGUgZ2VuZXJhdGVkIHNvdXJjZSBpcyBsb2NhdGVkLlxuICAgKiBAcGFyYW0gb3V0RGlyICAgIHRoZSBkaXJlY3Rvcnkgd2hlcmUgdGhlIHB1Ymxpc2hhYmxlIGFydGlmYWN0IHNob3VsZCBiZSBwbGFjZWQuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgYnVpbGQoc291cmNlRGlyOiBzdHJpbmcsIG91dERpcjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gY29weSBnZW5lcmF0ZWQgc291cmNlcyB0byB0aGUgb3V0cHV0IGRpcmVjdG9yeVxuICAgIGF3YWl0IHRoaXMuY29weUZpbGVzKHNvdXJjZURpciwgb3V0RGlyKTtcblxuICAgIGNvbnN0IHBrZ0RpciA9IHBhdGguam9pbihvdXREaXIsIHRoaXMuZ29HZW5lcmF0b3Iucm9vdFBhY2thZ2UucGFja2FnZU5hbWUpO1xuXG4gICAgLy8gd3JpdGUgYGxvY2FsLmdvLm1vZGAgd2l0aCBcInJlcGxhY2VcIiBkaXJlY3RpdmVzIGZvciBsb2NhbCBtb2R1bGVzXG4gICAgY29uc3QgbG9jYWxHb01vZCA9IGF3YWl0IHRoaXMud3JpdGVMb2NhbEdvTW9kKHBrZ0Rpcik7XG5cbiAgICB0cnkge1xuICAgICAgLy8gcnVuIGBnbyBidWlsZGAgd2l0aCBsb2NhbC5nby5tb2QsIGdvIDEuMTYgcmVxdWlyZXMgdGhhdCB3ZSBkb3dubG9hZFxuICAgICAgLy8gbW9kdWxlcyBleHBsaWNpdCBzbyBnby5zdW0gaXMgdXBkYXRlZC4gV2UnZCBub3JtYWxseSB3YW50IHRvIHVzZVxuICAgICAgLy8gYGdvIG1vZCBkb3dubG9hZGAsIGJ1dCBiZWNhdXNlIG9mIGEgYnVnIGluIGdvIDEuMTYsIHdlIGhhdmUgdG8gdXNlXG4gICAgICAvLyBgZ28gbW9kIHRpZHlgIGluc3RlYWQuXG4gICAgICAvL1xuICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZ29sYW5nL2dvL2lzc3Vlcy80NDEyOVxuICAgICAgYXdhaXQgZ28oJ21vZCcsIFsndGlkeScsICctbW9kZmlsZScsIGxvY2FsR29Nb2QucGF0aF0sIHtcbiAgICAgICAgY3dkOiBwa2dEaXIsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnaW5nLmluZm8oXG4gICAgICAgIGBbJHtwa2dEaXJ9XSBDb250ZW50IG9mICR7bG9jYWxHb01vZC5wYXRofSBmaWxlOlxcbiR7bG9jYWxHb01vZC5jb250ZW50fWAsXG4gICAgICApO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbiAgICBhd2FpdCBnbygnYnVpbGQnLCBbJy1tb2RmaWxlJywgbG9jYWxHb01vZC5wYXRoLCAnLi8uLi4nXSwgeyBjd2Q6IHBrZ0RpciB9KTtcblxuICAgIC8vIGRlbGV0ZSBsb2NhbC5nby5tb2QgYW5kIGxvY2FsLmdvLnN1bSBmcm9tIHRoZSBvdXRwdXQgZGlyZWN0b3J5IHNvIGl0IGRvZXNuJ3QgZ2V0IHB1Ymxpc2hlZFxuICAgIGNvbnN0IGxvY2FsR29TdW0gPSBgJHtwYXRoLmJhc2VuYW1lKGxvY2FsR29Nb2QucGF0aCwgJy5tb2QnKX0uc3VtYDtcbiAgICBhd2FpdCBmcy5yZW1vdmUocGF0aC5qb2luKHBrZ0RpciwgbG9jYWxHb01vZC5wYXRoKSk7XG4gICAgcmV0dXJuIGZzLnJlbW92ZShwYXRoLmpvaW4ocGtnRGlyLCBsb2NhbEdvU3VtKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGBnby5tb2RgIGZpbGUgY2FsbGVkIGBsb2NhbC5nby5tb2RgIHdpdGggYWRkZWRcbiAgICogYHJlcGxhY2VgIGRpcmVjdGl2ZXMgZm9yIGxvY2FsIG1vbm8tcmVwbyBkZXBlbmRlbmNpZXMuIFRoaXMgaXMgcmVxdWlyZWQgaW5cbiAgICogb3JkZXIgdG8gcnVuIGBnbyBmbXRgIGFuZCBgZ28gYnVpbGRgLlxuICAgKlxuICAgKiBAcGFyYW0gcGtnRGlyIFRoZSBkaXJlY3Rvcnkgd2hpY2ggY29udGFpbnMgdGhlIGdlbmVyYXRlZCBnbyBjb2RlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHdyaXRlTG9jYWxHb01vZChwa2dEaXI6IHN0cmluZykge1xuICAgIGNvbnN0IHJlcGxhY2U6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcblxuICAgIC8vIGZpbmQgbG9jYWwgZGVwcyBieSBjaGVjayBpZiBgPGpzaWkub3V0ZGlyPi9nb2AgZXhpc3RzIGZvciBkZXBlbmRlbmNpZXNcbiAgICAvLyBhbmQgYWxzbyBjb25zaWRlciBgb3V0RGlyYCBpbiBjYXNlIHBhY21hayBpcyBleGVjdXRlZCB1c2luZyBgLS1vdXRkaXJcbiAgICAvLyAtLXJlY3Vyc2VgIChpbiB3aGljaCBjYXNlIGFsbCBnbyBjb2RlIHdpbGwgYmUgZ2VuZXJhdGVkIHRoZXJlKS5cbiAgICBjb25zdCBkaXJzID0gW1xuICAgICAgcGF0aC5kaXJuYW1lKHBrZ0RpciksXG4gICAgICAuLi4oYXdhaXQgZmluZExvY2FsQnVpbGREaXJzKHRoaXMucGFja2FnZURpciwgJ2dvJykpLFxuICAgIF07XG5cbiAgICAvLyB0cnkgdG8gcmVzb2x2ZSBAanNpaS9nby1ydW50aW1lIChvbmx5IGV4aXN0cyBhcyBhIGRldkRlcGVuZGVuY3kpXG4gICAgY29uc3QgbG9jYWxNb2R1bGVzID0gdHJ5RmluZExvY2FsUnVudGltZSgpO1xuICAgIGlmIChsb2NhbE1vZHVsZXMgIT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBbbmFtZSwgbG9jYWxQYXRoXSBvZiBPYmplY3QuZW50cmllcyhsb2NhbE1vZHVsZXMpKSB7XG4gICAgICAgIHJlcGxhY2VbbmFtZV0gPSBsb2NhbFBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaXRlcmF0ZSAocmVjdXJzaXZlbHkpIG9uIGFsbCBwYWNrYWdlIGRlcGVuZGVuY2llcyBhbmQgY2hlY2sgaWYgd2UgaGF2ZSBhXG4gICAgLy8gbG9jYWwgYnVpbGQgZGlyZWN0b3J5IGZvciB0aGlzIG1vZHVsZS4gaWZcbiAgICAvLyB3ZSBkbywgYWRkIGEgXCJyZXBsYWNlXCIgZGlyZWN0aXZlIHRvIHBvaW50IHRvIGl0IGluc3RlYWQgb2YgZG93bmxvYWQgZnJvbVxuICAgIC8vIHRoZSBuZXR3b3JrLlxuICAgIGNvbnN0IHZpc2l0ID0gYXN5bmMgKHBrZzogUm9vdFBhY2thZ2UpID0+IHtcbiAgICAgIGZvciAoY29uc3QgZGVwIG9mIHBrZy5wYWNrYWdlRGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgYmFzZURpciBvZiBkaXJzKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICBjb25zdCBtb2R1bGVEaXIgPSBhd2FpdCB0cnlGaW5kTG9jYWxNb2R1bGUoYmFzZURpciwgZGVwKTtcbiAgICAgICAgICBpZiAobW9kdWxlRGlyKSB7XG4gICAgICAgICAgICByZXBsYWNlW2RlcC5nb01vZHVsZU5hbWVdID0gbW9kdWxlRGlyO1xuXG4gICAgICAgICAgICAvLyB3ZSBmb3VuZCBhIHJlcGxhY2VtZW50IGZvciB0aGlzIGRlcCwgd2UgY2FuIHN0b3Agc2VhcmNoaW5nXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWN1cnNlIHRvIHRyYW5zaXRpdmUgZGVwcyAoXCJyZXBsYWNlXCIgaXMgb25seSBjb25zaWRlcmVkIGF0IHRoZSB0b3AgbGV2ZWwgZ28ubW9kKVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgICBhd2FpdCB2aXNpdChkZXApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBhd2FpdCB2aXNpdCh0aGlzLmdvR2VuZXJhdG9yLnJvb3RQYWNrYWdlKTtcblxuICAgIC8vIHdyaXRlIGBsb2NhbC5nby5tb2RgXG5cbiAgICAvLyByZWFkIGV4aXN0aW5nIGNvbnRlbnRcbiAgICBjb25zdCBnb01vZCA9IHBhdGguam9pbihwa2dEaXIsIEdPTU9EX0ZJTEVOQU1FKTtcbiAgICBjb25zdCBsaW5lcyA9IFthd2FpdCBmcy5yZWFkRmlsZShnb01vZCwgJ3V0Zi04JyksICcnLCAnLy8gTG9jYWwgcGFja2FnZXM6J107XG5cbiAgICBmb3IgKGNvbnN0IFtmcm9tLCB0b10gb2YgT2JqZWN0LmVudHJpZXMocmVwbGFjZSkpIHtcbiAgICAgIGxvZ2dpbmcuaW5mbyhgWyR7cGtnRGlyfV0gTG9jYWwgcmVwbGFjZTogJHtmcm9tfSA9PiAke3RvfWApO1xuICAgICAgbGluZXMucHVzaChgcmVwbGFjZSAke2Zyb219ID0+ICR7dG99YCk7XG4gICAgfVxuXG4gICAgY29uc3QgbG9jYWxHb01vZCA9IGBsb2NhbC4ke0dPTU9EX0ZJTEVOQU1FfWA7XG4gICAgY29uc3QgY29udGVudCA9IGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShwYXRoLmpvaW4ocGtnRGlyLCBsb2NhbEdvTW9kKSwgY29udGVudCwge1xuICAgICAgZW5jb2Rpbmc6ICd1dGYtOCcsXG4gICAgfSk7XG5cbiAgICByZXR1cm4geyBwYXRoOiBsb2NhbEdvTW9kLCBjb250ZW50IH07XG4gIH1cbn1cblxuY2xhc3MgR29HZW5lcmF0b3IgaW1wbGVtZW50cyBJR2VuZXJhdG9yIHtcbiAgcHJpdmF0ZSBhc3NlbWJseSE6IEFzc2VtYmx5O1xuICBwdWJsaWMgcm9vdFBhY2thZ2UhOiBSb290UGFja2FnZTtcblxuICBwcml2YXRlIHJlYWRvbmx5IGNvZGUgPSBuZXcgQ29kZU1ha2VyKHtcbiAgICBpbmRlbnRDaGFyYWN0ZXI6ICdcXHQnLFxuICAgIGluZGVudGF0aW9uTGV2ZWw6IDEsXG4gIH0pO1xuICBwcml2YXRlIHJlYWRvbmx5IGRvY3VtZW50ZXI6IERvY3VtZW50YXRpb247XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcm9zZXR0YTogUm9zZXR0YSkge1xuICAgIHRoaXMuZG9jdW1lbnRlciA9IG5ldyBEb2N1bWVudGF0aW9uKHRoaXMuY29kZSwgdGhpcy5yb3NldHRhKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBsb2FkKF86IHN0cmluZywgYXNzZW1ibHk6IEFzc2VtYmx5KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5hc3NlbWJseSA9IGFzc2VtYmx5O1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyB1cFRvRGF0ZShfb3V0RGlyOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgfVxuXG4gIHB1YmxpYyBnZW5lcmF0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLnJvb3RQYWNrYWdlID0gbmV3IFJvb3RQYWNrYWdlKHRoaXMuYXNzZW1ibHkpO1xuXG4gICAgcmV0dXJuIHRoaXMucm9vdFBhY2thZ2UuZW1pdCh7XG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICBkb2N1bWVudGVyOiB0aGlzLmRvY3VtZW50ZXIsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc2F2ZShcbiAgICBvdXREaXI6IHN0cmluZyxcbiAgICB0YXJiYWxsOiBzdHJpbmcsXG4gICAgeyBsaWNlbnNlLCBub3RpY2UgfTogTGVnYWxlc2UsXG4gICk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gcGF0aC5qb2luKG91dERpciwgdGhpcy5yb290UGFja2FnZS5wYWNrYWdlTmFtZSk7XG4gICAgYXdhaXQgdGhpcy5jb2RlLnNhdmUob3V0cHV0KTtcbiAgICBhd2FpdCBmcy5jb3B5RmlsZShcbiAgICAgIHRhcmJhbGwsXG4gICAgICBwYXRoLmpvaW4ob3V0cHV0LCBKU0lJX0lOSVRfUEFDS0FHRSwgdGFyYmFsbE5hbWUodGhpcy5hc3NlbWJseSkpLFxuICAgICk7XG5cbiAgICBpZiAobGljZW5zZSkge1xuICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKHBhdGguam9pbihvdXRwdXQsICdMSUNFTlNFJyksIGxpY2Vuc2UsIHtcbiAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChub3RpY2UpIHtcbiAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShwYXRoLmpvaW4ob3V0cHV0LCAnTk9USUNFJyksIG5vdGljZSwge1xuICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBidWlsZERpcmAgaW5jbHVkZXMgYSBsb2NhbCBnbyBidWlsZCB2ZXJzaW9uICh3aXRoIFwicmVwbGFjZVwiXG4gKiBkaXJlY3RpdmVzKS5cbiAqIEBwYXJhbSBiYXNlRGlyIHRoZSBgZGlzdC9nb2AgZGlyZWN0b3J5XG4gKiBAcmV0dXJucyBgdW5kZWZpbmVkYCBpZiBub3Qgb3IgdGhlIG1vZHVsZSBkaXJlY3Rvcnkgb3RoZXJ3aXNlLlxuICovXG5hc3luYyBmdW5jdGlvbiB0cnlGaW5kTG9jYWxNb2R1bGUoYmFzZURpcjogc3RyaW5nLCBwa2c6IFJvb3RQYWNrYWdlKSB7XG4gIGNvbnN0IGdvbW9kUGF0aCA9IHBhdGguam9pbihiYXNlRGlyLCBwa2cucGFja2FnZU5hbWUsIEdPTU9EX0ZJTEVOQU1FKTtcbiAgaWYgKCEoYXdhaXQgZnMucGF0aEV4aXN0cyhnb21vZFBhdGgpKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyByZWFkIGBnby5tb2RgIGFuZCBjaGVjayB0aGF0IGl0IGlzIGZvciB0aGUgY29ycmVjdCBtb2R1bGVcbiAgY29uc3QgZ29tb2QgPSAoYXdhaXQgZnMucmVhZEZpbGUoZ29tb2RQYXRoLCAndXRmLTgnKSkuc3BsaXQoJ1xcbicpO1xuICBjb25zdCBpc0V4cGVjdGVkTW9kdWxlID0gZ29tb2QuZmluZChcbiAgICAobGluZSkgPT4gbGluZS50cmltKCkgPT09IGBtb2R1bGUgJHtwa2cuZ29Nb2R1bGVOYW1lfWAsXG4gICk7XG5cbiAgaWYgKCFpc0V4cGVjdGVkTW9kdWxlKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGdvbW9kUGF0aCkpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGZyb20gaW5zaWRlIHRoZSBqc2lpIHJlcG9zaXRvcnksIGFuZCB0aGVuIHdlIHdhbnQgdG9cbiAqIHVzZSB0aGUgbG9jYWwgcnVudGltZSBpbnN0ZWFkIG9mIGRvd25sb2FkIGZyb20gYSByZWxlYXNlZCB2ZXJzaW9uLlxuICpcbiAqIFRoaXMgaXMgYSBnZW5lcmF0b3IgdGhhdCBwcm9jdWRlcyBhbiBlbnRyeSBmb3IgZWFjaCBsb2NhbCBtb2R1bGUgdGhhdFxuICogaXMgaWRlbnRpZmllZCB1bmRlciB0aGUgbG9jYWwgbW9kdWxlIHBhdGggZXhwb3NlZCBieSBgQGpzaWkvZ28tcnVudGltZWAgLlxuICovXG5mdW5jdGlvbiB0cnlGaW5kTG9jYWxSdW50aW1lKCk6XG4gIHwgeyByZWFkb25seSBbbmFtZTogc3RyaW5nXTogc3RyaW5nIH1cbiAgfCB1bmRlZmluZWQge1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbiAgICBjb25zdCBsb2NhbFJ1bnRpbWUgPSByZXF1aXJlKCdAanNpaS9nby1ydW50aW1lJyk7XG4gICAgbG9nZ2luZy5kZWJ1ZyhgVXNpbmcgQGpzaWkvZ28tcnVudGltZSBmcm9tICR7bG9jYWxSdW50aW1lLnJ1bnRpbWVQYXRofWApO1xuXG4gICAgcmV0dXJuIGxvY2FsUnVudGltZS5ydW50aW1lTW9kdWxlcztcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIEV4ZWN1dGVzIGEgZ28gQ0xJIGNvbW1hbmQuXG4gKlxuICpcbiAqIEBwYXJhbSBjb21tYW5kIFRoZSBgZ29gIGNvbW1hbmQgdG8gZXhlY3V0ZSAoZS5nLiBgYnVpbGRgKVxuICogQHBhcmFtIGFyZ3MgQWRkaXRpb25hbCBhcmdzXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdvKGNvbW1hbmQ6IHN0cmluZywgYXJnczogc3RyaW5nW10sIG9wdGlvbnM6IHsgY3dkOiBzdHJpbmcgfSkge1xuICBjb25zdCB7IGN3ZCB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHNoZWxsKCdnbycsIFtjb21tYW5kLCAuLi5hcmdzXSwge1xuICAgIGN3ZCxcbiAgICBlbnY6IHtcbiAgICAgIC8vIGRpc2FibGUgdGhlIHVzZSBvZiBzdW1kYiB0byByZWR1Y2UgZXZlbnR1YWwgY29uc2lzdGVuY3kgaXNzdWVzIHdoZW4gbmV3IG1vZHVsZXMgYXJlIHB1Ymxpc2hlZFxuICAgICAgR09TVU1EQjogJ29mZicsXG4gICAgfSxcbiAgfSk7XG59XG4iXX0=