"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalPackage = exports.RootPackage = exports.Package = exports.GO_VERSION = exports.GOMOD_FILENAME = void 0;
const path_1 = require("path");
const semver = require("semver");
const version_1 = require("../../version");
const readme_file_1 = require("./readme-file");
const runtime_1 = require("./runtime");
const types_1 = require("./types");
const util_1 = require("./util");
const version_file_1 = require("./version-file");
exports.GOMOD_FILENAME = 'go.mod';
exports.GO_VERSION = '1.16';
// the name of a sub-package that includes internal type aliases it has to be
// "internal" so it not published.
const INTERNAL_PACKAGE_NAME = 'internal';
/*
 * Package represents a single `.go` source file within a package. This can be the root package file or a submodule
 */
class Package {
    constructor(typeSpec, submoduleSpec, packageName, filePath, moduleName, version, 
    // If no root is provided, this module is the root
    root) {
        this.typeSpec = typeSpec;
        this.submoduleSpec = submoduleSpec;
        this.packageName = packageName;
        this.filePath = filePath;
        this.moduleName = moduleName;
        this.version = version;
        this.embeddedTypes = {};
        this.directory = filePath;
        this.file = `${this.directory}/${packageName}.go`;
        this.root = root !== null && root !== void 0 ? root : this;
        this.submodules = this.submoduleSpec.map((sm) => new InternalPackage(this.root, this, sm));
        this.types = this.typeSpec.map((type) => {
            if (type.isInterfaceType() && type.datatype) {
                return new types_1.Struct(this, type);
            }
            else if (type.isInterfaceType()) {
                return new types_1.GoInterface(this, type);
            }
            else if (type.isClassType()) {
                return new types_1.GoClass(this, type);
            }
            else if (type.isEnumType()) {
                return new types_1.Enum(this, type);
            }
            throw new Error(`Type: ${type.name} with kind ${type.kind} is not a supported type`);
        });
    }
    /*
     * Packages within this module
     */
    get dependencies() {
        return util_1.flatMap(this.types, (t) => t.dependencies).filter((mod) => mod.packageName !== this.packageName);
    }
    /*
     * goModuleName returns the full path to the module name.
     * Used for import statements and go.mod generation
     */
    get goModuleName() {
        const moduleName = this.root.moduleName;
        const prefix = moduleName !== '' ? `${moduleName}/` : '';
        const rootPackageName = this.root.packageName;
        const versionSuffix = determineMajorVersionSuffix(this.version);
        const suffix = this.filePath !== '' ? `/${this.filePath}` : ``;
        return `${prefix}${rootPackageName}${versionSuffix}${suffix}`;
    }
    /*
     * The module names of this module's dependencies. Used for import statements.
     */
    get dependencyImports() {
        return new Set(this.dependencies.map((pkg) => pkg.goModuleName));
    }
    /*
     * Search for a type with a `fqn` within this. Searches all Children modules as well.
     */
    findType(fqn) {
        return util_1.findTypeInTree(this, fqn);
    }
    emit(context) {
        const { code } = context;
        code.openFile(this.file);
        this.emitHeader(code);
        this.emitImports(code);
        this.emitTypes(context);
        code.closeFile(this.file);
        this.emitGoInitFunction(context);
        this.emitSubmodules(context);
        this.emitInternal(context);
    }
    emitSubmodules(context) {
        for (const submodule of this.submodules) {
            submodule.emit(context);
        }
    }
    /**
     * Determines if `type` comes from a foreign package.
     */
    isExternalType(type) {
        return type.pkg !== this;
    }
    /**
     * Returns the name of the embed field used to embed a base class/interface in a
     * struct.
     *
     * @returns If the base is in the same package, returns the proxy name of the
     * base under `embed`, otherwise returns a unique symbol under `embed` and the
     * original interface reference under `original`.
     *
     * @param type The base type we want to embed
     */
    resolveEmbeddedType(type) {
        if (!this.isExternalType(type)) {
            return {
                embed: type.proxyName,
                fieldName: type.proxyName,
            };
        }
        const exists = this.embeddedTypes[type.fqn];
        if (exists) {
            return exists;
        }
        const typeref = new types_1.GoTypeRef(this.root, type.type.reference);
        const original = typeref.scopedName(this);
        const slug = original.replace(/[^A-Za-z0-9]/g, '');
        const aliasName = `Type__${slug}`;
        this.embeddedTypes[type.fqn] = {
            foriegnTypeName: original,
            foriegnType: typeref,
            fieldName: aliasName,
            embed: `${INTERNAL_PACKAGE_NAME}.${aliasName}`,
        };
        return this.resolveEmbeddedType(type);
    }
    emitHeader(code) {
        code.line(`package ${this.packageName}`);
        code.line();
    }
    get specialDependencies() {
        return this.types
            .map((t) => t.specialDependencies)
            .reduce((acc, elt) => ({
            runtime: acc.runtime || elt.runtime,
            init: acc.init || elt.init,
            internal: acc.internal || elt.internal,
            time: acc.time || elt.time,
        }), { runtime: false, init: false, internal: false, time: false });
    }
    /**
     * Emits a `func init() { ... }` in a dedicated file (so we don't have to
     * worry about what needs to be imported and whatnot). This function is
     * responsible for correctly initializing the module, including registering
     * the declared types with the jsii runtime for go.
     */
    emitGoInitFunction({ code }) {
        // We don't emit anything if there are not types in this (sub)module. This
        // avoids registering an `init` function that does nothing, which is poor
        // form. It also saves us from "imported but unused" errors that would arise
        // as a consequence.
        if (this.types.length > 0) {
            const initFile = path_1.join(path_1.dirname(this.file), `${path_1.basename(this.file, '.go')}.init.go`);
            code.openFile(initFile);
            code.line(`package ${this.packageName}`);
            code.line();
            importGoModules(code, [GO_REFLECT, JSII_RT_MODULE]);
            code.line();
            code.openBlock('func init()');
            for (const type of this.types) {
                type.emitRegistration(code);
            }
            code.closeBlock();
            code.closeFile(initFile);
        }
    }
    emitImports(code) {
        const toImport = new Array();
        const specialDeps = this.specialDependencies;
        if (specialDeps.time) {
            toImport.push({ module: 'time' });
        }
        if (specialDeps.runtime) {
            toImport.push(JSII_RT_MODULE);
        }
        if (specialDeps.init) {
            toImport.push({
                alias: runtime_1.JSII_INIT_ALIAS,
                module: `${this.root.goModuleName}/${runtime_1.JSII_INIT_PACKAGE}`,
            });
        }
        if (specialDeps.internal) {
            toImport.push({
                module: `${this.goModuleName}/${INTERNAL_PACKAGE_NAME}`,
            });
        }
        for (const packageName of this.dependencyImports) {
            // If the module is the same as the current one being written, don't emit an import statement
            if (packageName !== this.packageName) {
                toImport.push({ module: packageName });
            }
        }
        importGoModules(code, toImport);
        code.line();
    }
    emitTypes(context) {
        for (const type of this.types) {
            type.emit(context);
        }
    }
    emitInternal(context) {
        const aliases = Object.values(this.embeddedTypes);
        if (aliases.length === 0) {
            return;
        }
        const code = context.code;
        const fileName = path_1.join(this.directory, INTERNAL_PACKAGE_NAME, 'types.go');
        code.openFile(fileName);
        code.line(`package ${INTERNAL_PACKAGE_NAME}`);
        const imports = new Set();
        for (const alias of aliases) {
            if (!alias.foriegnType) {
                continue;
            }
            for (const pkg of alias.foriegnType.dependencies) {
                imports.add(pkg.goModuleName);
            }
        }
        code.open('import (');
        for (const imprt of imports) {
            code.line(`"${imprt}"`);
        }
        code.close(')');
        for (const alias of aliases) {
            code.line(`type ${alias.fieldName} = ${alias.foriegnTypeName}`);
        }
        code.closeFile(fileName);
    }
}
exports.Package = Package;
/*
 * RootPackage corresponds to JSII module.
 *
 * Extends `Package` for root source package emit logic
 */
class RootPackage extends Package {
    constructor(assembly) {
        var _a, _b, _c, _d, _e;
        const goConfig = (_b = (_a = assembly.targets) === null || _a === void 0 ? void 0 : _a.go) !== null && _b !== void 0 ? _b : {};
        const packageName = util_1.goPackageNameForAssembly(assembly);
        const filePath = '';
        const moduleName = (_c = goConfig.moduleName) !== null && _c !== void 0 ? _c : '';
        const version = `${assembly.version}${(_d = goConfig.versionSuffix) !== null && _d !== void 0 ? _d : ''}`;
        super(assembly.types, assembly.submodules, packageName, filePath, moduleName, version);
        this.assembly = assembly;
        this.version = version;
        this.versionFile = new version_file_1.VersionFile(this.version);
        if ((_e = this.assembly.readme) === null || _e === void 0 ? void 0 : _e.markdown) {
            this.readme = new readme_file_1.ReadmeFile(this.packageName, this.assembly.readme.markdown);
        }
    }
    emit(context) {
        var _a;
        super.emit(context);
        this.emitJsiiPackage(context);
        (_a = this.readme) === null || _a === void 0 ? void 0 : _a.emit(context);
        this.emitGomod(context.code);
        this.versionFile.emit(context.code);
    }
    emitGomod(code) {
        code.openFile(exports.GOMOD_FILENAME);
        code.line(`module ${this.goModuleName}`);
        code.line();
        code.line(`go ${exports.GO_VERSION}`);
        code.line();
        code.open('require (');
        // Strip " (build abcdef)" from the jsii version
        code.line(`${runtime_1.JSII_RT_MODULE_NAME} v${version_1.VERSION}`);
        const dependencies = this.packageDependencies;
        for (const dep of dependencies) {
            code.line(`${dep.goModuleName} v${dep.version}`);
        }
        indirectDependencies(dependencies, new Set(dependencies.map((dep) => dep.goModuleName)));
        code.close(')');
        code.closeFile(exports.GOMOD_FILENAME);
        /**
         * Emits indirect dependency declarations, which are helpful to make IDEs at
         * ease with the codebase.
         */
        function indirectDependencies(pkgs, alreadyEmitted) {
            for (const pkg of pkgs) {
                const deps = pkg.packageDependencies;
                for (const dep of deps) {
                    if (alreadyEmitted.has(dep.goModuleName)) {
                        continue;
                    }
                    alreadyEmitted.add(dep.goModuleName);
                    code.line(`${dep.goModuleName} v${dep.version} // indirect`);
                }
                indirectDependencies(deps, alreadyEmitted);
            }
        }
    }
    /*
     * Override package findType for root Package.
     *
     * This allows resolving type references from other JSII modules
     */
    findType(fqn) {
        return this.packageDependencies.reduce((accum, current) => {
            if (accum) {
                return accum;
            }
            return current.findType(fqn);
        }, super.findType(fqn));
    }
    /*
     * Get all JSII module dependencies of the package being generated
     */
    get packageDependencies() {
        return this.assembly.dependencies.map((dep) => new RootPackage(dep.assembly));
    }
    emitHeader(code) {
        if (this.assembly.description !== '') {
            code.line(`// ${this.assembly.description}`);
        }
        code.line(`package ${this.packageName}`);
        code.line();
    }
    emitJsiiPackage({ code }) {
        const dependencies = this.packageDependencies.sort((l, r) => l.moduleName.localeCompare(r.moduleName));
        const file = path_1.join(runtime_1.JSII_INIT_PACKAGE, `${runtime_1.JSII_INIT_PACKAGE}.go`);
        code.openFile(file);
        code.line(`// Package ${runtime_1.JSII_INIT_PACKAGE} contains the functionaility needed for jsii packages to`);
        code.line('// initialize their dependencies and themselves. Users should never need to use this package');
        code.line('// directly. If you find you need to - please report a bug at');
        code.line('// https://github.com/aws/jsii/issues/new/choose');
        code.line(`package ${runtime_1.JSII_INIT_PACKAGE}`);
        code.line();
        const toImport = [
            JSII_RT_MODULE,
            { module: 'embed', alias: '_' },
        ];
        if (dependencies.length > 0) {
            for (const pkg of dependencies) {
                toImport.push({
                    alias: pkg.packageName,
                    module: `${pkg.root.goModuleName}/${runtime_1.JSII_INIT_PACKAGE}`,
                });
            }
        }
        importGoModules(code, toImport);
        code.line();
        code.line(`//go:embed ${util_1.tarballName(this.assembly)}`);
        code.line('var tarball []byte');
        code.line();
        code.line(`// ${runtime_1.JSII_INIT_FUNC} loads the necessary packages in the @jsii/kernel to support the enclosing module.`);
        code.line('// The implementation is idempotent (and hence safe to be called over and over).');
        code.open(`func ${runtime_1.JSII_INIT_FUNC}() {`);
        if (dependencies.length > 0) {
            code.line('// Ensure all dependencies are initialized');
            for (const pkg of this.packageDependencies) {
                code.line(`${pkg.packageName}.${runtime_1.JSII_INIT_FUNC}()`);
            }
            code.line();
        }
        code.line('// Load this library into the kernel');
        code.line(`${runtime_1.JSII_RT_ALIAS}.Load("${this.assembly.name}", "${this.assembly.version}", tarball)`);
        code.close('}');
        code.closeFile(file);
    }
}
exports.RootPackage = RootPackage;
/*
 * InternalPackage refers to any go package within a given JSII module.
 */
class InternalPackage extends Package {
    constructor(root, parent, assembly) {
        const packageName = util_1.goPackageNameForAssembly(assembly);
        const filePath = parent === root ? packageName : `${parent.filePath}/${packageName}`;
        super(assembly.types, assembly.submodules, packageName, filePath, root.moduleName, root.version, root);
        this.parent = parent;
    }
}
exports.InternalPackage = InternalPackage;
/**
 * Go requires that when a module major version is v2.0 and above, the module
 * name will have a `/vNN` suffix (where `NN` is the major version).
 *
 * > Starting with major version 2, module paths must have a major version
 * > suffix like /v2 that matches the major version. For example, if a module
 * > has the path example.com/mod at v1.0.0, it must have the path
 * > example.com/mod/v2 at version v2.0.0.
 *
 * @see https://golang.org/ref/mod#major-version-suffixes
 * @param version The module version (e.g. `2.3.0`)
 * @returns a suffix to append to the module name in the form (`/vNN`). If the
 * module version is `0.x` or `1.x`, returns an empty string.
 */
function determineMajorVersionSuffix(version) {
    const sv = semver.parse(version);
    if (!sv) {
        throw new Error(`Unable to parse version "${version}" as a semantic version`);
    }
    // suffix is only needed for 2.0 and above
    if (sv.major <= 1) {
        return '';
    }
    return `/v${sv.major}`;
}
const JSII_RT_MODULE = {
    alias: runtime_1.JSII_RT_ALIAS,
    module: runtime_1.JSII_RT_PACKAGE_NAME,
};
const GO_REFLECT = { module: 'reflect' };
function importGoModules(code, modules) {
    if (modules.length === 0) {
        return;
    }
    const aliasSize = Math.max(...modules.map((mod) => { var _a, _b; return (_b = (_a = mod.alias) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0; }));
    code.open('import (');
    const sortedModules = Array.from(modules).sort(compareImportedModules);
    for (let i = 0; i < sortedModules.length; i++) {
        const mod = sortedModules[i];
        // Separate module categories from each other modules with a blank line.
        if (i > 0 &&
            (isBuiltIn(mod) !== isBuiltIn(sortedModules[i - 1]) ||
                isSpecial(mod) !== isSpecial(sortedModules[i - 1]))) {
            code.line();
        }
        if (mod.alias) {
            code.line(`${mod.alias.padEnd(aliasSize, ' ')} "${mod.module}"`);
        }
        else {
            code.line(`"${mod.module}"`);
        }
    }
    code.close(')');
    /**
     * A comparator for `ImportedModule` instances such that built-in modules
     * always appear first, followed by the rest. Then within these two groups,
     * aliased imports appear first, followed by the rest.
     */
    function compareImportedModules(l, r) {
        const lBuiltIn = isBuiltIn(l);
        const rBuiltIn = isBuiltIn(r);
        if (lBuiltIn && !rBuiltIn) {
            return -1;
        }
        if (!lBuiltIn && rBuiltIn) {
            return 1;
        }
        const lSpecial = isSpecial(l);
        const rSpecial = isSpecial(r);
        if (lSpecial && !rSpecial) {
            return -1;
        }
        if (!lSpecial && rSpecial) {
            return 1;
        }
        return l.module.localeCompare(r.module);
    }
    function isBuiltIn(mod) {
        // Standard library modules don't have any "." in their path, whereas any
        // other module has a DNS portion in them, which must include a ".".
        return !mod.module.includes('.');
    }
    function isSpecial(mod) {
        return mod.alias === runtime_1.JSII_RT_ALIAS || mod.alias === runtime_1.JSII_INIT_ALIAS;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhY2thZ2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBRUEsK0JBQStDO0FBQy9DLGlDQUFpQztBQUVqQywyQ0FBd0M7QUFHeEMsK0NBQTJDO0FBQzNDLHVDQU9tQjtBQUNuQixtQ0FBZ0Y7QUFDaEYsaUNBS2dCO0FBQ2hCLGlEQUE2QztBQUVoQyxRQUFBLGNBQWMsR0FBRyxRQUFRLENBQUM7QUFDMUIsUUFBQSxVQUFVLEdBQUcsTUFBTSxDQUFDO0FBRWpDLDZFQUE2RTtBQUM3RSxrQ0FBa0M7QUFDbEMsTUFBTSxxQkFBcUIsR0FBRyxVQUFVLENBQUM7QUFFekM7O0dBRUc7QUFDSCxNQUFzQixPQUFPO0lBUzNCLFlBQ21CLFFBQXlCLEVBQ3pCLGFBQXVDLEVBQ3hDLFdBQW1CLEVBQ25CLFFBQWdCLEVBQ2hCLFVBQWtCLEVBQ2xCLE9BQWU7SUFDL0Isa0RBQWtEO0lBQ2xELElBQWM7UUFQRyxhQUFRLEdBQVIsUUFBUSxDQUFpQjtRQUN6QixrQkFBYSxHQUFiLGFBQWEsQ0FBMEI7UUFDeEMsZ0JBQVcsR0FBWCxXQUFXLENBQVE7UUFDbkIsYUFBUSxHQUFSLFFBQVEsQ0FBUTtRQUNoQixlQUFVLEdBQVYsVUFBVSxDQUFRO1FBQ2xCLFlBQU8sR0FBUCxPQUFPLENBQVE7UUFSaEIsa0JBQWEsR0FBb0MsRUFBRSxDQUFDO1FBWW5FLElBQUksQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDO1FBQzFCLElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsU0FBUyxJQUFJLFdBQVcsS0FBSyxDQUFDO1FBQ2xELElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxhQUFKLElBQUksY0FBSixJQUFJLEdBQUksSUFBSSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQ3RDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxJQUFJLGVBQWUs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QUcsQ0FBQyxLQUFLLEtBQUsseUJBQWUsQ0FBQztJQUN0RSxDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvZGVNYWtlciB9IGZyb20gJ2NvZGVtYWtlcic7XG5pbXBvcnQgeyBBc3NlbWJseSwgVHlwZSwgU3VibW9kdWxlIGFzIEpzaWlTdWJtb2R1bGUgfSBmcm9tICdqc2lpLXJlZmxlY3QnO1xuaW1wb3J0IHsgYmFzZW5hbWUsIGRpcm5hbWUsIGpvaW4gfSBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIHNlbXZlciBmcm9tICdzZW12ZXInO1xuXG5pbXBvcnQgeyBWRVJTSU9OIH0gZnJvbSAnLi4vLi4vdmVyc2lvbic7XG5pbXBvcnQgeyBTcGVjaWFsRGVwZW5kZW5jaWVzIH0gZnJvbSAnLi9kZXBlbmRlbmNpZXMnO1xuaW1wb3J0IHsgRW1pdENvbnRleHQgfSBmcm9tICcuL2VtaXQtY29udGV4dCc7XG5pbXBvcnQgeyBSZWFkbWVGaWxlIH0gZnJvbSAnLi9yZWFkbWUtZmlsZSc7XG5pbXBvcnQge1xuICBKU0lJX1JUX0FMSUFTLFxuICBKU0lJX1JUX01PRFVMRV9OQU1FLFxuICBKU0lJX1JUX1BBQ0tBR0VfTkFNRSxcbiAgSlNJSV9JTklUX1BBQ0tBR0UsXG4gIEpTSUlfSU5JVF9GVU5DLFxuICBKU0lJX0lOSVRfQUxJQVMsXG59IGZyb20gJy4vcnVudGltZSc7XG5pbXBvcnQgeyBHb0NsYXNzLCBHb1R5cGUsIEVudW0sIEdvSW50ZXJmYWNlLCBTdHJ1Y3QsIEdvVHlwZVJlZiB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgZmluZFR5cGVJblRyZWUsXG4gIGdvUGFja2FnZU5hbWVGb3JBc3NlbWJseSxcbiAgZmxhdE1hcCxcbiAgdGFyYmFsbE5hbWUsXG59IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBWZXJzaW9uRmlsZSB9IGZyb20gJy4vdmVyc2lvbi1maWxlJztcblxuZXhwb3J0IGNvbnN0IEdPTU9EX0ZJTEVOQU1FID0gJ2dvLm1vZCc7XG5leHBvcnQgY29uc3QgR09fVkVSU0lPTiA9ICcxLjE2JztcblxuLy8gdGhlIG5hbWUgb2YgYSBzdWItcGFja2FnZSB0aGF0IGluY2x1ZGVzIGludGVybmFsIHR5cGUgYWxpYXNlcyBpdCBoYXMgdG8gYmVcbi8vIFwiaW50ZXJuYWxcIiBzbyBpdCBub3QgcHVibGlzaGVkLlxuY29uc3QgSU5URVJOQUxfUEFDS0FHRV9OQU1FID0gJ2ludGVybmFsJztcblxuLypcbiAqIFBhY2thZ2UgcmVwcmVzZW50cyBhIHNpbmdsZSBgLmdvYCBzb3VyY2UgZmlsZSB3aXRoaW4gYSBwYWNrYWdlLiBUaGlzIGNhbiBiZSB0aGUgcm9vdCBwYWNrYWdlIGZpbGUgb3IgYSBzdWJtb2R1bGVcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBhY2thZ2Uge1xuICBwdWJsaWMgcmVhZG9ubHkgcm9vdDogUGFja2FnZTtcbiAgcHVibGljIHJlYWRvbmx5IGZpbGU6IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IGRpcmVjdG9yeTogc3RyaW5nO1xuICBwdWJsaWMgcmVhZG9ubHkgc3VibW9kdWxlczogSW50ZXJuYWxQYWNrYWdlW107XG4gIHB1YmxpYyByZWFkb25seSB0eXBlczogR29UeXBlW107XG5cbiAgcHJpdmF0ZSByZWFkb25seSBlbWJlZGRlZFR5cGVzOiB7IFtmcW46IHN0cmluZ106IEVtYmVkZGVkVHlwZSB9ID0ge307XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdHlwZVNwZWM6IHJlYWRvbmx5IFR5cGVbXSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN1Ym1vZHVsZVNwZWM6IHJlYWRvbmx5IEpzaWlTdWJtb2R1bGVbXSxcbiAgICBwdWJsaWMgcmVhZG9ubHkgcGFja2FnZU5hbWU6IHN0cmluZyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgZmlsZVBhdGg6IHN0cmluZyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgbW9kdWxlTmFtZTogc3RyaW5nLFxuICAgIHB1YmxpYyByZWFkb25seSB2ZXJzaW9uOiBzdHJpbmcsXG4gICAgLy8gSWYgbm8gcm9vdCBpcyBwcm92aWRlZCwgdGhpcyBtb2R1bGUgaXMgdGhlIHJvb3RcbiAgICByb290PzogUGFja2FnZSxcbiAgKSB7XG4gICAgdGhpcy5kaXJlY3RvcnkgPSBmaWxlUGF0aDtcbiAgICB0aGlzLmZpbGUgPSBgJHt0aGlzLmRpcmVjdG9yeX0vJHtwYWNrYWdlTmFtZX0uZ29gO1xuICAgIHRoaXMucm9vdCA9IHJvb3QgPz8gdGhpcztcbiAgICB0aGlzLnN1Ym1vZHVsZXMgPSB0aGlzLnN1Ym1vZHVsZVNwZWMubWFwKFxuICAgICAgKHNtKSA9PiBuZXcgSW50ZXJuYWxQYWNrYWdlKHRoaXMucm9vdCwgdGhpcywgc20pLFxuICAgICk7XG5cbiAgICB0aGlzLnR5cGVzID0gdGhpcy50eXBlU3BlYy5tYXAoKHR5cGU6IFR5cGUpOiBHb1R5cGUgPT4ge1xuICAgICAgaWYgKHR5cGUuaXNJbnRlcmZhY2VUeXBlKCkgJiYgdHlwZS5kYXRhdHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCh0aGlzLCB0eXBlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZS5pc0ludGVyZmFjZVR5cGUoKSkge1xuICAgICAgICByZXR1cm4gbmV3IEdvSW50ZXJmYWNlKHRoaXMsIHR5cGUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlLmlzQ2xhc3NUeXBlKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHb0NsYXNzKHRoaXMsIHR5cGUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlLmlzRW51bVR5cGUoKSkge1xuICAgICAgICByZXR1cm4gbmV3IEVudW0odGhpcywgdHlwZSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUeXBlOiAke3R5cGUubmFtZX0gd2l0aCBraW5kICR7dHlwZS5raW5kfSBpcyBub3QgYSBzdXBwb3J0ZWQgdHlwZWAsXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgLypcbiAgICogUGFja2FnZXMgd2l0aGluIHRoaXMgbW9kdWxlXG4gICAqL1xuICBwdWJsaWMgZ2V0IGRlcGVuZGVuY2llcygpOiBQYWNrYWdlW10ge1xuICAgIHJldHVybiBmbGF0TWFwKHRoaXMudHlwZXMsICh0OiBHb1R5cGUpOiBQYWNrYWdlW10gPT4gdC5kZXBlbmRlbmNpZXMpLmZpbHRlcihcbiAgICAgIChtb2QpID0+IG1vZC5wYWNrYWdlTmFtZSAhPT0gdGhpcy5wYWNrYWdlTmFtZSxcbiAgICApO1xuICB9XG5cbiAgLypcbiAgICogZ29Nb2R1bGVOYW1lIHJldHVybnMgdGhlIGZ1bGwgcGF0aCB0byB0aGUgbW9kdWxlIG5hbWUuXG4gICAqIFVzZWQgZm9yIGltcG9ydCBzdGF0ZW1lbnRzIGFuZCBnby5tb2QgZ2VuZXJhdGlvblxuICAgKi9cbiAgcHVibGljIGdldCBnb01vZHVsZU5hbWUoKTogc3RyaW5nIHtcbiAgICBjb25zdCBtb2R1bGVOYW1lID0gdGhpcy5yb290Lm1vZHVsZU5hbWU7XG4gICAgY29uc3QgcHJlZml4ID0gbW9kdWxlTmFtZSAhPT0gJycgPyBgJHttb2R1bGVOYW1lfS9gIDogJyc7XG4gICAgY29uc3Qgcm9vdFBhY2thZ2VOYW1lID0gdGhpcy5yb290LnBhY2thZ2VOYW1lO1xuICAgIGNvbnN0IHZlcnNpb25TdWZmaXggPSBkZXRlcm1pbmVNYWpvclZlcnNpb25TdWZmaXgodGhpcy52ZXJzaW9uKTtcbiAgICBjb25zdCBzdWZmaXggPSB0aGlzLmZpbGVQYXRoICE9PSAnJyA/IGAvJHt0aGlzLmZpbGVQYXRofWAgOiBgYDtcbiAgICByZXR1cm4gYCR7cHJlZml4fSR7cm9vdFBhY2thZ2VOYW1lfSR7dmVyc2lvblN1ZmZpeH0ke3N1ZmZpeH1gO1xuICB9XG5cbiAgLypcbiAgICogVGhlIG1vZHVsZSBuYW1lcyBvZiB0aGlzIG1vZHVsZSdzIGRlcGVuZGVuY2llcy4gVXNlZCBmb3IgaW1wb3J0IHN0YXRlbWVudHMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGRlcGVuZGVuY3lJbXBvcnRzKCk6IFNldDxzdHJpbmc+IHtcbiAgICByZXR1cm4gbmV3IFNldCh0aGlzLmRlcGVuZGVuY2llcy5tYXAoKHBrZykgPT4gcGtnLmdvTW9kdWxlTmFtZSkpO1xuICB9XG5cbiAgLypcbiAgICogU2VhcmNoIGZvciBhIHR5cGUgd2l0aCBhIGBmcW5gIHdpdGhpbiB0aGlzLiBTZWFyY2hlcyBhbGwgQ2hpbGRyZW4gbW9kdWxlcyBhcyB3ZWxsLlxuICAgKi9cbiAgcHVibGljIGZpbmRUeXBlKGZxbjogc3RyaW5nKTogR29UeXBlIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gZmluZFR5cGVJblRyZWUodGhpcywgZnFuKTtcbiAgfVxuXG4gIHB1YmxpYyBlbWl0KGNvbnRleHQ6IEVtaXRDb250ZXh0KTogdm9pZCB7XG4gICAgY29uc3QgeyBjb2RlIH0gPSBjb250ZXh0O1xuXG4gICAgY29kZS5vcGVuRmlsZSh0aGlzLmZpbGUpO1xuICAgIHRoaXMuZW1pdEhlYWRlcihjb2RlKTtcbiAgICB0aGlzLmVtaXRJbXBvcnRzKGNvZGUpO1xuICAgIHRoaXMuZW1pdFR5cGVzKGNvbnRleHQpO1xuICAgIGNvZGUuY2xvc2VGaWxlKHRoaXMuZmlsZSk7XG5cbiAgICB0aGlzLmVtaXRHb0luaXRGdW5jdGlvbihjb250ZXh0KTtcbiAgICB0aGlzLmVtaXRTdWJtb2R1bGVzKGNvbnRleHQpO1xuXG4gICAgdGhpcy5lbWl0SW50ZXJuYWwoY29udGV4dCk7XG4gIH1cblxuICBwdWJsaWMgZW1pdFN1Ym1vZHVsZXMoY29udGV4dDogRW1pdENvbnRleHQpIHtcbiAgICBmb3IgKGNvbnN0IHN1Ym1vZHVsZSBvZiB0aGlzLnN1Ym1vZHVsZXMpIHtcbiAgICAgIHN1Ym1vZHVsZS5lbWl0KGNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIGB0eXBlYCBjb21lcyBmcm9tIGEgZm9yZWlnbiBwYWNrYWdlLlxuICAgKi9cbiAgcHVibGljIGlzRXh0ZXJuYWxUeXBlKHR5cGU6IEdvQ2xhc3MgfCBHb0ludGVyZmFjZSkge1xuICAgIHJldHVybiB0eXBlLnBrZyAhPT0gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBlbWJlZCBmaWVsZCB1c2VkIHRvIGVtYmVkIGEgYmFzZSBjbGFzcy9pbnRlcmZhY2UgaW4gYVxuICAgKiBzdHJ1Y3QuXG4gICAqXG4gICAqIEByZXR1cm5zIElmIHRoZSBiYXNlIGlzIGluIHRoZSBzYW1lIHBhY2thZ2UsIHJldHVybnMgdGhlIHByb3h5IG5hbWUgb2YgdGhlXG4gICAqIGJhc2UgdW5kZXIgYGVtYmVkYCwgb3RoZXJ3aXNlIHJldHVybnMgYSB1bmlxdWUgc3ltYm9sIHVuZGVyIGBlbWJlZGAgYW5kIHRoZVxuICAgKiBvcmlnaW5hbCBpbnRlcmZhY2UgcmVmZXJlbmNlIHVuZGVyIGBvcmlnaW5hbGAuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIFRoZSBiYXNlIHR5cGUgd2Ugd2FudCB0byBlbWJlZFxuICAgKi9cbiAgcHVibGljIHJlc29sdmVFbWJlZGRlZFR5cGUodHlwZTogR29DbGFzcyB8IEdvSW50ZXJmYWNlKTogRW1iZWRkZWRUeXBlIHtcbiAgICBpZiAoIXRoaXMuaXNFeHRlcm5hbFR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVtYmVkOiB0eXBlLnByb3h5TmFtZSxcbiAgICAgICAgZmllbGROYW1lOiB0eXBlLnByb3h5TmFtZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RzID0gdGhpcy5lbWJlZGRlZFR5cGVzW3R5cGUuZnFuXTtcbiAgICBpZiAoZXhpc3RzKSB7XG4gICAgICByZXR1cm4gZXhpc3RzO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGVyZWYgPSBuZXcgR29UeXBlUmVmKHRoaXMucm9vdCwgdHlwZS50eXBlLnJlZmVyZW5jZSk7XG4gICAgY29uc3Qgb3JpZ2luYWwgPSB0eXBlcmVmLnNjb3BlZE5hbWUodGhpcyk7XG5cbiAgICBjb25zdCBzbHVnID0gb3JpZ2luYWwucmVwbGFjZSgvW15BLVphLXowLTldL2csICcnKTtcbiAgICBjb25zdCBhbGlhc05hbWUgPSBgVHlwZV9fJHtzbHVnfWA7XG5cbiAgICB0aGlzLmVtYmVkZGVkVHlwZXNbdHlwZS5mcW5dID0ge1xuICAgICAgZm9yaWVnblR5cGVOYW1lOiBvcmlnaW5hbCxcbiAgICAgIGZvcmllZ25UeXBlOiB0eXBlcmVmLFxuICAgICAgZmllbGROYW1lOiBhbGlhc05hbWUsXG4gICAgICBlbWJlZDogYCR7SU5URVJOQUxfUEFDS0FHRV9OQU1FfS4ke2FsaWFzTmFtZX1gLFxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlRW1iZWRkZWRUeXBlKHR5cGUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGVtaXRIZWFkZXIoY29kZTogQ29kZU1ha2VyKSB7XG4gICAgY29kZS5saW5lKGBwYWNrYWdlICR7dGhpcy5wYWNrYWdlTmFtZX1gKTtcbiAgICBjb2RlLmxpbmUoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXQgc3BlY2lhbERlcGVuZGVuY2llcygpOiBTcGVjaWFsRGVwZW5kZW5jaWVzIHtcbiAgICByZXR1cm4gdGhpcy50eXBlc1xuICAgICAgLm1hcCgodCkgPT4gdC5zcGVjaWFsRGVwZW5kZW5jaWVzKVxuICAgICAgLnJlZHVjZShcbiAgICAgICAgKGFjYywgZWx0KSA9PiAoe1xuICAgICAgICAgIHJ1bnRpbWU6IGFjYy5ydW50aW1lIHx8IGVsdC5ydW50aW1lLFxuICAgICAgICAgIGluaXQ6IGFjYy5pbml0IHx8IGVsdC5pbml0LFxuICAgICAgICAgIGludGVybmFsOiBhY2MuaW50ZXJuYWwgfHwgZWx0LmludGVybmFsLFxuICAgICAgICAgIHRpbWU6IGFjYy50aW1lIHx8IGVsdC50aW1lLFxuICAgICAgICB9KSxcbiAgICAgICAgeyBydW50aW1lOiBmYWxzZSwgaW5pdDogZmFsc2UsIGludGVybmFsOiBmYWxzZSwgdGltZTogZmFsc2UgfSxcbiAgICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgYSBgZnVuYyBpbml0KCkgeyAuLi4gfWAgaW4gYSBkZWRpY2F0ZWQgZmlsZSAoc28gd2UgZG9uJ3QgaGF2ZSB0b1xuICAgKiB3b3JyeSBhYm91dCB3aGF0IG5lZWRzIHRvIGJlIGltcG9ydGVkIGFuZCB3aGF0bm90KS4gVGhpcyBmdW5jdGlvbiBpc1xuICAgKiByZXNwb25zaWJsZSBmb3IgY29ycmVjdGx5IGluaXRpYWxpemluZyB0aGUgbW9kdWxlLCBpbmNsdWRpbmcgcmVnaXN0ZXJpbmdcbiAgICogdGhlIGRlY2xhcmVkIHR5cGVzIHdpdGggdGhlIGpzaWkgcnVudGltZSBmb3IgZ28uXG4gICAqL1xuICBwcml2YXRlIGVtaXRHb0luaXRGdW5jdGlvbih7IGNvZGUgfTogRW1pdENvbnRleHQpOiB2b2lkIHtcbiAgICAvLyBXZSBkb24ndCBlbWl0IGFueXRoaW5nIGlmIHRoZXJlIGFyZSBub3QgdHlwZXMgaW4gdGhpcyAoc3ViKW1vZHVsZS4gVGhpc1xuICAgIC8vIGF2b2lkcyByZWdpc3RlcmluZyBhbiBgaW5pdGAgZnVuY3Rpb24gdGhhdCBkb2VzIG5vdGhpbmcsIHdoaWNoIGlzIHBvb3JcbiAgICAvLyBmb3JtLiBJdCBhbHNvIHNhdmVzIHVzIGZyb20gXCJpbXBvcnRlZCBidXQgdW51c2VkXCIgZXJyb3JzIHRoYXQgd291bGQgYXJpc2VcbiAgICAvLyBhcyBhIGNvbnNlcXVlbmNlLlxuICAgIGlmICh0aGlzLnR5cGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGluaXRGaWxlID0gam9pbihcbiAgICAgICAgZGlybmFtZSh0aGlzLmZpbGUpLFxuICAgICAgICBgJHtiYXNlbmFtZSh0aGlzLmZpbGUsICcuZ28nKX0uaW5pdC5nb2AsXG4gICAgICApO1xuICAgICAgY29kZS5vcGVuRmlsZShpbml0RmlsZSk7XG4gICAgICBjb2RlLmxpbmUoYHBhY2thZ2UgJHt0aGlzLnBhY2thZ2VOYW1lfWApO1xuICAgICAgY29kZS5saW5lKCk7XG4gICAgICBpbXBvcnRHb01vZHVsZXMoY29kZSwgW0dPX1JFRkxFQ1QsIEpTSUlfUlRfTU9EVUxFXSk7XG4gICAgICBjb2RlLmxpbmUoKTtcbiAgICAgIGNvZGUub3BlbkJsb2NrKCdmdW5jIGluaXQoKScpO1xuICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHRoaXMudHlwZXMpIHtcbiAgICAgICAgdHlwZS5lbWl0UmVnaXN0cmF0aW9uKGNvZGUpO1xuICAgICAgfVxuICAgICAgY29kZS5jbG9zZUJsb2NrKCk7XG4gICAgICBjb2RlLmNsb3NlRmlsZShpbml0RmlsZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBlbWl0SW1wb3J0cyhjb2RlOiBDb2RlTWFrZXIpIHtcbiAgICBjb25zdCB0b0ltcG9ydCA9IG5ldyBBcnJheTxJbXBvcnRlZE1vZHVsZT4oKTtcblxuICAgIGNvbnN0IHNwZWNpYWxEZXBzID0gdGhpcy5zcGVjaWFsRGVwZW5kZW5jaWVzO1xuXG4gICAgaWYgKHNwZWNpYWxEZXBzLnRpbWUpIHtcbiAgICAgIHRvSW1wb3J0LnB1c2goeyBtb2R1bGU6ICd0aW1lJyB9KTtcbiAgICB9XG5cbiAgICBpZiAoc3BlY2lhbERlcHMucnVudGltZSkge1xuICAgICAgdG9JbXBvcnQucHVzaChKU0lJX1JUX01PRFVMRSk7XG4gICAgfVxuXG4gICAgaWYgKHNwZWNpYWxEZXBzLmluaXQpIHtcbiAgICAgIHRvSW1wb3J0LnB1c2goe1xuICAgICAgICBhbGlhczogSlNJSV9JTklUX0FMSUFTLFxuICAgICAgICBtb2R1bGU6IGAke3RoaXMucm9vdC5nb01vZHVsZU5hbWV9LyR7SlNJSV9JTklUX1BBQ0tBR0V9YCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChzcGVjaWFsRGVwcy5pbnRlcm5hbCkge1xuICAgICAgdG9JbXBvcnQucHVzaCh7XG4gICAgICAgIG1vZHVsZTogYCR7dGhpcy5nb01vZHVsZU5hbWV9LyR7SU5URVJOQUxfUEFDS0FHRV9OQU1FfWAsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHBhY2thZ2VOYW1lIG9mIHRoaXMuZGVwZW5kZW5jeUltcG9ydHMpIHtcbiAgICAgIC8vIElmIHRoZSBtb2R1bGUgaXMgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgb25lIGJlaW5nIHdyaXR0ZW4sIGRvbid0IGVtaXQgYW4gaW1wb3J0IHN0YXRlbWVudFxuICAgICAgaWYgKHBhY2thZ2VOYW1lICE9PSB0aGlzLnBhY2thZ2VOYW1lKSB7XG4gICAgICAgIHRvSW1wb3J0LnB1c2goeyBtb2R1bGU6IHBhY2thZ2VOYW1lIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGltcG9ydEdvTW9kdWxlcyhjb2RlLCB0b0ltcG9ydCk7XG4gICAgY29kZS5saW5lKCk7XG4gIH1cblxuICBwcml2YXRlIGVtaXRUeXBlcyhjb250ZXh0OiBFbWl0Q29udGV4dCkge1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiB0aGlzLnR5cGVzKSB7XG4gICAgICB0eXBlLmVtaXQoY29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBlbWl0SW50ZXJuYWwoY29udGV4dDogRW1pdENvbnRleHQpIHtcbiAgICBjb25zdCBhbGlhc2VzID0gT2JqZWN0LnZhbHVlcyh0aGlzLmVtYmVkZGVkVHlwZXMpO1xuXG4gICAgaWYgKGFsaWFzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29kZSA9IGNvbnRleHQuY29kZTtcblxuICAgIGNvbnN0IGZpbGVOYW1lID0gam9pbih0aGlzLmRpcmVjdG9yeSwgSU5URVJOQUxfUEFDS0FHRV9OQU1FLCAndHlwZXMuZ28nKTtcbiAgICBjb2RlLm9wZW5GaWxlKGZpbGVOYW1lKTtcblxuICAgIGNvZGUubGluZShgcGFja2FnZSAke0lOVEVSTkFMX1BBQ0tBR0VfTkFNRX1gKTtcblxuICAgIGNvbnN0IGltcG9ydHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgIGZvciAoY29uc3QgYWxpYXMgb2YgYWxpYXNlcykge1xuICAgICAgaWYgKCFhbGlhcy5mb3JpZWduVHlwZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBwa2cgb2YgYWxpYXMuZm9yaWVnblR5cGUuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGltcG9ydHMuYWRkKHBrZy5nb01vZHVsZU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvZGUub3BlbignaW1wb3J0ICgnKTtcbiAgICBmb3IgKGNvbnN0IGltcHJ0IG9mIGltcG9ydHMpIHtcbiAgICAgIGNvZGUubGluZShgXCIke2ltcHJ0fVwiYCk7XG4gICAgfVxuICAgIGNvZGUuY2xvc2UoJyknKTtcblxuICAgIGZvciAoY29uc3QgYWxpYXMgb2YgYWxpYXNlcykge1xuICAgICAgY29kZS5saW5lKGB0eXBlICR7YWxpYXMuZmllbGROYW1lfSA9ICR7YWxpYXMuZm9yaWVnblR5cGVOYW1lfWApO1xuICAgIH1cblxuICAgIGNvZGUuY2xvc2VGaWxlKGZpbGVOYW1lKTtcbiAgfVxufVxuXG4vKlxuICogUm9vdFBhY2thZ2UgY29ycmVzcG9uZHMgdG8gSlNJSSBtb2R1bGUuXG4gKlxuICogRXh0ZW5kcyBgUGFja2FnZWAgZm9yIHJvb3Qgc291cmNlIHBhY2thZ2UgZW1pdCBsb2dpY1xuICovXG5leHBvcnQgY2xhc3MgUm9vdFBhY2thZ2UgZXh0ZW5kcyBQYWNrYWdlIHtcbiAgcHVibGljIHJlYWRvbmx5IGFzc2VtYmx5OiBBc3NlbWJseTtcbiAgcHVibGljIHJlYWRvbmx5IHZlcnNpb246IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSByZWFkbWU/OiBSZWFkbWVGaWxlO1xuICBwcml2YXRlIHJlYWRvbmx5IHZlcnNpb25GaWxlOiBWZXJzaW9uRmlsZTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoYXNzZW1ibHk6IEFzc2VtYmx5KSB7XG4gICAgY29uc3QgZ29Db25maWcgPSBhc3NlbWJseS50YXJnZXRzPy5nbyA/PyB7fTtcbiAgICBjb25zdCBwYWNrYWdlTmFtZSA9IGdvUGFja2FnZU5hbWVGb3JBc3NlbWJseShhc3NlbWJseSk7XG4gICAgY29uc3QgZmlsZVBhdGggPSAnJztcbiAgICBjb25zdCBtb2R1bGVOYW1lID0gZ29Db25maWcubW9kdWxlTmFtZSA/PyAnJztcbiAgICBjb25zdCB2ZXJzaW9uID0gYCR7YXNzZW1ibHkudmVyc2lvbn0ke2dvQ29uZmlnLnZlcnNpb25TdWZmaXggPz8gJyd9YDtcblxuICAgIHN1cGVyKFxuICAgICAgYXNzZW1ibHkudHlwZXMsXG4gICAgICBhc3NlbWJseS5zdWJtb2R1bGVzLFxuICAgICAgcGFja2FnZU5hbWUsXG4gICAgICBmaWxlUGF0aCxcbiAgICAgIG1vZHVsZU5hbWUsXG4gICAgICB2ZXJzaW9uLFxuICAgICk7XG5cbiAgICB0aGlzLmFzc2VtYmx5ID0gYXNzZW1ibHk7XG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0aGlzLnZlcnNpb25GaWxlID0gbmV3IFZlcnNpb25GaWxlKHRoaXMudmVyc2lvbik7XG5cbiAgICBpZiAodGhpcy5hc3NlbWJseS5yZWFkbWU/Lm1hcmtkb3duKSB7XG4gICAgICB0aGlzLnJlYWRtZSA9IG5ldyBSZWFkbWVGaWxlKFxuICAgICAgICB0aGlzLnBhY2thZ2VOYW1lLFxuICAgICAgICB0aGlzLmFzc2VtYmx5LnJlYWRtZS5tYXJrZG93bixcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGVtaXQoY29udGV4dDogRW1pdENvbnRleHQpOiB2b2lkIHtcbiAgICBzdXBlci5lbWl0KGNvbnRleHQpO1xuICAgIHRoaXMuZW1pdEpzaWlQYWNrYWdlKGNvbnRleHQpO1xuICAgIHRoaXMucmVhZG1lPy5lbWl0KGNvbnRleHQpO1xuXG4gICAgdGhpcy5lbWl0R29tb2QoY29udGV4dC5jb2RlKTtcbiAgICB0aGlzLnZlcnNpb25GaWxlLmVtaXQoY29udGV4dC5jb2RlKTtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdEdvbW9kKGNvZGU6IENvZGVNYWtlcikge1xuICAgIGNvZGUub3BlbkZpbGUoR09NT0RfRklMRU5BTUUpO1xuICAgIGNvZGUubGluZShgbW9kdWxlICR7dGhpcy5nb01vZHVsZU5hbWV9YCk7XG4gICAgY29kZS5saW5lKCk7XG4gICAgY29kZS5saW5lKGBnbyAke0dPX1ZFUlNJT059YCk7XG4gICAgY29kZS5saW5lKCk7XG4gICAgY29kZS5vcGVuKCdyZXF1aXJlICgnKTtcbiAgICAvLyBTdHJpcCBcIiAoYnVpbGQgYWJjZGVmKVwiIGZyb20gdGhlIGpzaWkgdmVyc2lvblxuICAgIGNvZGUubGluZShgJHtKU0lJX1JUX01PRFVMRV9OQU1FfSB2JHtWRVJTSU9OfWApO1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IHRoaXMucGFja2FnZURlcGVuZGVuY2llcztcbiAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBlbmRlbmNpZXMpIHtcbiAgICAgIGNvZGUubGluZShgJHtkZXAuZ29Nb2R1bGVOYW1lfSB2JHtkZXAudmVyc2lvbn1gKTtcbiAgICB9XG4gICAgaW5kaXJlY3REZXBlbmRlbmNpZXMoXG4gICAgICBkZXBlbmRlbmNpZXMsXG4gICAgICBuZXcgU2V0KGRlcGVuZGVuY2llcy5tYXAoKGRlcCkgPT4gZGVwLmdvTW9kdWxlTmFtZSkpLFxuICAgICk7XG4gICAgY29kZS5jbG9zZSgnKScpO1xuICAgIGNvZGUuY2xvc2VGaWxlKEdPTU9EX0ZJTEVOQU1FKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGluZGlyZWN0IGRlcGVuZGVuY3kgZGVjbGFyYXRpb25zLCB3aGljaCBhcmUgaGVscGZ1bCB0byBtYWtlIElERXMgYXRcbiAgICAgKiBlYXNlIHdpdGggdGhlIGNvZGViYXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGlyZWN0RGVwZW5kZW5jaWVzKFxuICAgICAgcGtnczogUm9vdFBhY2thZ2VbXSxcbiAgICAgIGFscmVhZHlFbWl0dGVkOiBTZXQ8c3RyaW5nPixcbiAgICApOiB2b2lkIHtcbiAgICAgIGZvciAoY29uc3QgcGtnIG9mIHBrZ3MpIHtcbiAgICAgICAgY29uc3QgZGVwcyA9IHBrZy5wYWNrYWdlRGVwZW5kZW5jaWVzO1xuICAgICAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBzKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlFbWl0dGVkLmhhcyhkZXAuZ29Nb2R1bGVOYW1lKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFscmVhZHlFbWl0dGVkLmFkZChkZXAuZ29Nb2R1bGVOYW1lKTtcbiAgICAgICAgICBjb2RlLmxpbmUoYCR7ZGVwLmdvTW9kdWxlTmFtZX0gdiR7ZGVwLnZlcnNpb259IC8vIGluZGlyZWN0YCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5kaXJlY3REZXBlbmRlbmNpZXMoZGVwcywgYWxyZWFkeUVtaXR0ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAqIE92ZXJyaWRlIHBhY2thZ2UgZmluZFR5cGUgZm9yIHJvb3QgUGFja2FnZS5cbiAgICpcbiAgICogVGhpcyBhbGxvd3MgcmVzb2x2aW5nIHR5cGUgcmVmZXJlbmNlcyBmcm9tIG90aGVyIEpTSUkgbW9kdWxlc1xuICAgKi9cbiAgcHVibGljIGZpbmRUeXBlKGZxbjogc3RyaW5nKTogR29UeXBlIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5wYWNrYWdlRGVwZW5kZW5jaWVzLnJlZHVjZShcbiAgICAgIChhY2N1bTogR29UeXBlIHwgdW5kZWZpbmVkLCBjdXJyZW50OiBSb290UGFja2FnZSkgPT4ge1xuICAgICAgICBpZiAoYWNjdW0pIHtcbiAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQuZmluZFR5cGUoZnFuKTtcbiAgICAgIH0sXG4gICAgICBzdXBlci5maW5kVHlwZShmcW4pLFxuICAgICk7XG4gIH1cblxuICAvKlxuICAgKiBHZXQgYWxsIEpTSUkgbW9kdWxlIGRlcGVuZGVuY2llcyBvZiB0aGUgcGFja2FnZSBiZWluZyBnZW5lcmF0ZWRcbiAgICovXG4gIHB1YmxpYyBnZXQgcGFja2FnZURlcGVuZGVuY2llcygpOiBSb290UGFja2FnZVtdIHtcbiAgICByZXR1cm4gdGhpcy5hc3NlbWJseS5kZXBlbmRlbmNpZXMubWFwKFxuICAgICAgKGRlcCkgPT4gbmV3IFJvb3RQYWNrYWdlKGRlcC5hc3NlbWJseSksXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBlbWl0SGVhZGVyKGNvZGU6IENvZGVNYWtlcikge1xuICAgIGlmICh0aGlzLmFzc2VtYmx5LmRlc2NyaXB0aW9uICE9PSAnJykge1xuICAgICAgY29kZS5saW5lKGAvLyAke3RoaXMuYXNzZW1ibHkuZGVzY3JpcHRpb259YCk7XG4gICAgfVxuICAgIGNvZGUubGluZShgcGFja2FnZSAke3RoaXMucGFja2FnZU5hbWV9YCk7XG4gICAgY29kZS5saW5lKCk7XG4gIH1cblxuICBwcml2YXRlIGVtaXRKc2lpUGFja2FnZSh7IGNvZGUgfTogRW1pdENvbnRleHQpIHtcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSB0aGlzLnBhY2thZ2VEZXBlbmRlbmNpZXMuc29ydCgobCwgcikgPT5cbiAgICAgIGwubW9kdWxlTmFtZS5sb2NhbGVDb21wYXJlKHIubW9kdWxlTmFtZSksXG4gICAgKTtcblxuICAgIGNvbnN0IGZpbGUgPSBqb2luKEpTSUlfSU5JVF9QQUNLQUdFLCBgJHtKU0lJX0lOSVRfUEFDS0FHRX0uZ29gKTtcbiAgICBjb2RlLm9wZW5GaWxlKGZpbGUpO1xuICAgIGNvZGUubGluZShcbiAgICAgIGAvLyBQYWNrYWdlICR7SlNJSV9JTklUX1BBQ0tBR0V9IGNvbnRhaW5zIHRoZSBmdW5jdGlvbmFpbGl0eSBuZWVkZWQgZm9yIGpzaWkgcGFja2FnZXMgdG9gLFxuICAgICk7XG4gICAgY29kZS5saW5lKFxuICAgICAgJy8vIGluaXRpYWxpemUgdGhlaXIgZGVwZW5kZW5jaWVzIGFuZCB0aGVtc2VsdmVzLiBVc2VycyBzaG91bGQgbmV2ZXIgbmVlZCB0byB1c2UgdGhpcyBwYWNrYWdlJyxcbiAgICApO1xuICAgIGNvZGUubGluZSgnLy8gZGlyZWN0bHkuIElmIHlvdSBmaW5kIHlvdSBuZWVkIHRvIC0gcGxlYXNlIHJlcG9ydCBhIGJ1ZyBhdCcpO1xuICAgIGNvZGUubGluZSgnLy8gaHR0cHM6Ly9naXRodWIuY29tL2F3cy9qc2lpL2lzc3Vlcy9uZXcvY2hvb3NlJyk7XG4gICAgY29kZS5saW5lKGBwYWNrYWdlICR7SlNJSV9JTklUX1BBQ0tBR0V9YCk7XG4gICAgY29kZS5saW5lKCk7XG5cbiAgICBjb25zdCB0b0ltcG9ydDogSW1wb3J0ZWRNb2R1bGVbXSA9IFtcbiAgICAgIEpTSUlfUlRfTU9EVUxFLFxuICAgICAgeyBtb2R1bGU6ICdlbWJlZCcsIGFsaWFzOiAnXycgfSxcbiAgICBdO1xuICAgIGlmIChkZXBlbmRlbmNpZXMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBwa2cgb2YgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIHRvSW1wb3J0LnB1c2goe1xuICAgICAgICAgIGFsaWFzOiBwa2cucGFja2FnZU5hbWUsXG4gICAgICAgICAgbW9kdWxlOiBgJHtwa2cucm9vdC5nb01vZHVsZU5hbWV9LyR7SlNJSV9JTklUX1BBQ0tBR0V9YCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGltcG9ydEdvTW9kdWxlcyhjb2RlLCB0b0ltcG9ydCk7XG5cbiAgICBjb2RlLmxpbmUoKTtcbiAgICBjb2RlLmxpbmUoYC8vZ286ZW1iZWQgJHt0YXJiYWxsTmFtZSh0aGlzLmFzc2VtYmx5KX1gKTtcbiAgICBjb2RlLmxpbmUoJ3ZhciB0YXJiYWxsIFtdYnl0ZScpO1xuICAgIGNvZGUubGluZSgpO1xuXG4gICAgY29kZS5saW5lKFxuICAgICAgYC8vICR7SlNJSV9JTklUX0ZVTkN9IGxvYWRzIHRoZSBuZWNlc3NhcnkgcGFja2FnZXMgaW4gdGhlIEBqc2lpL2tlcm5lbCB0byBzdXBwb3J0IHRoZSBlbmNsb3NpbmcgbW9kdWxlLmAsXG4gICAgKTtcbiAgICBjb2RlLmxpbmUoXG4gICAgICAnLy8gVGhlIGltcGxlbWVudGF0aW9uIGlzIGlkZW1wb3RlbnQgKGFuZCBoZW5jZSBzYWZlIHRvIGJlIGNhbGxlZCBvdmVyIGFuZCBvdmVyKS4nLFxuICAgICk7XG4gICAgY29kZS5vcGVuKGBmdW5jICR7SlNJSV9JTklUX0ZVTkN9KCkge2ApO1xuICAgIGlmIChkZXBlbmRlbmNpZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29kZS5saW5lKCcvLyBFbnN1cmUgYWxsIGRlcGVuZGVuY2llcyBhcmUgaW5pdGlhbGl6ZWQnKTtcbiAgICAgIGZvciAoY29uc3QgcGtnIG9mIHRoaXMucGFja2FnZURlcGVuZGVuY2llcykge1xuICAgICAgICBjb2RlLmxpbmUoYCR7cGtnLnBhY2thZ2VOYW1lfS4ke0pTSUlfSU5JVF9GVU5DfSgpYCk7XG4gICAgICB9XG4gICAgICBjb2RlLmxpbmUoKTtcbiAgICB9XG4gICAgY29kZS5saW5lKCcvLyBMb2FkIHRoaXMgbGlicmFyeSBpbnRvIHRoZSBrZXJuZWwnKTtcbiAgICBjb2RlLmxpbmUoXG4gICAgICBgJHtKU0lJX1JUX0FMSUFTfS5Mb2FkKFwiJHt0aGlzLmFzc2VtYmx5Lm5hbWV9XCIsIFwiJHt0aGlzLmFzc2VtYmx5LnZlcnNpb259XCIsIHRhcmJhbGwpYCxcbiAgICApO1xuICAgIGNvZGUuY2xvc2UoJ30nKTtcblxuICAgIGNvZGUuY2xvc2VGaWxlKGZpbGUpO1xuICB9XG59XG5cbi8qXG4gKiBJbnRlcm5hbFBhY2thZ2UgcmVmZXJzIHRvIGFueSBnbyBwYWNrYWdlIHdpdGhpbiBhIGdpdmVuIEpTSUkgbW9kdWxlLlxuICovXG5leHBvcnQgY2xhc3MgSW50ZXJuYWxQYWNrYWdlIGV4dGVuZHMgUGFja2FnZSB7XG4gIHB1YmxpYyByZWFkb25seSBwYXJlbnQ6IFBhY2thZ2U7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHJvb3Q6IFBhY2thZ2UsIHBhcmVudDogUGFja2FnZSwgYXNzZW1ibHk6IEpzaWlTdWJtb2R1bGUpIHtcbiAgICBjb25zdCBwYWNrYWdlTmFtZSA9IGdvUGFja2FnZU5hbWVGb3JBc3NlbWJseShhc3NlbWJseSk7XG4gICAgY29uc3QgZmlsZVBhdGggPVxuICAgICAgcGFyZW50ID09PSByb290ID8gcGFja2FnZU5hbWUgOiBgJHtwYXJlbnQuZmlsZVBhdGh9LyR7cGFja2FnZU5hbWV9YDtcblxuICAgIHN1cGVyKFxuICAgICAgYXNzZW1ibHkudHlwZXMsXG4gICAgICBhc3NlbWJseS5zdWJtb2R1bGVzLFxuICAgICAgcGFja2FnZU5hbWUsXG4gICAgICBmaWxlUGF0aCxcbiAgICAgIHJvb3QubW9kdWxlTmFtZSxcbiAgICAgIHJvb3QudmVyc2lvbixcbiAgICAgIHJvb3QsXG4gICAgKTtcblxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB9XG59XG5cbi8qKlxuICogR28gcmVxdWlyZXMgdGhhdCB3aGVuIGEgbW9kdWxlIG1ham9yIHZlcnNpb24gaXMgdjIuMCBhbmQgYWJvdmUsIHRoZSBtb2R1bGVcbiAqIG5hbWUgd2lsbCBoYXZlIGEgYC92Tk5gIHN1ZmZpeCAod2hlcmUgYE5OYCBpcyB0aGUgbWFqb3IgdmVyc2lvbikuXG4gKlxuICogPiBTdGFydGluZyB3aXRoIG1ham9yIHZlcnNpb24gMiwgbW9kdWxlIHBhdGhzIG11c3QgaGF2ZSBhIG1ham9yIHZlcnNpb25cbiAqID4gc3VmZml4IGxpa2UgL3YyIHRoYXQgbWF0Y2hlcyB0aGUgbWFqb3IgdmVyc2lvbi4gRm9yIGV4YW1wbGUsIGlmIGEgbW9kdWxlXG4gKiA+IGhhcyB0aGUgcGF0aCBleGFtcGxlLmNvbS9tb2QgYXQgdjEuMC4wLCBpdCBtdXN0IGhhdmUgdGhlIHBhdGhcbiAqID4gZXhhbXBsZS5jb20vbW9kL3YyIGF0IHZlcnNpb24gdjIuMC4wLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9nb2xhbmcub3JnL3JlZi9tb2QjbWFqb3ItdmVyc2lvbi1zdWZmaXhlc1xuICogQHBhcmFtIHZlcnNpb24gVGhlIG1vZHVsZSB2ZXJzaW9uIChlLmcuIGAyLjMuMGApXG4gKiBAcmV0dXJucyBhIHN1ZmZpeCB0byBhcHBlbmQgdG8gdGhlIG1vZHVsZSBuYW1lIGluIHRoZSBmb3JtIChgL3ZOTmApLiBJZiB0aGVcbiAqIG1vZHVsZSB2ZXJzaW9uIGlzIGAwLnhgIG9yIGAxLnhgLCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lTWFqb3JWZXJzaW9uU3VmZml4KHZlcnNpb246IHN0cmluZykge1xuICBjb25zdCBzdiA9IHNlbXZlci5wYXJzZSh2ZXJzaW9uKTtcbiAgaWYgKCFzdikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBVbmFibGUgdG8gcGFyc2UgdmVyc2lvbiBcIiR7dmVyc2lvbn1cIiBhcyBhIHNlbWFudGljIHZlcnNpb25gLFxuICAgICk7XG4gIH1cblxuICAvLyBzdWZmaXggaXMgb25seSBuZWVkZWQgZm9yIDIuMCBhbmQgYWJvdmVcbiAgaWYgKHN2Lm1ham9yIDw9IDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gYC92JHtzdi5tYWpvcn1gO1xufVxuXG5pbnRlcmZhY2UgSW1wb3J0ZWRNb2R1bGUge1xuICByZWFkb25seSBhbGlhcz86IHN0cmluZztcbiAgcmVhZG9ubHkgbW9kdWxlOiBzdHJpbmc7XG59XG5cbmNvbnN0IEpTSUlfUlRfTU9EVUxFOiBJbXBvcnRlZE1vZHVsZSA9IHtcbiAgYWxpYXM6IEpTSUlfUlRfQUxJQVMsXG4gIG1vZHVsZTogSlNJSV9SVF9QQUNLQUdFX05BTUUsXG59O1xuY29uc3QgR09fUkVGTEVDVDogSW1wb3J0ZWRNb2R1bGUgPSB7IG1vZHVsZTogJ3JlZmxlY3QnIH07XG5cbmZ1bmN0aW9uIGltcG9ydEdvTW9kdWxlcyhjb2RlOiBDb2RlTWFrZXIsIG1vZHVsZXM6IHJlYWRvbmx5IEltcG9ydGVkTW9kdWxlW10pIHtcbiAgaWYgKG1vZHVsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgYWxpYXNTaXplID0gTWF0aC5tYXgoLi4ubW9kdWxlcy5tYXAoKG1vZCkgPT4gbW9kLmFsaWFzPy5sZW5ndGggPz8gMCkpO1xuICBjb2RlLm9wZW4oJ2ltcG9ydCAoJyk7XG4gIGNvbnN0IHNvcnRlZE1vZHVsZXMgPSBBcnJheS5mcm9tKG1vZHVsZXMpLnNvcnQoY29tcGFyZUltcG9ydGVkTW9kdWxlcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc29ydGVkTW9kdWxlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1vZCA9IHNvcnRlZE1vZHVsZXNbaV07XG4gICAgLy8gU2VwYXJhdGUgbW9kdWxlIGNhdGVnb3JpZXMgZnJvbSBlYWNoIG90aGVyIG1vZHVsZXMgd2l0aCBhIGJsYW5rIGxpbmUuXG4gICAgaWYgKFxuICAgICAgaSA+IDAgJiZcbiAgICAgIChpc0J1aWx0SW4obW9kKSAhPT0gaXNCdWlsdEluKHNvcnRlZE1vZHVsZXNbaSAtIDFdKSB8fFxuICAgICAgICBpc1NwZWNpYWwobW9kKSAhPT0gaXNTcGVjaWFsKHNvcnRlZE1vZHVsZXNbaSAtIDFdKSlcbiAgICApIHtcbiAgICAgIGNvZGUubGluZSgpO1xuICAgIH1cbiAgICBpZiAobW9kLmFsaWFzKSB7XG4gICAgICBjb2RlLmxpbmUoYCR7bW9kLmFsaWFzLnBhZEVuZChhbGlhc1NpemUsICcgJyl9IFwiJHttb2QubW9kdWxlfVwiYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUubGluZShgXCIke21vZC5tb2R1bGV9XCJgKTtcbiAgICB9XG4gIH1cbiAgY29kZS5jbG9zZSgnKScpO1xuXG4gIC8qKlxuICAgKiBBIGNvbXBhcmF0b3IgZm9yIGBJbXBvcnRlZE1vZHVsZWAgaW5zdGFuY2VzIHN1Y2ggdGhhdCBidWlsdC1pbiBtb2R1bGVzXG4gICAqIGFsd2F5cyBhcHBlYXIgZmlyc3QsIGZvbGxvd2VkIGJ5IHRoZSByZXN0LiBUaGVuIHdpdGhpbiB0aGVzZSB0d28gZ3JvdXBzLFxuICAgKiBhbGlhc2VkIGltcG9ydHMgYXBwZWFyIGZpcnN0LCBmb2xsb3dlZCBieSB0aGUgcmVzdC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVJbXBvcnRlZE1vZHVsZXMoXG4gICAgbDogSW1wb3J0ZWRNb2R1bGUsXG4gICAgcjogSW1wb3J0ZWRNb2R1bGUsXG4gICk6IG51bWJlciB7XG4gICAgY29uc3QgbEJ1aWx0SW4gPSBpc0J1aWx0SW4obCk7XG4gICAgY29uc3QgckJ1aWx0SW4gPSBpc0J1aWx0SW4ocik7XG4gICAgaWYgKGxCdWlsdEluICYmICFyQnVpbHRJbikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoIWxCdWlsdEluICYmIHJCdWlsdEluKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBjb25zdCBsU3BlY2lhbCA9IGlzU3BlY2lhbChsKTtcbiAgICBjb25zdCByU3BlY2lhbCA9IGlzU3BlY2lhbChyKTtcbiAgICBpZiAobFNwZWNpYWwgJiYgIXJTcGVjaWFsKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmICghbFNwZWNpYWwgJiYgclNwZWNpYWwpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiBsLm1vZHVsZS5sb2NhbGVDb21wYXJlKHIubW9kdWxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQnVpbHRJbihtb2Q6IEltcG9ydGVkTW9kdWxlKTogYm9vbGVhbiB7XG4gICAgLy8gU3RhbmRhcmQgbGlicmFyeSBtb2R1bGVzIGRvbid0IGhhdmUgYW55IFwiLlwiIGluIHRoZWlyIHBhdGgsIHdoZXJlYXMgYW55XG4gICAgLy8gb3RoZXIgbW9kdWxlIGhhcyBhIEROUyBwb3J0aW9uIGluIHRoZW0sIHdoaWNoIG11c3QgaW5jbHVkZSBhIFwiLlwiLlxuICAgIHJldHVybiAhbW9kLm1vZHVsZS5pbmNsdWRlcygnLicpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTcGVjaWFsKG1vZDogSW1wb3J0ZWRNb2R1bGUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gbW9kLmFsaWFzID09PSBKU0lJX1JUX0FMSUFTIHx8IG1vZC5hbGlhcyA9PT0gSlNJSV9JTklUX0FMSUFTO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBlbWJlZGRlZCBHbyB0eXBlLlxuICovXG5pbnRlcmZhY2UgRW1iZWRkZWRUeXBlIHtcbiAgLyoqXG4gICAqIFRoZSBmaWVsZCBuYW1lIGZvciB0aGUgZW1iZWRkZWQgdHlwZS5cbiAgICovXG4gIHJlYWRvbmx5IGZpZWxkTmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZW1iZWRkZWQgdHlwZSBuYW1lIHRvIHVzZS4gQ291bGQgYmUgZWl0aGVyIGEgc3RydWN0IHByb3h5IChpZiB0aGUgYmFzZVxuICAgKiB0eXBlIGlzIGluIHRoZSBzYW1lIHBhY2thZ2UpIG9yIGFuIGludGVybmFsIGFsaWFzIGZvciBhIGZvcmllZ24gdHlwZSBuYW1lLlxuICAgKi9cbiAgcmVhZG9ubHkgZW1iZWQ6IHN0cmluZztcblxuICAvKipcbiAgICogUmVmZXJuY2UgdG8gdGhlIGZvcmVpZ24gdHlwZSAoaWYgdGhpcyBpcyBhIGZvcmllZ24gdHlwZSlcbiAgICovXG4gIHJlYWRvbmx5IGZvcmllZ25UeXBlPzogR29UeXBlUmVmO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZm9yaWVnbiB0eXBlLlxuICAgKi9cbiAgcmVhZG9ubHkgZm9yaWVnblR5cGVOYW1lPzogc3RyaW5nO1xufVxuIl19