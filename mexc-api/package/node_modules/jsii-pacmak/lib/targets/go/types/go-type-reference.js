"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GoTypeRef = void 0;
const log = require("../../../logging");
/*
 * Maps names of JS primitives to corresponding Go types as strings
 */
class PrimitiveMapper {
    constructor(name) {
        this.name = name;
        this.MAP = {
            number: 'float64',
            boolean: 'bool',
            any: 'interface{}',
            date: 'time.Time',
            string: 'string',
            json: `map[string]interface{}`,
        };
    }
    get goPrimitive() {
        const val = this.MAP[this.name];
        if (!val) {
            log.debug(`Unmapped primitive type: ${this.name}`);
        }
        return val !== null && val !== void 0 ? val : this.name;
    }
}
/*
 * Accepts a JSII TypeReference and Go Package and can resolve the GoType within the module tree.
 */
class GoTypeRef {
    constructor(root, reference) {
        this.root = root;
        this.reference = reference;
    }
    get type() {
        if (this.reference.fqn) {
            return this.root.findType(this.reference.fqn);
        }
        return undefined;
    }
    get specialDependencies() {
        return {
            runtime: false,
            init: false,
            internal: false,
            time: containsDate(this.reference),
        };
        function containsDate(ref) {
            if (ref.primitive === 'date') {
                return true;
            }
            if (ref.arrayOfType) {
                return containsDate(ref.arrayOfType);
            }
            if (ref.mapOfType) {
                return containsDate(ref.mapOfType);
            }
            if (ref.unionOfTypes) {
                return ref.unionOfTypes.some(containsDate);
            }
            return false;
        }
    }
    get primitiveType() {
        if (this.reference.primitive) {
            return new PrimitiveMapper(this.reference.primitive).goPrimitive;
        }
        return undefined;
    }
    get name() {
        var _a;
        return (_a = this.type) === null || _a === void 0 ? void 0 : _a.name;
    }
    get datatype() {
        var _a;
        const reflectType = (_a = this.type) === null || _a === void 0 ? void 0 : _a.type;
        return (reflectType === null || reflectType === void 0 ? void 0 : reflectType.isInterfaceType()) && reflectType.datatype;
    }
    get namespace() {
        var _a;
        return (_a = this.type) === null || _a === void 0 ? void 0 : _a.namespace;
    }
    get void() {
        return this.reference.void;
    }
    get typeMap() {
        if (!this._typeMap) {
            this._typeMap = this.buildTypeMap(this);
        }
        return this._typeMap;
    }
    /**
     * The go `import`s required in order to be able to use this type in code.
     */
    get dependencies() {
        var _a, _b, _c, _d;
        const ret = new Array();
        switch (this.typeMap.type) {
            case 'interface':
                if ((_a = this.type) === null || _a === void 0 ? void 0 : _a.pkg) {
                    ret.push((_b = this.type) === null || _b === void 0 ? void 0 : _b.pkg);
                }
                break;
            case 'array':
            case 'map':
                ret.push(...((_c = this.typeMap.value.dependencies) !== null && _c !== void 0 ? _c : []));
                break;
            case 'union':
                for (const t of this.typeMap.value) {
                    ret.push(...((_d = t.dependencies) !== null && _d !== void 0 ? _d : []));
                }
                break;
            case 'void':
            case 'primitive':
                break;
        }
        return ret;
    }
    /*
     * Return the name of a type for reference from the `Package` passed in
     */
    scopedName(scope) {
        return this.scopedTypeName(this.typeMap, scope);
    }
    scopedReference(scope) {
        return this.scopedTypeName(this.typeMap, scope, true);
    }
    buildTypeMap(ref) {
        if (ref.primitiveType) {
            return { type: 'primitive', value: ref.primitiveType };
        }
        else if (ref.reference.arrayOfType) {
            return {
                type: 'array',
                value: new GoTypeRef(this.root, ref.reference.arrayOfType),
            };
        }
        else if (ref.reference.mapOfType) {
            return {
                type: 'map',
                value: new GoTypeRef(this.root, ref.reference.mapOfType),
            };
        }
        else if (ref.reference.unionOfTypes) {
            return {
                type: 'union',
                value: ref.reference.unionOfTypes.map((typeRef) => new GoTypeRef(this.root, typeRef)),
            };
        }
        else if (ref.reference.void) {
            return { type: 'void' };
        }
        return { type: 'interface', value: ref };
    }
    scopedTypeName(typeMap, scope, asRef = false) {
        var _a, _b;
        if (typeMap.type === 'primitive') {
            const { value } = typeMap;
            const prefix = asRef && value !== 'interface{}' ? '*' : '';
            return `${prefix}${value}`;
        }
        else if (typeMap.type === 'array' || typeMap.type === 'map') {
            const prefix = asRef ? '*' : '';
            const wrapper = typeMap.type === 'array' ? '[]' : 'map[string]';
            const innerName = (_a = this.scopedTypeName(typeMap.value.typeMap, scope, asRef)) !== null && _a !== void 0 ? _a : 'interface{}';
            return `${prefix}${wrapper}${innerName}`;
        }
        else if (typeMap.type === 'interface') {
            const prefix = asRef && typeMap.value.datatype ? '*' : '';
            const baseName = typeMap.value.name;
            // type is defined in the same scope as the current one, no namespace required
            if (scope.packageName === typeMap.value.namespace && baseName) {
                // if the current scope is the same as the types scope, return without a namespace
                return `${prefix}${baseName}`;
            }
            // type is defined in another module and requires a namespace and import
            if (baseName) {
                return `${prefix}${typeMap.value.namespace}.${baseName}`;
            }
        }
        else if (typeMap.type === 'union') {
            return 'interface{}';
        }
        else if (typeMap.type === 'void') {
            return '';
        }
        // type isn't handled
        throw new Error(`Type ${(_b = typeMap.value) === null || _b === void 0 ? void 0 : _b.name} does not resolve to a known Go type.`);
    }
}
exports.GoTypeRef = GoTypeRef;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ28tdHlwZS1yZWZlcmVuY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJnby10eXBlLXJlZmVyZW5jZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFFQSx3Q0FBd0M7QUFLeEM7O0dBRUc7QUFDSCxNQUFNLGVBQWU7SUFVbkIsWUFBb0MsSUFBWTtRQUFaLFNBQUksR0FBSixJQUFJLENBQVE7UUFUL0IsUUFBRyxHQUE4QjtZQUNoRCxNQUFNLEVBQUUsU0FBUztZQUNqQixPQUFPLEVBQUUsTUFBTTtZQUNmLEdBQUcsRUFBRSxhQUFhO1lBQ2xCLElBQUksRUFBRSxXQUFXO1lBQ2pCLE1BQU0sRUFBRSxRQUFRO1lBQ2hCLElBQUksRUFBRSx3QkFBd0I7U0FDL0IsQ0FBQztJQUVpRCxDQUFDO0lBRXBELElBQVcsV0FBVztRQUNwQixNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNoQyxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ1IsR0FBRyxDQUFDLEtBQUssQ0FBQyw0QkFBNEIsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7U0FDcEQ7UUFFRCxPQUFPLEdBQUcsYUFBSCxHQUFHLGNBQUgsR0FBRyxHQUFJLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDMUIsQ0FBQztDQUNGO0FBY0Q7O0dBRUc7QUFDSCxNQUFhLFNBQVM7SUFFcEIsWUFDa0IsSUFBYSxFQUNiLFNBQXdCO1FBRHhCLFNBQUksR0FBSixJQUFJLENBQVM7UUFDYixjQUFTLEdBQVQsU0FBUyxDQUFlO0lBQ3ZDLENBQUM7SUFFSixJQUFXLElBQUk7UUFDYixJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFO1lBQ3RCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUMvQztRQUVELE9BQU8sU0FBUyxDQUFDO0lBQ25CLENB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LE9BQU8sQ0FBQyxJQUFJLEtBQUssV0FBVyxFQUFFO1lBQ3ZDLE1BQU0sTUFBTSxHQUFHLEtBQUssSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDMUQsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUM7WUFDcEMsOEVBQThFO1lBQzlFLElBQUksS0FBSyxDQUFDLFdBQVcsS0FBSyxPQUFPLENBQUMsS0FBSyxDQUFDLFNBQVMsSUFBSSxRQUFRLEVBQUU7Z0JBQzdELGtGQUFrRjtnQkFDbEYsT0FBTyxHQUFHLE1BQU0sR0FBRyxRQUFRLEVBQUUsQ0FBQzthQUMvQjtZQUVELHdFQUF3RTtZQUN4RSxJQUFJLFFBQVEsRUFBRTtnQkFDWixPQUFPLEdBQUcsTUFBTSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsU0FBUyxJQUFJLFFBQVEsRUFBRSxDQUFDO2FBQzFEO1NBQ0Y7YUFBTSxJQUFJLE9BQU8sQ0FBQyxJQUFJLEtBQUssT0FBTyxFQUFFO1lBQ25DLE9BQU8sYUFBYSxDQUFDO1NBQ3RCO2FBQU0sSUFBSSxPQUFPLENBQUMsSUFBSSxLQUFLLE1BQU0sRUFBRTtZQUNsQyxPQUFPLEVBQUUsQ0FBQztTQUNYO1FBRUQscUJBQXFCO1FBQ3JCLE1BQU0sSUFBSSxLQUFLLENBQ2IsUUFBUSxNQUFBLE9BQU8sQ0FBQyxLQUFLLDBDQUFFLElBQUksdUNBQXVDLENBQ25FLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUF0TEQsOEJBc0xDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHlwZVJlZmVyZW5jZSB9IGZyb20gJ2pzaWktcmVmbGVjdCc7XG5cbmltcG9ydCAqIGFzIGxvZyBmcm9tICcuLi8uLi8uLi9sb2dnaW5nJztcbmltcG9ydCB7IFNwZWNpYWxEZXBlbmRlbmNpZXMgfSBmcm9tICcuLi9kZXBlbmRlbmNpZXMnO1xuaW1wb3J0IHsgUGFja2FnZSB9IGZyb20gJy4uL3BhY2thZ2UnO1xuaW1wb3J0IHsgR29UeXBlIH0gZnJvbSAnLi9nby10eXBlJztcblxuLypcbiAqIE1hcHMgbmFtZXMgb2YgSlMgcHJpbWl0aXZlcyB0byBjb3JyZXNwb25kaW5nIEdvIHR5cGVzIGFzIHN0cmluZ3NcbiAqL1xuY2xhc3MgUHJpbWl0aXZlTWFwcGVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBNQVA6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICAgbnVtYmVyOiAnZmxvYXQ2NCcsXG4gICAgYm9vbGVhbjogJ2Jvb2wnLFxuICAgIGFueTogJ2ludGVyZmFjZXt9JyxcbiAgICBkYXRlOiAndGltZS5UaW1lJyxcbiAgICBzdHJpbmc6ICdzdHJpbmcnLFxuICAgIGpzb246IGBtYXBbc3RyaW5nXWludGVyZmFjZXt9YCxcbiAgfTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBuYW1lOiBzdHJpbmcpIHt9XG5cbiAgcHVibGljIGdldCBnb1ByaW1pdGl2ZSgpOiBzdHJpbmcge1xuICAgIGNvbnN0IHZhbCA9IHRoaXMuTUFQW3RoaXMubmFtZV07XG4gICAgaWYgKCF2YWwpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgVW5tYXBwZWQgcHJpbWl0aXZlIHR5cGU6ICR7dGhpcy5uYW1lfWApO1xuICAgIH1cblxuICAgIHJldHVybiB2YWwgPz8gdGhpcy5uYW1lO1xuICB9XG59XG5cbi8qKlxuICogVHlwZU1hcCB1c2VkIHRvIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaW50ZXJmYWNlcyBpbiBuZXN0ZWQgdHlwZXMgZm9yIHVzZSBpblxuICogcmVzb2x2aW5nIHNjb3BlZCB0eXBlIG5hbWVzIGFuZCBpbXBsZW1lbnRhdGlvbiBtYXBzLlxuICovXG50eXBlIFR5cGVNYXAgPVxuICB8IHsgcmVhZG9ubHkgdHlwZTogJ3ByaW1pdGl2ZSc7IHJlYWRvbmx5IHZhbHVlOiBzdHJpbmcgfVxuICB8IHsgcmVhZG9ubHkgdHlwZTogJ2FycmF5JzsgcmVhZG9ubHkgdmFsdWU6IEdvVHlwZVJlZiB9XG4gIHwgeyByZWFkb25seSB0eXBlOiAnbWFwJzsgcmVhZG9ubHkgdmFsdWU6IEdvVHlwZVJlZiB9XG4gIHwgeyByZWFkb25seSB0eXBlOiAndW5pb24nOyByZWFkb25seSB2YWx1ZTogcmVhZG9ubHkgR29UeXBlUmVmW10gfVxuICB8IHsgcmVhZG9ubHkgdHlwZTogJ2ludGVyZmFjZSc7IHJlYWRvbmx5IHZhbHVlOiBHb1R5cGVSZWYgfVxuICB8IHsgcmVhZG9ubHkgdHlwZTogJ3ZvaWQnIH07XG5cbi8qXG4gKiBBY2NlcHRzIGEgSlNJSSBUeXBlUmVmZXJlbmNlIGFuZCBHbyBQYWNrYWdlIGFuZCBjYW4gcmVzb2x2ZSB0aGUgR29UeXBlIHdpdGhpbiB0aGUgbW9kdWxlIHRyZWUuXG4gKi9cbmV4cG9ydCBjbGFzcyBHb1R5cGVSZWYge1xuICBwcml2YXRlIF90eXBlTWFwPzogVHlwZU1hcDtcbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSByb290OiBQYWNrYWdlLFxuICAgIHB1YmxpYyByZWFkb25seSByZWZlcmVuY2U6IFR5cGVSZWZlcmVuY2UsXG4gICkge31cblxuICBwdWJsaWMgZ2V0IHR5cGUoKTogR29UeXBlIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAodGhpcy5yZWZlcmVuY2UuZnFuKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb290LmZpbmRUeXBlKHRoaXMucmVmZXJlbmNlLmZxbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc3BlY2lhbERlcGVuZGVuY2llcygpOiBTcGVjaWFsRGVwZW5kZW5jaWVzIHtcbiAgICByZXR1cm4ge1xuICAgICAgcnVudGltZTogZmFsc2UsXG4gICAgICBpbml0OiBmYWxzZSxcbiAgICAgIGludGVybmFsOiBmYWxzZSxcbiAgICAgIHRpbWU6IGNvbnRhaW5zRGF0ZSh0aGlzLnJlZmVyZW5jZSksXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zRGF0ZShyZWY6IFR5cGVSZWZlcmVuY2UpOiBib29sZWFuIHtcbiAgICAgIGlmIChyZWYucHJpbWl0aXZlID09PSAnZGF0ZScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocmVmLmFycmF5T2ZUeXBlKSB7XG4gICAgICAgIHJldHVybiBjb250YWluc0RhdGUocmVmLmFycmF5T2ZUeXBlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWYubWFwT2ZUeXBlKSB7XG4gICAgICAgIHJldHVybiBjb250YWluc0RhdGUocmVmLm1hcE9mVHlwZSk7XG4gICAgICB9XG4gICAgICBpZiAocmVmLnVuaW9uT2ZUeXBlcykge1xuICAgICAgICByZXR1cm4gcmVmLnVuaW9uT2ZUeXBlcy5zb21lKGNvbnRhaW5zRGF0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldCBwcmltaXRpdmVUeXBlKCkge1xuICAgIGlmICh0aGlzLnJlZmVyZW5jZS5wcmltaXRpdmUpIHtcbiAgICAgIHJldHVybiBuZXcgUHJpbWl0aXZlTWFwcGVyKHRoaXMucmVmZXJlbmNlLnByaW1pdGl2ZSkuZ29QcmltaXRpdmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlPy5uYW1lO1xuICB9XG5cbiAgcHVibGljIGdldCBkYXRhdHlwZSgpIHtcbiAgICBjb25zdCByZWZsZWN0VHlwZSA9IHRoaXMudHlwZT8udHlwZTtcbiAgICByZXR1cm4gcmVmbGVjdFR5cGU/LmlzSW50ZXJmYWNlVHlwZSgpICYmIHJlZmxlY3RUeXBlLmRhdGF0eXBlO1xuICB9XG5cbiAgcHVibGljIGdldCBuYW1lc3BhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZT8ubmFtZXNwYWNlO1xuICB9XG5cbiAgcHVibGljIGdldCB2b2lkKCkge1xuICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZS52b2lkO1xuICB9XG5cbiAgcHVibGljIGdldCB0eXBlTWFwKCk6IFR5cGVNYXAge1xuICAgIGlmICghdGhpcy5fdHlwZU1hcCkge1xuICAgICAgdGhpcy5fdHlwZU1hcCA9IHRoaXMuYnVpbGRUeXBlTWFwKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdHlwZU1hcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZ28gYGltcG9ydGBzIHJlcXVpcmVkIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gdXNlIHRoaXMgdHlwZSBpbiBjb2RlLlxuICAgKi9cbiAgcHVibGljIGdldCBkZXBlbmRlbmNpZXMoKTogcmVhZG9ubHkgUGFja2FnZVtdIHtcbiAgICBjb25zdCByZXQgPSBuZXcgQXJyYXk8UGFja2FnZT4oKTtcblxuICAgIHN3aXRjaCAodGhpcy50eXBlTWFwLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2ludGVyZmFjZSc6XG4gICAgICAgIGlmICh0aGlzLnR5cGU/LnBrZykge1xuICAgICAgICAgIHJldC5wdXNoKHRoaXMudHlwZT8ucGtnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnbWFwJzpcbiAgICAgICAgcmV0LnB1c2goLi4uKHRoaXMudHlwZU1hcC52YWx1ZS5kZXBlbmRlbmNpZXMgPz8gW10pKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3VuaW9uJzpcbiAgICAgICAgZm9yIChjb25zdCB0IG9mIHRoaXMudHlwZU1hcC52YWx1ZSkge1xuICAgICAgICAgIHJldC5wdXNoKC4uLih0LmRlcGVuZGVuY2llcyA/PyBbXSkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd2b2lkJzpcbiAgICAgIGNhc2UgJ3ByaW1pdGl2ZSc6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvKlxuICAgKiBSZXR1cm4gdGhlIG5hbWUgb2YgYSB0eXBlIGZvciByZWZlcmVuY2UgZnJvbSB0aGUgYFBhY2thZ2VgIHBhc3NlZCBpblxuICAgKi9cbiAgcHVibGljIHNjb3BlZE5hbWUoc2NvcGU6IFBhY2thZ2UpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnNjb3BlZFR5cGVOYW1lKHRoaXMudHlwZU1hcCwgc2NvcGUpO1xuICB9XG5cbiAgcHVibGljIHNjb3BlZFJlZmVyZW5jZShzY29wZTogUGFja2FnZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc2NvcGVkVHlwZU5hbWUodGhpcy50eXBlTWFwLCBzY29wZSwgdHJ1ZSk7XG4gIH1cblxuICBwcml2YXRlIGJ1aWxkVHlwZU1hcChyZWY6IEdvVHlwZVJlZik6IFR5cGVNYXAge1xuICAgIGlmIChyZWYucHJpbWl0aXZlVHlwZSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogJ3ByaW1pdGl2ZScsIHZhbHVlOiByZWYucHJpbWl0aXZlVHlwZSB9O1xuICAgIH0gZWxzZSBpZiAocmVmLnJlZmVyZW5jZS5hcnJheU9mVHlwZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgdmFsdWU6IG5ldyBHb1R5cGVSZWYodGhpcy5yb290LCByZWYucmVmZXJlbmNlLmFycmF5T2ZUeXBlKSxcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChyZWYucmVmZXJlbmNlLm1hcE9mVHlwZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ21hcCcsXG4gICAgICAgIHZhbHVlOiBuZXcgR29UeXBlUmVmKHRoaXMucm9vdCwgcmVmLnJlZmVyZW5jZS5tYXBPZlR5cGUpLFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHJlZi5yZWZlcmVuY2UudW5pb25PZlR5cGVzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAndW5pb24nLFxuICAgICAgICB2YWx1ZTogcmVmLnJlZmVyZW5jZS51bmlvbk9mVHlwZXMubWFwKFxuICAgICAgICAgICh0eXBlUmVmKSA9PiBuZXcgR29UeXBlUmVmKHRoaXMucm9vdCwgdHlwZVJlZiksXG4gICAgICAgICksXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocmVmLnJlZmVyZW5jZS52b2lkKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiAndm9pZCcgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB0eXBlOiAnaW50ZXJmYWNlJywgdmFsdWU6IHJlZiB9O1xuICB9XG5cbiAgcHVibGljIHNjb3BlZFR5cGVOYW1lKFxuICAgIHR5cGVNYXA6IFR5cGVNYXAsXG4gICAgc2NvcGU6IFBhY2thZ2UsXG4gICAgYXNSZWYgPSBmYWxzZSxcbiAgKTogc3RyaW5nIHtcbiAgICBpZiAodHlwZU1hcC50eXBlID09PSAncHJpbWl0aXZlJykge1xuICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gdHlwZU1hcDtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGFzUmVmICYmIHZhbHVlICE9PSAnaW50ZXJmYWNle30nID8gJyonIDogJyc7XG4gICAgICByZXR1cm4gYCR7cHJlZml4fSR7dmFsdWV9YDtcbiAgICB9IGVsc2UgaWYgKHR5cGVNYXAudHlwZSA9PT0gJ2FycmF5JyB8fCB0eXBlTWFwLnR5cGUgPT09ICdtYXAnKSB7XG4gICAgICBjb25zdCBwcmVmaXggPSBhc1JlZiA/ICcqJyA6ICcnO1xuICAgICAgY29uc3Qgd3JhcHBlciA9IHR5cGVNYXAudHlwZSA9PT0gJ2FycmF5JyA/ICdbXScgOiAnbWFwW3N0cmluZ10nO1xuICAgICAgY29uc3QgaW5uZXJOYW1lID1cbiAgICAgICAgdGhpcy5zY29wZWRUeXBlTmFtZSh0eXBlTWFwLnZhbHVlLnR5cGVNYXAsIHNjb3BlLCBhc1JlZikgPz9cbiAgICAgICAgJ2ludGVyZmFjZXt9JztcbiAgICAgIHJldHVybiBgJHtwcmVmaXh9JHt3cmFwcGVyfSR7aW5uZXJOYW1lfWA7XG4gICAgfSBlbHNlIGlmICh0eXBlTWFwLnR5cGUgPT09ICdpbnRlcmZhY2UnKSB7XG4gICAgICBjb25zdCBwcmVmaXggPSBhc1JlZiAmJiB0eXBlTWFwLnZhbHVlLmRhdGF0eXBlID8gJyonIDogJyc7XG4gICAgICBjb25zdCBiYXNlTmFtZSA9IHR5cGVNYXAudmFsdWUubmFtZTtcbiAgICAgIC8vIHR5cGUgaXMgZGVmaW5lZCBpbiB0aGUgc2FtZSBzY29wZSBhcyB0aGUgY3VycmVudCBvbmUsIG5vIG5hbWVzcGFjZSByZXF1aXJlZFxuICAgICAgaWYgKHNjb3BlLnBhY2thZ2VOYW1lID09PSB0eXBlTWFwLnZhbHVlLm5hbWVzcGFjZSAmJiBiYXNlTmFtZSkge1xuICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBzY29wZSBpcyB0aGUgc2FtZSBhcyB0aGUgdHlwZXMgc2NvcGUsIHJldHVybiB3aXRob3V0IGEgbmFtZXNwYWNlXG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9JHtiYXNlTmFtZX1gO1xuICAgICAgfVxuXG4gICAgICAvLyB0eXBlIGlzIGRlZmluZWQgaW4gYW5vdGhlciBtb2R1bGUgYW5kIHJlcXVpcmVzIGEgbmFtZXNwYWNlIGFuZCBpbXBvcnRcbiAgICAgIGlmIChiYXNlTmFtZSkge1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fSR7dHlwZU1hcC52YWx1ZS5uYW1lc3BhY2V9LiR7YmFzZU5hbWV9YDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVNYXAudHlwZSA9PT0gJ3VuaW9uJykge1xuICAgICAgcmV0dXJuICdpbnRlcmZhY2V7fSc7XG4gICAgfSBlbHNlIGlmICh0eXBlTWFwLnR5cGUgPT09ICd2b2lkJykge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHR5cGUgaXNuJ3QgaGFuZGxlZFxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBUeXBlICR7dHlwZU1hcC52YWx1ZT8ubmFtZX0gZG9lcyBub3QgcmVzb2x2ZSB0byBhIGtub3duIEdvIHR5cGUuYCxcbiAgICApO1xuICB9XG59XG4iXX0=