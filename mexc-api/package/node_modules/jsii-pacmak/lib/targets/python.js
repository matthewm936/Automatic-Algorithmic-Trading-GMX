"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const spec = require("@jsii/spec");
const assert = require("assert");
const codemaker_1 = require("codemaker");
const escapeStringRegexp = require("escape-string-regexp");
const fs = require("fs-extra");
const jsii_rosetta_1 = require("jsii-rosetta");
const path = require("path");
const generator_1 = require("../generator");
const logging_1 = require("../logging");
const markdown_1 = require("../markdown");
const target_1 = require("../target");
const util_1 = require("../util");
const _utils_1 = require("./_utils");
const type_name_1 = require("./python/type-name");
const util_2 = require("./python/util");
const version_utils_1 = require("./version-utils");
const _1 = require(".");
// eslint-disable-next-line @typescript-eslint/no-var-requires,@typescript-eslint/no-require-imports
const spdxLicenseList = require('spdx-license-list');
const requirementsFile = path.resolve(__dirname, 'python', 'requirements-dev.txt');
// we use single-quotes for multi-line strings to allow examples within the
// docstrings themselves to include double-quotes (see https://github.com/aws/jsii/issues/2569)
const DOCSTRING_QUOTES = "'''";
class Python extends target_1.Target {
    constructor(options) {
        super(options);
        this.generator = new PythonGenerator(options.rosetta);
    }
    async generateCode(outDir, tarball) {
        await super.generateCode(outDir, tarball);
    }
    async build(sourceDir, outDir) {
        // Create a fresh virtual env
        const venv = await fs.mkdtemp(path.join(sourceDir, '.env-'));
        const venvBin = path.join(venv, process.platform === 'win32' ? 'Scripts' : 'bin');
        await util_1.shell('python3', [
            '-m',
            'venv',
            '--system-site-packages',
            venv,
        ]);
        const env = {
            ...process.env,
            PATH: `${venvBin}:${process.env.PATH}`,
            VIRTUAL_ENV: venv,
        };
        const python = path.join(venvBin, 'python');
        // Install the necessary things
        await util_1.shell(python, ['-m', 'pip', 'install', '--no-input', '-r', requirementsFile], {
            cwd: sourceDir,
            env,
            retry: { maxAttempts: 5 },
        });
        // Actually package up our code, both as a sdist and a wheel for publishing.
        await util_1.shell(python, ['setup.py', 'sdist', '--dist-dir', outDir], {
            cwd: sourceDir,
            env,
        });
        await util_1.shell(python, ['-m', 'pip', 'wheel', '--no-deps', '--wheel-dir', outDir, sourceDir], {
            cwd: sourceDir,
            env,
            retry: { maxAttempts: 5 },
        });
        await util_1.shell(python, ['-m', 'twine', 'check', path.join(outDir, '*')], {
            cwd: sourceDir,
            env,
        });
    }
}
exports.default = Python;
const pythonModuleNameToFilename = (name) => {
    return path.join(...name.split('.'));
};
const toPythonMethodName = (name, protectedItem = false) => {
    let value = util_2.toPythonIdentifier(codemaker_1.toSnakeCase(name));
    if (protectedItem) {
        value = `_${value}`;
    }
    return value;
};
const toPythonPropertyName = (name, constant = false, protectedItem = false) => {
    let value = util_2.toPythonIdentifier(codemaker_1.toSnakeCase(name));
    if (constant) {
        value = value.toUpperCase();
    }
    if (protectedItem) {
        value = `_${value}`;
    }
    return value;
};
/**
 * Converts a given signature's parameter name to what should be emitted in Python. It slugifies the
 * positional parameter names that collide with a lifted prop by appending trailing `_`. There is no
 * risk of conflicting with an other positional parameter that ends with a `_` character because
 * this is prohibited by the `jsii` compiler (parameter names MUST be camelCase, and only a single
 * `_` is permitted when it is on **leading** position)
 *
 * @param name              the name of the parameter that needs conversion.
 * @param liftedParamNames  the list of "lifted" keyword parameters in this signature. This must be
 *                          omitted when generating a name for a parameter that **is** lifted.
 */
function toPythonParameterName(name, liftedParamNames = new Set()) {
    let result = util_2.toPythonIdentifier(codemaker_1.toSnakeCase(name));
    while (liftedParamNames.has(result)) {
        result += '_';
    }
    return result;
}
const setDifference = (setA, setB) => {
    const result = new Set();
    for (const item of setA) {
        if (!setB.has(item)) {
            result.add(item);
        }
    }
    return result;
};
/**
 * Prepare python members for emission.
 *
 * If there are multiple members of the same name, they will all map to the same python
 * name, so we will filter all deprecated members and expect that there will be only one
 * left.
 *
 * Returns the members in a sorted list.
 */
function prepareMembers(members, resolver) {
    // create a map from python name to list of members
    const map = {};
    for (const m of members) {
        let list = map[m.pythonName];
        if (!list) {
            list = map[m.pythonName] = [];
        }
        list.push(m);
    }
    // now return all the members
    const ret = new Array();
    for (const [name, list] of Object.entries(map)) {
        let member;
        if (list.length === 1) {
            // if we have a single member for this normalized name, then use it
            member = list[0];
        }
        else {
            // we found more than one member with the same python name, filter all
            // deprecated versions and check that we are left with exactly one.
            // otherwise, they will overwrite each other
            // see https://github.com/aws/jsii/issues/2508
            const nonDeprecated = list.filter((x) => !isDeprecated(x));
            if (nonDeprecated.length > 1) {
                throw new Error(`Multiple non-deprecated members which map to the Python name "${name}"`);
            }
            if (nonDeprecated.length === 0) {
                throw new Error(`Multiple members which map to the Python name "${name}", but all of them are deprecated`);
            }
            member = nonDeprecated[0];
        }
        ret.push(member);
    }
    return sortMembers(ret, resolver);
}
const sortMembers = (members, resolver) => {
    let sortable = new Array();
    const sorted = new Array();
    const seen = new Set();
    // The first thing we want to do, is push any item which is not sortable to the very
    // front of the list. This will be things like methods, properties, etc.
    for (const member of members) {
        if (!isSortableType(member)) {
            sorted.push(member);
            seen.add(member);
        }
        else {
            sortable.push({ member, dependsOn: new Set(member.dependsOn(resolver)) });
        }
    }
    // Now that we've pulled out everything that couldn't possibly have dependencies,
    // we will go through the remaining items, and pull off any items which have no
    // dependencies that we haven't already sorted.
    while (sortable.length > 0) {
        for (const { member, dependsOn } of sortable) {
            const diff = setDifference(dependsOn, seen);
            if ([...diff].find((dep) => !(dep instanceof PythonModule)) == null) {
                sorted.push(member);
                seen.add(member);
            }
        }
        const leftover = sortable.filter(({ member }) => !seen.has(member));
        if (leftover.length === sortable.length) {
            throw new Error(`Could not sort members (circular dependency?). Leftover: ${leftover
                .map((lo) => lo.member.pythonName)
                .join(', ')}`);
        }
        else {
            sortable = leftover;
        }
    }
    return sorted;
};
function isSortableType(arg) {
    return arg.dependsOn !== undefined;
}
class BasePythonClassType {
    constructor(generator, pythonName, spec, fqn, opts, docs) {
        this.generator = generator;
        this.pythonName = pythonName;
        this.spec = spec;
        this.fqn = fqn;
        this.docs = docs;
        this.separateMembers = true;
        const { bases = [] } = opts;
        this.bases = bases;
        this.members = [];
    }
    dependsOn(resolver) {
        const dependencies = new Array();
        const parent = resolver.getParent(this.fqn);
        // We need to return any bases that are in the same module at the same level of
        // nesting.
        const seen = new Set();
        for (const base of this.bases) {
            if (spec.isNamedTypeReference(base)) {
                if (resolver.isInModule(base)) {
                    // Given a base, we need to locate the base's parent that is the same as
                    // our parent, because we only care about dependencies that are at the
                    // same level of our own.
                    // TODO: We might need to recurse into our members to also find their
                    //       dependencies.
                    let baseItem = resolver.getType(base);
                    let baseParent = resolver.getParent(base);
                    while (baseParent !== parent) {
                        baseItem = baseParent;
                        baseParent = resolver.getParent(baseItem.fqn);
                    }
                    if (!seen.has(baseItem.fqn)) {
                        dependencies.push(baseItem);
                        seen.add(baseItem.fqn);
                    }
                }
            }
        }
        return dependencies;
    }
    requiredImports(context) {
        return type_name_1.mergePythonImports(...this.bases.map((base) => type_name_1.toTypeName(base).requiredImports(context)), ...this.members.map((mem) => mem.requiredImports(context)));
    }
    addMember(member) {
        this.members.push(member);
    }
    get apiLocation() {
        if (!this.fqn) {
            throw new Error(`Cannot make apiLocation for ${this.pythonName}, does not have FQN`);
        }
        return { api: 'type', fqn: this.fqn };
    }
    emit(code, context) {
        context = nestedContext(context, this.fqn);
        const classParams = this.getClassParams(context);
        openSignature(code, 'class', this.pythonName, classParams);
        this.generator.emitDocString(code, this.apiLocation, this.docs, {
            documentableItem: `class-${this.pythonName}`,
            trailingNewLine: true,
        });
        if (this.members.length > 0) {
            const resolver = this.boundResolver(context.resolver);
            let shouldSeparate = false;
            for (const member of prepareMembers(this.members, resolver)) {
                if (shouldSeparate) {
                    code.line();
                }
                shouldSeparate = this.separateMembers;
                member.emit(code, { ...context, resolver });
            }
        }
        else {
            code.line('pass');
        }
        code.closeBlock();
        if (this.fqn != null) {
            context.emittedTypes.add(this.fqn);
        }
    }
    boundResolver(resolver) {
        if (this.fqn == null) {
            return resolver;
        }
        return resolver.bind(this.fqn);
    }
}
class BaseMethod {
    constructor(generator, pythonName, jsName, parameters, returns, docs, isStatic, opts) {
        this.generator = generator;
        this.pythonName = pythonName;
        this.jsName = jsName;
        this.parameters = parameters;
        this.returns = returns;
        this.docs = docs;
        this.isStatic = isStatic;
        this.classAsFirstParameter = false;
        this.returnFromJSIIMethod = true;
        this.shouldEmitBody = true;
        this.abstract = !!opts.abstract;
        this.liftedProp = opts.liftedProp;
        this.parent = opts.parent;
    }
    get apiLocation() {
        var _a;
        return {
            api: 'member',
            fqn: this.parent.fqn,
            memberName: (_a = this.jsName) !== null && _a !== void 0 ? _a : '',
        };
    }
    requiredImports(context) {
        return type_name_1.mergePythonImports(type_name_1.toTypeName(this.returns).requiredImports(context), ...this.parameters.map((param) => type_name_1.toTypeName(param).requiredImports(context)), ...liftedProperties(this.liftedProp));
        function* liftedProperties(struct) {
            var _a, _b;
            if (struct == null) {
                return;
            }
            for (const prop of (_a = struct.properties) !== null && _a !== void 0 ? _a : []) {
                yield type_name_1.toTypeName(prop.type).requiredImports(context);
            }
            for (const base of (_b = struct.interfaces) !== null && _b !== void 0 ? _b : []) {
                const iface = context.resolver.dereference(base);
                for (const imports of liftedProperties(iface)) {
                    yield imports;
                }
            }
        }
    }
    emit(code, context, opts) {
        var _a;
        const { renderAbstract = true, forceEmitBody = false } = opts !== null && opts !== void 0 ? opts : {};
        const returnType = type_name_1.toTypeName(this.returns).pythonType(context);
        // We cannot (currently?) blindly use the names given to us by the JSII for
        // initializers, because our keyword lifting will allow two names to clash.
        // This can hopefully be removed once we get https://github.com/aws/jsii/issues/288
        // resolved, so build up a list of all of the prop names so we can check against
        // them later.
        const liftedPropNames = new Set();
        if (((_a = this.liftedProp) === null || _a === void 0 ? void 0 : _a.properties) != null) {
            for (const prop of this.liftedProp.properties) {
                liftedPropNames.add(toPythonParameterName(prop.name));
            }
        }
        // We need to turn a list of JSII parameters, into Python style arguments with
        // gradual typing, so we'll have to iterate over the list of parameters, and
        // build the list, converting as we go.
        const pythonParams = [];
        for (const param of this.parameters) {
            // We cannot (currently?) blindly use the names given to us by the JSII for
            // initializers, because our keyword lifting will allow two names to clash.
            // This can hopefully be removed once we get https://github.com/aws/jsii/issues/288
            // resolved.
            const paramName = toPythonParameterName(param.name, liftedPropNames);
            const paramType = type_name_1.toTypeName(param).pythonType({
                ...context,
                parameterType: true,
            });
            const paramDefault = param.optional ? ' = None' : '';
            pythonParams.push(`${paramName}: ${paramType}${paramDefault}`);
        }
        const documentableArgs = this.parameters
            .map((p) => ({
            name: p.name,
            docs: p.docs,
            definingType: this.parent,
        }))
            // If there's liftedProps, the last argument is the struct and it won't be _actually_ emitted.
            .filter((_, index) => this.liftedProp != null ? index < this.parameters.length - 1 : true)
            .map((param) => ({
            ...param,
            name: toPythonParameterName(param.name, liftedPropNames),
        }));
        // If we have a lifted parameter, then we'll drop the last argument to our params
        // and then we'll lift all of the params of the lifted type as keyword arguments
        // to the function.
        if (this.liftedProp !== undefined) {
            // Remove our last item.
            pythonParams.pop();
            const liftedProperties = this.getLiftedProperties(context.resolver);
            if (liftedProperties.length >= 1) {
                // All of these parameters are keyword only arguments, so we'll mark them
                // as such.
                pythonParams.push('*');
                // Iterate over all of our props, and reflect them into our params.
                for (const prop of liftedProperties) {
                    const paramName = toPythonParameterName(prop.prop.name);
                    const paramType = type_name_1.toTypeName(prop.prop).pythonType({
                        ...context,
                        parameterType: true,
                    });
                    const paramDefault = prop.prop.optional ? ' = None' : '';
                    pythonParams.push(`${paramName}: ${paramType}${paramDefault}`);
                }
            }
            // Document them as keyword arguments
            documentableArgs.push(...liftedProperties.map((p) => ({
                name: p.prop.name,
                docs: p.prop.docs,
                definingType: p.definingType,
            })));
        }
        else if (this.parameters.length >= 1 &&
            this.parameters[this.parameters.length - 1].variadic) {
            // Another situation we could be in, is that instead of having a plain parameter
            // we have a variadic parameter where we need to expand the last parameter as a
            // *args.
            pythonParams.pop();
            const lastParameter = this.parameters.slice(-1)[0];
            const paramName = toPythonParameterName(lastParameter.name);
            const paramType = type_name_1.toTypeName(lastParameter.type).pythonType(context);
            pythonParams.push(`*${paramName}: ${paramType}`);
        }
        const decorators = new Array();
        if (this.jsName !== undefined) {
            // "# type: ignore[misc]" needed because mypy does not know how to check decorated declarations
            decorators.push(`@jsii.member(jsii_name="${this.jsName}")`);
        }
        if (this.decorator !== undefined) {
            decorators.push(`@${this.decorator}`);
        }
        if (renderAbstract && this.abstract) {
            decorators.push('@abc.abstractmethod');
        }
        if (decorators.length > 0) {
            // "# type: ignore[misc]" needed because mypy does not know how to check decorated declarations
            for (const decorator of decorators
                .join(' # type: ignore[misc]\n')
                .split('\n')) {
                code.line(decorator);
            }
        }
        pythonParams.unshift(slugifyAsNeeded(this.implicitParameter, pythonParams.map((param) => param.split(':')[0].trim())));
        openSignature(code, 'def', this.pythonName, pythonParams, false, returnType);
        this.generator.emitDocString(code, this.apiLocation, this.docs, {
            arguments: documentableArgs,
            documentableItem: `method-${this.pythonName}`,
        });
        this.emitBody(code, context, renderAbstract, forceEmitBody, liftedPropNames, pythonParams[0], returnType);
        code.closeBlock();
    }
    emitBody(code, context, renderAbstract, forceEmitBody, liftedPropNames, implicitParameter, returnType) {
        if ((!this.shouldEmitBody && !forceEmitBody) ||
            (renderAbstract && this.abstract)) {
            code.line('...');
        }
        else {
            if (this.liftedProp !== undefined) {
                this.emitAutoProps(code, context, liftedPropNames);
            }
            this.emitJsiiMethodCall(code, context, liftedPropNames, implicitParameter, returnType);
        }
    }
    emitAutoProps(code, context, liftedPropNames) {
        const lastParameter = this.parameters.slice(-1)[0];
        const argName = toPythonParameterName(lastParameter.name, liftedPropNames);
        const typeName = type_name_1.toTypeName(lastParameter.type).pythonType({
            ...context,
            typeAnnotation: false,
        });
        // We need to build up a list of properties, which are mandatory, these are the
        // ones we will specifiy to start with in our dictionary literal.
        const liftedProps = this.getLiftedProperties(context.resolver).map((p) => new StructField(this.generator, p.prop, p.definingType));
        const assignments = liftedProps
            .map((p) => p.pythonName)
            .map((v) => `${v}=${v}`);
        assignCallResult(code, argName, typeName, assignments);
        code.line();
    }
    emitJsiiMethodCall(code, context, liftedPropNames, implicitParameter, returnType) {
        const methodPrefix = this.returnFromJSIIMethod ? 'return ' : '';
        const jsiiMethodParams = [];
        if (this.classAsFirstParameter) {
            if (this.parent === undefined) {
                throw new Error('Parent not known.');
            }
            if (this.isStatic) {
                jsiiMethodParams.push(type_name_1.toTypeName(this.parent).pythonType({
                    ...context,
                    typeAnnotation: false,
                }));
            }
            else {
                // Using the dynamic class of `self`.
                jsiiMethodParams.push(`${implicitParameter}.__class__`);
            }
        }
        jsiiMethodParams.push(implicitParameter);
        if (this.jsName !== undefined) {
            jsiiMethodParams.push(`"${this.jsName}"`);
        }
        // If the last arg is variadic, expand the tuple
        const params = [];
        for (const param of this.parameters) {
            let expr = toPythonParameterName(param.name, liftedPropNames);
            if (param.variadic) {
                expr = `*${expr}`;
            }
            params.push(expr);
        }
        const value = `jsii.${this.jsiiMethod}(${jsiiMethodParams.join(', ')}, [${params.join(', ')}])`;
        code.line(`${methodPrefix}${this.returnFromJSIIMethod && returnType
            ? `typing.cast(${returnType}, ${value})`
            : value}`);
    }
    getLiftedProperties(resolver) {
        const liftedProperties = [];
        const stack = [this.liftedProp];
        const knownIfaces = new Set();
        const knownProps = new Set();
        for (let current = stack.shift(); current != null; current = stack.shift()) {
            knownIfaces.add(current.fqn);
            // Add any interfaces that this interface depends on, to the list.
            if (current.interfaces !== undefined) {
                for (const iface of current.interfaces) {
                    if (knownIfaces.has(iface)) {
                        continue;
                    }
                    stack.push(resolver.dereference(iface));
                    knownIfaces.add(iface);
                }
            }
            // Add all of the properties of this interface to our list of properties.
            if (current.properties !== undefined) {
                for (const prop of current.properties) {
                    if (knownProps.has(prop.name)) {
                        continue;
                    }
                    liftedProperties.push({ prop, definingType: current });
                    knownProps.add(prop.name);
                }
            }
        }
        return liftedProperties;
    }
}
class BaseProperty {
    constructor(generator, pythonName, jsName, type, docs, opts) {
        this.generator = generator;
        this.pythonName = pythonName;
        this.jsName = jsName;
        this.type = type;
        this.docs = docs;
        this.shouldEmitBody = true;
        const { abstract = false, immutable = false, isStatic = false } = opts;
        this.abstract = abstract;
        this.immutable = immutable;
        this.isStatic = isStatic;
        this.parent = opts.parent;
    }
    get apiLocation() {
        return { api: 'member', fqn: this.parent.fqn, memberName: this.jsName };
    }
    requiredImports(context) {
        return type_name_1.toTypeName(this.type).requiredImports(context);
    }
    emit(code, context, opts) {
        const { renderAbstract = true, forceEmitBody = false } = opts !== null && opts !== void 0 ? opts : {};
        const pythonType = type_name_1.toTypeName(this.type).pythonType(context);
        // "# type: ignore[misc]" is needed because mypy cannot check decorated things
        code.line(`@${this.decorator} # type: ignore[misc]`);
        code.line(`@jsii.member(jsii_name="${this.jsName}")`);
        if (renderAbstract && this.abstract) {
            code.line('@abc.abstractmethod');
        }
        openSignature(code, 'def', this.pythonName, [this.implicitParameter], true, pythonType);
        this.generator.emitDocString(code, this.apiLocation, this.docs, {
            documentableItem: `prop-${this.pythonName}`,
        });
        if ((this.shouldEmitBody || forceEmitBody) &&
            (!renderAbstract || !this.abstract)) {
            code.line(`return typing.cast(${pythonType}, jsii.${this.jsiiGetMethod}(${this.implicitParameter}, "${this.jsName}"))`);
        }
        else {
            code.line('...');
        }
        code.closeBlock();
        if (!this.immutable) {
            code.line();
            code.line(`@${this.pythonName}.setter${this.isStatic ? ' # type: ignore[no-redef]' : ''}`);
            if (renderAbstract && this.abstract) {
                code.line('@abc.abstractmethod');
            }
            openSignature(code, 'def', this.pythonName, [this.implicitParameter, `value: ${pythonType}`], false, 'None');
            if ((this.shouldEmitBody || forceEmitBody) &&
                (!renderAbstract || !this.abstract)) {
                code.line(`jsii.${this.jsiiSetMethod}(${this.implicitParameter}, "${this.jsName}", value)`);
            }
            else {
                code.line('...');
            }
            code.closeBlock();
        }
    }
}
class Interface extends BasePythonClassType {
    emit(code, context) {
        context = nestedContext(context, this.fqn);
        emitList(code, '@jsii.interface(', [`jsii_type="${this.fqn}"`], ')');
        // First we do our normal class logic for emitting our members.
        super.emit(code, context);
        code.line();
        code.line();
        // Then, we have to emit a Proxy class which implements our proxy interface.
        const proxyBases = this.bases.map((b) => 
        // "# type: ignore[misc]" because MyPy cannot check dynamic base classes (naturally)
        `jsii.proxy_for(${type_name_1.toTypeName(b).pythonType({
            ...context,
            typeAnnotation: false,
        })}) # type: ignore[misc]`);
        openSignature(code, 'class', this.proxyClassName, proxyBases);
        this.generator.emitDocString(code, this.apiLocation, this.docs, {
            documentableItem: `class-${this.pythonName}`,
            trailingNewLine: true,
        });
        code.line(`__jsii_type__: typing.ClassVar[str] = "${this.fqn}"`);
        if (this.members.length > 0) {
            for (const member of this.members) {
                if (this.separateMembers) {
                    code.line();
                }
                member.emit(code, context, { forceEmitBody: true });
            }
        }
        else {
            code.line('pass');
        }
        code.closeBlock();
        code.line();
        code.line('# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface');
        code.line(`typing.cast(typing.Any, ${this.pythonName}).__jsii_proxy_class__ = lambda : ${this.proxyClassName}`);
        if (this.fqn != null) {
            context.emittedTypes.add(this.fqn);
        }
    }
    getClassParams(context) {
        const params = this.bases.map((b) => type_name_1.toTypeName(b).pythonType({ ...context, typeAnnotation: false }));
        params.push('typing_extensions.Protocol');
        return params;
    }
    get proxyClassName() {
        return `_${this.pythonName}Proxy`;
    }
}
class InterfaceMethod extends BaseMethod {
    constructor() {
        super(...arguments);
        this.implicitParameter = 'self';
        this.jsiiMethod = 'invoke';
        this.shouldEmitBody = false;
    }
}
class InterfaceProperty extends BaseProperty {
    constructor() {
        super(...arguments);
        this.decorator = 'builtins.property';
        this.implicitParameter = 'self';
        this.jsiiGetMethod = 'get';
        this.jsiiSetMethod = 'set';
        this.shouldEmitBody = false;
    }
}
class Struct extends BasePythonClassType {
    constructor() {
        super(...arguments);
        this.directMembers = new Array();
    }
    addMember(member) {
        if (!(member instanceof StructField)) {
            throw new Error('Must add StructField to Struct');
        }
        this.directMembers.push(member);
    }
    emit(code, context) {
        context = nestedContext(context, this.fqn);
        const baseInterfaces = this.getClassParams(context);
        code.indent('@jsii.data_type(');
        code.line(`jsii_type=${JSON.stringify(this.fqn)},`);
        emitList(code, 'jsii_struct_bases=[', baseInterfaces, '],');
        assignDictionary(code, 'name_mapping', this.propertyMap(), ',', true);
        code.unindent(')');
        openSignature(code, 'class', this.pythonName, baseInterfaces);
        this.emitConstructor(code, context);
        for (const member of this.allMembers) {
            code.line();
            this.emitGetter(member, code, context);
        }
        this.emitMagicMethods(code);
        code.closeBlock();
        if (this.fqn != null) {
            context.emittedTypes.add(this.fqn);
        }
    }
    requiredImports(context) {
        return type_name_1.mergePythonImports(super.requiredImports(context), ...this.allMembers.map((mem) => mem.requiredImports(context)));
    }
    getClassParams(context) {
        return this.bases.map((b) => type_name_1.toTypeName(b).pythonType({ ...context, typeAnnotation: false }));
    }
    /**
     * Find all fields (inherited as well)
     */
    get allMembers() {
        return this.thisInterface.allProperties.map((x) => new StructField(this.generator, x.spec, x.definingType.spec));
    }
    get thisInterface() {
        if (this.fqn == null) {
            throw new Error('FQN not set');
        }
        return this.generator.reflectAssembly.system.findInterface(this.fqn);
    }
    emitConstructor(code, context) {
        const members = this.allMembers;
        const kwargs = members.map((m) => m.constructorDecl(context));
        const implicitParameter = slugifyAsNeeded('self', members.map((m) => m.pythonName));
        const constructorArguments = kwargs.length > 0
            ? [implicitParameter, '*', ...kwargs]
            : [implicitParameter];
        openSignature(code, 'def', '__init__', constructorArguments, false, 'None');
        this.emitConstructorDocstring(code);
        // Re-type struct arguments that were passed as "dict"
        for (const member of members.filter((m) => m.isStruct(this.generator))) {
            // Note that "None" is NOT an instance of dict (that's convenient!)
            const typeName = type_name_1.toTypeName(member.type.type).pythonType({
                ...context,
                typeAnnotation: false,
            });
            code.openBlock(`if isinstance(${member.pythonName}, dict)`);
            code.line(`${member.pythonName} = ${typeName}(**${member.pythonName})`);
            code.closeBlock();
        }
        // Required properties, those will always be put into the dict
        assignDictionary(code, `${implicitParameter}._values: typing.Dict[str, typing.Any]`, members
            .filter((m) => !m.optional)
            .map((member) => `${JSON.stringify(member.pythonName)}: ${member.pythonName}`));
        // Optional properties, will only be put into the dict if they're not None
        for (const member of members.filter((m) => m.optional)) {
            code.openBlock(`if ${member.pythonName} is not None`);
            code.line(`${implicitParameter}._values["${member.pythonName}"] = ${member.pythonName}`);
            code.closeBlock();
        }
        code.closeBlock();
    }
    emitConstructorDocstring(code) {
        const args = this.allMembers.map((m) => ({
            name: m.pythonName,
            docs: m.docs,
            definingType: this.spec,
        }));
        this.generator.emitDocString(code, this.apiLocation, this.docs, {
            arguments: args,
            documentableItem: `class-${this.pythonName}`,
        });
    }
    emitGetter(member, code, context) {
        const pythonType = member.typeAnnotation(context);
        code.line('@builtins.property');
        openSignature(code, 'def', member.pythonName, ['self'], true, pythonType);
        member.emitDocString(code);
        code.line(`result = self._values.get(${JSON.stringify(member.pythonName)})`);
        if (!member.optional) {
            // Add an assertion to maye MyPY happy!
            code.line(`assert result is not None, "Required property '${member.pythonName}' is missing"`);
        }
        code.line(`return typing.cast(${pythonType}, result)`);
        code.closeBlock();
    }
    emitMagicMethods(code) {
        code.line();
        code.openBlock('def __eq__(self, rhs: typing.Any) -> builtins.bool');
        code.line('return isinstance(rhs, self.__class__) and rhs._values == self._values');
        code.closeBlock();
        code.line();
        code.openBlock('def __ne__(self, rhs: typing.Any) -> builtins.bool');
        code.line('return not (rhs == self)');
        code.closeBlock();
        code.line();
        code.openBlock('def __repr__(self) -> str');
        code.indent(`return "${this.pythonName}(%s)" % ", ".join(`);
        code.line('k + "=" + repr(v) for k, v in self._values.items()');
        code.unindent(')');
        code.closeBlock();
    }
    propertyMap() {
        const ret = new Array();
        for (const member of this.allMembers) {
            ret.push(`${JSON.stringify(member.pythonName)}: ${JSON.stringify(member.jsiiName)}`);
        }
        return ret;
    }
}
class StructField {
    constructor(generator, prop, definingType) {
        this.generator = generator;
        this.prop = prop;
        this.definingType = definingType;
        this.pythonName = toPythonPropertyName(prop.name);
        this.jsiiName = prop.name;
        this.type = prop;
        this.docs = prop.docs;
    }
    get apiLocation() {
        return {
            api: 'member',
            fqn: this.definingType.fqn,
            memberName: this.jsiiName,
        };
    }
    get optional() {
        return !!this.type.optional;
    }
    requiredImports(context) {
        return type_name_1.toTypeName(this.type).requiredImports(context);
    }
    isStruct(generator) {
        return isStruct(generator.reflectAssembly.system, this.type.type);
    }
    constructorDecl(context) {
        const opt = this.optional ? ' = None' : '';
        return `${this.pythonName}: ${this.typeAnnotation({
            ...context,
            parameterType: true,
        })}${opt}`;
    }
    /**
     * Return the Python type annotation for this type
     */
    typeAnnotation(context) {
        return type_name_1.toTypeName(this.type).pythonType(context);
    }
    emitDocString(code) {
        this.generator.emitDocString(code, this.apiLocation, this.docs, {
            documentableItem: `prop-${this.pythonName}`,
        });
    }
    emit(code, context) {
        const resolvedType = this.typeAnnotation(context);
        code.line(`${this.pythonName}: ${resolvedType}`);
        this.emitDocString(code);
    }
}
class Class extends BasePythonClassType {
    constructor(generator, name, spec, fqn, opts, docs) {
        super(generator, name, spec, fqn, opts, docs);
        const { abstract = false, interfaces = [], abstractBases = [] } = opts;
        this.abstract = abstract;
        this.interfaces = interfaces;
        this.abstractBases = abstractBases;
    }
    dependsOn(resolver) {
        const dependencies = super.dependsOn(resolver);
        const parent = resolver.getParent(this.fqn);
        // We need to return any ifaces that are in the same module at the same level of
        // nesting.
        const seen = new Set();
        for (const iface of this.interfaces) {
            if (resolver.isInModule(iface)) {
                // Given a iface, we need to locate the ifaces's parent that is the same
                // as our parent, because we only care about dependencies that are at the
                // same level of our own.
                // TODO: We might need to recurse into our members to also find their
                //       dependencies.
                let ifaceItem = resolver.getType(iface);
                let ifaceParent = resolver.getParent(iface);
                while (ifaceParent !== parent) {
                    ifaceItem = ifaceParent;
                    ifaceParent = resolver.getParent(ifaceItem.fqn);
                }
                if (!seen.has(ifaceItem.fqn)) {
                    dependencies.push(ifaceItem);
                    seen.add(ifaceItem.fqn);
                }
            }
        }
        return dependencies;
    }
    requiredImports(context) {
        return type_name_1.mergePythonImports(super.requiredImports(context), // Takes care of base & members
        ...this.interfaces.map((base) => type_name_1.toTypeName(base).requiredImports(context)));
    }
    emit(code, context) {
        // First we emit our implments decorator
        if (this.interfaces.length > 0) {
            const interfaces = this.interfaces.map((b) => type_name_1.toTypeName(b).pythonType({ ...context, typeAnnotation: false }));
            code.line(`@jsii.implements(${interfaces.join(', ')})`);
        }
        // Then we do our normal class logic for emitting our members.
        super.emit(code, context);
        // Then, if our class is Abstract, we have to go through and redo all of
        // this logic, except only emiting abstract methods and properties as non
        // abstract, and subclassing our initial class.
        if (this.abstract) {
            context = nestedContext(context, this.fqn);
            const proxyBases = [this.pythonName];
            for (const base of this.abstractBases) {
                // "# type: ignore[misc]" because MyPy cannot check dynamic base classes (naturally)
                proxyBases.push(`jsii.proxy_for(${type_name_1.toTypeName(base).pythonType({
                    ...context,
                    typeAnnotation: false,
                })}) # type: ignore[misc]`);
            }
            code.line();
            code.line();
            openSignature(code, 'class', this.proxyClassName, proxyBases);
            // Filter our list of members to *only* be abstract members, and not any
            // other types.
            const abstractMembers = this.members.filter((m) => (m instanceof BaseMethod || m instanceof BaseProperty) && m.abstract);
            if (abstractMembers.length > 0) {
                let first = true;
                for (const member of abstractMembers) {
                    if (this.separateMembers) {
                        if (first) {
                            first = false;
                        }
                        else {
                            code.line();
                        }
                    }
                    member.emit(code, context, { renderAbstract: false });
                }
            }
            else {
                code.line('pass');
            }
            code.closeBlock();
            code.line();
            code.line('# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class');
            code.line(`typing.cast(typing.Any, ${this.pythonName}).__jsii_proxy_class__ = lambda : ${this.proxyClassName}`);
        }
    }
    getClassParams(context) {
        const params = this.bases.map((b) => type_name_1.toTypeName(b).pythonType({ ...context, typeAnnotation: false }));
        const metaclass = this.abstract ? 'JSIIAbstractClass' : 'JSIIMeta';
        params.push(`metaclass=jsii.${metaclass}`);
        params.push(`jsii_type="${this.fqn}"`);
        return params;
    }
    get proxyClassName() {
        return `_${this.pythonName}Proxy`;
    }
}
class StaticMethod extends BaseMethod {
    constructor() {
        super(...arguments);
        this.decorator = 'builtins.classmethod';
        this.implicitParameter = 'cls';
        this.jsiiMethod = 'sinvoke';
    }
}
class Initializer extends BaseMethod {
    constructor() {
        super(...arguments);
        this.implicitParameter = 'self';
        this.jsiiMethod = 'create';
        this.classAsFirstParameter = true;
        this.returnFromJSIIMethod = false;
    }
}
class Method extends BaseMethod {
    constructor() {
        super(...arguments);
        this.implicitParameter = 'self';
        this.jsiiMethod = 'invoke';
    }
}
class AsyncMethod extends BaseMethod {
    constructor() {
        super(...arguments);
        this.implicitParameter = 'self';
        this.jsiiMethod = 'ainvoke';
    }
}
class StaticProperty extends BaseProperty {
    constructor() {
        super(...arguments);
        this.decorator = 'jsii.python.classproperty';
        this.implicitParameter = 'cls';
        this.jsiiGetMethod = 'sget';
        this.jsiiSetMethod = 'sset';
    }
}
class Property extends BaseProperty {
    constructor() {
        super(...arguments);
        this.decorator = 'builtins.property';
        this.implicitParameter = 'self';
        this.jsiiGetMethod = 'get';
        this.jsiiSetMethod = 'set';
    }
}
class Enum extends BasePythonClassType {
    constructor() {
        super(...arguments);
        this.separateMembers = false;
    }
    emit(code, context) {
        context = nestedContext(context, this.fqn);
        emitList(code, '@jsii.enum(', [`jsii_type="${this.fqn}"`], ')');
        return super.emit(code, context);
    }
    getClassParams(_context) {
        return ['enum.Enum'];
    }
    requiredImports(context) {
        return super.requiredImports(context);
    }
}
class EnumMember {
    constructor(generator, pythonName, value, docs, parent) {
        this.generator = generator;
        this.pythonName = pythonName;
        this.value = value;
        this.docs = docs;
        this.parent = parent;
        this.pythonName = pythonName;
        this.value = value;
    }
    get apiLocation() {
        return { api: 'member', fqn: this.parent.fqn, memberName: this.value };
    }
    dependsOnModules() {
        return new Set();
    }
    emit(code, _context) {
        code.line(`${this.pythonName} = "${this.value}"`);
        this.generator.emitDocString(code, this.apiLocation, this.docs, {
            documentableItem: `enum-${this.pythonName}`,
        });
    }
    requiredImports(_context) {
        return {};
    }
}
/**
 * Python module
 *
 * Will be called for jsii submodules and namespaces.
 */
class PythonModule {
    constructor(pythonName, fqn, opts) {
        this.pythonName = pythonName;
        this.fqn = fqn;
        this.members = new Array();
        this.modules = new Array();
        this.assembly = opts.assembly;
        this.assemblyFilename = opts.assemblyFilename;
        this.loadAssembly = !!opts.loadAssembly;
        this.moduleDocumentation = opts.moduleDocumentation;
    }
    addMember(member) {
        this.members.push(member);
    }
    addPythonModule(pyMod) {
        assert(!this.loadAssembly, 'PythonModule.addPythonModule CANNOT be called on assembly-loading modules (it would cause a load cycle)!');
        this.modules.push(pyMod);
    }
    requiredImports(context) {
        return type_name_1.mergePythonImports(...this.members.map((mem) => mem.requiredImports(context)));
    }
    emit(code, context) {
        var _a;
        this.emitModuleDocumentation(code);
        const resolver = this.fqn
            ? context.resolver.bind(this.fqn, this.pythonName)
            : context.resolver;
        context = {
            ...context,
            submodule: (_a = this.fqn) !== null && _a !== void 0 ? _a : context.submodule,
            resolver,
        };
        // Before we write anything else, we need to write out our module headers, this
        // is where we handle stuff like imports, any required initialization, etc.
        code.line('import abc');
        code.line('import builtins');
        code.line('import datetime');
        code.line('import enum');
        code.line('import typing');
        code.line();
        code.line('import jsii');
        code.line('import publication');
        code.line('import typing_extensions');
        // Determine if we need to write out the kernel load line.
        if (this.loadAssembly) {
            this.emitDependencyImports(code);
            code.line();
            emitList(code, '__jsii_assembly__ = jsii.JSIIAssembly.load(', [
                JSON.stringify(this.assembly.name),
                JSON.stringify(this.assembly.version),
                '__name__[0:-6]',
                `${JSON.stringify(this.assemblyFilename)}`,
            ], ')');
        }
        else {
            // Then we must import the ._jsii subpackage.
            code.line();
            let distanceFromRoot = 0;
            for (let curr = this.fqn; curr !== this.assembly.name; curr = curr.substring(0, curr.lastIndexOf('.'))) {
                distanceFromRoot++;
            }
            code.line(`from ${'.'.repeat(distanceFromRoot + 1)}_jsii import *`);
            this.emitRequiredImports(code, context);
        }
        // Emit all of our members.
        for (const member of prepareMembers(this.members, resolver)) {
            code.line();
            code.line();
            member.emit(code, context);
        }
        // Whatever names we've exported, we'll write out our __all__ that lists them.
        const exportedMembers = this.members.map((m) => `"${m.pythonName}"`);
        if (this.loadAssembly) {
            exportedMembers.push('"__jsii_assembly__"');
        }
        // Declare the list of "public" members this module exports
        if (this.members.length > 0) {
            code.line();
        }
        code.line();
        if (exportedMembers.length > 0) {
            code.indent('__all__ = [');
            for (const member of exportedMembers.sort()) {
                // Writing one by line might be _a lot_ of lines, but it'll make reviewing changes to the list easier. Trust me.
                code.line(`${member},`);
            }
            code.unindent(']');
        }
        else {
            code.line('__all__: typing.List[typing.Any] = []');
        }
        // Next up, we'll use publication to ensure that all of the non-public names
        // get hidden from dir(), tab-complete, etc.
        code.line();
        code.line('publication.publish()');
        // Finally, we'll load all registered python modules
        if (this.modules.length > 0) {
            code.line();
            code.line('# Loading modules to ensure their types are registered with the jsii runtime library');
            for (const module of this.modules.sort((l, r) => l.pythonName.localeCompare(r.pythonName))) {
                code.line(`import ${module.pythonName}`);
            }
        }
    }
    /**
     * Emit the bin scripts if bin section defined.
     */
    emitBinScripts(code) {
        const scripts = new Array();
        if (this.loadAssembly) {
            if (this.assembly.bin != null) {
                for (const name of Object.keys(this.assembly.bin)) {
                    const script_file = path.join('src', pythonModuleNameToFilename(this.pythonName), 'bin', name);
                    code.openFile(script_file);
                    code.line('#!/usr/bin/env python');
                    code.line();
                    code.line('import jsii');
                    code.line('import sys');
                    code.line();
                    emitList(code, '__jsii_assembly__ = jsii.JSIIAssembly.load(', [
                        JSON.stringify(this.assembly.name),
                        JSON.stringify(this.assembly.version),
                        JSON.stringify(this.pythonName.replace('._jsii', '')),
                        `${JSON.stringify(this.assemblyFilename)}`,
                    ], ')');
                    code.line();
                    emitList(code, '__jsii_assembly__.invokeBinScript(', [
                        JSON.stringify(this.assembly.name),
                        JSON.stringify(name),
                        'sys.argv[1:]',
                    ], ')');
                    code.closeFile(script_file);
                    scripts.push(script_file.replace(/\\/g, '/'));
                }
            }
        }
        return scripts;
    }
    /**
     * Emit the README as module docstring if this is the entry point module (it loads the assembly)
     */
    emitModuleDocumentation(code) {
        if (this.moduleDocumentation) {
            code.line(DOCSTRING_QUOTES);
            code.line(this.moduleDocumentation);
            code.line(DOCSTRING_QUOTES);
        }
    }
    emitDependencyImports(code) {
        var _a;
        // Collect all the (direct) dependencies' ._jsii packages.
        const deps = Object.keys((_a = this.assembly.dependencies) !== null && _a !== void 0 ? _a : {})
            .map((dep) => { var _a, _b, _c, _d, _e; return (_e = (_d = (_c = (_b = (_a = this.assembly.dependencyClosure) === null || _a === void 0 ? void 0 : _a[dep]) === null || _b === void 0 ? void 0 : _b.targets) === null || _c === void 0 ? void 0 : _c.python) === null || _d === void 0 ? void 0 : _d.module) !== null && _e !== void 0 ? _e : util_2.die(`No Python target was configrued for the dependency "${dep}".`); })
            .map((mod) => `${mod}._jsii`)
            .sort();
        // Now actually write the import statements...
        if (deps.length > 0) {
            code.line();
            for (const moduleName of deps) {
                code.line(`import ${moduleName}`);
            }
        }
    }
    emitRequiredImports(code, context) {
        const requiredImports = this.requiredImports(context);
        const statements = Object.entries(requiredImports)
            .map(([sourcePackage, items]) => toImportStatements(sourcePackage, items))
            .reduce((acc, elt) => [...acc, ...elt], new Array())
            .sort(importComparator);
        if (statements.length > 0) {
            code.line();
        }
        for (const statement of statements) {
            statement.emit(code);
        }
        function toImportStatements(sourcePkg, items) {
            const result = new Array();
            if (items.has('')) {
                result.push({
                    comparisonBase: `import ${sourcePkg}`,
                    emit(code) {
                        code.line(this.comparisonBase);
                    },
                });
            }
            const pieceMeal = Array.from(items)
                .filter((i) => i !== '')
                .sort();
            if (pieceMeal.length > 0) {
                result.push({
                    comparisonBase: `from ${sourcePkg} import`,
                    emit: (code) => emitList(code, `from ${sourcePkg} import `, pieceMeal, '', {
                        ifMulti: ['(', ')'],
                    }),
                });
            }
            return result;
        }
        function importComparator(left, right) {
            if (left.comparisonBase.startsWith('import') ===
                right.comparisonBase.startsWith('import')) {
                return left.comparisonBase.localeCompare(right.comparisonBase);
            }
            // We want "from .foo import (...)" to be *after* "import bar"
            return right.comparisonBase.localeCompare(left.comparisonBase);
        }
    }
}
class Package {
    constructor(name, version, metadata) {
        this.modules = new Map();
        this.data = new Map();
        this.name = name;
        this.version = version;
        this.metadata = metadata;
    }
    addModule(module) {
        this.modules.set(module.pythonName, module);
        // This is the module that represents the assembly
        if (module.fqn === this.metadata.name) {
            this.rootModule = module;
        }
    }
    addData(module, filename, data) {
        if (!this.data.has(module.pythonName)) {
            this.data.set(module.pythonName, []);
        }
        this.data.get(module.pythonName).push({ filename, data });
    }
    write(code, context) {
        var _a, _b, _c, _d, _e, _f, _g;
        const modules = [...this.modules.values()].sort((a, b) => a.pythonName.localeCompare(b.pythonName));
        const scripts = new Array();
        // Iterate over all of our modules, and write them out to disk.
        for (const mod of modules) {
            const filename = path.join('src', pythonModuleNameToFilename(mod.pythonName), '__init__.py');
            code.openFile(filename);
            mod.emit(code, context);
            code.closeFile(filename);
            scripts.push(...mod.emitBinScripts(code));
        }
        // Handle our package data.
        const packageData = {};
        for (const [mod, pdata] of this.data) {
            for (const data of pdata) {
                if (data.data != null) {
                    const filepath = path.join('src', pythonModuleNameToFilename(mod), data.filename);
                    code.openFile(filepath);
                    code.line(data.data);
                    code.closeFile(filepath);
                }
            }
            packageData[mod] = pdata.map((pd) => pd.filename);
        }
        // Compute our list of dependencies
        const dependencies = [];
        for (const [depName, version] of Object.entries((_a = this.metadata.dependencies) !== null && _a !== void 0 ? _a : {})) {
            const depInfo = this.metadata.dependencyClosure[depName];
            dependencies.push(`${depInfo.targets.python.distName}${version_utils_1.toPythonVersionRange(version)}`);
        }
        // Need to always write this file as the build process depends on it.
        // Make up some contents if we don't have anything useful to say.
        code.openFile('README.md');
        code.line((_c = (_b = this.rootModule) === null || _b === void 0 ? void 0 : _b.moduleDocumentation) !== null && _c !== void 0 ? _c : `${this.name}\n${'='.repeat(this.name.length)}`);
        code.closeFile('README.md');
        // Strip " (build abcdef)" from the jsii version
        const jsiiVersionSimple = this.metadata.jsiiVersion.replace(/ .*$/, '');
        const setupKwargs = {
            name: this.name,
            version: this.version,
            description: this.metadata.description,
            license: this.metadata.license,
            url: this.metadata.homepage,
            long_description_content_type: 'text/markdown',
            author: this.metadata.author.name +
                (this.metadata.author.email !== undefined
                    ? `<${this.metadata.author.email}>`
                    : ''),
            bdist_wheel: {
                universal: true,
            },
            project_urls: {
                Source: this.metadata.repository.url,
            },
            package_dir: { '': 'src' },
            packages: modules.map((m) => m.pythonName),
            package_data: packageData,
            python_requires: '>=3.6',
            install_requires: [
                `jsii${version_utils_1.toPythonVersionRange(`^${jsiiVersionSimple}`)}`,
                'publication>=0.0.3',
            ]
                .concat(dependencies)
                .sort(),
            classifiers: [
                'Intended Audience :: Developers',
                'Operating System :: OS Independent',
                'Programming Language :: JavaScript',
                'Programming Language :: Python :: 3 :: Only',
                'Programming Language :: Python :: 3.6',
                'Programming Language :: Python :: 3.7',
                'Programming Language :: Python :: 3.8',
                'Programming Language :: Python :: 3.9',
                'Typing :: Typed',
            ],
            scripts,
        };
        switch ((_d = this.metadata.docs) === null || _d === void 0 ? void 0 : _d.stability) {
            case spec.Stability.Experimental:
                setupKwargs.classifiers.push('Development Status :: 4 - Beta');
                break;
            case spec.Stability.Stable:
                setupKwargs.classifiers.push('Development Status :: 5 - Production/Stable');
                break;
            case spec.Stability.Deprecated:
                setupKwargs.classifiers.push('Development Status :: 7 - Inactive');
                break;
            default:
            // No 'Development Status' trove classifier for you!
        }
        if ((_e = spdxLicenseList[this.metadata.license]) === null || _e === void 0 ? void 0 : _e.osiApproved) {
            setupKwargs.classifiers.push('License :: OSI Approved');
        }
        const additionalClassifiers = (_g = (_f = this.metadata.targets) === null || _f === void 0 ? void 0 : _f.python) === null || _g === void 0 ? void 0 : _g.classifiers;
        if (additionalClassifiers != null) {
            if (!Array.isArray(additionalClassifiers)) {
                throw new Error(`The "jsii.targets.python.classifiers" value must be an array of strings if provided, but found ${JSON.stringify(additionalClassifiers, null, 2)}`);
            }
            // We discourage using those since we automatically set a value for them
            for (let classifier of additionalClassifiers.sort()) {
                if (typeof classifier !== 'string') {
                    throw new Error(`The "jsii.targets.python.classifiers" value can only contain strings, but found ${JSON.stringify(classifier, null, 2)}`);
                }
                // We'll split on `::` and re-join later so classifiers are "normalized" to a standard spacing
                const parts = classifier.split('::').map((part) => part.trim());
                const reservedClassifiers = [
                    'Development Status',
                    'License',
                    'Operating System',
                    'Typing',
                ];
                if (reservedClassifiers.includes(parts[0])) {
                    logging_1.warn(`Classifiers starting with ${reservedClassifiers
                        .map((x) => `"${x} ::"`)
                        .join(', ')} are automatically set and should not be manually configured`);
                }
                classifier = parts.join(' :: ');
                if (setupKwargs.classifiers.includes(classifier)) {
                    continue;
                }
                setupKwargs.classifiers.push(classifier);
            }
        }
        // We Need a setup.py to make this Package, actually a Package.
        code.openFile('setup.py');
        code.line('import json');
        code.line('import setuptools');
        code.line();
        code.line('kwargs = json.loads(');
        code.line('    """');
        code.line(JSON.stringify(setupKwargs, null, 4));
        code.line('"""');
        code.line(')');
        code.line();
        code.openBlock('with open("README.md", encoding="utf8") as fp');
        code.line('kwargs["long_description"] = fp.read()');
        code.closeBlock();
        code.line();
        code.line();
        code.line('setuptools.setup(**kwargs)');
        code.closeFile('setup.py');
        // Because we're good citizens, we're going to go ahead and support pyproject.toml
        // as well.
        // TODO: Might be easier to just use a TOML library to write this out.
        code.openFile('pyproject.toml');
        code.line('[build-system]');
        const buildTools = fs
            .readFileSync(requirementsFile, { encoding: 'utf-8' })
            .split('\n')
            .map((line) => { var _a, _b; return (_b = (_a = /^\s*(.+)\s*#\s*build-system\s*$/.exec(line)) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.trim(); })
            .reduce((buildTools, entry) => (entry ? [...buildTools, entry] : buildTools), new Array());
        code.line(`requires = [${buildTools.map((x) => `"${x}"`).join(', ')}]`);
        code.line('build-backend = "setuptools.build_meta"');
        code.closeFile('pyproject.toml');
        // We also need to write out a MANIFEST.in to ensure that all of our required
        // files are included.
        code.openFile('MANIFEST.in');
        code.line('include pyproject.toml');
        code.closeFile('MANIFEST.in');
    }
}
class TypeResolver {
    constructor(types, findModule, findType, boundTo, moduleName) {
        this.types = types;
        this.findModule = findModule;
        this.findType = findType;
        this.moduleName = moduleName;
        this.boundTo = boundTo !== undefined ? this.toPythonFQN(boundTo) : boundTo;
        if (this.moduleName !== undefined) {
            this.moduleRe = new RegExp(`^(${escapeStringRegexp(this.moduleName)})\\.(.+)$`);
        }
        if (this.boundTo !== undefined) {
            this.boundRe = new RegExp(`^(${escapeStringRegexp(this.boundTo)})\\.(.+)$`);
        }
    }
    bind(fqn, moduleName) {
        return new TypeResolver(this.types, this.findModule, this.findType, fqn, moduleName !== undefined
            ? moduleName.startsWith('.')
                ? `${this.moduleName}${moduleName}`
                : moduleName
            : this.moduleName);
    }
    isInModule(typeRef) {
        const pythonType = typeof typeRef !== 'string' ? this.toPythonFQN(typeRef.fqn) : typeRef;
        return this.moduleRe.test(pythonType);
    }
    isInNamespace(typeRef) {
        const pythonType = typeof typeRef !== 'string' ? this.toPythonFQN(typeRef.fqn) : typeRef;
        return this.boundRe.test(pythonType);
    }
    getParent(typeRef) {
        const fqn = typeof typeRef !== 'string' ? typeRef.fqn : typeRef;
        const matches = /^(.+)\.[^.]+$/.exec(fqn);
        if (matches == null || !Array.isArray(matches)) {
            throw new Error(`Invalid FQN: ${fqn}`);
        }
        const [, parentFQN] = matches;
        const parent = this.types.get(parentFQN);
        if (parent === undefined) {
            throw new Error(`Could not find parent:  ${parentFQN}`);
        }
        return parent;
    }
    getDefiningPythonModule(typeRef) {
        const fqn = typeof typeRef !== 'string' ? typeRef.fqn : typeRef;
        const parent = this.types.get(fqn);
        if (parent) {
            let mod = parent;
            while (!(mod instanceof PythonModule)) {
                mod = this.getParent(mod.fqn);
            }
            return mod.pythonName;
        }
        const matches = /^([^.]+)\./.exec(fqn);
        if (matches == null || !Array.isArray(matches)) {
            throw new Error(`Invalid FQN: ${fqn}`);
        }
        const [, assm] = matches;
        return this.findModule(assm).targets.python.module;
    }
    getType(typeRef) {
        const type = this.types.get(typeRef.fqn);
        if (type === undefined) {
            throw new Error(`Could not locate type: "${typeRef.fqn}"`);
        }
        return type;
    }
    dereference(typeRef) {
        if (typeof typeRef !== 'string') {
            typeRef = typeRef.fqn;
        }
        return this.findType(typeRef);
    }
    toPythonFQN(fqn) {
        const [assemblyName, ...qualifiedIdentifiers] = fqn.split('.');
        const fqnParts = [
            this.findModule(assemblyName).targets.python.module,
        ];
        for (const part of qualifiedIdentifiers) {
            fqnParts.push(util_2.toPythonIdentifier(part));
        }
        return fqnParts.join('.');
    }
}
class PythonGenerator extends generator_1.Generator {
    constructor(rosetta, options = {}) {
        super(options);
        this.rosetta = rosetta;
        this.code.openBlockFormatter = (s) => `${s}:`;
        this.code.closeBlockFormatter = (_s) => false;
        this.types = new Map();
    }
    // eslint-disable-next-line complexity
    emitDocString(code, apiLocation, docs, options = {}) {
        var _a, _b, _c, _d;
        if ((!docs || Object.keys(docs).length === 0) && !options.arguments) {
            return;
        }
        if (!docs) {
            docs = {};
        }
        const lines = new Array();
        if (docs.summary) {
            lines.push(markdown_1.md2rst(_utils_1.renderSummary(docs)));
            brk();
        }
        else {
            lines.push('');
        }
        function brk() {
            if (lines.length > 0 && lines[lines.length - 1].trim() !== '') {
                lines.push('');
            }
        }
        function block(heading, content, doBrk = true) {
            if (doBrk) {
                brk();
            }
            const contentLines = markdown_1.md2rst(content).split('\n');
            if (contentLines.length <= 1) {
                lines.push(`:${heading}: ${contentLines.join('')}`.trim());
            }
            else {
                lines.push(`:${heading}:`);
                brk();
                for (const line of contentLines) {
                    lines.push(line.trim());
                }
            }
            if (doBrk) {
                brk();
            }
        }
        if (docs.remarks) {
            brk();
            lines.push(...markdown_1.md2rst(this.convertMarkdown((_a = docs.remarks) !== null && _a !== void 0 ? _a : '', apiLocation)).split('\n'));
            brk();
        }
        if ((_c = (_b = options.arguments) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0 > 0) {
            brk();
            for (const param of options.arguments) {
                // Add a line for every argument. Even if there is no description, we need
                // the docstring so that the Sphinx extension can add the type annotations.
                lines.push(`:param ${toPythonParameterName(param.name)}: ${onelineDescription(param.docs)}`);
            }
            brk();
        }
        if (docs.default) {
            block('default', docs.default);
        }
        if (docs.returns) {
            block('return', docs.returns);
        }
        if (docs.deprecated) {
            block('deprecated', docs.deprecated);
        }
        if (docs.see) {
            block('see', docs.see, false);
        }
        if (docs.stability && shouldMentionStability(docs.stability)) {
            block('stability', docs.stability, false);
        }
        if (docs.subclassable) {
            block('subclassable', 'Yes');
        }
        for (const [k, v] of Object.entries((_d = docs.custom) !== null && _d !== void 0 ? _d : {})) {
            block(k, v, false);
        }
        if (docs.example) {
            brk();
            lines.push('Example::');
            lines.push('');
            const exampleText = this.convertExample(docs.example, apiLocation);
            for (const line of exampleText.split('\n')) {
                lines.push(`    ${line}`);
            }
            brk();
        }
        while (lines.length > 0 && lines[lines.length - 1] === '') {
            lines.pop();
        }
        if (lines.length === 0) {
            return;
        }
        if (lines.length === 1) {
            code.line(`${DOCSTRING_QUOTES}${lines[0]}${DOCSTRING_QUOTES}`);
        }
        else {
            code.line(`${DOCSTRING_QUOTES}${lines[0]}`);
            lines.splice(0, 1);
            for (const line of lines) {
                code.line(line);
            }
            code.line(DOCSTRING_QUOTES);
        }
        if (options.trailingNewLine) {
            code.line();
        }
    }
    convertExample(example, apiLoc) {
        const translated = this.rosetta.translateExample(apiLoc, example, jsii_rosetta_1.TargetLanguage.PYTHON, jsii_rosetta_1.enforcesStrictMode(this.assembly));
        return this.prefixDisclaimer(translated);
    }
    convertMarkdown(markdown, apiLoc) {
        return this.rosetta.translateSnippetsInMarkdown(apiLoc, markdown, jsii_rosetta_1.TargetLanguage.PYTHON, jsii_rosetta_1.enforcesStrictMode(this.assembly), (trans) => ({
            language: trans.language,
            source: this.prefixDisclaimer(trans),
        }));
    }
    prefixDisclaimer(translated) {
        if (!translated.didCompile && _1.INCOMPLETE_DISCLAIMER_NONCOMPILING) {
            return `# ${_1.INCOMPLETE_DISCLAIMER_NONCOMPILING}\n${translated.source}`;
        }
        return translated.source;
    }
    getPythonType(fqn) {
        const type = this.types.get(fqn);
        if (type === undefined) {
            throw new Error(`Could not locate type: "${fqn}"`);
        }
        return type;
    }
    getAssemblyOutputDir(assm) {
        return path.join('src', pythonModuleNameToFilename(this.getAssemblyModuleName(assm)));
    }
    onBeginAssembly(assm, _fingerprint) {
        this.package = new Package(assm.targets.python.distName, version_utils_1.toReleaseVersion(assm.version, _1.TargetName.PYTHON), assm);
        // This is the '<packagename>._jsii' module for this assembly
        const assemblyModule = new PythonModule(this.getAssemblyModuleName(assm), undefined, {
            assembly: assm,
            assemblyFilename: this.getAssemblyFileName(),
            loadAssembly: true,
            package: this.package,
        });
        this.package.addModule(assemblyModule);
        this.package.addData(assemblyModule, this.getAssemblyFileName(), undefined);
    }
    onEndAssembly(assm, _fingerprint) {
        const resolver = new TypeResolver(this.types, (fqn) => this.findModule(fqn), (fqn) => this.findType(fqn));
        this.package.write(this.code, {
            assembly: assm,
            emittedTypes: new Set(),
            resolver,
            submodule: assm.name,
        });
    }
    /**
     * Will be called for assembly root, namespaces and submodules (anything that contains other types, based on its FQN)
     */
    onBeginNamespace(ns) {
        var _a, _b;
        // 'ns' contains something like '@scope/jsii-calc-base-of-base'
        const submoduleLike = ns === this.assembly.name
            ? this.assembly
            : (_a = this.assembly.submodules) === null || _a === void 0 ? void 0 : _a[ns];
        const readmeLocation = { api: 'moduleReadme', moduleFqn: ns };
        const module = new PythonModule(type_name_1.toPackageName(ns, this.assembly), ns, {
            assembly: this.assembly,
            assemblyFilename: this.getAssemblyFileName(),
            package: this.package,
            moduleDocumentation: (submoduleLike === null || submoduleLike === void 0 ? void 0 : submoduleLike.readme) ? this.convertMarkdown((_b = submoduleLike.readme) === null || _b === void 0 ? void 0 : _b.markdown, readmeLocation).trim()
                : undefined,
        });
        this.package.addModule(module);
        this.types.set(ns, module);
        if (ns === this.assembly.name) {
            // This applies recursively to submodules, so no need to duplicate!
            this.package.addData(module, 'py.typed', '');
        }
        if (ns === this.assembly.name) {
            this.rootModule = module;
        }
        else {
            this.rootModule.addPythonModule(module);
        }
    }
    onEndNamespace(ns) {
        if (ns === this.assembly.name) {
            delete this.rootModule;
        }
    }
    onBeginClass(cls, abstract) {
        var _a;
        const klass = new Class(this, util_2.toPythonIdentifier(cls.name), cls, cls.fqn, {
            abstract,
            bases: cls.base ? [this.findType(cls.base)] : undefined,
            interfaces: (_a = cls.interfaces) === null || _a === void 0 ? void 0 : _a.map((base) => this.findType(base)),
            abstractBases: abstract ? this.getAbstractBases(cls) : [],
        }, cls.docs);
        if (cls.initializer !== undefined) {
            const { parameters = [] } = cls.initializer;
            klass.addMember(new Initializer(this, '__init__', undefined, parameters, undefined, cls.initializer.docs, false, // Never static
            { liftedProp: this.getliftedProp(cls.initializer), parent: cls }));
        }
        this.addPythonType(klass);
    }
    onStaticMethod(cls, method) {
        const { parameters = [] } = method;
        this.getPythonType(cls.fqn).addMember(new StaticMethod(this, toPythonMethodName(method.name), method.name, parameters, method.returns, method.docs, true, // Always static
        {
            abstract: method.abstract,
            liftedProp: this.getliftedProp(method),
            parent: cls,
        }));
    }
    onStaticProperty(cls, prop) {
        this.getPythonType(cls.fqn).addMember(new StaticProperty(this, toPythonPropertyName(prop.name, prop.const), prop.name, prop, prop.docs, {
            abstract: prop.abstract,
            immutable: prop.immutable,
            isStatic: prop.static,
            parent: cls,
        }));
    }
    onMethod(cls, method) {
        const { parameters = [] } = method;
        if (method.async) {
            this.getPythonType(cls.fqn).addMember(new AsyncMethod(this, toPythonMethodName(method.name, method.protected), method.name, parameters, method.returns, method.docs, !!method.static, {
                abstract: method.abstract,
                liftedProp: this.getliftedProp(method),
                parent: cls,
            }));
        }
        else {
            this.getPythonType(cls.fqn).addMember(new Method(this, toPythonMethodName(method.name, method.protected), method.name, parameters, method.returns, method.docs, !!method.static, {
                abstract: method.abstract,
                liftedProp: this.getliftedProp(method),
                parent: cls,
            }));
        }
    }
    onProperty(cls, prop) {
        this.getPythonType(cls.fqn).addMember(new Property(this, toPythonPropertyName(prop.name, prop.const, prop.protected), prop.name, prop, prop.docs, {
            abstract: prop.abstract,
            immutable: prop.immutable,
            isStatic: prop.static,
            parent: cls,
        }));
    }
    onUnionProperty(cls, prop, _union) {
        this.onProperty(cls, prop);
    }
    onBeginInterface(ifc) {
        var _a, _b;
        let iface;
        if (ifc.datatype) {
            iface = new Struct(this, util_2.toPythonIdentifier(ifc.name), ifc, ifc.fqn, { bases: (_a = ifc.interfaces) === null || _a === void 0 ? void 0 : _a.map((base) => this.findType(base)) }, ifc.docs);
        }
        else {
            iface = new Interface(this, util_2.toPythonIdentifier(ifc.name), ifc, ifc.fqn, { bases: (_b = ifc.interfaces) === null || _b === void 0 ? void 0 : _b.map((base) => this.findType(base)) }, ifc.docs);
        }
        this.addPythonType(iface);
    }
    onEndInterface(_ifc) {
        return;
    }
    onInterfaceMethod(ifc, method) {
        const { parameters = [] } = method;
        this.getPythonType(ifc.fqn).addMember(new InterfaceMethod(this, toPythonMethodName(method.name, method.protected), method.name, parameters, method.returns, method.docs, !!method.static, { liftedProp: this.getliftedProp(method), parent: ifc }));
    }
    onInterfaceProperty(ifc, prop) {
        let ifaceProperty;
        if (ifc.datatype) {
            ifaceProperty = new StructField(this, prop, ifc);
        }
        else {
            ifaceProperty = new InterfaceProperty(this, toPythonPropertyName(prop.name, prop.const, prop.protected), prop.name, prop, prop.docs, { immutable: prop.immutable, isStatic: prop.static, parent: ifc });
        }
        this.getPythonType(ifc.fqn).addMember(ifaceProperty);
    }
    onBeginEnum(enm) {
        this.addPythonType(new Enum(this, util_2.toPythonIdentifier(enm.name), enm, enm.fqn, {}, enm.docs));
    }
    onEnumMember(enm, member) {
        this.getPythonType(enm.fqn).addMember(new EnumMember(this, util_2.toPythonIdentifier(member.name), member.name, member.docs, enm));
    }
    onInterfaceMethodOverload(_ifc, _overload, _originalMethod) {
        throw new Error('Unhandled Type: InterfaceMethodOverload');
    }
    onMethodOverload(_cls, _overload, _originalMethod) {
        throw new Error('Unhandled Type: MethodOverload');
    }
    onStaticMethodOverload(_cls, _overload, _originalMethod) {
        throw new Error('Unhandled Type: StaticMethodOverload');
    }
    getAssemblyModuleName(assm) {
        return `${assm.targets.python.module}._jsii`;
    }
    getParentFQN(fqn) {
        const m = /^(.+)\.[^.]+$/.exec(fqn);
        if (m == null) {
            throw new Error(`Could not determine parent FQN of: ${fqn}`);
        }
        return m[1];
    }
    getParent(fqn) {
        return this.getPythonType(this.getParentFQN(fqn));
    }
    addPythonType(type) {
        if (type.fqn == null) {
            throw new Error('Cannot add a Python type without a FQN.');
        }
        this.getParent(type.fqn).addMember(type);
        this.types.set(type.fqn, type);
    }
    getliftedProp(method) {
        var _a, _b;
        // If there are parameters to this method, and if the last parameter's type is
        // a datatype interface, then we want to lift the members of that last paramter
        // as keyword arguments to this function.
        if ((_b = (_a = method.parameters) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0 >= 1) {
            const lastParameter = method.parameters.slice(-1)[0];
            if (!lastParameter.variadic &&
                spec.isNamedTypeReference(lastParameter.type)) {
                const lastParameterType = this.findType(lastParameter.type.fqn);
                if (spec.isInterfaceType(lastParameterType) &&
                    lastParameterType.datatype) {
                    return lastParameterType;
                }
            }
        }
        return undefined;
    }
    getAbstractBases(cls) {
        const abstractBases = [];
        if (cls.base !== undefined) {
            const base = this.findType(cls.base);
            if (!spec.isClassType(base)) {
                throw new Error("Class inheritence that isn't a class?");
            }
            if (base.abstract) {
                abstractBases.push(base);
            }
        }
        return abstractBases;
    }
}
/**
 * Render a one-line description of the given docs, used for method arguments and inlined properties
 */
function onelineDescription(docs) {
    // Only consider a subset of fields here, we don't have a lot of formatting space
    if (!docs || Object.keys(docs).length === 0) {
        return '-';
    }
    const parts = [];
    if (docs.summary) {
        parts.push(markdown_1.md2rst(_utils_1.renderSummary(docs)));
    }
    if (docs.remarks) {
        parts.push(markdown_1.md2rst(docs.remarks));
    }
    if (docs.default) {
        parts.push(`Default: ${markdown_1.md2rst(docs.default)}`);
    }
    return parts.join(' ').replace(/\s+/g, ' ');
}
function shouldMentionStability(s) {
    // Don't render "stable" or "external", those are both stable by implication.
    return s === spec.Stability.Deprecated || s === spec.Stability.Experimental;
}
function isStruct(typeSystem, ref) {
    if (!spec.isNamedTypeReference(ref)) {
        return false;
    }
    const type = typeSystem.tryFindFqn(ref.fqn);
    return !!((type === null || type === void 0 ? void 0 : type.isInterfaceType()) && (type === null || type === void 0 ? void 0 : type.isDataType()));
}
/**
 * Appends `_` at the end of `name` until it no longer conflicts with any of the
 * entries in `inUse`.
 *
 * @param name  the name to be slugified.
 * @param inUse the names that are already being used.
 *
 * @returns the slugified name.
 */
function slugifyAsNeeded(name, inUse) {
    const inUseSet = new Set(inUse);
    while (inUseSet.has(name)) {
        name = `${name}_`;
    }
    return name;
}
////////////////////////////////////////////////////////////////////////////////
// BEHOLD: Helpers to output code that looks like what Black would format into...
//
// @see https://black.readthedocs.io/en/stable/the_black_code_style.html
const TARGET_LINE_LENGTH = 88;
function openSignature(code, keyword, name, params, trailingComma = false, returnType) {
    const prefix = `${keyword} ${name}`;
    const suffix = returnType ? ` -> ${returnType}` : '';
    if (params.length === 0) {
        code.openBlock(`${prefix}${returnType ? '()' : ''}${suffix}`);
        return;
    }
    const join = ', ';
    const { elementsSize, joinSize } = totalSizeOf(params, join);
    const hasComments = !params.some((param) => /# .+$/.exec(param));
    if (hasComments &&
        TARGET_LINE_LENGTH >
            code.currentIndentLength +
                prefix.length +
                elementsSize +
                joinSize +
                suffix.length +
                2) {
        code.openBlock(`${prefix}(${params.join(join)})${suffix}`);
        return;
    }
    code.indent(`${prefix}(`);
    if (!hasComments &&
        TARGET_LINE_LENGTH >
            code.currentIndentLength +
                elementsSize +
                joinSize +
                (trailingComma ? 1 : 0)) {
        code.line(`${params.join(join)}${trailingComma ? ',' : ''}`);
    }
    else {
        for (const param of params) {
            code.line(param.replace(/(\s*# .+)?$/, ',$1'));
        }
    }
    code.unindent(false);
    code.openBlock(`)${suffix}`);
}
function assignCallResult(code, variable, funct, params) {
    const prefix = `${variable} = ${funct}(`;
    const suffix = ')';
    if (params.length === 0) {
        code.line(`${prefix}${suffix}`);
        return;
    }
    const join = ', ';
    const { elementsSize, joinSize } = totalSizeOf(params, join);
    if (TARGET_LINE_LENGTH >
        code.currentIndentLength +
            prefix.length +
            elementsSize +
            joinSize +
            suffix.length) {
        code.line(`${prefix}${params.join(join)}${suffix}`);
        return;
    }
    code.indent(prefix);
    if (TARGET_LINE_LENGTH > code.currentIndentLength + elementsSize + joinSize) {
        code.line(params.join(join));
    }
    else {
        for (const param of params) {
            code.line(`${param},`);
        }
    }
    code.unindent(suffix);
}
function assignDictionary(code, variable, elements, trailing, compact = false) {
    const space = compact ? '' : ' ';
    const prefix = `${variable}${space}=${space}{`;
    const suffix = `}${trailing !== null && trailing !== void 0 ? trailing : ''}`;
    if (elements.length === 0) {
        code.line(`${prefix}${suffix}`);
        return;
    }
    if (compact) {
        const join = ', ';
        const { elementsSize, joinSize } = totalSizeOf(elements, join);
        if (TARGET_LINE_LENGTH >
            prefix.length +
                code.currentIndentLength +
                elementsSize +
                joinSize +
                suffix.length) {
            code.line(`${prefix}${elements.join(join)}${suffix}`);
            return;
        }
    }
    code.indent(prefix);
    for (const elt of elements) {
        code.line(`${elt},`);
    }
    code.unindent(suffix);
}
function emitList(code, prefix, elements, suffix, opts) {
    var _a;
    if (elements.length === 0) {
        code.line(`${prefix}${suffix}`);
        return;
    }
    const join = ', ';
    const { elementsSize, joinSize } = totalSizeOf(elements, join);
    if (TARGET_LINE_LENGTH >
        code.currentIndentLength +
            prefix.length +
            elementsSize +
            joinSize +
            suffix.length) {
        code.line(`${prefix}${elements.join(join)}${suffix}`);
        return;
    }
    const [before, after] = (_a = opts === null || opts === void 0 ? void 0 : opts.ifMulti) !== null && _a !== void 0 ? _a : ['', ''];
    code.indent(`${prefix}${before}`);
    if (elements.length === 1) {
        code.line(elements[0]);
    }
    else {
        if (TARGET_LINE_LENGTH >
            code.currentIndentLength + elementsSize + joinSize) {
            code.line(elements.join(join));
        }
        else {
            for (const elt of elements) {
                code.line(`${elt},`);
            }
        }
    }
    code.unindent(`${after}${suffix}`);
}
function totalSizeOf(strings, join) {
    return {
        elementsSize: strings
            .map((str) => str.length)
            .reduce((acc, elt) => acc + elt, 0),
        joinSize: strings.length > 1 ? join.length * (strings.length - 1) : 0,
    };
}
function nestedContext(context, fqn) {
    var _a;
    return {
        ...context,
        surroundingTypeFqns: fqn != null
            ? [...((_a = context.surroundingTypeFqns) !== null && _a !== void 0 ? _a : []), fqn]
            : context.surroundingTypeFqns,
    };
}
const isDeprecated = (x) => { var _a; return ((_a = x.docs) === null || _a === void 0 ? void 0 : _a.deprecated) !== undefined; };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHl0aG9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicHl0aG9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsbUNBQW1DO0FBQ25DLGlDQUFpQztBQUNqQyx5Q0FBbUQ7QUFDbkQsMkRBQTJEO0FBQzNELCtCQUErQjtBQUUvQiwrQ0FNc0I7QUFDdEIsNkJBQTZCO0FBRTdCLDRDQUEyRDtBQUMzRCx3Q0FBa0M7QUFDbEMsMENBQXFDO0FBQ3JDLHNDQUFrRDtBQUNsRCxrQ0FBZ0M7QUFDaEMscUNBQTZEO0FBQzdELGtEQU00QjtBQUM1Qix3Q0FBd0Q7QUFDeEQsbURBQXlFO0FBRXpFLHdCQUFtRTtBQUVuRSxvR0FBb0c7QUFDcEcsTUFBTSxlQUFlLEdBQUcsT0FBTyxDQUFDLG1CQUFtQixDQUFDLENBQUM7QUFFckQsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUNuQyxTQUFTLEVBQ1QsUUFBUSxFQUNSLHNCQUFzQixDQUN2QixDQUFDO0FBRUYsMkVBQTJFO0FBQzNFLCtGQUErRjtBQUMvRixNQUFNLGdCQUFnQixHQUFHLEtBQUssQ0FBQztBQUUvQixNQUFxQixNQUFPLFNBQVEsZUFBTTtJQUd4QyxZQUFtQixPQUFzQjtRQUN2QyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFZixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksZUFBZSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRU0sS0FBSyxDQUFDLFlBQVksQ0FBQyxNQUFjLEVBQUUsT0FBZTtRQUN2RCxNQUFNLEtBQUssQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFTSxLQUFLLENBQUMsS0FBSyxDQUFDLFNBQWlCLEVBQUUsTUFBYztRQUNsRCw2QkFBNkI7UUFDN0IsTUFBTSxJQUFJLEdBQUcsTUFBTSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FB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Y2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBzcGVjIGZyb20gJ0Bqc2lpL3NwZWMnO1xuaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgeyBDb2RlTWFrZXIsIHRvU25ha2VDYXNlIH0gZnJvbSAnY29kZW1ha2VyJztcbmltcG9ydCAqIGFzIGVzY2FwZVN0cmluZ1JlZ2V4cCBmcm9tICdlc2NhcGUtc3RyaW5nLXJlZ2V4cCc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyByZWZsZWN0IGZyb20gJ2pzaWktcmVmbGVjdCc7XG5pbXBvcnQge1xuICBUYXJnZXRMYW5ndWFnZSxcbiAgVHJhbnNsYXRpb24sXG4gIFJvc2V0dGEsXG4gIGVuZm9yY2VzU3RyaWN0TW9kZSxcbiAgQXBpTG9jYXRpb24sXG59IGZyb20gJ2pzaWktcm9zZXR0YSc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyBHZW5lcmF0b3IsIEdlbmVyYXRvck9wdGlvbnMgfSBmcm9tICcuLi9nZW5lcmF0b3InO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgbWQycnN0IH0gZnJvbSAnLi4vbWFya2Rvd24nO1xuaW1wb3J0IHsgVGFyZ2V0LCBUYXJnZXRPcHRpb25zIH0gZnJvbSAnLi4vdGFyZ2V0JztcbmltcG9ydCB7IHNoZWxsIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgeyByZW5kZXJTdW1tYXJ5LCBQcm9wZXJ0eURlZmluaXRpb24gfSBmcm9tICcuL191dGlscyc7XG5pbXBvcnQge1xuICBOYW1pbmdDb250ZXh0LFxuICB0b1R5cGVOYW1lLFxuICBQeXRob25JbXBvcnRzLFxuICBtZXJnZVB5dGhvbkltcG9ydHMsXG4gIHRvUGFja2FnZU5hbWUsXG59IGZyb20gJy4vcHl0aG9uL3R5cGUtbmFtZSc7XG5pbXBvcnQgeyBkaWUsIHRvUHl0aG9uSWRlbnRpZmllciB9IGZyb20gJy4vcHl0aG9uL3V0aWwnO1xuaW1wb3J0IHsgdG9QeXRob25WZXJzaW9uUmFuZ2UsIHRvUmVsZWFzZVZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24tdXRpbHMnO1xuXG5pbXBvcnQgeyBJTkNPTVBMRVRFX0RJU0NMQUlNRVJfTk9OQ09NUElMSU5HLCBUYXJnZXROYW1lIH0gZnJvbSAnLic7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzLEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbmNvbnN0IHNwZHhMaWNlbnNlTGlzdCA9IHJlcXVpcmUoJ3NwZHgtbGljZW5zZS1saXN0Jyk7XG5cbmNvbnN0IHJlcXVpcmVtZW50c0ZpbGUgPSBwYXRoLnJlc29sdmUoXG4gIF9fZGlybmFtZSxcbiAgJ3B5dGhvbicsXG4gICdyZXF1aXJlbWVudHMtZGV2LnR4dCcsXG4pO1xuXG4vLyB3ZSB1c2Ugc2luZ2xlLXF1b3RlcyBmb3IgbXVsdGktbGluZSBzdHJpbmdzIHRvIGFsbG93IGV4YW1wbGVzIHdpdGhpbiB0aGVcbi8vIGRvY3N0cmluZ3MgdGhlbXNlbHZlcyB0byBpbmNsdWRlIGRvdWJsZS1xdW90ZXMgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vYXdzL2pzaWkvaXNzdWVzLzI1NjkpXG5jb25zdCBET0NTVFJJTkdfUVVPVEVTID0gXCInJydcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHl0aG9uIGV4dGVuZHMgVGFyZ2V0IHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGdlbmVyYXRvcjogUHl0aG9uR2VuZXJhdG9yO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihvcHRpb25zOiBUYXJnZXRPcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICB0aGlzLmdlbmVyYXRvciA9IG5ldyBQeXRob25HZW5lcmF0b3Iob3B0aW9ucy5yb3NldHRhKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZW5lcmF0ZUNvZGUob3V0RGlyOiBzdHJpbmcsIHRhcmJhbGw6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHN1cGVyLmdlbmVyYXRlQ29kZShvdXREaXIsIHRhcmJhbGwpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGJ1aWxkKHNvdXJjZURpcjogc3RyaW5nLCBvdXREaXI6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIENyZWF0ZSBhIGZyZXNoIHZpcnR1YWwgZW52XG4gICAgY29uc3QgdmVudiA9IGF3YWl0IGZzLm1rZHRlbXAocGF0aC5qb2luKHNvdXJjZURpciwgJy5lbnYtJykpO1xuICAgIGNvbnN0IHZlbnZCaW4gPSBwYXRoLmpvaW4oXG4gICAgICB2ZW52LFxuICAgICAgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/ICdTY3JpcHRzJyA6ICdiaW4nLFxuICAgICk7XG4gICAgYXdhaXQgc2hlbGwoJ3B5dGhvbjMnLCBbXG4gICAgICAnLW0nLFxuICAgICAgJ3ZlbnYnLFxuICAgICAgJy0tc3lzdGVtLXNpdGUtcGFja2FnZXMnLCAvLyBBbGxvdyB1c2luZyBnbG9iYWxseSBpbnN0YWxsZWQgcGFja2FnZXMgKHNhdmVzIHRpbWUgJiBkaXNrIHNwYWNlKVxuICAgICAgdmVudixcbiAgICBdKTtcbiAgICBjb25zdCBlbnYgPSB7XG4gICAgICAuLi5wcm9jZXNzLmVudixcbiAgICAgIFBBVEg6IGAke3ZlbnZCaW59OiR7cHJvY2Vzcy5lbnYuUEFUSH1gLFxuICAgICAgVklSVFVBTF9FTlY6IHZlbnYsXG4gICAgfTtcbiAgICBjb25zdCBweXRob24gPSBwYXRoLmpvaW4odmVudkJpbiwgJ3B5dGhvbicpO1xuXG4gICAgLy8gSW5zdGFsbCB0aGUgbmVjZXNzYXJ5IHRoaW5nc1xuICAgIGF3YWl0IHNoZWxsKFxuICAgICAgcHl0aG9uLFxuICAgICAgWyctbScsICdwaXAnLCAnaW5zdGFsbCcsICctLW5vLWlucHV0JywgJy1yJywgcmVxdWlyZW1lbnRzRmlsZV0sXG4gICAgICB7XG4gICAgICAgIGN3ZDogc291cmNlRGlyLFxuICAgICAgICBlbnYsXG4gICAgICAgIHJldHJ5OiB7IG1heEF0dGVtcHRzOiA1IH0sXG4gICAgICB9LFxuICAgICk7XG5cbiAgICAvLyBBY3R1YWxseSBwYWNrYWdlIHVwIG91ciBjb2RlLCBib3RoIGFzIGEgc2Rpc3QgYW5kIGEgd2hlZWwgZm9yIHB1Ymxpc2hpbmcuXG4gICAgYXdhaXQgc2hlbGwocHl0aG9uLCBbJ3NldHVwLnB5JywgJ3NkaXN0JywgJy0tZGlzdC1kaXInLCBvdXREaXJdLCB7XG4gICAgICBjd2Q6IHNvdXJjZURpcixcbiAgICAgIGVudixcbiAgICB9KTtcbiAgICBhd2FpdCBzaGVsbChcbiAgICAgIHB5dGhvbixcbiAgICAgIFsnLW0nLCAncGlwJywgJ3doZWVsJywgJy0tbm8tZGVwcycsICctLXdoZWVsLWRpcicsIG91dERpciwgc291cmNlRGlyXSxcbiAgICAgIHtcbiAgICAgICAgY3dkOiBzb3VyY2VEaXIsXG4gICAgICAgIGVudixcbiAgICAgICAgcmV0cnk6IHsgbWF4QXR0ZW1wdHM6IDUgfSxcbiAgICAgIH0sXG4gICAgKTtcbiAgICBhd2FpdCBzaGVsbChweXRob24sIFsnLW0nLCAndHdpbmUnLCAnY2hlY2snLCBwYXRoLmpvaW4ob3V0RGlyLCAnKicpXSwge1xuICAgICAgY3dkOiBzb3VyY2VEaXIsXG4gICAgICBlbnYsXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyAjIENPREUgR0VORVJBVE9SICNcbi8vICMjIyMjIyMjIyMjIyMjIyMjI1xuXG5pbnRlcmZhY2UgRW1pdENvbnRleHQgZXh0ZW5kcyBOYW1pbmdDb250ZXh0IHtcbiAgLyoqIEBkZXByZWNhdGVkIFRoZSBUeXBlUmVzb2x2ZXIgKi9cbiAgcmVhZG9ubHkgcmVzb2x2ZXI6IFR5cGVSZXNvbHZlcjtcbn1cblxuY29uc3QgcHl0aG9uTW9kdWxlTmFtZVRvRmlsZW5hbWUgPSAobmFtZTogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIHBhdGguam9pbiguLi5uYW1lLnNwbGl0KCcuJykpO1xufTtcblxuY29uc3QgdG9QeXRob25NZXRob2ROYW1lID0gKG5hbWU6IHN0cmluZywgcHJvdGVjdGVkSXRlbSA9IGZhbHNlKTogc3RyaW5nID0+IHtcbiAgbGV0IHZhbHVlID0gdG9QeXRob25JZGVudGlmaWVyKHRvU25ha2VDYXNlKG5hbWUpKTtcbiAgaWYgKHByb3RlY3RlZEl0ZW0pIHtcbiAgICB2YWx1ZSA9IGBfJHt2YWx1ZX1gO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbmNvbnN0IHRvUHl0aG9uUHJvcGVydHlOYW1lID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIGNvbnN0YW50ID0gZmFsc2UsXG4gIHByb3RlY3RlZEl0ZW0gPSBmYWxzZSxcbik6IHN0cmluZyA9PiB7XG4gIGxldCB2YWx1ZSA9IHRvUHl0aG9uSWRlbnRpZmllcih0b1NuYWtlQ2FzZShuYW1lKSk7XG5cbiAgaWYgKGNvbnN0YW50KSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50b1VwcGVyQ2FzZSgpO1xuICB9XG5cbiAgaWYgKHByb3RlY3RlZEl0ZW0pIHtcbiAgICB2YWx1ZSA9IGBfJHt2YWx1ZX1gO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGdpdmVuIHNpZ25hdHVyZSdzIHBhcmFtZXRlciBuYW1lIHRvIHdoYXQgc2hvdWxkIGJlIGVtaXR0ZWQgaW4gUHl0aG9uLiBJdCBzbHVnaWZpZXMgdGhlXG4gKiBwb3NpdGlvbmFsIHBhcmFtZXRlciBuYW1lcyB0aGF0IGNvbGxpZGUgd2l0aCBhIGxpZnRlZCBwcm9wIGJ5IGFwcGVuZGluZyB0cmFpbGluZyBgX2AuIFRoZXJlIGlzIG5vXG4gKiByaXNrIG9mIGNvbmZsaWN0aW5nIHdpdGggYW4gb3RoZXIgcG9zaXRpb25hbCBwYXJhbWV0ZXIgdGhhdCBlbmRzIHdpdGggYSBgX2AgY2hhcmFjdGVyIGJlY2F1c2VcbiAqIHRoaXMgaXMgcHJvaGliaXRlZCBieSB0aGUgYGpzaWlgIGNvbXBpbGVyIChwYXJhbWV0ZXIgbmFtZXMgTVVTVCBiZSBjYW1lbENhc2UsIGFuZCBvbmx5IGEgc2luZ2xlXG4gKiBgX2AgaXMgcGVybWl0dGVkIHdoZW4gaXQgaXMgb24gKipsZWFkaW5nKiogcG9zaXRpb24pXG4gKlxuICogQHBhcmFtIG5hbWUgICAgICAgICAgICAgIHRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgdGhhdCBuZWVkcyBjb252ZXJzaW9uLlxuICogQHBhcmFtIGxpZnRlZFBhcmFtTmFtZXMgIHRoZSBsaXN0IG9mIFwibGlmdGVkXCIga2V5d29yZCBwYXJhbWV0ZXJzIGluIHRoaXMgc2lnbmF0dXJlLiBUaGlzIG11c3QgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBvbWl0dGVkIHdoZW4gZ2VuZXJhdGluZyBhIG5hbWUgZm9yIGEgcGFyYW1ldGVyIHRoYXQgKippcyoqIGxpZnRlZC5cbiAqL1xuZnVuY3Rpb24gdG9QeXRob25QYXJhbWV0ZXJOYW1lKFxuICBuYW1lOiBzdHJpbmcsXG4gIGxpZnRlZFBhcmFtTmFtZXMgPSBuZXcgU2V0PHN0cmluZz4oKSxcbik6IHN0cmluZyB7XG4gIGxldCByZXN1bHQgPSB0b1B5dGhvbklkZW50aWZpZXIodG9TbmFrZUNhc2UobmFtZSkpO1xuXG4gIHdoaWxlIChsaWZ0ZWRQYXJhbU5hbWVzLmhhcyhyZXN1bHQpKSB7XG4gICAgcmVzdWx0ICs9ICdfJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IHNldERpZmZlcmVuY2UgPSA8VD4oc2V0QTogU2V0PFQ+LCBzZXRCOiBTZXQ8VD4pOiBTZXQ8VD4gPT4ge1xuICBjb25zdCByZXN1bHQgPSBuZXcgU2V0PFQ+KCk7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBzZXRBKSB7XG4gICAgaWYgKCFzZXRCLmhhcyhpdGVtKSkge1xuICAgICAgcmVzdWx0LmFkZChpdGVtKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUHJlcGFyZSBweXRob24gbWVtYmVycyBmb3IgZW1pc3Npb24uXG4gKlxuICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIG1lbWJlcnMgb2YgdGhlIHNhbWUgbmFtZSwgdGhleSB3aWxsIGFsbCBtYXAgdG8gdGhlIHNhbWUgcHl0aG9uXG4gKiBuYW1lLCBzbyB3ZSB3aWxsIGZpbHRlciBhbGwgZGVwcmVjYXRlZCBtZW1iZXJzIGFuZCBleHBlY3QgdGhhdCB0aGVyZSB3aWxsIGJlIG9ubHkgb25lXG4gKiBsZWZ0LlxuICpcbiAqIFJldHVybnMgdGhlIG1lbWJlcnMgaW4gYSBzb3J0ZWQgbGlzdC5cbiAqL1xuZnVuY3Rpb24gcHJlcGFyZU1lbWJlcnMobWVtYmVyczogUHl0aG9uQmFzZVtdLCByZXNvbHZlcjogVHlwZVJlc29sdmVyKSB7XG4gIC8vIGNyZWF0ZSBhIG1hcCBmcm9tIHB5dGhvbiBuYW1lIHRvIGxpc3Qgb2YgbWVtYmVyc1xuICBjb25zdCBtYXA6IHsgW3B5dGhvbk5hbWU6IHN0cmluZ106IFB5dGhvbkJhc2VbXSB9ID0ge307XG4gIGZvciAoY29uc3QgbSBvZiBtZW1iZXJzKSB7XG4gICAgbGV0IGxpc3QgPSBtYXBbbS5weXRob25OYW1lXTtcbiAgICBpZiAoIWxpc3QpIHtcbiAgICAgIGxpc3QgPSBtYXBbbS5weXRob25OYW1lXSA9IFtdO1xuICAgIH1cblxuICAgIGxpc3QucHVzaChtKTtcbiAgfVxuXG4gIC8vIG5vdyByZXR1cm4gYWxsIHRoZSBtZW1iZXJzXG4gIGNvbnN0IHJldCA9IG5ldyBBcnJheTxQeXRob25CYXNlPigpO1xuXG4gIGZvciAoY29uc3QgW25hbWUsIGxpc3RdIG9mIE9iamVjdC5lbnRyaWVzKG1hcCkpIHtcbiAgICBsZXQgbWVtYmVyO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBpZiB3ZSBoYXZlIGEgc2luZ2xlIG1lbWJlciBmb3IgdGhpcyBub3JtYWxpemVkIG5hbWUsIHRoZW4gdXNlIGl0XG4gICAgICBtZW1iZXIgPSBsaXN0WzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3ZSBmb3VuZCBtb3JlIHRoYW4gb25lIG1lbWJlciB3aXRoIHRoZSBzYW1lIHB5dGhvbiBuYW1lLCBmaWx0ZXIgYWxsXG4gICAgICAvLyBkZXByZWNhdGVkIHZlcnNpb25zIGFuZCBjaGVjayB0aGF0IHdlIGFyZSBsZWZ0IHdpdGggZXhhY3RseSBvbmUuXG4gICAgICAvLyBvdGhlcndpc2UsIHRoZXkgd2lsbCBvdmVyd3JpdGUgZWFjaCBvdGhlclxuICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvanNpaS9pc3N1ZXMvMjUwOFxuICAgICAgY29uc3Qgbm9uRGVwcmVjYXRlZCA9IGxpc3QuZmlsdGVyKCh4KSA9PiAhaXNEZXByZWNhdGVkKHgpKTtcbiAgICAgIGlmIChub25EZXByZWNhdGVkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBNdWx0aXBsZSBub24tZGVwcmVjYXRlZCBtZW1iZXJzIHdoaWNoIG1hcCB0byB0aGUgUHl0aG9uIG5hbWUgXCIke25hbWV9XCJgLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9uRGVwcmVjYXRlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBNdWx0aXBsZSBtZW1iZXJzIHdoaWNoIG1hcCB0byB0aGUgUHl0aG9uIG5hbWUgXCIke25hbWV9XCIsIGJ1dCBhbGwgb2YgdGhlbSBhcmUgZGVwcmVjYXRlZGAsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIG1lbWJlciA9IG5vbkRlcHJlY2F0ZWRbMF07XG4gICAgfVxuXG4gICAgcmV0LnB1c2gobWVtYmVyKTtcbiAgfVxuXG4gIHJldHVybiBzb3J0TWVtYmVycyhyZXQsIHJlc29sdmVyKTtcbn1cblxuY29uc3Qgc29ydE1lbWJlcnMgPSAoXG4gIG1lbWJlcnM6IFB5dGhvbkJhc2VbXSxcbiAgcmVzb2x2ZXI6IFR5cGVSZXNvbHZlcixcbik6IFB5dGhvbkJhc2VbXSA9PiB7XG4gIGxldCBzb3J0YWJsZSA9IG5ldyBBcnJheTx7XG4gICAgbWVtYmVyOiBQeXRob25CYXNlICYgSVNvcnRhYmxlVHlwZTtcbiAgICBkZXBlbmRzT246IFNldDxQeXRob25UeXBlPjtcbiAgfT4oKTtcbiAgY29uc3Qgc29ydGVkID0gbmV3IEFycmF5PFB5dGhvbkJhc2U+KCk7XG4gIGNvbnN0IHNlZW4gPSBuZXcgU2V0PFB5dGhvbkJhc2U+KCk7XG5cbiAgLy8gVGhlIGZpcnN0IHRoaW5nIHdlIHdhbnQgdG8gZG8sIGlzIHB1c2ggYW55IGl0ZW0gd2hpY2ggaXMgbm90IHNvcnRhYmxlIHRvIHRoZSB2ZXJ5XG4gIC8vIGZyb250IG9mIHRoZSBsaXN0LiBUaGlzIHdpbGwgYmUgdGhpbmdzIGxpa2UgbWV0aG9kcywgcHJvcGVydGllcywgZXRjLlxuICBmb3IgKGNvbnN0IG1lbWJlciBvZiBtZW1iZXJzKSB7XG4gICAgaWYgKCFpc1NvcnRhYmxlVHlwZShtZW1iZXIpKSB7XG4gICAgICBzb3J0ZWQucHVzaChtZW1iZXIpO1xuICAgICAgc2Vlbi5hZGQobWVtYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc29ydGFibGUucHVzaCh7IG1lbWJlciwgZGVwZW5kc09uOiBuZXcgU2V0KG1lbWJlci5kZXBlbmRzT24ocmVzb2x2ZXIpKSB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBOb3cgdGhhdCB3ZSd2ZSBwdWxsZWQgb3V0IGV2ZXJ5dGhpbmcgdGhhdCBjb3VsZG4ndCBwb3NzaWJseSBoYXZlIGRlcGVuZGVuY2llcyxcbiAgLy8gd2Ugd2lsbCBnbyB0aHJvdWdoIHRoZSByZW1haW5pbmcgaXRlbXMsIGFuZCBwdWxsIG9mZiBhbnkgaXRlbXMgd2hpY2ggaGF2ZSBub1xuICAvLyBkZXBlbmRlbmNpZXMgdGhhdCB3ZSBoYXZlbid0IGFscmVhZHkgc29ydGVkLlxuICB3aGlsZSAoc29ydGFibGUubGVuZ3RoID4gMCkge1xuICAgIGZvciAoY29uc3QgeyBtZW1iZXIsIGRlcGVuZHNPbiB9IG9mIHNvcnRhYmxlKSB7XG4gICAgICBjb25zdCBkaWZmID0gc2V0RGlmZmVyZW5jZShkZXBlbmRzT24sIHNlZW4pO1xuICAgICAgaWYgKFsuLi5kaWZmXS5maW5kKChkZXApID0+ICEoZGVwIGluc3RhbmNlb2YgUHl0aG9uTW9kdWxlKSkgPT0gbnVsbCkge1xuICAgICAgICBzb3J0ZWQucHVzaChtZW1iZXIpO1xuICAgICAgICBzZWVuLmFkZChtZW1iZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGxlZnRvdmVyID0gc29ydGFibGUuZmlsdGVyKCh7IG1lbWJlciB9KSA9PiAhc2Vlbi5oYXMobWVtYmVyKSk7XG4gICAgaWYgKGxlZnRvdmVyLmxlbmd0aCA9PT0gc29ydGFibGUubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDb3VsZCBub3Qgc29ydCBtZW1iZXJzIChjaXJjdWxhciBkZXBlbmRlbmN5PykuIExlZnRvdmVyOiAke2xlZnRvdmVyXG4gICAgICAgICAgLm1hcCgobG8pID0+IGxvLm1lbWJlci5weXRob25OYW1lKVxuICAgICAgICAgIC5qb2luKCcsICcpfWAsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3J0YWJsZSA9IGxlZnRvdmVyO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb3J0ZWQ7XG59O1xuXG5pbnRlcmZhY2UgUHl0aG9uQmFzZSB7XG4gIHJlYWRvbmx5IHB5dGhvbk5hbWU6IHN0cmluZztcbiAgcmVhZG9ubHkgZG9jcz86IHNwZWMuRG9jcztcblxuICBlbWl0KGNvZGU6IENvZGVNYWtlciwgY29udGV4dDogRW1pdENvbnRleHQsIG9wdHM/OiBhbnkpOiB2b2lkO1xuXG4gIHJlcXVpcmVkSW1wb3J0cyhjb250ZXh0OiBFbWl0Q29udGV4dCk6IFB5dGhvbkltcG9ydHM7XG59XG5cbmludGVyZmFjZSBQeXRob25UeXBlIGV4dGVuZHMgUHl0aG9uQmFzZSB7XG4gIC8vIFRoZSBKU0lJIEZRTiBmb3IgdGhpcyBpdGVtLCBpZiB0aGlzIGl0ZW0gZG9lc24ndCBleGlzdCBhcyBhIEpTSUkgdHlwZSwgdGhlbiBpdFxuICAvLyBkb2Vzbid0IGhhdmUgYSBGUU4gYW5kIGl0IHNob3VsZCBiZSBudWxsO1xuICByZWFkb25seSBmcW4/OiBzdHJpbmc7XG5cbiAgYWRkTWVtYmVyKG1lbWJlcjogUHl0aG9uQmFzZSk6IHZvaWQ7XG59XG5cbmludGVyZmFjZSBJU29ydGFibGVUeXBlIHtcbiAgZGVwZW5kc09uKHJlc29sdmVyOiBUeXBlUmVzb2x2ZXIpOiBQeXRob25UeXBlW107XG59XG5cbmZ1bmN0aW9uIGlzU29ydGFibGVUeXBlKGFyZzogdW5rbm93bik6IGFyZyBpcyBJU29ydGFibGVUeXBlIHtcbiAgcmV0dXJuIChhcmcgYXMgUGFydGlhbDxJU29ydGFibGVUeXBlPikuZGVwZW5kc09uICE9PSB1bmRlZmluZWQ7XG59XG5cbmludGVyZmFjZSBQeXRob25UeXBlT3B0cyB7XG4gIGJhc2VzPzogc3BlYy5UeXBlUmVmZXJlbmNlW107XG59XG5cbmFic3RyYWN0IGNsYXNzIEJhc2VQeXRob25DbGFzc1R5cGUgaW1wbGVtZW50cyBQeXRob25UeXBlLCBJU29ydGFibGVUeXBlIHtcbiAgcHJvdGVjdGVkIGJhc2VzOiBzcGVjLlR5cGVSZWZlcmVuY2VbXTtcbiAgcHJvdGVjdGVkIG1lbWJlcnM6IFB5dGhvbkJhc2VbXTtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHNlcGFyYXRlTWVtYmVyczogYm9vbGVhbiA9IHRydWU7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCByZWFkb25seSBnZW5lcmF0b3I6IFB5dGhvbkdlbmVyYXRvcixcbiAgICBwdWJsaWMgcmVhZG9ubHkgcHl0aG9uTmFtZTogc3RyaW5nLFxuICAgIHB1YmxpYyByZWFkb25seSBzcGVjOiBzcGVjLlR5cGUsXG4gICAgcHVibGljIHJlYWRvbmx5IGZxbjogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIG9wdHM6IFB5dGhvblR5cGVPcHRzLFxuICAgIHB1YmxpYyByZWFkb25seSBkb2NzOiBzcGVjLkRvY3MgfCB1bmRlZmluZWQsXG4gICkge1xuICAgIGNvbnN0IHsgYmFzZXMgPSBbXSB9ID0gb3B0cztcblxuICAgIHRoaXMuYmFzZXMgPSBiYXNlcztcbiAgICB0aGlzLm1lbWJlcnMgPSBbXTtcbiAgfVxuXG4gIHB1YmxpYyBkZXBlbmRzT24ocmVzb2x2ZXI6IFR5cGVSZXNvbHZlcik6IFB5dGhvblR5cGVbXSB7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gbmV3IEFycmF5PFB5dGhvblR5cGU+KCk7XG4gICAgY29uc3QgcGFyZW50ID0gcmVzb2x2ZXIuZ2V0UGFyZW50KHRoaXMuZnFuISk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIHJldHVybiBhbnkgYmFzZXMgdGhhdCBhcmUgaW4gdGhlIHNhbWUgbW9kdWxlIGF0IHRoZSBzYW1lIGxldmVsIG9mXG4gICAgLy8gbmVzdGluZy5cbiAgICBjb25zdCBzZWVuID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgZm9yIChjb25zdCBiYXNlIG9mIHRoaXMuYmFzZXMpIHtcbiAgICAgIGlmIChzcGVjLmlzTmFtZWRUeXBlUmVmZXJlbmNlKGJhc2UpKSB7XG4gICAgICAgIGlmIChyZXNvbHZlci5pc0luTW9kdWxlKGJhc2UpKSB7XG4gICAgICAgICAgLy8gR2l2ZW4gYSBiYXNlLCB3ZSBuZWVkIHRvIGxvY2F0ZSB0aGUgYmFzZSdzIHBhcmVudCB0aGF0IGlzIHRoZSBzYW1lIGFzXG4gICAgICAgICAgLy8gb3VyIHBhcmVudCwgYmVjYXVzZSB3ZSBvbmx5IGNhcmUgYWJvdXQgZGVwZW5kZW5jaWVzIHRoYXQgYXJlIGF0IHRoZVxuICAgICAgICAgIC8vIHNhbWUgbGV2ZWwgb2Ygb3VyIG93bi5cbiAgICAgICAgICAvLyBUT0RPOiBXZSBtaWdodCBuZWVkIHRvIHJlY3Vyc2UgaW50byBvdXIgbWVtYmVycyB0byBhbHNvIGZpbmQgdGhlaXJcbiAgICAgICAgICAvLyAgICAgICBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAgbGV0IGJhc2VJdGVtID0gcmVzb2x2ZXIuZ2V0VHlwZShiYXNlKTtcbiAgICAgICAgICBsZXQgYmFzZVBhcmVudCA9IHJlc29sdmVyLmdldFBhcmVudChiYXNlKTtcbiAgICAgICAgICB3aGlsZSAoYmFzZVBhcmVudCAhPT0gcGFyZW50KSB7XG4gICAgICAgICAgICBiYXNlSXRlbSA9IGJhc2VQYXJlbnQ7XG4gICAgICAgICAgICBiYXNlUGFyZW50ID0gcmVzb2x2ZXIuZ2V0UGFyZW50KGJhc2VJdGVtLmZxbiEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghc2Vlbi5oYXMoYmFzZUl0ZW0uZnFuISkpIHtcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKGJhc2VJdGVtKTtcbiAgICAgICAgICAgIHNlZW4uYWRkKGJhc2VJdGVtLmZxbiEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cblxuICBwdWJsaWMgcmVxdWlyZWRJbXBvcnRzKGNvbnRleHQ6IEVtaXRDb250ZXh0KTogUHl0aG9uSW1wb3J0cyB7XG4gICAgcmV0dXJuIG1lcmdlUHl0aG9uSW1wb3J0cyhcbiAgICAgIC4uLnRoaXMuYmFzZXMubWFwKChiYXNlKSA9PiB0b1R5cGVOYW1lKGJhc2UpLnJlcXVpcmVkSW1wb3J0cyhjb250ZXh0KSksXG4gICAgICAuLi50aGlzLm1lbWJlcnMubWFwKChtZW0pID0+IG1lbS5yZXF1aXJlZEltcG9ydHMoY29udGV4dCkpLFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgYWRkTWVtYmVyKG1lbWJlcjogUHl0aG9uQmFzZSkge1xuICAgIHRoaXMubWVtYmVycy5wdXNoKG1lbWJlcik7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGFwaUxvY2F0aW9uKCk6IEFwaUxvY2F0aW9uIHtcbiAgICBpZiAoIXRoaXMuZnFuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgbWFrZSBhcGlMb2NhdGlvbiBmb3IgJHt0aGlzLnB5dGhvbk5hbWV9LCBkb2VzIG5vdCBoYXZlIEZRTmAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4geyBhcGk6ICd0eXBlJywgZnFuOiB0aGlzLmZxbiB9O1xuICB9XG5cbiAgcHVibGljIGVtaXQoY29kZTogQ29kZU1ha2VyLCBjb250ZXh0OiBFbWl0Q29udGV4dCkge1xuICAgIGNvbnRleHQgPSBuZXN0ZWRDb250ZXh0KGNvbnRleHQsIHRoaXMuZnFuKTtcblxuICAgIGNvbnN0IGNsYXNzUGFyYW1zID0gdGhpcy5nZXRDbGFzc1BhcmFtcyhjb250ZXh0KTtcbiAgICBvcGVuU2lnbmF0dXJlKGNvZGUsICdjbGFzcycsIHRoaXMucHl0aG9uTmFtZSwgY2xhc3NQYXJhbXMpO1xuXG4gICAgdGhpcy5nZW5lcmF0b3IuZW1pdERvY1N0cmluZyhjb2RlLCB0aGlzLmFwaUxvY2F0aW9uLCB0aGlzLmRvY3MsIHtcbiAgICAgIGRvY3VtZW50YWJsZUl0ZW06IGBjbGFzcy0ke3RoaXMucHl0aG9uTmFtZX1gLFxuICAgICAgdHJhaWxpbmdOZXdMaW5lOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMubWVtYmVycy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZXNvbHZlciA9IHRoaXMuYm91bmRSZXNvbHZlcihjb250ZXh0LnJlc29sdmVyKTtcbiAgICAgIGxldCBzaG91bGRTZXBhcmF0ZSA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgcHJlcGFyZU1lbWJlcnModGhpcy5tZW1iZXJzLCByZXNvbHZlcikpIHtcbiAgICAgICAgaWYgKHNob3VsZFNlcGFyYXRlKSB7XG4gICAgICAgICAgY29kZS5saW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2hvdWxkU2VwYXJhdGUgPSB0aGlzLnNlcGFyYXRlTWVtYmVycztcbiAgICAgICAgbWVtYmVyLmVtaXQoY29kZSwgeyAuLi5jb250ZXh0LCByZXNvbHZlciB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29kZS5saW5lKCdwYXNzJyk7XG4gICAgfVxuXG4gICAgY29kZS5jbG9zZUJsb2NrKCk7XG5cbiAgICBpZiAodGhpcy5mcW4gIT0gbnVsbCkge1xuICAgICAgY29udGV4dC5lbWl0dGVkVHlwZXMuYWRkKHRoaXMuZnFuKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgYm91bmRSZXNvbHZlcihyZXNvbHZlcjogVHlwZVJlc29sdmVyKTogVHlwZVJlc29sdmVyIHtcbiAgICBpZiAodGhpcy5mcW4gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVyO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZXIuYmluZCh0aGlzLmZxbik7XG4gIH1cblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0Q2xhc3NQYXJhbXMoY29udGV4dDogRW1pdENvbnRleHQpOiBzdHJpbmdbXTtcbn1cblxuaW50ZXJmYWNlIEJhc2VNZXRob2RPcHRzIHtcbiAgYWJzdHJhY3Q/OiBib29sZWFuO1xuICBsaWZ0ZWRQcm9wPzogc3BlYy5JbnRlcmZhY2VUeXBlO1xuICBwYXJlbnQ6IHNwZWMuTmFtZWRUeXBlUmVmZXJlbmNlO1xufVxuXG5pbnRlcmZhY2UgQmFzZU1ldGhvZEVtaXRPcHRzIHtcbiAgcmVuZGVyQWJzdHJhY3Q/OiBib29sZWFuO1xuICBmb3JjZUVtaXRCb2R5PzogYm9vbGVhbjtcbn1cblxuYWJzdHJhY3QgY2xhc3MgQmFzZU1ldGhvZCBpbXBsZW1lbnRzIFB5dGhvbkJhc2Uge1xuICBwdWJsaWMgcmVhZG9ubHkgYWJzdHJhY3Q6IGJvb2xlYW47XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHJlYWRvbmx5IGltcGxpY2l0UGFyYW1ldGVyOiBzdHJpbmc7XG4gIHByb3RlY3RlZCByZWFkb25seSBqc2lpTWV0aG9kITogc3RyaW5nO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZGVjb3JhdG9yPzogc3RyaW5nO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgY2xhc3NBc0ZpcnN0UGFyYW1ldGVyOiBib29sZWFuID0gZmFsc2U7XG4gIHByb3RlY3RlZCByZWFkb25seSByZXR1cm5Gcm9tSlNJSU1ldGhvZDogYm9vbGVhbiA9IHRydWU7XG4gIHByb3RlY3RlZCByZWFkb25seSBzaG91bGRFbWl0Qm9keTogYm9vbGVhbiA9IHRydWU7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBsaWZ0ZWRQcm9wPzogc3BlYy5JbnRlcmZhY2VUeXBlO1xuICBwcml2YXRlIHJlYWRvbmx5IHBhcmVudDogc3BlYy5OYW1lZFR5cGVSZWZlcmVuY2U7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCByZWFkb25seSBnZW5lcmF0b3I6IFB5dGhvbkdlbmVyYXRvcixcbiAgICBwdWJsaWMgcmVhZG9ubHkgcHl0aG9uTmFtZTogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkganNOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgcHJpdmF0ZSByZWFkb25seSBwYXJhbWV0ZXJzOiBzcGVjLlBhcmFtZXRlcltdLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcmV0dXJuczogc3BlYy5PcHRpb25hbFZhbHVlIHwgdW5kZWZpbmVkLFxuICAgIHB1YmxpYyByZWFkb25seSBkb2NzOiBzcGVjLkRvY3MgfCB1bmRlZmluZWQsXG4gICAgcHVibGljIHJlYWRvbmx5IGlzU3RhdGljOiBib29sZWFuLFxuICAgIG9wdHM6IEJhc2VNZXRob2RPcHRzLFxuICApIHtcbiAgICB0aGlzLmFic3RyYWN0ID0gISFvcHRzLmFic3RyYWN0O1xuICAgIHRoaXMubGlmdGVkUHJvcCA9IG9wdHMubGlmdGVkUHJvcDtcbiAgICB0aGlzLnBhcmVudCA9IG9wdHMucGFyZW50O1xuICB9XG5cbiAgcHVibGljIGdldCBhcGlMb2NhdGlvbigpOiBBcGlMb2NhdGlvbiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFwaTogJ21lbWJlcicsXG4gICAgICBmcW46IHRoaXMucGFyZW50LmZxbixcbiAgICAgIG1lbWJlck5hbWU6IHRoaXMuanNOYW1lID8/ICcnLFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgcmVxdWlyZWRJbXBvcnRzKGNvbnRleHQ6IEVtaXRDb250ZXh0KTogUHl0aG9uSW1wb3J0cyB7XG4gICAgcmV0dXJuIG1lcmdlUHl0aG9uSW1wb3J0cyhcbiAgICAgIHRvVHlwZU5hbWUodGhpcy5yZXR1cm5zKS5yZXF1aXJlZEltcG9ydHMoY29udGV4dCksXG4gICAgICAuLi50aGlzLnBhcmFtZXRlcnMubWFwKChwYXJhbSkgPT5cbiAgICAgICAgdG9UeXBlTmFtZShwYXJhbSkucmVxdWlyZWRJbXBvcnRzKGNvbnRleHQpLFxuICAgICAgKSxcbiAgICAgIC4uLmxpZnRlZFByb3BlcnRpZXModGhpcy5saWZ0ZWRQcm9wKSxcbiAgICApO1xuXG4gICAgZnVuY3Rpb24qIGxpZnRlZFByb3BlcnRpZXMoXG4gICAgICBzdHJ1Y3Q6IHNwZWMuSW50ZXJmYWNlVHlwZSB8IHVuZGVmaW5lZCxcbiAgICApOiBJdGVyYWJsZUl0ZXJhdG9yPFB5dGhvbkltcG9ydHM+IHtcbiAgICAgIGlmIChzdHJ1Y3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHByb3Agb2Ygc3RydWN0LnByb3BlcnRpZXMgPz8gW10pIHtcbiAgICAgICAgeWllbGQgdG9UeXBlTmFtZShwcm9wLnR5cGUpLnJlcXVpcmVkSW1wb3J0cyhjb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgYmFzZSBvZiBzdHJ1Y3QuaW50ZXJmYWNlcyA/PyBbXSkge1xuICAgICAgICBjb25zdCBpZmFjZSA9IGNvbnRleHQucmVzb2x2ZXIuZGVyZWZlcmVuY2UoYmFzZSkgYXMgc3BlYy5JbnRlcmZhY2VUeXBlO1xuICAgICAgICBmb3IgKGNvbnN0IGltcG9ydHMgb2YgbGlmdGVkUHJvcGVydGllcyhpZmFjZSkpIHtcbiAgICAgICAgICB5aWVsZCBpbXBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGVtaXQoXG4gICAgY29kZTogQ29kZU1ha2VyLFxuICAgIGNvbnRleHQ6IEVtaXRDb250ZXh0LFxuICAgIG9wdHM/OiBCYXNlTWV0aG9kRW1pdE9wdHMsXG4gICkge1xuICAgIGNvbnN0IHsgcmVuZGVyQWJzdHJhY3QgPSB0cnVlLCBmb3JjZUVtaXRCb2R5ID0gZmFsc2UgfSA9IG9wdHMgPz8ge307XG5cbiAgICBjb25zdCByZXR1cm5UeXBlOiBzdHJpbmcgPSB0b1R5cGVOYW1lKHRoaXMucmV0dXJucykucHl0aG9uVHlwZShjb250ZXh0KTtcblxuICAgIC8vIFdlIGNhbm5vdCAoY3VycmVudGx5PykgYmxpbmRseSB1c2UgdGhlIG5hbWVzIGdpdmVuIHRvIHVzIGJ5IHRoZSBKU0lJIGZvclxuICAgIC8vIGluaXRpYWxpemVycywgYmVjYXVzZSBvdXIga2V5d29yZCBsaWZ0aW5nIHdpbGwgYWxsb3cgdHdvIG5hbWVzIHRvIGNsYXNoLlxuICAgIC8vIFRoaXMgY2FuIGhvcGVmdWxseSBiZSByZW1vdmVkIG9uY2Ugd2UgZ2V0IGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvanNpaS9pc3N1ZXMvMjg4XG4gICAgLy8gcmVzb2x2ZWQsIHNvIGJ1aWxkIHVwIGEgbGlzdCBvZiBhbGwgb2YgdGhlIHByb3AgbmFtZXMgc28gd2UgY2FuIGNoZWNrIGFnYWluc3RcbiAgICAvLyB0aGVtIGxhdGVyLlxuICAgIGNvbnN0IGxpZnRlZFByb3BOYW1lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGlmICh0aGlzLmxpZnRlZFByb3A/LnByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHRoaXMubGlmdGVkUHJvcC5wcm9wZXJ0aWVzKSB7XG4gICAgICAgIGxpZnRlZFByb3BOYW1lcy5hZGQodG9QeXRob25QYXJhbWV0ZXJOYW1lKHByb3AubmFtZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdlIG5lZWQgdG8gdHVybiBhIGxpc3Qgb2YgSlNJSSBwYXJhbWV0ZXJzLCBpbnRvIFB5dGhvbiBzdHlsZSBhcmd1bWVudHMgd2l0aFxuICAgIC8vIGdyYWR1YWwgdHlwaW5nLCBzbyB3ZSdsbCBoYXZlIHRvIGl0ZXJhdGUgb3ZlciB0aGUgbGlzdCBvZiBwYXJhbWV0ZXJzLCBhbmRcbiAgICAvLyBidWlsZCB0aGUgbGlzdCwgY29udmVydGluZyBhcyB3ZSBnby5cbiAgICBjb25zdCBweXRob25QYXJhbXM6IHN0cmluZ1tdID0gW107XG4gICAgZm9yIChjb25zdCBwYXJhbSBvZiB0aGlzLnBhcmFtZXRlcnMpIHtcbiAgICAgIC8vIFdlIGNhbm5vdCAoY3VycmVudGx5PykgYmxpbmRseSB1c2UgdGhlIG5hbWVzIGdpdmVuIHRvIHVzIGJ5IHRoZSBKU0lJIGZvclxuICAgICAgLy8gaW5pdGlhbGl6ZXJzLCBiZWNhdXNlIG91ciBrZXl3b3JkIGxpZnRpbmcgd2lsbCBhbGxvdyB0d28gbmFtZXMgdG8gY2xhc2guXG4gICAgICAvLyBUaGlzIGNhbiBob3BlZnVsbHkgYmUgcmVtb3ZlZCBvbmNlIHdlIGdldCBodHRwczovL2dpdGh1Yi5jb20vYXdzL2pzaWkvaXNzdWVzLzI4OFxuICAgICAgLy8gcmVzb2x2ZWQuXG4gICAgICBjb25zdCBwYXJhbU5hbWU6IHN0cmluZyA9IHRvUHl0aG9uUGFyYW1ldGVyTmFtZShcbiAgICAgICAgcGFyYW0ubmFtZSxcbiAgICAgICAgbGlmdGVkUHJvcE5hbWVzLFxuICAgICAgKTtcblxuICAgICAgY29uc3QgcGFyYW1UeXBlID0gdG9UeXBlTmFtZShwYXJhbSkucHl0aG9uVHlwZSh7XG4gICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgIHBhcmFtZXRlclR5cGU6IHRydWUsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHBhcmFtRGVmYXVsdCA9IHBhcmFtLm9wdGlvbmFsID8gJyA9IE5vbmUnIDogJyc7XG5cbiAgICAgIHB5dGhvblBhcmFtcy5wdXNoKGAke3BhcmFtTmFtZX06ICR7cGFyYW1UeXBlfSR7cGFyYW1EZWZhdWx0fWApO1xuICAgIH1cblxuICAgIGNvbnN0IGRvY3VtZW50YWJsZUFyZ3M6IERvY3VtZW50YWJsZUFyZ3VtZW50W10gPSB0aGlzLnBhcmFtZXRlcnNcbiAgICAgIC5tYXAoXG4gICAgICAgIChwKSA9PlxuICAgICAgICAgICh7XG4gICAgICAgICAgICBuYW1lOiBwLm5hbWUsXG4gICAgICAgICAgICBkb2NzOiBwLmRvY3MsXG4gICAgICAgICAgICBkZWZpbmluZ1R5cGU6IHRoaXMucGFyZW50LFxuICAgICAgICAgIH0gYXMgRG9jdW1lbnRhYmxlQXJndW1lbnQpLFxuICAgICAgKVxuICAgICAgLy8gSWYgdGhlcmUncyBsaWZ0ZWRQcm9wcywgdGhlIGxhc3QgYXJndW1lbnQgaXMgdGhlIHN0cnVjdCBhbmQgaXQgd29uJ3QgYmUgX2FjdHVhbGx5XyBlbWl0dGVkLlxuICAgICAgLmZpbHRlcigoXywgaW5kZXgpID0+XG4gICAgICAgIHRoaXMubGlmdGVkUHJvcCAhPSBudWxsID8gaW5kZXggPCB0aGlzLnBhcmFtZXRlcnMubGVuZ3RoIC0gMSA6IHRydWUsXG4gICAgICApXG4gICAgICAubWFwKChwYXJhbSkgPT4gKHtcbiAgICAgICAgLi4ucGFyYW0sXG4gICAgICAgIG5hbWU6IHRvUHl0aG9uUGFyYW1ldGVyTmFtZShwYXJhbS5uYW1lLCBsaWZ0ZWRQcm9wTmFtZXMpLFxuICAgICAgfSkpO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIGxpZnRlZCBwYXJhbWV0ZXIsIHRoZW4gd2UnbGwgZHJvcCB0aGUgbGFzdCBhcmd1bWVudCB0byBvdXIgcGFyYW1zXG4gICAgLy8gYW5kIHRoZW4gd2UnbGwgbGlmdCBhbGwgb2YgdGhlIHBhcmFtcyBvZiB0aGUgbGlmdGVkIHR5cGUgYXMga2V5d29yZCBhcmd1bWVudHNcbiAgICAvLyB0byB0aGUgZnVuY3Rpb24uXG4gICAgaWYgKHRoaXMubGlmdGVkUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBSZW1vdmUgb3VyIGxhc3QgaXRlbS5cbiAgICAgIHB5dGhvblBhcmFtcy5wb3AoKTtcbiAgICAgIGNvbnN0IGxpZnRlZFByb3BlcnRpZXMgPSB0aGlzLmdldExpZnRlZFByb3BlcnRpZXMoY29udGV4dC5yZXNvbHZlcik7XG5cbiAgICAgIGlmIChsaWZ0ZWRQcm9wZXJ0aWVzLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgIC8vIEFsbCBvZiB0aGVzZSBwYXJhbWV0ZXJzIGFyZSBrZXl3b3JkIG9ubHkgYXJndW1lbnRzLCBzbyB3ZSdsbCBtYXJrIHRoZW1cbiAgICAgICAgLy8gYXMgc3VjaC5cbiAgICAgICAgcHl0aG9uUGFyYW1zLnB1c2goJyonKTtcblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIG9mIG91ciBwcm9wcywgYW5kIHJlZmxlY3QgdGhlbSBpbnRvIG91ciBwYXJhbXMuXG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBsaWZ0ZWRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgY29uc3QgcGFyYW1OYW1lID0gdG9QeXRob25QYXJhbWV0ZXJOYW1lKHByb3AucHJvcC5uYW1lKTtcbiAgICAgICAgICBjb25zdCBwYXJhbVR5cGUgPSB0b1R5cGVOYW1lKHByb3AucHJvcCkucHl0aG9uVHlwZSh7XG4gICAgICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICAgICAgcGFyYW1ldGVyVHlwZTogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBwYXJhbURlZmF1bHQgPSBwcm9wLnByb3Aub3B0aW9uYWwgPyAnID0gTm9uZScgOiAnJztcblxuICAgICAgICAgIHB5dGhvblBhcmFtcy5wdXNoKGAke3BhcmFtTmFtZX06ICR7cGFyYW1UeXBlfSR7cGFyYW1EZWZhdWx0fWApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERvY3VtZW50IHRoZW0gYXMga2V5d29yZCBhcmd1bWVudHNcbiAgICAgIGRvY3VtZW50YWJsZUFyZ3MucHVzaChcbiAgICAgICAgLi4ubGlmdGVkUHJvcGVydGllcy5tYXAoXG4gICAgICAgICAgKHApID0+XG4gICAgICAgICAgICAoe1xuICAgICAgICAgICAgICBuYW1lOiBwLnByb3AubmFtZSxcbiAgICAgICAgICAgICAgZG9jczogcC5wcm9wLmRvY3MsXG4gICAgICAgICAgICAgIGRlZmluaW5nVHlwZTogcC5kZWZpbmluZ1R5cGUsXG4gICAgICAgICAgICB9IGFzIERvY3VtZW50YWJsZUFyZ3VtZW50KSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRoaXMucGFyYW1ldGVycy5sZW5ndGggPj0gMSAmJlxuICAgICAgdGhpcy5wYXJhbWV0ZXJzW3RoaXMucGFyYW1ldGVycy5sZW5ndGggLSAxXS52YXJpYWRpY1xuICAgICkge1xuICAgICAgLy8gQW5vdGhlciBzaXR1YXRpb24gd2UgY291bGQgYmUgaW4sIGlzIHRoYXQgaW5zdGVhZCBvZiBoYXZpbmcgYSBwbGFpbiBwYXJhbWV0ZXJcbiAgICAgIC8vIHdlIGhhdmUgYSB2YXJpYWRpYyBwYXJhbWV0ZXIgd2hlcmUgd2UgbmVlZCB0byBleHBhbmQgdGhlIGxhc3QgcGFyYW1ldGVyIGFzIGFcbiAgICAgIC8vICphcmdzLlxuICAgICAgcHl0aG9uUGFyYW1zLnBvcCgpO1xuXG4gICAgICBjb25zdCBsYXN0UGFyYW1ldGVyID0gdGhpcy5wYXJhbWV0ZXJzLnNsaWNlKC0xKVswXTtcbiAgICAgIGNvbnN0IHBhcmFtTmFtZSA9IHRvUHl0aG9uUGFyYW1ldGVyTmFtZShsYXN0UGFyYW1ldGVyLm5hbWUpO1xuICAgICAgY29uc3QgcGFyYW1UeXBlID0gdG9UeXBlTmFtZShsYXN0UGFyYW1ldGVyLnR5cGUpLnB5dGhvblR5cGUoY29udGV4dCk7XG5cbiAgICAgIHB5dGhvblBhcmFtcy5wdXNoKGAqJHtwYXJhbU5hbWV9OiAke3BhcmFtVHlwZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWNvcmF0b3JzID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICAgIGlmICh0aGlzLmpzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBcIiMgdHlwZTogaWdub3JlW21pc2NdXCIgbmVlZGVkIGJlY2F1c2UgbXlweSBkb2VzIG5vdCBrbm93IGhvdyB0byBjaGVjayBkZWNvcmF0ZWQgZGVjbGFyYXRpb25zXG4gICAgICBkZWNvcmF0b3JzLnB1c2goYEBqc2lpLm1lbWJlcihqc2lpX25hbWU9XCIke3RoaXMuanNOYW1lfVwiKWApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRlY29yYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWNvcmF0b3JzLnB1c2goYEAke3RoaXMuZGVjb3JhdG9yfWApO1xuICAgIH1cblxuICAgIGlmIChyZW5kZXJBYnN0cmFjdCAmJiB0aGlzLmFic3RyYWN0KSB7XG4gICAgICBkZWNvcmF0b3JzLnB1c2goJ0BhYmMuYWJzdHJhY3RtZXRob2QnKTtcbiAgICB9XG5cbiAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBcIiMgdHlwZTogaWdub3JlW21pc2NdXCIgbmVlZGVkIGJlY2F1c2UgbXlweSBkb2VzIG5vdCBrbm93IGhvdyB0byBjaGVjayBkZWNvcmF0ZWQgZGVjbGFyYXRpb25zXG4gICAgICBmb3IgKGNvbnN0IGRlY29yYXRvciBvZiBkZWNvcmF0b3JzXG4gICAgICAgIC5qb2luKCcgIyB0eXBlOiBpZ25vcmVbbWlzY11cXG4nKVxuICAgICAgICAuc3BsaXQoJ1xcbicpKSB7XG4gICAgICAgIGNvZGUubGluZShkZWNvcmF0b3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHB5dGhvblBhcmFtcy51bnNoaWZ0KFxuICAgICAgc2x1Z2lmeUFzTmVlZGVkKFxuICAgICAgICB0aGlzLmltcGxpY2l0UGFyYW1ldGVyLFxuICAgICAgICBweXRob25QYXJhbXMubWFwKChwYXJhbSkgPT4gcGFyYW0uc3BsaXQoJzonKVswXS50cmltKCkpLFxuICAgICAgKSxcbiAgICApO1xuXG4gICAgb3BlblNpZ25hdHVyZShcbiAgICAgIGNvZGUsXG4gICAgICAnZGVmJyxcbiAgICAgIHRoaXMucHl0aG9uTmFtZSxcbiAgICAgIHB5dGhvblBhcmFtcyxcbiAgICAgIGZhbHNlLFxuICAgICAgcmV0dXJuVHlwZSxcbiAgICApO1xuICAgIHRoaXMuZ2VuZXJhdG9yLmVtaXREb2NTdHJpbmcoY29kZSwgdGhpcy5hcGlMb2NhdGlvbiwgdGhpcy5kb2NzLCB7XG4gICAgICBhcmd1bWVudHM6IGRvY3VtZW50YWJsZUFyZ3MsXG4gICAgICBkb2N1bWVudGFibGVJdGVtOiBgbWV0aG9kLSR7dGhpcy5weXRob25OYW1lfWAsXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0Qm9keShcbiAgICAgIGNvZGUsXG4gICAgICBjb250ZXh0LFxuICAgICAgcmVuZGVyQWJzdHJhY3QsXG4gICAgICBmb3JjZUVtaXRCb2R5LFxuICAgICAgbGlmdGVkUHJvcE5hbWVzLFxuICAgICAgcHl0aG9uUGFyYW1zWzBdLFxuICAgICAgcmV0dXJuVHlwZSxcbiAgICApO1xuICAgIGNvZGUuY2xvc2VCbG9jaygpO1xuICB9XG5cbiAgcHJpdmF0ZSBlbWl0Qm9keShcbiAgICBjb2RlOiBDb2RlTWFrZXIsXG4gICAgY29udGV4dDogRW1pdENvbnRleHQsXG4gICAgcmVuZGVyQWJzdHJhY3Q6IGJvb2xlYW4sXG4gICAgZm9yY2VFbWl0Qm9keTogYm9vbGVhbixcbiAgICBsaWZ0ZWRQcm9wTmFtZXM6IFNldDxzdHJpbmc+LFxuICAgIGltcGxpY2l0UGFyYW1ldGVyOiBzdHJpbmcsXG4gICAgcmV0dXJuVHlwZTogc3RyaW5nLFxuICApIHtcbiAgICBpZiAoXG4gICAgICAoIXRoaXMuc2hvdWxkRW1pdEJvZHkgJiYgIWZvcmNlRW1pdEJvZHkpIHx8XG4gICAgICAocmVuZGVyQWJzdHJhY3QgJiYgdGhpcy5hYnN0cmFjdClcbiAgICApIHtcbiAgICAgIGNvZGUubGluZSgnLi4uJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmxpZnRlZFByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmVtaXRBdXRvUHJvcHMoY29kZSwgY29udGV4dCwgbGlmdGVkUHJvcE5hbWVzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbWl0SnNpaU1ldGhvZENhbGwoXG4gICAgICAgIGNvZGUsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGxpZnRlZFByb3BOYW1lcyxcbiAgICAgICAgaW1wbGljaXRQYXJhbWV0ZXIsXG4gICAgICAgIHJldHVyblR5cGUsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZW1pdEF1dG9Qcm9wcyhcbiAgICBjb2RlOiBDb2RlTWFrZXIsXG4gICAgY29udGV4dDogRW1pdENvbnRleHQsXG4gICAgbGlmdGVkUHJvcE5hbWVzOiBTZXQ8c3RyaW5nPixcbiAgKSB7XG4gICAgY29uc3QgbGFzdFBhcmFtZXRlciA9IHRoaXMucGFyYW1ldGVycy5zbGljZSgtMSlbMF07XG4gICAgY29uc3QgYXJnTmFtZSA9IHRvUHl0aG9uUGFyYW1ldGVyTmFtZShsYXN0UGFyYW1ldGVyLm5hbWUsIGxpZnRlZFByb3BOYW1lcyk7XG4gICAgY29uc3QgdHlwZU5hbWUgPSB0b1R5cGVOYW1lKGxhc3RQYXJhbWV0ZXIudHlwZSkucHl0aG9uVHlwZSh7XG4gICAgICAuLi5jb250ZXh0LFxuICAgICAgdHlwZUFubm90YXRpb246IGZhbHNlLFxuICAgIH0pO1xuXG4gICAgLy8gV2UgbmVlZCB0byBidWlsZCB1cCBhIGxpc3Qgb2YgcHJvcGVydGllcywgd2hpY2ggYXJlIG1hbmRhdG9yeSwgdGhlc2UgYXJlIHRoZVxuICAgIC8vIG9uZXMgd2Ugd2lsbCBzcGVjaWZpeSB0byBzdGFydCB3aXRoIGluIG91ciBkaWN0aW9uYXJ5IGxpdGVyYWwuXG4gICAgY29uc3QgbGlmdGVkUHJvcHMgPSB0aGlzLmdldExpZnRlZFByb3BlcnRpZXMoY29udGV4dC5yZXNvbHZlcikubWFwKFxuICAgICAgKHApID0+IG5ldyBTdHJ1Y3RGaWVsZCh0aGlzLmdlbmVyYXRvciwgcC5wcm9wLCBwLmRlZmluaW5nVHlwZSksXG4gICAgKTtcbiAgICBjb25zdCBhc3NpZ25tZW50cyA9IGxpZnRlZFByb3BzXG4gICAgICAubWFwKChwKSA9PiBwLnB5dGhvbk5hbWUpXG4gICAgICAubWFwKCh2KSA9PiBgJHt2fT0ke3Z9YCk7XG5cbiAgICBhc3NpZ25DYWxsUmVzdWx0KGNvZGUsIGFyZ05hbWUsIHR5cGVOYW1lLCBhc3NpZ25tZW50cyk7XG4gICAgY29kZS5saW5lKCk7XG4gIH1cblxuICBwcml2YXRlIGVtaXRKc2lpTWV0aG9kQ2FsbChcbiAgICBjb2RlOiBDb2RlTWFrZXIsXG4gICAgY29udGV4dDogRW1pdENvbnRleHQsXG4gICAgbGlmdGVkUHJvcE5hbWVzOiBTZXQ8c3RyaW5nPixcbiAgICBpbXBsaWNpdFBhcmFtZXRlcjogc3RyaW5nLFxuICAgIHJldHVyblR5cGU6IHN0cmluZyxcbiAgKSB7XG4gICAgY29uc3QgbWV0aG9kUHJlZml4OiBzdHJpbmcgPSB0aGlzLnJldHVybkZyb21KU0lJTWV0aG9kID8gJ3JldHVybiAnIDogJyc7XG5cbiAgICBjb25zdCBqc2lpTWV0aG9kUGFyYW1zOiBzdHJpbmdbXSA9IFtdO1xuICAgIGlmICh0aGlzLmNsYXNzQXNGaXJzdFBhcmFtZXRlcikge1xuICAgICAgaWYgKHRoaXMucGFyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJlbnQgbm90IGtub3duLicpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNTdGF0aWMpIHtcbiAgICAgICAganNpaU1ldGhvZFBhcmFtcy5wdXNoKFxuICAgICAgICAgIHRvVHlwZU5hbWUodGhpcy5wYXJlbnQpLnB5dGhvblR5cGUoe1xuICAgICAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgICAgIHR5cGVBbm5vdGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVzaW5nIHRoZSBkeW5hbWljIGNsYXNzIG9mIGBzZWxmYC5cbiAgICAgICAganNpaU1ldGhvZFBhcmFtcy5wdXNoKGAke2ltcGxpY2l0UGFyYW1ldGVyfS5fX2NsYXNzX19gKTtcbiAgICAgIH1cbiAgICB9XG4gICAganNpaU1ldGhvZFBhcmFtcy5wdXNoKGltcGxpY2l0UGFyYW1ldGVyKTtcbiAgICBpZiAodGhpcy5qc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAganNpaU1ldGhvZFBhcmFtcy5wdXNoKGBcIiR7dGhpcy5qc05hbWV9XCJgKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbGFzdCBhcmcgaXMgdmFyaWFkaWMsIGV4cGFuZCB0aGUgdHVwbGVcbiAgICBjb25zdCBwYXJhbXM6IHN0cmluZ1tdID0gW107XG4gICAgZm9yIChjb25zdCBwYXJhbSBvZiB0aGlzLnBhcmFtZXRlcnMpIHtcbiAgICAgIGxldCBleHByID0gdG9QeXRob25QYXJhbWV0ZXJOYW1lKHBhcmFtLm5hbWUsIGxpZnRlZFByb3BOYW1lcyk7XG4gICAgICBpZiAocGFyYW0udmFyaWFkaWMpIHtcbiAgICAgICAgZXhwciA9IGAqJHtleHByfWA7XG4gICAgICB9XG4gICAgICBwYXJhbXMucHVzaChleHByKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IGBqc2lpLiR7dGhpcy5qc2lpTWV0aG9kfSgke2pzaWlNZXRob2RQYXJhbXMuam9pbihcbiAgICAgICcsICcsXG4gICAgKX0sIFske3BhcmFtcy5qb2luKCcsICcpfV0pYDtcbiAgICBjb2RlLmxpbmUoXG4gICAgICBgJHttZXRob2RQcmVmaXh9JHtcbiAgICAgICAgdGhpcy5yZXR1cm5Gcm9tSlNJSU1ldGhvZCAmJiByZXR1cm5UeXBlXG4gICAgICAgICAgPyBgdHlwaW5nLmNhc3QoJHtyZXR1cm5UeXBlfSwgJHt2YWx1ZX0pYFxuICAgICAgICAgIDogdmFsdWVcbiAgICAgIH1gLFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGdldExpZnRlZFByb3BlcnRpZXMocmVzb2x2ZXI6IFR5cGVSZXNvbHZlcik6IFByb3BlcnR5RGVmaW5pdGlvbltdIHtcbiAgICBjb25zdCBsaWZ0ZWRQcm9wZXJ0aWVzOiBQcm9wZXJ0eURlZmluaXRpb25bXSA9IFtdO1xuXG4gICAgY29uc3Qgc3RhY2sgPSBbdGhpcy5saWZ0ZWRQcm9wXTtcbiAgICBjb25zdCBrbm93bklmYWNlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IGtub3duUHJvcHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBmb3IgKFxuICAgICAgbGV0IGN1cnJlbnQgPSBzdGFjay5zaGlmdCgpO1xuICAgICAgY3VycmVudCAhPSBudWxsO1xuICAgICAgY3VycmVudCA9IHN0YWNrLnNoaWZ0KClcbiAgICApIHtcbiAgICAgIGtub3duSWZhY2VzLmFkZChjdXJyZW50LmZxbik7XG5cbiAgICAgIC8vIEFkZCBhbnkgaW50ZXJmYWNlcyB0aGF0IHRoaXMgaW50ZXJmYWNlIGRlcGVuZHMgb24sIHRvIHRoZSBsaXN0LlxuICAgICAgaWYgKGN1cnJlbnQuaW50ZXJmYWNlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWZhY2Ugb2YgY3VycmVudC5pbnRlcmZhY2VzKSB7XG4gICAgICAgICAgaWYgKGtub3duSWZhY2VzLmhhcyhpZmFjZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjay5wdXNoKHJlc29sdmVyLmRlcmVmZXJlbmNlKGlmYWNlKSBhcyBzcGVjLkludGVyZmFjZVR5cGUpO1xuICAgICAgICAgIGtub3duSWZhY2VzLmFkZChpZmFjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGFsbCBvZiB0aGUgcHJvcGVydGllcyBvZiB0aGlzIGludGVyZmFjZSB0byBvdXIgbGlzdCBvZiBwcm9wZXJ0aWVzLlxuICAgICAgaWYgKGN1cnJlbnQucHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBjdXJyZW50LnByb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAoa25vd25Qcm9wcy5oYXMocHJvcC5uYW1lKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpZnRlZFByb3BlcnRpZXMucHVzaCh7IHByb3AsIGRlZmluaW5nVHlwZTogY3VycmVudCB9KTtcbiAgICAgICAgICBrbm93blByb3BzLmFkZChwcm9wLm5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpZnRlZFByb3BlcnRpZXM7XG4gIH1cbn1cblxuaW50ZXJmYWNlIEJhc2VQcm9wZXJ0eU9wdHMge1xuICBhYnN0cmFjdD86IGJvb2xlYW47XG4gIGltbXV0YWJsZT86IGJvb2xlYW47XG4gIGlzU3RhdGljPzogYm9vbGVhbjtcbiAgcGFyZW50OiBzcGVjLk5hbWVkVHlwZVJlZmVyZW5jZTtcbn1cblxuaW50ZXJmYWNlIEJhc2VQcm9wZXJ0eUVtaXRPcHRzIHtcbiAgcmVuZGVyQWJzdHJhY3Q/OiBib29sZWFuO1xuICBmb3JjZUVtaXRCb2R5PzogYm9vbGVhbjtcbn1cblxuYWJzdHJhY3QgY2xhc3MgQmFzZVByb3BlcnR5IGltcGxlbWVudHMgUHl0aG9uQmFzZSB7XG4gIHB1YmxpYyByZWFkb25seSBhYnN0cmFjdDogYm9vbGVhbjtcbiAgcHVibGljIHJlYWRvbmx5IGlzU3RhdGljOiBib29sZWFuO1xuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCByZWFkb25seSBkZWNvcmF0b3I6IHN0cmluZztcbiAgcHJvdGVjdGVkIGFic3RyYWN0IHJlYWRvbmx5IGltcGxpY2l0UGFyYW1ldGVyOiBzdHJpbmc7XG4gIHByb3RlY3RlZCByZWFkb25seSBqc2lpR2V0TWV0aG9kITogc3RyaW5nO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkganNpaVNldE1ldGhvZCE6IHN0cmluZztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHNob3VsZEVtaXRCb2R5OiBib29sZWFuID0gdHJ1ZTtcblxuICBwcml2YXRlIHJlYWRvbmx5IGltbXV0YWJsZTogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSBwYXJlbnQ6IHNwZWMuTmFtZWRUeXBlUmVmZXJlbmNlO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGdlbmVyYXRvcjogUHl0aG9uR2VuZXJhdG9yLFxuICAgIHB1YmxpYyByZWFkb25seSBweXRob25OYW1lOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBqc05hbWU6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHR5cGU6IHNwZWMuT3B0aW9uYWxWYWx1ZSxcbiAgICBwdWJsaWMgcmVhZG9ubHkgZG9jczogc3BlYy5Eb2NzIHwgdW5kZWZpbmVkLFxuICAgIG9wdHM6IEJhc2VQcm9wZXJ0eU9wdHMsXG4gICkge1xuICAgIGNvbnN0IHsgYWJzdHJhY3QgPSBmYWxzZSwgaW1tdXRhYmxlID0gZmFsc2UsIGlzU3RhdGljID0gZmFsc2UgfSA9IG9wdHM7XG5cbiAgICB0aGlzLmFic3RyYWN0ID0gYWJzdHJhY3Q7XG4gICAgdGhpcy5pbW11dGFibGUgPSBpbW11dGFibGU7XG4gICAgdGhpcy5pc1N0YXRpYyA9IGlzU3RhdGljO1xuICAgIHRoaXMucGFyZW50ID0gb3B0cy5wYXJlbnQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGFwaUxvY2F0aW9uKCk6IEFwaUxvY2F0aW9uIHtcbiAgICByZXR1cm4geyBhcGk6ICdtZW1iZXInLCBmcW46IHRoaXMucGFyZW50LmZxbiwgbWVtYmVyTmFtZTogdGhpcy5qc05hbWUgfTtcbiAgfVxuXG4gIHB1YmxpYyByZXF1aXJlZEltcG9ydHMoY29udGV4dDogRW1pdENvbnRleHQpOiBQeXRob25JbXBvcnRzIHtcbiAgICByZXR1cm4gdG9UeXBlTmFtZSh0aGlzLnR5cGUpLnJlcXVpcmVkSW1wb3J0cyhjb250ZXh0KTtcbiAgfVxuXG4gIHB1YmxpYyBlbWl0KFxuICAgIGNvZGU6IENvZGVNYWtlcixcbiAgICBjb250ZXh0OiBFbWl0Q29udGV4dCxcbiAgICBvcHRzPzogQmFzZVByb3BlcnR5RW1pdE9wdHMsXG4gICkge1xuICAgIGNvbnN0IHsgcmVuZGVyQWJzdHJhY3QgPSB0cnVlLCBmb3JjZUVtaXRCb2R5ID0gZmFsc2UgfSA9IG9wdHMgPz8ge307XG4gICAgY29uc3QgcHl0aG9uVHlwZSA9IHRvVHlwZU5hbWUodGhpcy50eXBlKS5weXRob25UeXBlKGNvbnRleHQpO1xuXG4gICAgLy8gXCIjIHR5cGU6IGlnbm9yZVttaXNjXVwiIGlzIG5lZWRlZCBiZWNhdXNlIG15cHkgY2Fubm90IGNoZWNrIGRlY29yYXRlZCB0aGluZ3NcbiAgICBjb2RlLmxpbmUoYEAke3RoaXMuZGVjb3JhdG9yfSAjIHR5cGU6IGlnbm9yZVttaXNjXWApO1xuICAgIGNvZGUubGluZShgQGpzaWkubWVtYmVyKGpzaWlfbmFtZT1cIiR7dGhpcy5qc05hbWV9XCIpYCk7XG4gICAgaWYgKHJlbmRlckFic3RyYWN0ICYmIHRoaXMuYWJzdHJhY3QpIHtcbiAgICAgIGNvZGUubGluZSgnQGFiYy5hYnN0cmFjdG1ldGhvZCcpO1xuICAgIH1cbiAgICBvcGVuU2lnbmF0dXJlKFxuICAgICAgY29kZSxcbiAgICAgICdkZWYnLFxuICAgICAgdGhpcy5weXRob25OYW1lLFxuICAgICAgW3RoaXMuaW1wbGljaXRQYXJhbWV0ZXJdLFxuICAgICAgdHJ1ZSxcbiAgICAgIHB5dGhvblR5cGUsXG4gICAgKTtcbiAgICB0aGlzLmdlbmVyYXRvci5lbWl0RG9jU3RyaW5nKGNvZGUsIHRoaXMuYXBpTG9jYXRpb24sIHRoaXMuZG9jcywge1xuICAgICAgZG9jdW1lbnRhYmxlSXRlbTogYHByb3AtJHt0aGlzLnB5dGhvbk5hbWV9YCxcbiAgICB9KTtcbiAgICBpZiAoXG4gICAgICAodGhpcy5zaG91bGRFbWl0Qm9keSB8fCBmb3JjZUVtaXRCb2R5KSAmJlxuICAgICAgKCFyZW5kZXJBYnN0cmFjdCB8fCAhdGhpcy5hYnN0cmFjdClcbiAgICApIHtcbiAgICAgIGNvZGUubGluZShcbiAgICAgICAgYHJldHVybiB0eXBpbmcuY2FzdCgke3B5dGhvblR5cGV9LCBqc2lpLiR7dGhpcy5qc2lpR2V0TWV0aG9kfSgke3RoaXMuaW1wbGljaXRQYXJhbWV0ZXJ9LCBcIiR7dGhpcy5qc05hbWV9XCIpKWAsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlLmxpbmUoJy4uLicpO1xuICAgIH1cbiAgICBjb2RlLmNsb3NlQmxvY2soKTtcblxuICAgIGlmICghdGhpcy5pbW11dGFibGUpIHtcbiAgICAgIGNvZGUubGluZSgpO1xuICAgICAgY29kZS5saW5lKFxuICAgICAgICBgQCR7dGhpcy5weXRob25OYW1lfS5zZXR0ZXIke1xuICAgICAgICAgIHRoaXMuaXNTdGF0aWMgPyAnICMgdHlwZTogaWdub3JlW25vLXJlZGVmXScgOiAnJ1xuICAgICAgICB9YCxcbiAgICAgICk7XG4gICAgICBpZiAocmVuZGVyQWJzdHJhY3QgJiYgdGhpcy5hYnN0cmFjdCkge1xuICAgICAgICBjb2RlLmxpbmUoJ0BhYmMuYWJzdHJhY3RtZXRob2QnKTtcbiAgICAgIH1cbiAgICAgIG9wZW5TaWduYXR1cmUoXG4gICAgICAgIGNvZGUsXG4gICAgICAgICdkZWYnLFxuICAgICAgICB0aGlzLnB5dGhvbk5hbWUsXG4gICAgICAgIFt0aGlzLmltcGxpY2l0UGFyYW1ldGVyLCBgdmFsdWU6ICR7cHl0aG9uVHlwZX1gXSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdOb25lJyxcbiAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgICh0aGlzLnNob3VsZEVtaXRCb2R5IHx8IGZvcmNlRW1pdEJvZHkpICYmXG4gICAgICAgICghcmVuZGVyQWJzdHJhY3QgfHwgIXRoaXMuYWJzdHJhY3QpXG4gICAgICApIHtcbiAgICAgICAgY29kZS5saW5lKFxuICAgICAgICAgIGBqc2lpLiR7dGhpcy5qc2lpU2V0TWV0aG9kfSgke3RoaXMuaW1wbGljaXRQYXJhbWV0ZXJ9LCBcIiR7dGhpcy5qc05hbWV9XCIsIHZhbHVlKWAsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlLmxpbmUoJy4uLicpO1xuICAgICAgfVxuICAgICAgY29kZS5jbG9zZUJsb2NrKCk7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEludGVyZmFjZSBleHRlbmRzIEJhc2VQeXRob25DbGFzc1R5cGUge1xuICBwdWJsaWMgZW1pdChjb2RlOiBDb2RlTWFrZXIsIGNvbnRleHQ6IEVtaXRDb250ZXh0KSB7XG4gICAgY29udGV4dCA9IG5lc3RlZENvbnRleHQoY29udGV4dCwgdGhpcy5mcW4pO1xuICAgIGVtaXRMaXN0KGNvZGUsICdAanNpaS5pbnRlcmZhY2UoJywgW2Bqc2lpX3R5cGU9XCIke3RoaXMuZnFufVwiYF0sICcpJyk7XG5cbiAgICAvLyBGaXJzdCB3ZSBkbyBvdXIgbm9ybWFsIGNsYXNzIGxvZ2ljIGZvciBlbWl0dGluZyBvdXIgbWVtYmVycy5cbiAgICBzdXBlci5lbWl0KGNvZGUsIGNvbnRleHQpO1xuXG4gICAgY29kZS5saW5lKCk7XG4gICAgY29kZS5saW5lKCk7XG5cbiAgICAvLyBUaGVuLCB3ZSBoYXZlIHRvIGVtaXQgYSBQcm94eSBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIG91ciBwcm94eSBpbnRlcmZhY2UuXG4gICAgY29uc3QgcHJveHlCYXNlczogc3RyaW5nW10gPSB0aGlzLmJhc2VzLm1hcChcbiAgICAgIChiKSA9PlxuICAgICAgICAvLyBcIiMgdHlwZTogaWdub3JlW21pc2NdXCIgYmVjYXVzZSBNeVB5IGNhbm5vdCBjaGVjayBkeW5hbWljIGJhc2UgY2xhc3NlcyAobmF0dXJhbGx5KVxuICAgICAgICBganNpaS5wcm94eV9mb3IoJHt0b1R5cGVOYW1lKGIpLnB5dGhvblR5cGUoe1xuICAgICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgICAgdHlwZUFubm90YXRpb246IGZhbHNlLFxuICAgICAgICB9KX0pICMgdHlwZTogaWdub3JlW21pc2NdYCxcbiAgICApO1xuICAgIG9wZW5TaWduYXR1cmUoY29kZSwgJ2NsYXNzJywgdGhpcy5wcm94eUNsYXNzTmFtZSwgcHJveHlCYXNlcyk7XG4gICAgdGhpcy5nZW5lcmF0b3IuZW1pdERvY1N0cmluZyhjb2RlLCB0aGlzLmFwaUxvY2F0aW9uLCB0aGlzLmRvY3MsIHtcbiAgICAgIGRvY3VtZW50YWJsZUl0ZW06IGBjbGFzcy0ke3RoaXMucHl0aG9uTmFtZX1gLFxuICAgICAgdHJhaWxpbmdOZXdMaW5lOiB0cnVlLFxuICAgIH0pO1xuICAgIGNvZGUubGluZShgX19qc2lpX3R5cGVfXzogdHlwaW5nLkNsYXNzVmFyW3N0cl0gPSBcIiR7dGhpcy5mcW59XCJgKTtcblxuICAgIGlmICh0aGlzLm1lbWJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdGhpcy5tZW1iZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlcGFyYXRlTWVtYmVycykge1xuICAgICAgICAgIGNvZGUubGluZSgpO1xuICAgICAgICB9XG4gICAgICAgIG1lbWJlci5lbWl0KGNvZGUsIGNvbnRleHQsIHsgZm9yY2VFbWl0Qm9keTogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29kZS5saW5lKCdwYXNzJyk7XG4gICAgfVxuXG4gICAgY29kZS5jbG9zZUJsb2NrKCk7XG4gICAgY29kZS5saW5lKCk7XG4gICAgY29kZS5saW5lKFxuICAgICAgJyMgQWRkaW5nIGEgXCJfX2pzaWlfcHJveHlfY2xhc3NfXygpOiB0eXBpbmcuVHlwZVwiIGZ1bmN0aW9uIHRvIHRoZSBpbnRlcmZhY2UnLFxuICAgICk7XG4gICAgY29kZS5saW5lKFxuICAgICAgYHR5cGluZy5jYXN0KHR5cGluZy5BbnksICR7dGhpcy5weXRob25OYW1lfSkuX19qc2lpX3Byb3h5X2NsYXNzX18gPSBsYW1iZGEgOiAke3RoaXMucHJveHlDbGFzc05hbWV9YCxcbiAgICApO1xuXG4gICAgaWYgKHRoaXMuZnFuICE9IG51bGwpIHtcbiAgICAgIGNvbnRleHQuZW1pdHRlZFR5cGVzLmFkZCh0aGlzLmZxbik7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGdldENsYXNzUGFyYW1zKGNvbnRleHQ6IEVtaXRDb250ZXh0KTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHBhcmFtczogc3RyaW5nW10gPSB0aGlzLmJhc2VzLm1hcCgoYikgPT5cbiAgICAgIHRvVHlwZU5hbWUoYikucHl0aG9uVHlwZSh7IC4uLmNvbnRleHQsIHR5cGVBbm5vdGF0aW9uOiBmYWxzZSB9KSxcbiAgICApO1xuXG4gICAgcGFyYW1zLnB1c2goJ3R5cGluZ19leHRlbnNpb25zLlByb3RvY29sJyk7XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgcHJveHlDbGFzc05hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYF8ke3RoaXMucHl0aG9uTmFtZX1Qcm94eWA7XG4gIH1cbn1cblxuY2xhc3MgSW50ZXJmYWNlTWV0aG9kIGV4dGVuZHMgQmFzZU1ldGhvZCB7XG4gIHByb3RlY3RlZCByZWFkb25seSBpbXBsaWNpdFBhcmFtZXRlcjogc3RyaW5nID0gJ3NlbGYnO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkganNpaU1ldGhvZDogc3RyaW5nID0gJ2ludm9rZSc7XG4gIHByb3RlY3RlZCByZWFkb25seSBzaG91bGRFbWl0Qm9keTogYm9vbGVhbiA9IGZhbHNlO1xufVxuXG5jbGFzcyBJbnRlcmZhY2VQcm9wZXJ0eSBleHRlbmRzIEJhc2VQcm9wZXJ0eSB7XG4gIHByb3RlY3RlZCByZWFkb25seSBkZWNvcmF0b3I6IHN0cmluZyA9ICdidWlsdGlucy5wcm9wZXJ0eSc7XG4gIHByb3RlY3RlZCByZWFkb25seSBpbXBsaWNpdFBhcmFtZXRlcjogc3RyaW5nID0gJ3NlbGYnO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkganNpaUdldE1ldGhvZDogc3RyaW5nID0gJ2dldCc7XG4gIHByb3RlY3RlZCByZWFkb25seSBqc2lpU2V0TWV0aG9kOiBzdHJpbmcgPSAnc2V0JztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHNob3VsZEVtaXRCb2R5OiBib29sZWFuID0gZmFsc2U7XG59XG5cbmNsYXNzIFN0cnVjdCBleHRlbmRzIEJhc2VQeXRob25DbGFzc1R5cGUge1xuICBwcm90ZWN0ZWQgZGlyZWN0TWVtYmVycyA9IG5ldyBBcnJheTxTdHJ1Y3RGaWVsZD4oKTtcblxuICBwdWJsaWMgYWRkTWVtYmVyKG1lbWJlcjogUHl0aG9uQmFzZSk6IHZvaWQge1xuICAgIGlmICghKG1lbWJlciBpbnN0YW5jZW9mIFN0cnVjdEZpZWxkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBTdHJ1Y3RGaWVsZCB0byBTdHJ1Y3QnKTtcbiAgICB9XG4gICAgdGhpcy5kaXJlY3RNZW1iZXJzLnB1c2gobWVtYmVyKTtcbiAgfVxuXG4gIHB1YmxpYyBlbWl0KGNvZGU6IENvZGVNYWtlciwgY29udGV4dDogRW1pdENvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gbmVzdGVkQ29udGV4dChjb250ZXh0LCB0aGlzLmZxbik7XG4gICAgY29uc3QgYmFzZUludGVyZmFjZXMgPSB0aGlzLmdldENsYXNzUGFyYW1zKGNvbnRleHQpO1xuXG4gICAgY29kZS5pbmRlbnQoJ0Bqc2lpLmRhdGFfdHlwZSgnKTtcbiAgICBjb2RlLmxpbmUoYGpzaWlfdHlwZT0ke0pTT04uc3RyaW5naWZ5KHRoaXMuZnFuKX0sYCk7XG4gICAgZW1pdExpc3QoY29kZSwgJ2pzaWlfc3RydWN0X2Jhc2VzPVsnLCBiYXNlSW50ZXJmYWNlcywgJ10sJyk7XG4gICAgYXNzaWduRGljdGlvbmFyeShjb2RlLCAnbmFtZV9tYXBwaW5nJywgdGhpcy5wcm9wZXJ0eU1hcCgpLCAnLCcsIHRydWUpO1xuICAgIGNvZGUudW5pbmRlbnQoJyknKTtcbiAgICBvcGVuU2lnbmF0dXJlKGNvZGUsICdjbGFzcycsIHRoaXMucHl0aG9uTmFtZSwgYmFzZUludGVyZmFjZXMpO1xuICAgIHRoaXMuZW1pdENvbnN0cnVjdG9yKGNvZGUsIGNvbnRleHQpO1xuXG4gICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdGhpcy5hbGxNZW1iZXJzKSB7XG4gICAgICBjb2RlLmxpbmUoKTtcbiAgICAgIHRoaXMuZW1pdEdldHRlcihtZW1iZXIsIGNvZGUsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdE1hZ2ljTWV0aG9kcyhjb2RlKTtcblxuICAgIGNvZGUuY2xvc2VCbG9jaygpO1xuXG4gICAgaWYgKHRoaXMuZnFuICE9IG51bGwpIHtcbiAgICAgIGNvbnRleHQuZW1pdHRlZFR5cGVzLmFkZCh0aGlzLmZxbik7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlcXVpcmVkSW1wb3J0cyhjb250ZXh0OiBFbWl0Q29udGV4dCkge1xuICAgIHJldHVybiBtZXJnZVB5dGhvbkltcG9ydHMoXG4gICAgICBzdXBlci5yZXF1aXJlZEltcG9ydHMoY29udGV4dCksXG4gICAgICAuLi50aGlzLmFsbE1lbWJlcnMubWFwKChtZW0pID0+IG1lbS5yZXF1aXJlZEltcG9ydHMoY29udGV4dCkpLFxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0Q2xhc3NQYXJhbXMoY29udGV4dDogRW1pdENvbnRleHQpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZXMubWFwKChiKSA9PlxuICAgICAgdG9UeXBlTmFtZShiKS5weXRob25UeXBlKHsgLi4uY29udGV4dCwgdHlwZUFubm90YXRpb246IGZhbHNlIH0pLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBhbGwgZmllbGRzIChpbmhlcml0ZWQgYXMgd2VsbClcbiAgICovXG4gIHByaXZhdGUgZ2V0IGFsbE1lbWJlcnMoKTogU3RydWN0RmllbGRbXSB7XG4gICAgcmV0dXJuIHRoaXMudGhpc0ludGVyZmFjZS5hbGxQcm9wZXJ0aWVzLm1hcChcbiAgICAgICh4KSA9PiBuZXcgU3RydWN0RmllbGQodGhpcy5nZW5lcmF0b3IsIHguc3BlYywgeC5kZWZpbmluZ1R5cGUuc3BlYyksXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IHRoaXNJbnRlcmZhY2UoKSB7XG4gICAgaWYgKHRoaXMuZnFuID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRlFOIG5vdCBzZXQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2VuZXJhdG9yLnJlZmxlY3RBc3NlbWJseS5zeXN0ZW0uZmluZEludGVyZmFjZSh0aGlzLmZxbik7XG4gIH1cblxuICBwcml2YXRlIGVtaXRDb25zdHJ1Y3Rvcihjb2RlOiBDb2RlTWFrZXIsIGNvbnRleHQ6IEVtaXRDb250ZXh0KSB7XG4gICAgY29uc3QgbWVtYmVycyA9IHRoaXMuYWxsTWVtYmVycztcblxuICAgIGNvbnN0IGt3YXJncyA9IG1lbWJlcnMubWFwKChtKSA9PiBtLmNvbnN0cnVjdG9yRGVjbChjb250ZXh0KSk7XG5cbiAgICBjb25zdCBpbXBsaWNpdFBhcmFtZXRlciA9IHNsdWdpZnlBc05lZWRlZChcbiAgICAgICdzZWxmJyxcbiAgICAgIG1lbWJlcnMubWFwKChtKSA9PiBtLnB5dGhvbk5hbWUpLFxuICAgICk7XG4gICAgY29uc3QgY29uc3RydWN0b3JBcmd1bWVudHMgPVxuICAgICAga3dhcmdzLmxlbmd0aCA+IDBcbiAgICAgICAgPyBbaW1wbGljaXRQYXJhbWV0ZXIsICcqJywgLi4ua3dhcmdzXVxuICAgICAgICA6IFtpbXBsaWNpdFBhcmFtZXRlcl07XG5cbiAgICBvcGVuU2lnbmF0dXJlKGNvZGUsICdkZWYnLCAnX19pbml0X18nLCBjb25zdHJ1Y3RvckFyZ3VtZW50cywgZmFsc2UsICdOb25lJyk7XG4gICAgdGhpcy5lbWl0Q29uc3RydWN0b3JEb2NzdHJpbmcoY29kZSk7XG5cbiAgICAvLyBSZS10eXBlIHN0cnVjdCBhcmd1bWVudHMgdGhhdCB3ZXJlIHBhc3NlZCBhcyBcImRpY3RcIlxuICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIG1lbWJlcnMuZmlsdGVyKChtKSA9PiBtLmlzU3RydWN0KHRoaXMuZ2VuZXJhdG9yKSkpIHtcbiAgICAgIC8vIE5vdGUgdGhhdCBcIk5vbmVcIiBpcyBOT1QgYW4gaW5zdGFuY2Ugb2YgZGljdCAodGhhdCdzIGNvbnZlbmllbnQhKVxuICAgICAgY29uc3QgdHlwZU5hbWUgPSB0b1R5cGVOYW1lKG1lbWJlci50eXBlLnR5cGUpLnB5dGhvblR5cGUoe1xuICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICB0eXBlQW5ub3RhdGlvbjogZmFsc2UsXG4gICAgICB9KTtcbiAgICAgIGNvZGUub3BlbkJsb2NrKGBpZiBpc2luc3RhbmNlKCR7bWVtYmVyLnB5dGhvbk5hbWV9LCBkaWN0KWApO1xuICAgICAgY29kZS5saW5lKGAke21lbWJlci5weXRob25OYW1lfSA9ICR7dHlwZU5hbWV9KCoqJHttZW1iZXIucHl0aG9uTmFtZX0pYCk7XG4gICAgICBjb2RlLmNsb3NlQmxvY2soKTtcbiAgICB9XG5cbiAgICAvLyBSZXF1aXJlZCBwcm9wZXJ0aWVzLCB0aG9zZSB3aWxsIGFsd2F5cyBiZSBwdXQgaW50byB0aGUgZGljdFxuICAgIGFzc2lnbkRpY3Rpb25hcnkoXG4gICAgICBjb2RlLFxuICAgICAgYCR7aW1wbGljaXRQYXJhbWV0ZXJ9Ll92YWx1ZXM6IHR5cGluZy5EaWN0W3N0ciwgdHlwaW5nLkFueV1gLFxuICAgICAgbWVtYmVyc1xuICAgICAgICAuZmlsdGVyKChtKSA9PiAhbS5vcHRpb25hbClcbiAgICAgICAgLm1hcChcbiAgICAgICAgICAobWVtYmVyKSA9PlxuICAgICAgICAgICAgYCR7SlNPTi5zdHJpbmdpZnkobWVtYmVyLnB5dGhvbk5hbWUpfTogJHttZW1iZXIucHl0aG9uTmFtZX1gLFxuICAgICAgICApLFxuICAgICk7XG5cbiAgICAvLyBPcHRpb25hbCBwcm9wZXJ0aWVzLCB3aWxsIG9ubHkgYmUgcHV0IGludG8gdGhlIGRpY3QgaWYgdGhleSdyZSBub3QgTm9uZVxuICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIG1lbWJlcnMuZmlsdGVyKChtKSA9PiBtLm9wdGlvbmFsKSkge1xuICAgICAgY29kZS5vcGVuQmxvY2soYGlmICR7bWVtYmVyLnB5dGhvbk5hbWV9IGlzIG5vdCBOb25lYCk7XG4gICAgICBjb2RlLmxpbmUoXG4gICAgICAgIGAke2ltcGxpY2l0UGFyYW1ldGVyfS5fdmFsdWVzW1wiJHttZW1iZXIucHl0aG9uTmFtZX1cIl0gPSAke21lbWJlci5weXRob25OYW1lfWAsXG4gICAgICApO1xuICAgICAgY29kZS5jbG9zZUJsb2NrKCk7XG4gICAgfVxuXG4gICAgY29kZS5jbG9zZUJsb2NrKCk7XG4gIH1cblxuICBwcml2YXRlIGVtaXRDb25zdHJ1Y3RvckRvY3N0cmluZyhjb2RlOiBDb2RlTWFrZXIpIHtcbiAgICBjb25zdCBhcmdzOiBEb2N1bWVudGFibGVBcmd1bWVudFtdID0gdGhpcy5hbGxNZW1iZXJzLm1hcCgobSkgPT4gKHtcbiAgICAgIG5hbWU6IG0ucHl0aG9uTmFtZSxcbiAgICAgIGRvY3M6IG0uZG9jcyxcbiAgICAgIGRlZmluaW5nVHlwZTogdGhpcy5zcGVjLFxuICAgIH0pKTtcbiAgICB0aGlzLmdlbmVyYXRvci5lbWl0RG9jU3RyaW5nKGNvZGUsIHRoaXMuYXBpTG9jYXRpb24sIHRoaXMuZG9jcywge1xuICAgICAgYXJndW1lbnRzOiBhcmdzLFxuICAgICAgZG9jdW1lbnRhYmxlSXRlbTogYGNsYXNzLSR7dGhpcy5weXRob25OYW1lfWAsXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGVtaXRHZXR0ZXIoXG4gICAgbWVtYmVyOiBTdHJ1Y3RGaWVsZCxcbiAgICBjb2RlOiBDb2RlTWFrZXIsXG4gICAgY29udGV4dDogRW1pdENvbnRleHQsXG4gICkge1xuICAgIGNvbnN0IHB5dGhvblR5cGUgPSBtZW1iZXIudHlwZUFubm90YXRpb24oY29udGV4dCk7XG5cbiAgICBjb2RlLmxpbmUoJ0BidWlsdGlucy5wcm9wZXJ0eScpO1xuICAgIG9wZW5TaWduYXR1cmUoY29kZSwgJ2RlZicsIG1lbWJlci5weXRob25OYW1lLCBbJ3NlbGYnXSwgdHJ1ZSwgcHl0aG9uVHlwZSk7XG4gICAgbWVtYmVyLmVtaXREb2NTdHJpbmcoY29kZSk7XG4gICAgY29kZS5saW5lKFxuICAgICAgYHJlc3VsdCA9IHNlbGYuX3ZhbHVlcy5nZXQoJHtKU09OLnN0cmluZ2lmeShtZW1iZXIucHl0aG9uTmFtZSl9KWAsXG4gICAgKTtcbiAgICBpZiAoIW1lbWJlci5vcHRpb25hbCkge1xuICAgICAgLy8gQWRkIGFuIGFzc2VydGlvbiB0byBtYXllIE15UFkgaGFwcHkhXG4gICAgICBjb2RlLmxpbmUoXG4gICAgICAgIGBhc3NlcnQgcmVzdWx0IGlzIG5vdCBOb25lLCBcIlJlcXVpcmVkIHByb3BlcnR5ICcke21lbWJlci5weXRob25OYW1lfScgaXMgbWlzc2luZ1wiYCxcbiAgICAgICk7XG4gICAgfVxuICAgIGNvZGUubGluZShgcmV0dXJuIHR5cGluZy5jYXN0KCR7cHl0aG9uVHlwZX0sIHJlc3VsdClgKTtcbiAgICBjb2RlLmNsb3NlQmxvY2soKTtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdE1hZ2ljTWV0aG9kcyhjb2RlOiBDb2RlTWFrZXIpIHtcbiAgICBjb2RlLmxpbmUoKTtcbiAgICBjb2RlLm9wZW5CbG9jaygnZGVmIF9fZXFfXyhzZWxmLCByaHM6IHR5cGluZy5BbnkpIC0+IGJ1aWx0aW5zLmJvb2wnKTtcbiAgICBjb2RlLmxpbmUoXG4gICAgICAncmV0dXJuIGlzaW5zdGFuY2UocmhzLCBzZWxmLl9fY2xhc3NfXykgYW5kIHJocy5fdmFsdWVzID09IHNlbGYuX3ZhbHVlcycsXG4gICAgKTtcbiAgICBjb2RlLmNsb3NlQmxvY2soKTtcblxuICAgIGNvZGUubGluZSgpO1xuICAgIGNvZGUub3BlbkJsb2NrKCdkZWYgX19uZV9fKHNlbGYsIHJoczogdHlwaW5nLkFueSkgLT4gYnVpbHRpbnMuYm9vbCcpO1xuICAgIGNvZGUubGluZSgncmV0dXJuIG5vdCAocmhzID09IHNlbGYpJyk7XG4gICAgY29kZS5jbG9zZUJsb2NrKCk7XG5cbiAgICBjb2RlLmxpbmUoKTtcbiAgICBjb2RlLm9wZW5CbG9jaygnZGVmIF9fcmVwcl9fKHNlbGYpIC0+IHN0cicpO1xuICAgIGNvZGUuaW5kZW50KGByZXR1cm4gXCIke3RoaXMucHl0aG9uTmFtZX0oJXMpXCIgJSBcIiwgXCIuam9pbihgKTtcbiAgICBjb2RlLmxpbmUoJ2sgKyBcIj1cIiArIHJlcHIodikgZm9yIGssIHYgaW4gc2VsZi5fdmFsdWVzLml0ZW1zKCknKTtcbiAgICBjb2RlLnVuaW5kZW50KCcpJyk7XG4gICAgY29kZS5jbG9zZUJsb2NrKCk7XG4gIH1cblxuICBwcml2YXRlIHByb3BlcnR5TWFwKCkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG4gICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdGhpcy5hbGxNZW1iZXJzKSB7XG4gICAgICByZXQucHVzaChcbiAgICAgICAgYCR7SlNPTi5zdHJpbmdpZnkobWVtYmVyLnB5dGhvbk5hbWUpfTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBtZW1iZXIuanNpaU5hbWUsXG4gICAgICAgICl9YCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cblxuY2xhc3MgU3RydWN0RmllbGQgaW1wbGVtZW50cyBQeXRob25CYXNlIHtcbiAgcHVibGljIHJlYWRvbmx5IHB5dGhvbk5hbWU6IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IGpzaWlOYW1lOiBzdHJpbmc7XG4gIHB1YmxpYyByZWFkb25seSBkb2NzPzogc3BlYy5Eb2NzO1xuICBwdWJsaWMgcmVhZG9ubHkgdHlwZTogc3BlYy5PcHRpb25hbFZhbHVlO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGdlbmVyYXRvcjogUHl0aG9uR2VuZXJhdG9yLFxuICAgIHB1YmxpYyByZWFkb25seSBwcm9wOiBzcGVjLlByb3BlcnR5LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZGVmaW5pbmdUeXBlOiBzcGVjLlR5cGUsXG4gICkge1xuICAgIHRoaXMucHl0aG9uTmFtZSA9IHRvUHl0aG9uUHJvcGVydHlOYW1lKHByb3AubmFtZSk7XG4gICAgdGhpcy5qc2lpTmFtZSA9IHByb3AubmFtZTtcbiAgICB0aGlzLnR5cGUgPSBwcm9wO1xuICAgIHRoaXMuZG9jcyA9IHByb3AuZG9jcztcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYXBpTG9jYXRpb24oKTogQXBpTG9jYXRpb24ge1xuICAgIHJldHVybiB7XG4gICAgICBhcGk6ICdtZW1iZXInLFxuICAgICAgZnFuOiB0aGlzLmRlZmluaW5nVHlwZS5mcW4sXG4gICAgICBtZW1iZXJOYW1lOiB0aGlzLmpzaWlOYW1lLFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgZ2V0IG9wdGlvbmFsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMudHlwZS5vcHRpb25hbDtcbiAgfVxuXG4gIHB1YmxpYyByZXF1aXJlZEltcG9ydHMoY29udGV4dDogRW1pdENvbnRleHQpOiBQeXRob25JbXBvcnRzIHtcbiAgICByZXR1cm4gdG9UeXBlTmFtZSh0aGlzLnR5cGUpLnJlcXVpcmVkSW1wb3J0cyhjb250ZXh0KTtcbiAgfVxuXG4gIHB1YmxpYyBpc1N0cnVjdChnZW5lcmF0b3I6IFB5dGhvbkdlbmVyYXRvcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc1N0cnVjdChnZW5lcmF0b3IucmVmbGVjdEFzc2VtYmx5LnN5c3RlbSwgdGhpcy50eXBlLnR5cGUpO1xuICB9XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yRGVjbChjb250ZXh0OiBFbWl0Q29udGV4dCkge1xuICAgIGNvbnN0IG9wdCA9IHRoaXMub3B0aW9uYWwgPyAnID0gTm9uZScgOiAnJztcbiAgICByZXR1cm4gYCR7dGhpcy5weXRob25OYW1lfTogJHt0aGlzLnR5cGVBbm5vdGF0aW9uKHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICBwYXJhbWV0ZXJUeXBlOiB0cnVlLFxuICAgIH0pfSR7b3B0fWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBQeXRob24gdHlwZSBhbm5vdGF0aW9uIGZvciB0aGlzIHR5cGVcbiAgICovXG4gIHB1YmxpYyB0eXBlQW5ub3RhdGlvbihjb250ZXh0OiBFbWl0Q29udGV4dCkge1xuICAgIHJldHVybiB0b1R5cGVOYW1lKHRoaXMudHlwZSkucHl0aG9uVHlwZShjb250ZXh0KTtcbiAgfVxuXG4gIHB1YmxpYyBlbWl0RG9jU3RyaW5nKGNvZGU6IENvZGVNYWtlcikge1xuICAgIHRoaXMuZ2VuZXJhdG9yLmVtaXREb2NTdHJpbmcoY29kZSwgdGhpcy5hcGlMb2NhdGlvbiwgdGhpcy5kb2NzLCB7XG4gICAgICBkb2N1bWVudGFibGVJdGVtOiBgcHJvcC0ke3RoaXMucHl0aG9uTmFtZX1gLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGVtaXQoY29kZTogQ29kZU1ha2VyLCBjb250ZXh0OiBFbWl0Q29udGV4dCkge1xuICAgIGNvbnN0IHJlc29sdmVkVHlwZSA9IHRoaXMudHlwZUFubm90YXRpb24oY29udGV4dCk7XG4gICAgY29kZS5saW5lKGAke3RoaXMucHl0aG9uTmFtZX06ICR7cmVzb2x2ZWRUeXBlfWApO1xuICAgIHRoaXMuZW1pdERvY1N0cmluZyhjb2RlKTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgQ2xhc3NPcHRzIGV4dGVuZHMgUHl0aG9uVHlwZU9wdHMge1xuICBhYnN0cmFjdD86IGJvb2xlYW47XG4gIGludGVyZmFjZXM/OiBzcGVjLk5hbWVkVHlwZVJlZmVyZW5jZVtdO1xuICBhYnN0cmFjdEJhc2VzPzogc3BlYy5DbGFzc1R5cGVbXTtcbn1cblxuY2xhc3MgQ2xhc3MgZXh0ZW5kcyBCYXNlUHl0aG9uQ2xhc3NUeXBlIGltcGxlbWVudHMgSVNvcnRhYmxlVHlwZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgYWJzdHJhY3Q6IGJvb2xlYW47XG4gIHByaXZhdGUgcmVhZG9ubHkgYWJzdHJhY3RCYXNlczogc3BlYy5DbGFzc1R5cGVbXTtcbiAgcHJpdmF0ZSByZWFkb25seSBpbnRlcmZhY2VzOiBzcGVjLk5hbWVkVHlwZVJlZmVyZW5jZVtdO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBnZW5lcmF0b3I6IFB5dGhvbkdlbmVyYXRvcixcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgc3BlYzogc3BlYy5UeXBlLFxuICAgIGZxbjogc3RyaW5nLFxuICAgIG9wdHM6IENsYXNzT3B0cyxcbiAgICBkb2NzOiBzcGVjLkRvY3MgfCB1bmRlZmluZWQsXG4gICkge1xuICAgIHN1cGVyKGdlbmVyYXRvciwgbmFtZSwgc3BlYywgZnFuLCBvcHRzLCBkb2NzKTtcblxuICAgIGNvbnN0IHsgYWJzdHJhY3QgPSBmYWxzZSwgaW50ZXJmYWNlcyA9IFtdLCBhYnN0cmFjdEJhc2VzID0gW10gfSA9IG9wdHM7XG5cbiAgICB0aGlzLmFic3RyYWN0ID0gYWJzdHJhY3Q7XG4gICAgdGhpcy5pbnRlcmZhY2VzID0gaW50ZXJmYWNlcztcbiAgICB0aGlzLmFic3RyYWN0QmFzZXMgPSBhYnN0cmFjdEJhc2VzO1xuICB9XG5cbiAgcHVibGljIGRlcGVuZHNPbihyZXNvbHZlcjogVHlwZVJlc29sdmVyKTogUHl0aG9uVHlwZVtdIHtcbiAgICBjb25zdCBkZXBlbmRlbmNpZXM6IFB5dGhvblR5cGVbXSA9IHN1cGVyLmRlcGVuZHNPbihyZXNvbHZlcik7XG4gICAgY29uc3QgcGFyZW50ID0gcmVzb2x2ZXIuZ2V0UGFyZW50KHRoaXMuZnFuISk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIHJldHVybiBhbnkgaWZhY2VzIHRoYXQgYXJlIGluIHRoZSBzYW1lIG1vZHVsZSBhdCB0aGUgc2FtZSBsZXZlbCBvZlxuICAgIC8vIG5lc3RpbmcuXG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGZvciAoY29uc3QgaWZhY2Ugb2YgdGhpcy5pbnRlcmZhY2VzKSB7XG4gICAgICBpZiAocmVzb2x2ZXIuaXNJbk1vZHVsZShpZmFjZSkpIHtcbiAgICAgICAgLy8gR2l2ZW4gYSBpZmFjZSwgd2UgbmVlZCB0byBsb2NhdGUgdGhlIGlmYWNlcydzIHBhcmVudCB0aGF0IGlzIHRoZSBzYW1lXG4gICAgICAgIC8vIGFzIG91ciBwYXJlbnQsIGJlY2F1c2Ugd2Ugb25seSBjYXJlIGFib3V0IGRlcGVuZGVuY2llcyB0aGF0IGFyZSBhdCB0aGVcbiAgICAgICAgLy8gc2FtZSBsZXZlbCBvZiBvdXIgb3duLlxuICAgICAgICAvLyBUT0RPOiBXZSBtaWdodCBuZWVkIHRvIHJlY3Vyc2UgaW50byBvdXIgbWVtYmVycyB0byBhbHNvIGZpbmQgdGhlaXJcbiAgICAgICAgLy8gICAgICAgZGVwZW5kZW5jaWVzLlxuICAgICAgICBsZXQgaWZhY2VJdGVtID0gcmVzb2x2ZXIuZ2V0VHlwZShpZmFjZSk7XG4gICAgICAgIGxldCBpZmFjZVBhcmVudCA9IHJlc29sdmVyLmdldFBhcmVudChpZmFjZSk7XG4gICAgICAgIHdoaWxlIChpZmFjZVBhcmVudCAhPT0gcGFyZW50KSB7XG4gICAgICAgICAgaWZhY2VJdGVtID0gaWZhY2VQYXJlbnQ7XG4gICAgICAgICAgaWZhY2VQYXJlbnQgPSByZXNvbHZlci5nZXRQYXJlbnQoaWZhY2VJdGVtLmZxbiEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzZWVuLmhhcyhpZmFjZUl0ZW0uZnFuISkpIHtcbiAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChpZmFjZUl0ZW0pO1xuICAgICAgICAgIHNlZW4uYWRkKGlmYWNlSXRlbS5mcW4hKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cblxuICBwdWJsaWMgcmVxdWlyZWRJbXBvcnRzKGNvbnRleHQ6IEVtaXRDb250ZXh0KTogUHl0aG9uSW1wb3J0cyB7XG4gICAgcmV0dXJuIG1lcmdlUHl0aG9uSW1wb3J0cyhcbiAgICAgIHN1cGVyLnJlcXVpcmVkSW1wb3J0cyhjb250ZXh0KSwgLy8gVGFrZXMgY2FyZSBvZiBiYXNlICYgbWVtYmVyc1xuICAgICAgLi4udGhpcy5pbnRlcmZhY2VzLm1hcCgoYmFzZSkgPT5cbiAgICAgICAgdG9UeXBlTmFtZShiYXNlKS5yZXF1aXJlZEltcG9ydHMoY29udGV4dCksXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZW1pdChjb2RlOiBDb2RlTWFrZXIsIGNvbnRleHQ6IEVtaXRDb250ZXh0KSB7XG4gICAgLy8gRmlyc3Qgd2UgZW1pdCBvdXIgaW1wbG1lbnRzIGRlY29yYXRvclxuICAgIGlmICh0aGlzLmludGVyZmFjZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaW50ZXJmYWNlczogc3RyaW5nW10gPSB0aGlzLmludGVyZmFjZXMubWFwKChiKSA9PlxuICAgICAgICB0b1R5cGVOYW1lKGIpLnB5dGhvblR5cGUoeyAuLi5jb250ZXh0LCB0eXBlQW5ub3RhdGlvbjogZmFsc2UgfSksXG4gICAgICApO1xuICAgICAgY29kZS5saW5lKGBAanNpaS5pbXBsZW1lbnRzKCR7aW50ZXJmYWNlcy5qb2luKCcsICcpfSlgKTtcbiAgICB9XG5cbiAgICAvLyBUaGVuIHdlIGRvIG91ciBub3JtYWwgY2xhc3MgbG9naWMgZm9yIGVtaXR0aW5nIG91ciBtZW1iZXJzLlxuICAgIHN1cGVyLmVtaXQoY29kZSwgY29udGV4dCk7XG5cbiAgICAvLyBUaGVuLCBpZiBvdXIgY2xhc3MgaXMgQWJzdHJhY3QsIHdlIGhhdmUgdG8gZ28gdGhyb3VnaCBhbmQgcmVkbyBhbGwgb2ZcbiAgICAvLyB0aGlzIGxvZ2ljLCBleGNlcHQgb25seSBlbWl0aW5nIGFic3RyYWN0IG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgYXMgbm9uXG4gICAgLy8gYWJzdHJhY3QsIGFuZCBzdWJjbGFzc2luZyBvdXIgaW5pdGlhbCBjbGFzcy5cbiAgICBpZiAodGhpcy5hYnN0cmFjdCkge1xuICAgICAgY29udGV4dCA9IG5lc3RlZENvbnRleHQoY29udGV4dCwgdGhpcy5mcW4pO1xuXG4gICAgICBjb25zdCBwcm94eUJhc2VzID0gW3RoaXMucHl0aG9uTmFtZV07XG4gICAgICBmb3IgKGNvbnN0IGJhc2Ugb2YgdGhpcy5hYnN0cmFjdEJhc2VzKSB7XG4gICAgICAgIC8vIFwiIyB0eXBlOiBpZ25vcmVbbWlzY11cIiBiZWNhdXNlIE15UHkgY2Fubm90IGNoZWNrIGR5bmFtaWMgYmFzZSBjbGFzc2VzIChuYXR1cmFsbHkpXG4gICAgICAgIHByb3h5QmFzZXMucHVzaChcbiAgICAgICAgICBganNpaS5wcm94eV9mb3IoJHt0b1R5cGVOYW1lKGJhc2UpLnB5dGhvblR5cGUoe1xuICAgICAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgICAgIHR5cGVBbm5vdGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICB9KX0pICMgdHlwZTogaWdub3JlW21pc2NdYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29kZS5saW5lKCk7XG4gICAgICBjb2RlLmxpbmUoKTtcbiAgICAgIG9wZW5TaWduYXR1cmUoY29kZSwgJ2NsYXNzJywgdGhpcy5wcm94eUNsYXNzTmFtZSwgcHJveHlCYXNlcyk7XG5cbiAgICAgIC8vIEZpbHRlciBvdXIgbGlzdCBvZiBtZW1iZXJzIHRvICpvbmx5KiBiZSBhYnN0cmFjdCBtZW1iZXJzLCBhbmQgbm90IGFueVxuICAgICAgLy8gb3RoZXIgdHlwZXMuXG4gICAgICBjb25zdCBhYnN0cmFjdE1lbWJlcnMgPSB0aGlzLm1lbWJlcnMuZmlsdGVyKFxuICAgICAgICAobSkgPT5cbiAgICAgICAgICAobSBpbnN0YW5jZW9mIEJhc2VNZXRob2QgfHwgbSBpbnN0YW5jZW9mIEJhc2VQcm9wZXJ0eSkgJiYgbS5hYnN0cmFjdCxcbiAgICAgICk7XG4gICAgICBpZiAoYWJzdHJhY3RNZW1iZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgYWJzdHJhY3RNZW1iZXJzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VwYXJhdGVNZW1iZXJzKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvZGUubGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBtZW1iZXIuZW1pdChjb2RlLCBjb250ZXh0LCB7IHJlbmRlckFic3RyYWN0OiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZS5saW5lKCdwYXNzJyk7XG4gICAgICB9XG5cbiAgICAgIGNvZGUuY2xvc2VCbG9jaygpO1xuICAgICAgY29kZS5saW5lKCk7XG4gICAgICBjb2RlLmxpbmUoXG4gICAgICAgICcjIEFkZGluZyBhIFwiX19qc2lpX3Byb3h5X2NsYXNzX18oKTogdHlwaW5nLlR5cGVcIiBmdW5jdGlvbiB0byB0aGUgYWJzdHJhY3QgY2xhc3MnLFxuICAgICAgKTtcbiAgICAgIGNvZGUubGluZShcbiAgICAgICAgYHR5cGluZy5jYXN0KHR5cGluZy5BbnksICR7dGhpcy5weXRob25OYW1lfSkuX19qc2lpX3Byb3h5X2NsYXNzX18gPSBsYW1iZGEgOiAke3RoaXMucHJveHlDbGFzc05hbWV9YCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGdldENsYXNzUGFyYW1zKGNvbnRleHQ6IEVtaXRDb250ZXh0KTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHBhcmFtczogc3RyaW5nW10gPSB0aGlzLmJhc2VzLm1hcCgoYikgPT5cbiAgICAgIHRvVHlwZU5hbWUoYikucHl0aG9uVHlwZSh7IC4uLmNvbnRleHQsIHR5cGVBbm5vdGF0aW9uOiBmYWxzZSB9KSxcbiAgICApO1xuICAgIGNvbnN0IG1ldGFjbGFzczogc3RyaW5nID0gdGhpcy5hYnN0cmFjdCA/ICdKU0lJQWJzdHJhY3RDbGFzcycgOiAnSlNJSU1ldGEnO1xuXG4gICAgcGFyYW1zLnB1c2goYG1ldGFjbGFzcz1qc2lpLiR7bWV0YWNsYXNzfWApO1xuICAgIHBhcmFtcy5wdXNoKGBqc2lpX3R5cGU9XCIke3RoaXMuZnFufVwiYCk7XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgcHJveHlDbGFzc05hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYF8ke3RoaXMucHl0aG9uTmFtZX1Qcm94eWA7XG4gIH1cbn1cblxuY2xhc3MgU3RhdGljTWV0aG9kIGV4dGVuZHMgQmFzZU1ldGhvZCB7XG4gIHByb3RlY3RlZCByZWFkb25seSBkZWNvcmF0b3I/OiBzdHJpbmcgPSAnYnVpbHRpbnMuY2xhc3NtZXRob2QnO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgaW1wbGljaXRQYXJhbWV0ZXI6IHN0cmluZyA9ICdjbHMnO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkganNpaU1ldGhvZDogc3RyaW5nID0gJ3NpbnZva2UnO1xufVxuXG5jbGFzcyBJbml0aWFsaXplciBleHRlbmRzIEJhc2VNZXRob2Qge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgaW1wbGljaXRQYXJhbWV0ZXI6IHN0cmluZyA9ICdzZWxmJztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGpzaWlNZXRob2Q6IHN0cmluZyA9ICdjcmVhdGUnO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgY2xhc3NBc0ZpcnN0UGFyYW1ldGVyOiBib29sZWFuID0gdHJ1ZTtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHJldHVybkZyb21KU0lJTWV0aG9kOiBib29sZWFuID0gZmFsc2U7XG59XG5cbmNsYXNzIE1ldGhvZCBleHRlbmRzIEJhc2VNZXRob2Qge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgaW1wbGljaXRQYXJhbWV0ZXI6IHN0cmluZyA9ICdzZWxmJztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGpzaWlNZXRob2Q6IHN0cmluZyA9ICdpbnZva2UnO1xufVxuXG5jbGFzcyBBc3luY01ldGhvZCBleHRlbmRzIEJhc2VNZXRob2Qge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgaW1wbGljaXRQYXJhbWV0ZXI6IHN0cmluZyA9ICdzZWxmJztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGpzaWlNZXRob2Q6IHN0cmluZyA9ICdhaW52b2tlJztcbn1cblxuY2xhc3MgU3RhdGljUHJvcGVydHkgZXh0ZW5kcyBCYXNlUHJvcGVydHkge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZGVjb3JhdG9yOiBzdHJpbmcgPSAnanNpaS5weXRob24uY2xhc3Nwcm9wZXJ0eSc7XG4gIHByb3RlY3RlZCByZWFkb25seSBpbXBsaWNpdFBhcmFtZXRlcjogc3RyaW5nID0gJ2Nscyc7XG4gIHByb3RlY3RlZCByZWFkb25seSBqc2lpR2V0TWV0aG9kOiBzdHJpbmcgPSAnc2dldCc7XG4gIHByb3RlY3RlZCByZWFkb25seSBqc2lpU2V0TWV0aG9kOiBzdHJpbmcgPSAnc3NldCc7XG59XG5cbmNsYXNzIFByb3BlcnR5IGV4dGVuZHMgQmFzZVByb3BlcnR5IHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGRlY29yYXRvcjogc3RyaW5nID0gJ2J1aWx0aW5zLnByb3BlcnR5JztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGltcGxpY2l0UGFyYW1ldGVyOiBzdHJpbmcgPSAnc2VsZic7XG4gIHByb3RlY3RlZCByZWFkb25seSBqc2lpR2V0TWV0aG9kOiBzdHJpbmcgPSAnZ2V0JztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGpzaWlTZXRNZXRob2Q6IHN0cmluZyA9ICdzZXQnO1xufVxuXG5jbGFzcyBFbnVtIGV4dGVuZHMgQmFzZVB5dGhvbkNsYXNzVHlwZSB7XG4gIHByb3RlY3RlZCByZWFkb25seSBzZXBhcmF0ZU1lbWJlcnMgPSBmYWxzZTtcblxuICBwdWJsaWMgZW1pdChjb2RlOiBDb2RlTWFrZXIsIGNvbnRleHQ6IEVtaXRDb250ZXh0KSB7XG4gICAgY29udGV4dCA9IG5lc3RlZENvbnRleHQoY29udGV4dCwgdGhpcy5mcW4pO1xuICAgIGVtaXRMaXN0KGNvZGUsICdAanNpaS5lbnVtKCcsIFtganNpaV90eXBlPVwiJHt0aGlzLmZxbn1cImBdLCAnKScpO1xuICAgIHJldHVybiBzdXBlci5lbWl0KGNvZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldENsYXNzUGFyYW1zKF9jb250ZXh0OiBFbWl0Q29udGV4dCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gWydlbnVtLkVudW0nXTtcbiAgfVxuXG4gIHB1YmxpYyByZXF1aXJlZEltcG9ydHMoY29udGV4dDogRW1pdENvbnRleHQpOiBQeXRob25JbXBvcnRzIHtcbiAgICByZXR1cm4gc3VwZXIucmVxdWlyZWRJbXBvcnRzKGNvbnRleHQpO1xuICB9XG59XG5cbmNsYXNzIEVudW1NZW1iZXIgaW1wbGVtZW50cyBQeXRob25CYXNlIHtcbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZ2VuZXJhdG9yOiBQeXRob25HZW5lcmF0b3IsXG4gICAgcHVibGljIHJlYWRvbmx5IHB5dGhvbk5hbWU6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHZhbHVlOiBzdHJpbmcsXG4gICAgcHVibGljIHJlYWRvbmx5IGRvY3M6IHNwZWMuRG9jcyB8IHVuZGVmaW5lZCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBhcmVudDogc3BlYy5OYW1lZFR5cGVSZWZlcmVuY2UsXG4gICkge1xuICAgIHRoaXMucHl0aG9uTmFtZSA9IHB5dGhvbk5hbWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgcHVibGljIGdldCBhcGlMb2NhdGlvbigpOiBBcGlMb2NhdGlvbiB7XG4gICAgcmV0dXJuIHsgYXBpOiAnbWVtYmVyJywgZnFuOiB0aGlzLnBhcmVudC5mcW4sIG1lbWJlck5hbWU6IHRoaXMudmFsdWUgfTtcbiAgfVxuXG4gIHB1YmxpYyBkZXBlbmRzT25Nb2R1bGVzKCkge1xuICAgIHJldHVybiBuZXcgU2V0PHN0cmluZz4oKTtcbiAgfVxuXG4gIHB1YmxpYyBlbWl0KGNvZGU6IENvZGVNYWtlciwgX2NvbnRleHQ6IEVtaXRDb250ZXh0KSB7XG4gICAgY29kZS5saW5lKGAke3RoaXMucHl0aG9uTmFtZX0gPSBcIiR7dGhpcy52YWx1ZX1cImApO1xuICAgIHRoaXMuZ2VuZXJhdG9yLmVtaXREb2NTdHJpbmcoY29kZSwgdGhpcy5hcGlMb2NhdGlvbiwgdGhpcy5kb2NzLCB7XG4gICAgICBkb2N1bWVudGFibGVJdGVtOiBgZW51bS0ke3RoaXMucHl0aG9uTmFtZX1gLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJlcXVpcmVkSW1wb3J0cyhfY29udGV4dDogRW1pdENvbnRleHQpOiBQeXRob25JbXBvcnRzIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cblxuaW50ZXJmYWNlIE1vZHVsZU9wdHMge1xuICByZWFkb25seSBhc3NlbWJseTogc3BlYy5Bc3NlbWJseTtcbiAgcmVhZG9ubHkgYXNzZW1ibHlGaWxlbmFtZTogc3RyaW5nO1xuICByZWFkb25seSBsb2FkQXNzZW1ibHk/OiBib29sZWFuO1xuICByZWFkb25seSBwYWNrYWdlPzogUGFja2FnZTtcblxuICAvKipcbiAgICogVGhlIGRvY3N0cmluZyB0byBlbWl0IGF0IHRoZSB0b3Agb2YgdGhpcyBtb2R1bGUsIGlmIGFueS5cbiAgICovXG4gIHJlYWRvbmx5IG1vZHVsZURvY3VtZW50YXRpb24/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUHl0aG9uIG1vZHVsZVxuICpcbiAqIFdpbGwgYmUgY2FsbGVkIGZvciBqc2lpIHN1Ym1vZHVsZXMgYW5kIG5hbWVzcGFjZXMuXG4gKi9cbmNsYXNzIFB5dGhvbk1vZHVsZSBpbXBsZW1lbnRzIFB5dGhvblR5cGUge1xuICAvKipcbiAgICogQ29udmVydGVkIHRvIHB1dCBvbiB0aGUgbW9kdWxlXG4gICAqXG4gICAqIFRoZSBmb3JtYXQgaXMgaW4gbWFya2Rvd24sIHdpdGggY29kZSBzYW1wbGVzIGNvbnZlcnRlZCBmcm9tIFRTIHRvIFB5dGhvbi5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBtb2R1bGVEb2N1bWVudGF0aW9uPzogc3RyaW5nO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgYXNzZW1ibHk6IHNwZWMuQXNzZW1ibHk7XG4gIHByaXZhdGUgcmVhZG9ubHkgYXNzZW1ibHlGaWxlbmFtZTogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IGxvYWRBc3NlbWJseTogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSBtZW1iZXJzID0gbmV3IEFycmF5PFB5dGhvbkJhc2U+KCk7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBtb2R1bGVzID0gbmV3IEFycmF5PFB5dGhvbk1vZHVsZT4oKTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlYWRvbmx5IHB5dGhvbk5hbWU6IHN0cmluZyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgZnFuOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgb3B0czogTW9kdWxlT3B0cyxcbiAgKSB7XG4gICAgdGhpcy5hc3NlbWJseSA9IG9wdHMuYXNzZW1ibHk7XG4gICAgdGhpcy5hc3NlbWJseUZpbGVuYW1lID0gb3B0cy5hc3NlbWJseUZpbGVuYW1lO1xuICAgIHRoaXMubG9hZEFzc2VtYmx5ID0gISFvcHRzLmxvYWRBc3NlbWJseTtcbiAgICB0aGlzLm1vZHVsZURvY3VtZW50YXRpb24gPSBvcHRzLm1vZHVsZURvY3VtZW50YXRpb247XG4gIH1cblxuICBwdWJsaWMgYWRkTWVtYmVyKG1lbWJlcjogUHl0aG9uQmFzZSkge1xuICAgIHRoaXMubWVtYmVycy5wdXNoKG1lbWJlcik7XG4gIH1cblxuICBwdWJsaWMgYWRkUHl0aG9uTW9kdWxlKHB5TW9kOiBQeXRob25Nb2R1bGUpIHtcbiAgICBhc3NlcnQoXG4gICAgICAhdGhpcy5sb2FkQXNzZW1ibHksXG4gICAgICAnUHl0aG9uTW9kdWxlLmFkZFB5dGhvbk1vZHVsZSBDQU5OT1QgYmUgY2FsbGVkIG9uIGFzc2VtYmx5LWxvYWRpbmcgbW9kdWxlcyAoaXQgd291bGQgY2F1c2UgYSBsb2FkIGN5Y2xlKSEnLFxuICAgICk7XG4gICAgdGhpcy5tb2R1bGVzLnB1c2gocHlNb2QpO1xuICB9XG5cbiAgcHVibGljIHJlcXVpcmVkSW1wb3J0cyhjb250ZXh0OiBFbWl0Q29udGV4dCk6IFB5dGhvbkltcG9ydHMge1xuICAgIHJldHVybiBtZXJnZVB5dGhvbkltcG9ydHMoXG4gICAgICAuLi50aGlzLm1lbWJlcnMubWFwKChtZW0pID0+IG1lbS5yZXF1aXJlZEltcG9ydHMoY29udGV4dCkpLFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZW1pdChjb2RlOiBDb2RlTWFrZXIsIGNvbnRleHQ6IEVtaXRDb250ZXh0KSB7XG4gICAgdGhpcy5lbWl0TW9kdWxlRG9jdW1lbnRhdGlvbihjb2RlKTtcblxuICAgIGNvbnN0IHJlc29sdmVyID0gdGhpcy5mcW5cbiAgICAgID8gY29udGV4dC5yZXNvbHZlci5iaW5kKHRoaXMuZnFuLCB0aGlzLnB5dGhvbk5hbWUpXG4gICAgICA6IGNvbnRleHQucmVzb2x2ZXI7XG4gICAgY29udGV4dCA9IHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICBzdWJtb2R1bGU6IHRoaXMuZnFuID8/IGNvbnRleHQuc3VibW9kdWxlLFxuICAgICAgcmVzb2x2ZXIsXG4gICAgfTtcblxuICAgIC8vIEJlZm9yZSB3ZSB3cml0ZSBhbnl0aGluZyBlbHNlLCB3ZSBuZWVkIHRvIHdyaXRlIG91dCBvdXIgbW9kdWxlIGhlYWRlcnMsIHRoaXNcbiAgICAvLyBpcyB3aGVyZSB3ZSBoYW5kbGUgc3R1ZmYgbGlrZSBpbXBvcnRzLCBhbnkgcmVxdWlyZWQgaW5pdGlhbGl6YXRpb24sIGV0Yy5cbiAgICBjb2RlLmxpbmUoJ2ltcG9ydCBhYmMnKTtcbiAgICBjb2RlLmxpbmUoJ2ltcG9ydCBidWlsdGlucycpO1xuICAgIGNvZGUubGluZSgnaW1wb3J0IGRhdGV0aW1lJyk7XG4gICAgY29kZS5saW5lKCdpbXBvcnQgZW51bScpO1xuICAgIGNvZGUubGluZSgnaW1wb3J0IHR5cGluZycpO1xuICAgIGNvZGUubGluZSgpO1xuICAgIGNvZGUubGluZSgnaW1wb3J0IGpzaWknKTtcbiAgICBjb2RlLmxpbmUoJ2ltcG9ydCBwdWJsaWNhdGlvbicpO1xuICAgIGNvZGUubGluZSgnaW1wb3J0IHR5cGluZ19leHRlbnNpb25zJyk7XG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgd2UgbmVlZCB0byB3cml0ZSBvdXQgdGhlIGtlcm5lbCBsb2FkIGxpbmUuXG4gICAgaWYgKHRoaXMubG9hZEFzc2VtYmx5KSB7XG4gICAgICB0aGlzLmVtaXREZXBlbmRlbmN5SW1wb3J0cyhjb2RlKTtcblxuICAgICAgY29kZS5saW5lKCk7XG4gICAgICBlbWl0TGlzdChcbiAgICAgICAgY29kZSxcbiAgICAgICAgJ19fanNpaV9hc3NlbWJseV9fID0ganNpaS5KU0lJQXNzZW1ibHkubG9hZCgnLFxuICAgICAgICBbXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkodGhpcy5hc3NlbWJseS5uYW1lKSxcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0aGlzLmFzc2VtYmx5LnZlcnNpb24pLFxuICAgICAgICAgICdfX25hbWVfX1swOi02XScsXG4gICAgICAgICAgYCR7SlNPTi5zdHJpbmdpZnkodGhpcy5hc3NlbWJseUZpbGVuYW1lKX1gLFxuICAgICAgICBdLFxuICAgICAgICAnKScsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVuIHdlIG11c3QgaW1wb3J0IHRoZSAuX2pzaWkgc3VicGFja2FnZS5cbiAgICAgIGNvZGUubGluZSgpO1xuICAgICAgbGV0IGRpc3RhbmNlRnJvbVJvb3QgPSAwO1xuICAgICAgZm9yIChcbiAgICAgICAgbGV0IGN1cnIgPSB0aGlzLmZxbiE7XG4gICAgICAgIGN1cnIgIT09IHRoaXMuYXNzZW1ibHkubmFtZTtcbiAgICAgICAgY3VyciA9IGN1cnIuc3Vic3RyaW5nKDAsIGN1cnIubGFzdEluZGV4T2YoJy4nKSlcbiAgICAgICkge1xuICAgICAgICBkaXN0YW5jZUZyb21Sb290Kys7XG4gICAgICB9XG4gICAgICBjb2RlLmxpbmUoYGZyb20gJHsnLicucmVwZWF0KGRpc3RhbmNlRnJvbVJvb3QgKyAxKX1fanNpaSBpbXBvcnQgKmApO1xuXG4gICAgICB0aGlzLmVtaXRSZXF1aXJlZEltcG9ydHMoY29kZSwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gRW1pdCBhbGwgb2Ygb3VyIG1lbWJlcnMuXG4gICAgZm9yIChjb25zdCBtZW1iZXIgb2YgcHJlcGFyZU1lbWJlcnModGhpcy5tZW1iZXJzLCByZXNvbHZlcikpIHtcbiAgICAgIGNvZGUubGluZSgpO1xuICAgICAgY29kZS5saW5lKCk7XG4gICAgICBtZW1iZXIuZW1pdChjb2RlLCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICAvLyBXaGF0ZXZlciBuYW1lcyB3ZSd2ZSBleHBvcnRlZCwgd2UnbGwgd3JpdGUgb3V0IG91ciBfX2FsbF9fIHRoYXQgbGlzdHMgdGhlbS5cbiAgICBjb25zdCBleHBvcnRlZE1lbWJlcnMgPSB0aGlzLm1lbWJlcnMubWFwKChtKSA9PiBgXCIke20ucHl0aG9uTmFtZX1cImApO1xuICAgIGlmICh0aGlzLmxvYWRBc3NlbWJseSkge1xuICAgICAgZXhwb3J0ZWRNZW1iZXJzLnB1c2goJ1wiX19qc2lpX2Fzc2VtYmx5X19cIicpO1xuICAgIH1cblxuICAgIC8vIERlY2xhcmUgdGhlIGxpc3Qgb2YgXCJwdWJsaWNcIiBtZW1iZXJzIHRoaXMgbW9kdWxlIGV4cG9ydHNcbiAgICBpZiAodGhpcy5tZW1iZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvZGUubGluZSgpO1xuICAgIH1cbiAgICBjb2RlLmxpbmUoKTtcblxuICAgIGlmIChleHBvcnRlZE1lbWJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgY29kZS5pbmRlbnQoJ19fYWxsX18gPSBbJyk7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBleHBvcnRlZE1lbWJlcnMuc29ydCgpKSB7XG4gICAgICAgIC8vIFdyaXRpbmcgb25lIGJ5IGxpbmUgbWlnaHQgYmUgX2EgbG90XyBvZiBsaW5lcywgYnV0IGl0J2xsIG1ha2UgcmV2aWV3aW5nIGNoYW5nZXMgdG8gdGhlIGxpc3QgZWFzaWVyLiBUcnVzdCBtZS5cbiAgICAgICAgY29kZS5saW5lKGAke21lbWJlcn0sYCk7XG4gICAgICB9XG4gICAgICBjb2RlLnVuaW5kZW50KCddJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUubGluZSgnX19hbGxfXzogdHlwaW5nLkxpc3RbdHlwaW5nLkFueV0gPSBbXScpO1xuICAgIH1cblxuICAgIC8vIE5leHQgdXAsIHdlJ2xsIHVzZSBwdWJsaWNhdGlvbiB0byBlbnN1cmUgdGhhdCBhbGwgb2YgdGhlIG5vbi1wdWJsaWMgbmFtZXNcbiAgICAvLyBnZXQgaGlkZGVuIGZyb20gZGlyKCksIHRhYi1jb21wbGV0ZSwgZXRjLlxuICAgIGNvZGUubGluZSgpO1xuICAgIGNvZGUubGluZSgncHVibGljYXRpb24ucHVibGlzaCgpJyk7XG5cbiAgICAvLyBGaW5hbGx5LCB3ZSdsbCBsb2FkIGFsbCByZWdpc3RlcmVkIHB5dGhvbiBtb2R1bGVzXG4gICAgaWYgKHRoaXMubW9kdWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb2RlLmxpbmUoKTtcbiAgICAgIGNvZGUubGluZShcbiAgICAgICAgJyMgTG9hZGluZyBtb2R1bGVzIHRvIGVuc3VyZSB0aGVpciB0eXBlcyBhcmUgcmVnaXN0ZXJlZCB3aXRoIHRoZSBqc2lpIHJ1bnRpbWUgbGlicmFyeScsXG4gICAgICApO1xuICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgdGhpcy5tb2R1bGVzLnNvcnQoKGwsIHIpID0+XG4gICAgICAgIGwucHl0aG9uTmFtZS5sb2NhbGVDb21wYXJlKHIucHl0aG9uTmFtZSksXG4gICAgICApKSB7XG4gICAgICAgIGNvZGUubGluZShgaW1wb3J0ICR7bW9kdWxlLnB5dGhvbk5hbWV9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgdGhlIGJpbiBzY3JpcHRzIGlmIGJpbiBzZWN0aW9uIGRlZmluZWQuXG4gICAqL1xuICBwdWJsaWMgZW1pdEJpblNjcmlwdHMoY29kZTogQ29kZU1ha2VyKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHNjcmlwdHMgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuICAgIGlmICh0aGlzLmxvYWRBc3NlbWJseSkge1xuICAgICAgaWYgKHRoaXMuYXNzZW1ibHkuYmluICE9IG51bGwpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKHRoaXMuYXNzZW1ibHkuYmluKSkge1xuICAgICAgICAgIGNvbnN0IHNjcmlwdF9maWxlID0gcGF0aC5qb2luKFxuICAgICAgICAgICAgJ3NyYycsXG4gICAgICAgICAgICBweXRob25Nb2R1bGVOYW1lVG9GaWxlbmFtZSh0aGlzLnB5dGhvbk5hbWUpLFxuICAgICAgICAgICAgJ2JpbicsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29kZS5vcGVuRmlsZShzY3JpcHRfZmlsZSk7XG4gICAgICAgICAgY29kZS5saW5lKCcjIS91c3IvYmluL2VudiBweXRob24nKTtcbiAgICAgICAgICBjb2RlLmxpbmUoKTtcbiAgICAgICAgICBjb2RlLmxpbmUoJ2ltcG9ydCBqc2lpJyk7XG4gICAgICAgICAgY29kZS5saW5lKCdpbXBvcnQgc3lzJyk7XG4gICAgICAgICAgY29kZS5saW5lKCk7XG4gICAgICAgICAgZW1pdExpc3QoXG4gICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgJ19fanNpaV9hc3NlbWJseV9fID0ganNpaS5KU0lJQXNzZW1ibHkubG9hZCgnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0aGlzLmFzc2VtYmx5Lm5hbWUpLFxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0aGlzLmFzc2VtYmx5LnZlcnNpb24pLFxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0aGlzLnB5dGhvbk5hbWUucmVwbGFjZSgnLl9qc2lpJywgJycpKSxcbiAgICAgICAgICAgICAgYCR7SlNPTi5zdHJpbmdpZnkodGhpcy5hc3NlbWJseUZpbGVuYW1lKX1gLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICcpJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvZGUubGluZSgpO1xuICAgICAgICAgIGVtaXRMaXN0KFxuICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICdfX2pzaWlfYXNzZW1ibHlfXy5pbnZva2VCaW5TY3JpcHQoJyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkodGhpcy5hc3NlbWJseS5uYW1lKSxcbiAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobmFtZSksXG4gICAgICAgICAgICAgICdzeXMuYXJndlsxOl0nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICcpJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvZGUuY2xvc2VGaWxlKHNjcmlwdF9maWxlKTtcbiAgICAgICAgICBzY3JpcHRzLnB1c2goc2NyaXB0X2ZpbGUucmVwbGFjZSgvXFxcXC9nLCAnLycpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2NyaXB0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IHRoZSBSRUFETUUgYXMgbW9kdWxlIGRvY3N0cmluZyBpZiB0aGlzIGlzIHRoZSBlbnRyeSBwb2ludCBtb2R1bGUgKGl0IGxvYWRzIHRoZSBhc3NlbWJseSlcbiAgICovXG4gIHByaXZhdGUgZW1pdE1vZHVsZURvY3VtZW50YXRpb24oY29kZTogQ29kZU1ha2VyKSB7XG4gICAgaWYgKHRoaXMubW9kdWxlRG9jdW1lbnRhdGlvbikge1xuICAgICAgY29kZS5saW5lKERPQ1NUUklOR19RVU9URVMpO1xuICAgICAgY29kZS5saW5lKHRoaXMubW9kdWxlRG9jdW1lbnRhdGlvbik7XG4gICAgICBjb2RlLmxpbmUoRE9DU1RSSU5HX1FVT1RFUyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBlbWl0RGVwZW5kZW5jeUltcG9ydHMoY29kZTogQ29kZU1ha2VyKSB7XG4gICAgLy8gQ29sbGVjdCBhbGwgdGhlIChkaXJlY3QpIGRlcGVuZGVuY2llcycgLl9qc2lpIHBhY2thZ2VzLlxuICAgIGNvbnN0IGRlcHMgPSBPYmplY3Qua2V5cyh0aGlzLmFzc2VtYmx5LmRlcGVuZGVuY2llcyA/PyB7fSlcbiAgICAgIC5tYXAoXG4gICAgICAgIChkZXApID0+XG4gICAgICAgICAgdGhpcy5hc3NlbWJseS5kZXBlbmRlbmN5Q2xvc3VyZT8uW2RlcF0/LnRhcmdldHM/LnB5dGhvbj8ubW9kdWxlID8/XG4gICAgICAgICAgZGllKGBObyBQeXRob24gdGFyZ2V0IHdhcyBjb25maWdydWVkIGZvciB0aGUgZGVwZW5kZW5jeSBcIiR7ZGVwfVwiLmApLFxuICAgICAgKVxuICAgICAgLm1hcCgobW9kKSA9PiBgJHttb2R9Ll9qc2lpYClcbiAgICAgIC5zb3J0KCk7XG5cbiAgICAvLyBOb3cgYWN0dWFsbHkgd3JpdGUgdGhlIGltcG9ydCBzdGF0ZW1lbnRzLi4uXG4gICAgaWYgKGRlcHMubGVuZ3RoID4gMCkge1xuICAgICAgY29kZS5saW5lKCk7XG4gICAgICBmb3IgKGNvbnN0IG1vZHVsZU5hbWUgb2YgZGVwcykge1xuICAgICAgICBjb2RlLmxpbmUoYGltcG9ydCAke21vZHVsZU5hbWV9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBlbWl0UmVxdWlyZWRJbXBvcnRzKGNvZGU6IENvZGVNYWtlciwgY29udGV4dDogRW1pdENvbnRleHQpIHtcbiAgICBjb25zdCByZXF1aXJlZEltcG9ydHMgPSB0aGlzLnJlcXVpcmVkSW1wb3J0cyhjb250ZXh0KTtcbiAgICBjb25zdCBzdGF0ZW1lbnRzID0gT2JqZWN0LmVudHJpZXMocmVxdWlyZWRJbXBvcnRzKVxuICAgICAgLm1hcCgoW3NvdXJjZVBhY2thZ2UsIGl0ZW1zXSkgPT4gdG9JbXBvcnRTdGF0ZW1lbnRzKHNvdXJjZVBhY2thZ2UsIGl0ZW1zKSlcbiAgICAgIC5yZWR1Y2UoXG4gICAgICAgIChhY2MsIGVsdCkgPT4gWy4uLmFjYywgLi4uZWx0XSxcbiAgICAgICAgbmV3IEFycmF5PHsgZW1pdDogKCkgPT4gdm9pZDsgY29tcGFyaXNvbkJhc2U6IHN0cmluZyB9PigpLFxuICAgICAgKVxuICAgICAgLnNvcnQoaW1wb3J0Q29tcGFyYXRvcik7XG5cbiAgICBpZiAoc3RhdGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb2RlLmxpbmUoKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBzdGF0ZW1lbnQgb2Ygc3RhdGVtZW50cykge1xuICAgICAgc3RhdGVtZW50LmVtaXQoY29kZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JbXBvcnRTdGF0ZW1lbnRzKFxuICAgICAgc291cmNlUGtnOiBzdHJpbmcsXG4gICAgICBpdGVtczogUmVhZG9ubHlTZXQ8c3RyaW5nPixcbiAgICApOiBBcnJheTx7IGVtaXQ6IChjb2RlOiBDb2RlTWFrZXIpID0+IHZvaWQ7IGNvbXBhcmlzb25CYXNlOiBzdHJpbmcgfT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PHtcbiAgICAgICAgZW1pdDogKGNvZGU6IENvZGVNYWtlcikgPT4gdm9pZDtcbiAgICAgICAgY29tcGFyaXNvbkJhc2U6IHN0cmluZztcbiAgICAgIH0+KCk7XG4gICAgICBpZiAoaXRlbXMuaGFzKCcnKSkge1xuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgY29tcGFyaXNvbkJhc2U6IGBpbXBvcnQgJHtzb3VyY2VQa2d9YCxcbiAgICAgICAgICBlbWl0KGNvZGUpIHtcbiAgICAgICAgICAgIGNvZGUubGluZSh0aGlzLmNvbXBhcmlzb25CYXNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBpZWNlTWVhbCA9IEFycmF5LmZyb20oaXRlbXMpXG4gICAgICAgIC5maWx0ZXIoKGkpID0+IGkgIT09ICcnKVxuICAgICAgICAuc29ydCgpO1xuICAgICAgaWYgKHBpZWNlTWVhbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICBjb21wYXJpc29uQmFzZTogYGZyb20gJHtzb3VyY2VQa2d9IGltcG9ydGAsXG4gICAgICAgICAgZW1pdDogKGNvZGUpID0+XG4gICAgICAgICAgICBlbWl0TGlzdChjb2RlLCBgZnJvbSAke3NvdXJjZVBrZ30gaW1wb3J0IGAsIHBpZWNlTWVhbCwgJycsIHtcbiAgICAgICAgICAgICAgaWZNdWx0aTogWycoJywgJyknXSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW1wb3J0Q29tcGFyYXRvcihcbiAgICAgIGxlZnQ6IHsgY29tcGFyaXNvbkJhc2U6IHN0cmluZyB9LFxuICAgICAgcmlnaHQ6IHsgY29tcGFyaXNvbkJhc2U6IHN0cmluZyB9LFxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBsZWZ0LmNvbXBhcmlzb25CYXNlLnN0YXJ0c1dpdGgoJ2ltcG9ydCcpID09PVxuICAgICAgICByaWdodC5jb21wYXJpc29uQmFzZS5zdGFydHNXaXRoKCdpbXBvcnQnKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBsZWZ0LmNvbXBhcmlzb25CYXNlLmxvY2FsZUNvbXBhcmUocmlnaHQuY29tcGFyaXNvbkJhc2UpO1xuICAgICAgfVxuICAgICAgLy8gV2Ugd2FudCBcImZyb20gLmZvbyBpbXBvcnQgKC4uLilcIiB0byBiZSAqYWZ0ZXIqIFwiaW1wb3J0IGJhclwiXG4gICAgICByZXR1cm4gcmlnaHQuY29tcGFyaXNvbkJhc2UubG9jYWxlQ29tcGFyZShsZWZ0LmNvbXBhcmlzb25CYXNlKTtcbiAgICB9XG4gIH1cbn1cblxuaW50ZXJmYWNlIFBhY2thZ2VEYXRhIHtcbiAgZmlsZW5hbWU6IHN0cmluZztcbiAgZGF0YTogc3RyaW5nIHwgdW5kZWZpbmVkO1xufVxuXG5jbGFzcyBQYWNrYWdlIHtcbiAgLyoqXG4gICAqIFRoZSBQeXRob25Nb2R1bGUgdGhhdCByZXByZXNlbnRzIHRoZSByb290IG1vZHVsZSBvZiB0aGUgcGFja2FnZVxuICAgKi9cbiAgcHVibGljIHJvb3RNb2R1bGU/OiBQeXRob25Nb2R1bGU7XG5cbiAgcHVibGljIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IHZlcnNpb246IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IG1ldGFkYXRhOiBzcGVjLkFzc2VtYmx5O1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgbW9kdWxlcyA9IG5ldyBNYXA8c3RyaW5nLCBQeXRob25Nb2R1bGU+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgZGF0YSA9IG5ldyBNYXA8c3RyaW5nLCBQYWNrYWdlRGF0YVtdPigpO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIHZlcnNpb246IHN0cmluZywgbWV0YWRhdGE6IHNwZWMuQXNzZW1ibHkpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICB9XG5cbiAgcHVibGljIGFkZE1vZHVsZShtb2R1bGU6IFB5dGhvbk1vZHVsZSkge1xuICAgIHRoaXMubW9kdWxlcy5zZXQobW9kdWxlLnB5dGhvbk5hbWUsIG1vZHVsZSk7XG5cbiAgICAvLyBUaGlzIGlzIHRoZSBtb2R1bGUgdGhhdCByZXByZXNlbnRzIHRoZSBhc3NlbWJseVxuICAgIGlmIChtb2R1bGUuZnFuID09PSB0aGlzLm1ldGFkYXRhLm5hbWUpIHtcbiAgICAgIHRoaXMucm9vdE1vZHVsZSA9IG1vZHVsZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYWRkRGF0YShcbiAgICBtb2R1bGU6IFB5dGhvbk1vZHVsZSxcbiAgICBmaWxlbmFtZTogc3RyaW5nLFxuICAgIGRhdGE6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEuaGFzKG1vZHVsZS5weXRob25OYW1lKSkge1xuICAgICAgdGhpcy5kYXRhLnNldChtb2R1bGUucHl0aG9uTmFtZSwgW10pO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YS5nZXQobW9kdWxlLnB5dGhvbk5hbWUpIS5wdXNoKHsgZmlsZW5hbWUsIGRhdGEgfSk7XG4gIH1cblxuICBwdWJsaWMgd3JpdGUoY29kZTogQ29kZU1ha2VyLCBjb250ZXh0OiBFbWl0Q29udGV4dCkge1xuICAgIGNvbnN0IG1vZHVsZXMgPSBbLi4udGhpcy5tb2R1bGVzLnZhbHVlcygpXS5zb3J0KChhLCBiKSA9PlxuICAgICAgYS5weXRob25OYW1lLmxvY2FsZUNvbXBhcmUoYi5weXRob25OYW1lKSxcbiAgICApO1xuXG4gICAgY29uc3Qgc2NyaXB0cyA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIG9mIG91ciBtb2R1bGVzLCBhbmQgd3JpdGUgdGhlbSBvdXQgdG8gZGlzay5cbiAgICBmb3IgKGNvbnN0IG1vZCBvZiBtb2R1bGVzKSB7XG4gICAgICBjb25zdCBmaWxlbmFtZSA9IHBhdGguam9pbihcbiAgICAgICAgJ3NyYycsXG4gICAgICAgIHB5dGhvbk1vZHVsZU5hbWVUb0ZpbGVuYW1lKG1vZC5weXRob25OYW1lKSxcbiAgICAgICAgJ19faW5pdF9fLnB5JyxcbiAgICAgICk7XG5cbiAgICAgIGNvZGUub3BlbkZpbGUoZmlsZW5hbWUpO1xuICAgICAgbW9kLmVtaXQoY29kZSwgY29udGV4dCk7XG4gICAgICBjb2RlLmNsb3NlRmlsZShmaWxlbmFtZSk7XG5cbiAgICAgIHNjcmlwdHMucHVzaCguLi5tb2QuZW1pdEJpblNjcmlwdHMoY29kZSkpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBvdXIgcGFja2FnZSBkYXRhLlxuICAgIGNvbnN0IHBhY2thZ2VEYXRhOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZ1tdIH0gPSB7fTtcbiAgICBmb3IgKGNvbnN0IFttb2QsIHBkYXRhXSBvZiB0aGlzLmRhdGEpIHtcbiAgICAgIGZvciAoY29uc3QgZGF0YSBvZiBwZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5kYXRhICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBmaWxlcGF0aCA9IHBhdGguam9pbihcbiAgICAgICAgICAgICdzcmMnLFxuICAgICAgICAgICAgcHl0aG9uTW9kdWxlTmFtZVRvRmlsZW5hbWUobW9kKSxcbiAgICAgICAgICAgIGRhdGEuZmlsZW5hbWUsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNvZGUub3BlbkZpbGUoZmlsZXBhdGgpO1xuICAgICAgICAgIGNvZGUubGluZShkYXRhLmRhdGEpO1xuICAgICAgICAgIGNvZGUuY2xvc2VGaWxlKGZpbGVwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwYWNrYWdlRGF0YVttb2RdID0gcGRhdGEubWFwKChwZCkgPT4gcGQuZmlsZW5hbWUpO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgb3VyIGxpc3Qgb2YgZGVwZW5kZW5jaWVzXG4gICAgY29uc3QgZGVwZW5kZW5jaWVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgW2RlcE5hbWUsIHZlcnNpb25dIG9mIE9iamVjdC5lbnRyaWVzKFxuICAgICAgdGhpcy5tZXRhZGF0YS5kZXBlbmRlbmNpZXMgPz8ge30sXG4gICAgKSkge1xuICAgICAgY29uc3QgZGVwSW5mbyA9IHRoaXMubWV0YWRhdGEuZGVwZW5kZW5jeUNsb3N1cmUhW2RlcE5hbWVdO1xuICAgICAgZGVwZW5kZW5jaWVzLnB1c2goXG4gICAgICAgIGAke2RlcEluZm8udGFyZ2V0cyEucHl0aG9uIS5kaXN0TmFtZX0ke3RvUHl0aG9uVmVyc2lvblJhbmdlKHZlcnNpb24pfWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIE5lZWQgdG8gYWx3YXlzIHdyaXRlIHRoaXMgZmlsZSBhcyB0aGUgYnVpbGQgcHJvY2VzcyBkZXBlbmRzIG9uIGl0LlxuICAgIC8vIE1ha2UgdXAgc29tZSBjb250ZW50cyBpZiB3ZSBkb24ndCBoYXZlIGFueXRoaW5nIHVzZWZ1bCB0byBzYXkuXG4gICAgY29kZS5vcGVuRmlsZSgnUkVBRE1FLm1kJyk7XG4gICAgY29kZS5saW5lKFxuICAgICAgdGhpcy5yb290TW9kdWxlPy5tb2R1bGVEb2N1bWVudGF0aW9uID8/XG4gICAgICAgIGAke3RoaXMubmFtZX1cXG4keyc9Jy5yZXBlYXQodGhpcy5uYW1lLmxlbmd0aCl9YCxcbiAgICApO1xuICAgIGNvZGUuY2xvc2VGaWxlKCdSRUFETUUubWQnKTtcblxuICAgIC8vIFN0cmlwIFwiIChidWlsZCBhYmNkZWYpXCIgZnJvbSB0aGUganNpaSB2ZXJzaW9uXG4gICAgY29uc3QganNpaVZlcnNpb25TaW1wbGUgPSB0aGlzLm1ldGFkYXRhLmpzaWlWZXJzaW9uLnJlcGxhY2UoLyAuKiQvLCAnJyk7XG5cbiAgICBjb25zdCBzZXR1cEt3YXJncyA9IHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLm1ldGFkYXRhLmRlc2NyaXB0aW9uLFxuICAgICAgbGljZW5zZTogdGhpcy5tZXRhZGF0YS5saWNlbnNlLFxuICAgICAgdXJsOiB0aGlzLm1ldGFkYXRhLmhvbWVwYWdlLFxuICAgICAgbG9uZ19kZXNjcmlwdGlvbl9jb250ZW50X3R5cGU6ICd0ZXh0L21hcmtkb3duJyxcbiAgICAgIGF1dGhvcjpcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5hdXRob3IubmFtZSArXG4gICAgICAgICh0aGlzLm1ldGFkYXRhLmF1dGhvci5lbWFpbCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBgPCR7dGhpcy5tZXRhZGF0YS5hdXRob3IuZW1haWx9PmBcbiAgICAgICAgICA6ICcnKSxcbiAgICAgIGJkaXN0X3doZWVsOiB7XG4gICAgICAgIHVuaXZlcnNhbDogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICBwcm9qZWN0X3VybHM6IHtcbiAgICAgICAgU291cmNlOiB0aGlzLm1ldGFkYXRhLnJlcG9zaXRvcnkudXJsLFxuICAgICAgfSxcbiAgICAgIHBhY2thZ2VfZGlyOiB7ICcnOiAnc3JjJyB9LFxuICAgICAgcGFja2FnZXM6IG1vZHVsZXMubWFwKChtKSA9PiBtLnB5dGhvbk5hbWUpLFxuICAgICAgcGFja2FnZV9kYXRhOiBwYWNrYWdlRGF0YSxcbiAgICAgIHB5dGhvbl9yZXF1aXJlczogJz49My42JyxcbiAgICAgIGluc3RhbGxfcmVxdWlyZXM6IFtcbiAgICAgICAgYGpzaWkke3RvUHl0aG9uVmVyc2lvblJhbmdlKGBeJHtqc2lpVmVyc2lvblNpbXBsZX1gKX1gLFxuICAgICAgICAncHVibGljYXRpb24+PTAuMC4zJyxcbiAgICAgIF1cbiAgICAgICAgLmNvbmNhdChkZXBlbmRlbmNpZXMpXG4gICAgICAgIC5zb3J0KCksXG4gICAgICBjbGFzc2lmaWVyczogW1xuICAgICAgICAnSW50ZW5kZWQgQXVkaWVuY2UgOjogRGV2ZWxvcGVycycsXG4gICAgICAgICdPcGVyYXRpbmcgU3lzdGVtIDo6IE9TIEluZGVwZW5kZW50JyxcbiAgICAgICAgJ1Byb2dyYW1taW5nIExhbmd1YWdlIDo6IEphdmFTY3JpcHQnLFxuICAgICAgICAnUHJvZ3JhbW1pbmcgTGFuZ3VhZ2UgOjogUHl0aG9uIDo6IDMgOjogT25seScsXG4gICAgICAgICdQcm9ncmFtbWluZyBMYW5ndWFnZSA6OiBQeXRob24gOjogMy42JyxcbiAgICAgICAgJ1Byb2dyYW1taW5nIExhbmd1YWdlIDo6IFB5dGhvbiA6OiAzLjcnLFxuICAgICAgICAnUHJvZ3JhbW1pbmcgTGFuZ3VhZ2UgOjogUHl0aG9uIDo6IDMuOCcsXG4gICAgICAgICdQcm9ncmFtbWluZyBMYW5ndWFnZSA6OiBQeXRob24gOjogMy45JyxcbiAgICAgICAgJ1R5cGluZyA6OiBUeXBlZCcsXG4gICAgICBdLFxuICAgICAgc2NyaXB0cyxcbiAgICB9O1xuXG4gICAgc3dpdGNoICh0aGlzLm1ldGFkYXRhLmRvY3M/LnN0YWJpbGl0eSkge1xuICAgICAgY2FzZSBzcGVjLlN0YWJpbGl0eS5FeHBlcmltZW50YWw6XG4gICAgICAgIHNldHVwS3dhcmdzLmNsYXNzaWZpZXJzLnB1c2goJ0RldmVsb3BtZW50IFN0YXR1cyA6OiA0IC0gQmV0YScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugc3BlYy5TdGFiaWxpdHkuU3RhYmxlOlxuICAgICAgICBzZXR1cEt3YXJncy5jbGFzc2lmaWVycy5wdXNoKFxuICAgICAgICAgICdEZXZlbG9wbWVudCBTdGF0dXMgOjogNSAtIFByb2R1Y3Rpb24vU3RhYmxlJyxcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHNwZWMuU3RhYmlsaXR5LkRlcHJlY2F0ZWQ6XG4gICAgICAgIHNldHVwS3dhcmdzLmNsYXNzaWZpZXJzLnB1c2goJ0RldmVsb3BtZW50IFN0YXR1cyA6OiA3IC0gSW5hY3RpdmUnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgLy8gTm8gJ0RldmVsb3BtZW50IFN0YXR1cycgdHJvdmUgY2xhc3NpZmllciBmb3IgeW91IVxuICAgIH1cblxuICAgIGlmIChzcGR4TGljZW5zZUxpc3RbdGhpcy5tZXRhZGF0YS5saWNlbnNlXT8ub3NpQXBwcm92ZWQpIHtcbiAgICAgIHNldHVwS3dhcmdzLmNsYXNzaWZpZXJzLnB1c2goJ0xpY2Vuc2UgOjogT1NJIEFwcHJvdmVkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYWRkaXRpb25hbENsYXNzaWZpZXJzID0gdGhpcy5tZXRhZGF0YS50YXJnZXRzPy5weXRob24/LmNsYXNzaWZpZXJzO1xuICAgIGlmIChhZGRpdGlvbmFsQ2xhc3NpZmllcnMgIT0gbnVsbCkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFkZGl0aW9uYWxDbGFzc2lmaWVycykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBUaGUgXCJqc2lpLnRhcmdldHMucHl0aG9uLmNsYXNzaWZpZXJzXCIgdmFsdWUgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzIGlmIHByb3ZpZGVkLCBidXQgZm91bmQgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIGFkZGl0aW9uYWxDbGFzc2lmaWVycyxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAyLFxuICAgICAgICAgICl9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIGRpc2NvdXJhZ2UgdXNpbmcgdGhvc2Ugc2luY2Ugd2UgYXV0b21hdGljYWxseSBzZXQgYSB2YWx1ZSBmb3IgdGhlbVxuICAgICAgZm9yIChsZXQgY2xhc3NpZmllciBvZiBhZGRpdGlvbmFsQ2xhc3NpZmllcnMuc29ydCgpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhc3NpZmllciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVGhlIFwianNpaS50YXJnZXRzLnB5dGhvbi5jbGFzc2lmaWVyc1wiIHZhbHVlIGNhbiBvbmx5IGNvbnRhaW4gc3RyaW5ncywgYnV0IGZvdW5kICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgIGNsYXNzaWZpZXIsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIDIsXG4gICAgICAgICAgICApfWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSdsbCBzcGxpdCBvbiBgOjpgIGFuZCByZS1qb2luIGxhdGVyIHNvIGNsYXNzaWZpZXJzIGFyZSBcIm5vcm1hbGl6ZWRcIiB0byBhIHN0YW5kYXJkIHNwYWNpbmdcbiAgICAgICAgY29uc3QgcGFydHMgPSBjbGFzc2lmaWVyLnNwbGl0KCc6OicpLm1hcCgocGFydCkgPT4gcGFydC50cmltKCkpO1xuICAgICAgICBjb25zdCByZXNlcnZlZENsYXNzaWZpZXJzID0gW1xuICAgICAgICAgICdEZXZlbG9wbWVudCBTdGF0dXMnLFxuICAgICAgICAgICdMaWNlbnNlJyxcbiAgICAgICAgICAnT3BlcmF0aW5nIFN5c3RlbScsXG4gICAgICAgICAgJ1R5cGluZycsXG4gICAgICAgIF07XG4gICAgICAgIGlmIChyZXNlcnZlZENsYXNzaWZpZXJzLmluY2x1ZGVzKHBhcnRzWzBdKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgQ2xhc3NpZmllcnMgc3RhcnRpbmcgd2l0aCAke3Jlc2VydmVkQ2xhc3NpZmllcnNcbiAgICAgICAgICAgICAgLm1hcCgoeCkgPT4gYFwiJHt4fSA6OlwiYClcbiAgICAgICAgICAgICAgLmpvaW4oXG4gICAgICAgICAgICAgICAgJywgJyxcbiAgICAgICAgICAgICAgKX0gYXJlIGF1dG9tYXRpY2FsbHkgc2V0IGFuZCBzaG91bGQgbm90IGJlIG1hbnVhbGx5IGNvbmZpZ3VyZWRgLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NpZmllciA9IHBhcnRzLmpvaW4oJyA6OiAnKTtcbiAgICAgICAgaWYgKHNldHVwS3dhcmdzLmNsYXNzaWZpZXJzLmluY2x1ZGVzKGNsYXNzaWZpZXIpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0dXBLd2FyZ3MuY2xhc3NpZmllcnMucHVzaChjbGFzc2lmaWVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZSBOZWVkIGEgc2V0dXAucHkgdG8gbWFrZSB0aGlzIFBhY2thZ2UsIGFjdHVhbGx5IGEgUGFja2FnZS5cbiAgICBjb2RlLm9wZW5GaWxlKCdzZXR1cC5weScpO1xuICAgIGNvZGUubGluZSgnaW1wb3J0IGpzb24nKTtcbiAgICBjb2RlLmxpbmUoJ2ltcG9ydCBzZXR1cHRvb2xzJyk7XG4gICAgY29kZS5saW5lKCk7XG4gICAgY29kZS5saW5lKCdrd2FyZ3MgPSBqc29uLmxvYWRzKCcpO1xuICAgIGNvZGUubGluZSgnICAgIFwiXCJcIicpO1xuICAgIGNvZGUubGluZShKU09OLnN0cmluZ2lmeShzZXR1cEt3YXJncywgbnVsbCwgNCkpO1xuICAgIGNvZGUubGluZSgnXCJcIlwiJyk7XG4gICAgY29kZS5saW5lKCcpJyk7XG4gICAgY29kZS5saW5lKCk7XG4gICAgY29kZS5vcGVuQmxvY2soJ3dpdGggb3BlbihcIlJFQURNRS5tZFwiLCBlbmNvZGluZz1cInV0ZjhcIikgYXMgZnAnKTtcbiAgICBjb2RlLmxpbmUoJ2t3YXJnc1tcImxvbmdfZGVzY3JpcHRpb25cIl0gPSBmcC5yZWFkKCknKTtcbiAgICBjb2RlLmNsb3NlQmxvY2soKTtcbiAgICBjb2RlLmxpbmUoKTtcbiAgICBjb2RlLmxpbmUoKTtcbiAgICBjb2RlLmxpbmUoJ3NldHVwdG9vbHMuc2V0dXAoKiprd2FyZ3MpJyk7XG4gICAgY29kZS5jbG9zZUZpbGUoJ3NldHVwLnB5Jyk7XG5cbiAgICAvLyBCZWNhdXNlIHdlJ3JlIGdvb2QgY2l0aXplbnMsIHdlJ3JlIGdvaW5nIHRvIGdvIGFoZWFkIGFuZCBzdXBwb3J0IHB5cHJvamVjdC50b21sXG4gICAgLy8gYXMgd2VsbC5cbiAgICAvLyBUT0RPOiBNaWdodCBiZSBlYXNpZXIgdG8ganVzdCB1c2UgYSBUT01MIGxpYnJhcnkgdG8gd3JpdGUgdGhpcyBvdXQuXG4gICAgY29kZS5vcGVuRmlsZSgncHlwcm9qZWN0LnRvbWwnKTtcbiAgICBjb2RlLmxpbmUoJ1tidWlsZC1zeXN0ZW1dJyk7XG4gICAgY29uc3QgYnVpbGRUb29scyA9IGZzXG4gICAgICAucmVhZEZpbGVTeW5jKHJlcXVpcmVtZW50c0ZpbGUsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSlcbiAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgIC5tYXAoKGxpbmUpID0+IC9eXFxzKiguKylcXHMqI1xccypidWlsZC1zeXN0ZW1cXHMqJC8uZXhlYyhsaW5lKT8uWzFdPy50cmltKCkpXG4gICAgICAucmVkdWNlKFxuICAgICAgICAoYnVpbGRUb29scywgZW50cnkpID0+IChlbnRyeSA/IFsuLi5idWlsZFRvb2xzLCBlbnRyeV0gOiBidWlsZFRvb2xzKSxcbiAgICAgICAgbmV3IEFycmF5PHN0cmluZz4oKSxcbiAgICAgICk7XG4gICAgY29kZS5saW5lKGByZXF1aXJlcyA9IFske2J1aWxkVG9vbHMubWFwKCh4KSA9PiBgXCIke3h9XCJgKS5qb2luKCcsICcpfV1gKTtcbiAgICBjb2RlLmxpbmUoJ2J1aWxkLWJhY2tlbmQgPSBcInNldHVwdG9vbHMuYnVpbGRfbWV0YVwiJyk7XG4gICAgY29kZS5jbG9zZUZpbGUoJ3B5cHJvamVjdC50b21sJyk7XG5cbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gd3JpdGUgb3V0IGEgTUFOSUZFU1QuaW4gdG8gZW5zdXJlIHRoYXQgYWxsIG9mIG91ciByZXF1aXJlZFxuICAgIC8vIGZpbGVzIGFyZSBpbmNsdWRlZC5cbiAgICBjb2RlLm9wZW5GaWxlKCdNQU5JRkVTVC5pbicpO1xuICAgIGNvZGUubGluZSgnaW5jbHVkZSBweXByb2plY3QudG9tbCcpO1xuICAgIGNvZGUuY2xvc2VGaWxlKCdNQU5JRkVTVC5pbicpO1xuICB9XG59XG5cbnR5cGUgRmluZE1vZHVsZUNhbGxiYWNrID0gKGZxbjogc3RyaW5nKSA9PiBzcGVjLkFzc2VtYmx5Q29uZmlndXJhdGlvbjtcbnR5cGUgRmluZFR5cGVDYWxsYmFjayA9IChmcW46IHN0cmluZykgPT4gc3BlYy5UeXBlO1xuXG5jbGFzcyBUeXBlUmVzb2x2ZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IHR5cGVzOiBNYXA8c3RyaW5nLCBQeXRob25UeXBlPjtcbiAgcHJpdmF0ZSByZWFkb25seSBib3VuZFRvPzogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IGJvdW5kUmUhOiBSZWdFeHA7XG4gIHByaXZhdGUgcmVhZG9ubHkgbW9kdWxlTmFtZT86IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBtb2R1bGVSZSE6IFJlZ0V4cDtcbiAgcHJpdmF0ZSByZWFkb25seSBmaW5kTW9kdWxlOiBGaW5kTW9kdWxlQ2FsbGJhY2s7XG4gIHByaXZhdGUgcmVhZG9ubHkgZmluZFR5cGU6IEZpbmRUeXBlQ2FsbGJhY2s7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHR5cGVzOiBNYXA8c3RyaW5nLCBQeXRob25UeXBlPixcbiAgICBmaW5kTW9kdWxlOiBGaW5kTW9kdWxlQ2FsbGJhY2ssXG4gICAgZmluZFR5cGU6IEZpbmRUeXBlQ2FsbGJhY2ssXG4gICAgYm91bmRUbz86IHN0cmluZyxcbiAgICBtb2R1bGVOYW1lPzogc3RyaW5nLFxuICApIHtcbiAgICB0aGlzLnR5cGVzID0gdHlwZXM7XG4gICAgdGhpcy5maW5kTW9kdWxlID0gZmluZE1vZHVsZTtcbiAgICB0aGlzLmZpbmRUeXBlID0gZmluZFR5cGU7XG4gICAgdGhpcy5tb2R1bGVOYW1lID0gbW9kdWxlTmFtZTtcbiAgICB0aGlzLmJvdW5kVG8gPSBib3VuZFRvICE9PSB1bmRlZmluZWQgPyB0aGlzLnRvUHl0aG9uRlFOKGJvdW5kVG8pIDogYm91bmRUbztcblxuICAgIGlmICh0aGlzLm1vZHVsZU5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5tb2R1bGVSZSA9IG5ldyBSZWdFeHAoXG4gICAgICAgIGBeKCR7ZXNjYXBlU3RyaW5nUmVnZXhwKHRoaXMubW9kdWxlTmFtZSl9KVxcXFwuKC4rKSRgLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ib3VuZFRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYm91bmRSZSA9IG5ldyBSZWdFeHAoXG4gICAgICAgIGBeKCR7ZXNjYXBlU3RyaW5nUmVnZXhwKHRoaXMuYm91bmRUbyl9KVxcXFwuKC4rKSRgLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYmluZChmcW46IHN0cmluZywgbW9kdWxlTmFtZT86IHN0cmluZyk6IFR5cGVSZXNvbHZlciB7XG4gICAgcmV0dXJuIG5ldyBUeXBlUmVzb2x2ZXIoXG4gICAgICB0aGlzLnR5cGVzLFxuICAgICAgdGhpcy5maW5kTW9kdWxlLFxuICAgICAgdGhpcy5maW5kVHlwZSxcbiAgICAgIGZxbixcbiAgICAgIG1vZHVsZU5hbWUgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG1vZHVsZU5hbWUuc3RhcnRzV2l0aCgnLicpXG4gICAgICAgICAgPyBgJHt0aGlzLm1vZHVsZU5hbWV9JHttb2R1bGVOYW1lfWBcbiAgICAgICAgICA6IG1vZHVsZU5hbWVcbiAgICAgICAgOiB0aGlzLm1vZHVsZU5hbWUsXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBpc0luTW9kdWxlKHR5cGVSZWY6IHNwZWMuTmFtZWRUeXBlUmVmZXJlbmNlIHwgc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgcHl0aG9uVHlwZSA9XG4gICAgICB0eXBlb2YgdHlwZVJlZiAhPT0gJ3N0cmluZycgPyB0aGlzLnRvUHl0aG9uRlFOKHR5cGVSZWYuZnFuKSA6IHR5cGVSZWY7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlUmUudGVzdChweXRob25UeXBlKTtcbiAgfVxuXG4gIHB1YmxpYyBpc0luTmFtZXNwYWNlKHR5cGVSZWY6IHNwZWMuTmFtZWRUeXBlUmVmZXJlbmNlIHwgc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgcHl0aG9uVHlwZSA9XG4gICAgICB0eXBlb2YgdHlwZVJlZiAhPT0gJ3N0cmluZycgPyB0aGlzLnRvUHl0aG9uRlFOKHR5cGVSZWYuZnFuKSA6IHR5cGVSZWY7XG4gICAgcmV0dXJuIHRoaXMuYm91bmRSZS50ZXN0KHB5dGhvblR5cGUpO1xuICB9XG5cbiAgcHVibGljIGdldFBhcmVudCh0eXBlUmVmOiBzcGVjLk5hbWVkVHlwZVJlZmVyZW5jZSB8IHN0cmluZyk6IFB5dGhvblR5cGUge1xuICAgIGNvbnN0IGZxbiA9IHR5cGVvZiB0eXBlUmVmICE9PSAnc3RyaW5nJyA/IHR5cGVSZWYuZnFuIDogdHlwZVJlZjtcbiAgICBjb25zdCBtYXRjaGVzID0gL14oLispXFwuW14uXSskLy5leGVjKGZxbik7XG4gICAgaWYgKG1hdGNoZXMgPT0gbnVsbCB8fCAhQXJyYXkuaXNBcnJheShtYXRjaGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEZRTjogJHtmcW59YCk7XG4gICAgfVxuICAgIGNvbnN0IFssIHBhcmVudEZRTl0gPSBtYXRjaGVzO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMudHlwZXMuZ2V0KHBhcmVudEZRTik7XG5cbiAgICBpZiAocGFyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgcGFyZW50OiAgJHtwYXJlbnRGUU59YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudDtcbiAgfVxuXG4gIHB1YmxpYyBnZXREZWZpbmluZ1B5dGhvbk1vZHVsZShcbiAgICB0eXBlUmVmOiBzcGVjLk5hbWVkVHlwZVJlZmVyZW5jZSB8IHN0cmluZyxcbiAgKTogc3RyaW5nIHtcbiAgICBjb25zdCBmcW4gPSB0eXBlb2YgdHlwZVJlZiAhPT0gJ3N0cmluZycgPyB0eXBlUmVmLmZxbiA6IHR5cGVSZWY7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy50eXBlcy5nZXQoZnFuKTtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGxldCBtb2QgPSBwYXJlbnQ7XG4gICAgICB3aGlsZSAoIShtb2QgaW5zdGFuY2VvZiBQeXRob25Nb2R1bGUpKSB7XG4gICAgICAgIG1vZCA9IHRoaXMuZ2V0UGFyZW50KG1vZC5mcW4hKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtb2QucHl0aG9uTmFtZTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXRjaGVzID0gL14oW14uXSspXFwuLy5leGVjKGZxbik7XG4gICAgaWYgKG1hdGNoZXMgPT0gbnVsbCB8fCAhQXJyYXkuaXNBcnJheShtYXRjaGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEZRTjogJHtmcW59YCk7XG4gICAgfVxuICAgIGNvbnN0IFssIGFzc21dID0gbWF0Y2hlcztcbiAgICByZXR1cm4gdGhpcy5maW5kTW9kdWxlKGFzc20pLnRhcmdldHMhLnB5dGhvbiEubW9kdWxlO1xuICB9XG5cbiAgcHVibGljIGdldFR5cGUodHlwZVJlZjogc3BlYy5OYW1lZFR5cGVSZWZlcmVuY2UpOiBQeXRob25UeXBlIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlcy5nZXQodHlwZVJlZi5mcW4pO1xuXG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgbG9jYXRlIHR5cGU6IFwiJHt0eXBlUmVmLmZxbn1cImApO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgcHVibGljIGRlcmVmZXJlbmNlKHR5cGVSZWY6IHN0cmluZyB8IHNwZWMuTmFtZWRUeXBlUmVmZXJlbmNlKTogc3BlYy5UeXBlIHtcbiAgICBpZiAodHlwZW9mIHR5cGVSZWYgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0eXBlUmVmID0gdHlwZVJlZi5mcW47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmRUeXBlKHR5cGVSZWYpO1xuICB9XG5cbiAgcHJpdmF0ZSB0b1B5dGhvbkZRTihmcW46IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgW2Fzc2VtYmx5TmFtZSwgLi4ucXVhbGlmaWVkSWRlbnRpZmllcnNdID0gZnFuLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgZnFuUGFydHM6IHN0cmluZ1tdID0gW1xuICAgICAgdGhpcy5maW5kTW9kdWxlKGFzc2VtYmx5TmFtZSkudGFyZ2V0cyEucHl0aG9uIS5tb2R1bGUsXG4gICAgXTtcblxuICAgIGZvciAoY29uc3QgcGFydCBvZiBxdWFsaWZpZWRJZGVudGlmaWVycykge1xuICAgICAgZnFuUGFydHMucHVzaCh0b1B5dGhvbklkZW50aWZpZXIocGFydCkpO1xuICAgIH1cblxuICAgIHJldHVybiBmcW5QYXJ0cy5qb2luKCcuJyk7XG4gIH1cbn1cblxuY2xhc3MgUHl0aG9uR2VuZXJhdG9yIGV4dGVuZHMgR2VuZXJhdG9yIHtcbiAgcHJpdmF0ZSBwYWNrYWdlITogUGFja2FnZTtcbiAgcHJpdmF0ZSByb290TW9kdWxlPzogUHl0aG9uTW9kdWxlO1xuICBwcml2YXRlIHJlYWRvbmx5IHR5cGVzOiBNYXA8c3RyaW5nLCBQeXRob25UeXBlPjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSByb3NldHRhOiBSb3NldHRhLFxuICAgIG9wdGlvbnM6IEdlbmVyYXRvck9wdGlvbnMgPSB7fSxcbiAgKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICB0aGlzLmNvZGUub3BlbkJsb2NrRm9ybWF0dGVyID0gKHMpID0+IGAke3N9OmA7XG4gICAgdGhpcy5jb2RlLmNsb3NlQmxvY2tGb3JtYXR0ZXIgPSAoX3MpID0+IGZhbHNlO1xuXG4gICAgdGhpcy50eXBlcyA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIHB1YmxpYyBlbWl0RG9jU3RyaW5nKFxuICAgIGNvZGU6IENvZGVNYWtlcixcbiAgICBhcGlMb2NhdGlvbjogQXBpTG9jYXRpb24sXG4gICAgZG9jczogc3BlYy5Eb2NzIHwgdW5kZWZpbmVkLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGFyZ3VtZW50cz86IERvY3VtZW50YWJsZUFyZ3VtZW50W107XG4gICAgICBkb2N1bWVudGFibGVJdGVtPzogc3RyaW5nO1xuICAgICAgdHJhaWxpbmdOZXdMaW5lPzogYm9vbGVhbjtcbiAgICB9ID0ge30sXG4gICkge1xuICAgIGlmICgoIWRvY3MgfHwgT2JqZWN0LmtleXMoZG9jcykubGVuZ3RoID09PSAwKSAmJiAhb3B0aW9ucy5hcmd1bWVudHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFkb2NzKSB7XG4gICAgICBkb2NzID0ge307XG4gICAgfVxuXG4gICAgY29uc3QgbGluZXMgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuXG4gICAgaWYgKGRvY3Muc3VtbWFyeSkge1xuICAgICAgbGluZXMucHVzaChtZDJyc3QocmVuZGVyU3VtbWFyeShkb2NzKSkpO1xuICAgICAgYnJrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJyaygpIHtcbiAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAwICYmIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmxvY2soaGVhZGluZzogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcsIGRvQnJrID0gdHJ1ZSkge1xuICAgICAgaWYgKGRvQnJrKSB7XG4gICAgICAgIGJyaygpO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGVudExpbmVzID0gbWQycnN0KGNvbnRlbnQpLnNwbGl0KCdcXG4nKTtcbiAgICAgIGlmIChjb250ZW50TGluZXMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgbGluZXMucHVzaChgOiR7aGVhZGluZ306ICR7Y29udGVudExpbmVzLmpvaW4oJycpfWAudHJpbSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmVzLnB1c2goYDoke2hlYWRpbmd9OmApO1xuICAgICAgICBicmsoKTtcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGNvbnRlbnRMaW5lcykge1xuICAgICAgICAgIGxpbmVzLnB1c2gobGluZS50cmltKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZG9CcmspIHtcbiAgICAgICAgYnJrKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRvY3MucmVtYXJrcykge1xuICAgICAgYnJrKCk7XG4gICAgICBsaW5lcy5wdXNoKFxuICAgICAgICAuLi5tZDJyc3QodGhpcy5jb252ZXJ0TWFya2Rvd24oZG9jcy5yZW1hcmtzID8/ICcnLCBhcGlMb2NhdGlvbikpLnNwbGl0KFxuICAgICAgICAgICdcXG4nLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICAgIGJyaygpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFyZ3VtZW50cz8ubGVuZ3RoID8/IDAgPiAwKSB7XG4gICAgICBicmsoKTtcbiAgICAgIGZvciAoY29uc3QgcGFyYW0gb2Ygb3B0aW9ucy5hcmd1bWVudHMhKSB7XG4gICAgICAgIC8vIEFkZCBhIGxpbmUgZm9yIGV2ZXJ5IGFyZ3VtZW50LiBFdmVuIGlmIHRoZXJlIGlzIG5vIGRlc2NyaXB0aW9uLCB3ZSBuZWVkXG4gICAgICAgIC8vIHRoZSBkb2NzdHJpbmcgc28gdGhhdCB0aGUgU3BoaW54IGV4dGVuc2lvbiBjYW4gYWRkIHRoZSB0eXBlIGFubm90YXRpb25zLlxuICAgICAgICBsaW5lcy5wdXNoKFxuICAgICAgICAgIGA6cGFyYW0gJHt0b1B5dGhvblBhcmFtZXRlck5hbWUocGFyYW0ubmFtZSl9OiAke29uZWxpbmVEZXNjcmlwdGlvbihcbiAgICAgICAgICAgIHBhcmFtLmRvY3MsXG4gICAgICAgICAgKX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYnJrKCk7XG4gICAgfVxuXG4gICAgaWYgKGRvY3MuZGVmYXVsdCkge1xuICAgICAgYmxvY2soJ2RlZmF1bHQnLCBkb2NzLmRlZmF1bHQpO1xuICAgIH1cbiAgICBpZiAoZG9jcy5yZXR1cm5zKSB7XG4gICAgICBibG9jaygncmV0dXJuJywgZG9jcy5yZXR1cm5zKTtcbiAgICB9XG4gICAgaWYgKGRvY3MuZGVwcmVjYXRlZCkge1xuICAgICAgYmxvY2soJ2RlcHJlY2F0ZWQnLCBkb2NzLmRlcHJlY2F0ZWQpO1xuICAgIH1cbiAgICBpZiAoZG9jcy5zZWUpIHtcbiAgICAgIGJsb2NrKCdzZWUnLCBkb2NzLnNlZSwgZmFsc2UpO1xuICAgIH1cbiAgICBpZiAoZG9jcy5zdGFiaWxpdHkgJiYgc2hvdWxkTWVudGlvblN0YWJpbGl0eShkb2NzLnN0YWJpbGl0eSkpIHtcbiAgICAgIGJsb2NrKCdzdGFiaWxpdHknLCBkb2NzLnN0YWJpbGl0eSwgZmFsc2UpO1xuICAgIH1cbiAgICBpZiAoZG9jcy5zdWJjbGFzc2FibGUpIHtcbiAgICAgIGJsb2NrKCdzdWJjbGFzc2FibGUnLCAnWWVzJyk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoZG9jcy5jdXN0b20gPz8ge30pKSB7XG4gICAgICBibG9jayhrLCB2LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKGRvY3MuZXhhbXBsZSkge1xuICAgICAgYnJrKCk7XG4gICAgICBsaW5lcy5wdXNoKCdFeGFtcGxlOjonKTtcbiAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgY29uc3QgZXhhbXBsZVRleHQgPSB0aGlzLmNvbnZlcnRFeGFtcGxlKGRvY3MuZXhhbXBsZSwgYXBpTG9jYXRpb24pO1xuXG4gICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgZXhhbXBsZVRleHQuc3BsaXQoJ1xcbicpKSB7XG4gICAgICAgIGxpbmVzLnB1c2goYCAgICAke2xpbmV9YCk7XG4gICAgICB9XG4gICAgICBicmsoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAobGluZXMubGVuZ3RoID4gMCAmJiBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgIGxpbmVzLnBvcCgpO1xuICAgIH1cblxuICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGluZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb2RlLmxpbmUoYCR7RE9DU1RSSU5HX1FVT1RFU30ke2xpbmVzWzBdfSR7RE9DU1RSSU5HX1FVT1RFU31gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZS5saW5lKGAke0RPQ1NUUklOR19RVU9URVN9JHtsaW5lc1swXX1gKTtcbiAgICAgIGxpbmVzLnNwbGljZSgwLCAxKTtcblxuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgIGNvZGUubGluZShsaW5lKTtcbiAgICAgIH1cblxuICAgICAgY29kZS5saW5lKERPQ1NUUklOR19RVU9URVMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50cmFpbGluZ05ld0xpbmUpIHtcbiAgICAgIGNvZGUubGluZSgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBjb252ZXJ0RXhhbXBsZShleGFtcGxlOiBzdHJpbmcsIGFwaUxvYzogQXBpTG9jYXRpb24pOiBzdHJpbmcge1xuICAgIGNvbnN0IHRyYW5zbGF0ZWQgPSB0aGlzLnJvc2V0dGEudHJhbnNsYXRlRXhhbXBsZShcbiAgICAgIGFwaUxvYyxcbiAgICAgIGV4YW1wbGUsXG4gICAgICBUYXJnZXRMYW5ndWFnZS5QWVRIT04sXG4gICAgICBlbmZvcmNlc1N0cmljdE1vZGUodGhpcy5hc3NlbWJseSksXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5wcmVmaXhEaXNjbGFpbWVyKHRyYW5zbGF0ZWQpO1xuICB9XG5cbiAgcHVibGljIGNvbnZlcnRNYXJrZG93bihtYXJrZG93bjogc3RyaW5nLCBhcGlMb2M6IEFwaUxvY2F0aW9uKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5yb3NldHRhLnRyYW5zbGF0ZVNuaXBwZXRzSW5NYXJrZG93bihcbiAgICAgIGFwaUxvYyxcbiAgICAgIG1hcmtkb3duLFxuICAgICAgVGFyZ2V0TGFuZ3VhZ2UuUFlUSE9OLFxuICAgICAgZW5mb3JjZXNTdHJpY3RNb2RlKHRoaXMuYXNzZW1ibHkpLFxuICAgICAgKHRyYW5zKSA9PiAoe1xuICAgICAgICBsYW5ndWFnZTogdHJhbnMubGFuZ3VhZ2UsXG4gICAgICAgIHNvdXJjZTogdGhpcy5wcmVmaXhEaXNjbGFpbWVyKHRyYW5zKSxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHByZWZpeERpc2NsYWltZXIodHJhbnNsYXRlZDogVHJhbnNsYXRpb24pIHtcbiAgICBpZiAoIXRyYW5zbGF0ZWQuZGlkQ29tcGlsZSAmJiBJTkNPTVBMRVRFX0RJU0NMQUlNRVJfTk9OQ09NUElMSU5HKSB7XG4gICAgICByZXR1cm4gYCMgJHtJTkNPTVBMRVRFX0RJU0NMQUlNRVJfTk9OQ09NUElMSU5HfVxcbiR7dHJhbnNsYXRlZC5zb3VyY2V9YDtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zbGF0ZWQuc291cmNlO1xuICB9XG5cbiAgcHVibGljIGdldFB5dGhvblR5cGUoZnFuOiBzdHJpbmcpOiBQeXRob25UeXBlIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlcy5nZXQoZnFuKTtcblxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGxvY2F0ZSB0eXBlOiBcIiR7ZnFufVwiYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0QXNzZW1ibHlPdXRwdXREaXIoYXNzbTogc3BlYy5Bc3NlbWJseSkge1xuICAgIHJldHVybiBwYXRoLmpvaW4oXG4gICAgICAnc3JjJyxcbiAgICAgIHB5dGhvbk1vZHVsZU5hbWVUb0ZpbGVuYW1lKHRoaXMuZ2V0QXNzZW1ibHlNb2R1bGVOYW1lKGFzc20pKSxcbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uQmVnaW5Bc3NlbWJseShhc3NtOiBzcGVjLkFzc2VtYmx5LCBfZmluZ2VycHJpbnQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnBhY2thZ2UgPSBuZXcgUGFja2FnZShcbiAgICAgIGFzc20udGFyZ2V0cyEucHl0aG9uIS5kaXN0TmFtZSxcbiAgICAgIHRvUmVsZWFzZVZlcnNpb24oYXNzbS52ZXJzaW9uLCBUYXJnZXROYW1lLlBZVEhPTiksXG4gICAgICBhc3NtLFxuICAgICk7XG5cbiAgICAvLyBUaGlzIGlzIHRoZSAnPHBhY2thZ2VuYW1lPi5fanNpaScgbW9kdWxlIGZvciB0aGlzIGFzc2VtYmx5XG4gICAgY29uc3QgYXNzZW1ibHlNb2R1bGUgPSBuZXcgUHl0aG9uTW9kdWxlKFxuICAgICAgdGhpcy5nZXRBc3NlbWJseU1vZHVsZU5hbWUoYXNzbSksXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB7XG4gICAgICAgIGFzc2VtYmx5OiBhc3NtLFxuICAgICAgICBhc3NlbWJseUZpbGVuYW1lOiB0aGlzLmdldEFzc2VtYmx5RmlsZU5hbWUoKSxcbiAgICAgICAgbG9hZEFzc2VtYmx5OiB0cnVlLFxuICAgICAgICBwYWNrYWdlOiB0aGlzLnBhY2thZ2UsXG4gICAgICB9LFxuICAgICk7XG5cbiAgICB0aGlzLnBhY2thZ2UuYWRkTW9kdWxlKGFzc2VtYmx5TW9kdWxlKTtcbiAgICB0aGlzLnBhY2thZ2UuYWRkRGF0YShhc3NlbWJseU1vZHVsZSwgdGhpcy5nZXRBc3NlbWJseUZpbGVOYW1lKCksIHVuZGVmaW5lZCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25FbmRBc3NlbWJseShhc3NtOiBzcGVjLkFzc2VtYmx5LCBfZmluZ2VycHJpbnQ6IGJvb2xlYW4pIHtcbiAgICBjb25zdCByZXNvbHZlciA9IG5ldyBUeXBlUmVzb2x2ZXIoXG4gICAgICB0aGlzLnR5cGVzLFxuICAgICAgKGZxbjogc3RyaW5nKSA9PiB0aGlzLmZpbmRNb2R1bGUoZnFuKSxcbiAgICAgIChmcW46IHN0cmluZykgPT4gdGhpcy5maW5kVHlwZShmcW4pLFxuICAgICk7XG4gICAgdGhpcy5wYWNrYWdlLndyaXRlKHRoaXMuY29kZSwge1xuICAgICAgYXNzZW1ibHk6IGFzc20sXG4gICAgICBlbWl0dGVkVHlwZXM6IG5ldyBTZXQoKSxcbiAgICAgIHJlc29sdmVyLFxuICAgICAgc3VibW9kdWxlOiBhc3NtLm5hbWUsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogV2lsbCBiZSBjYWxsZWQgZm9yIGFzc2VtYmx5IHJvb3QsIG5hbWVzcGFjZXMgYW5kIHN1Ym1vZHVsZXMgKGFueXRoaW5nIHRoYXQgY29udGFpbnMgb3RoZXIgdHlwZXMsIGJhc2VkIG9uIGl0cyBGUU4pXG4gICAqL1xuICBwcm90ZWN0ZWQgb25CZWdpbk5hbWVzcGFjZShuczogc3RyaW5nKSB7XG4gICAgLy8gJ25zJyBjb250YWlucyBzb21ldGhpbmcgbGlrZSAnQHNjb3BlL2pzaWktY2FsYy1iYXNlLW9mLWJhc2UnXG4gICAgY29uc3Qgc3VibW9kdWxlTGlrZSA9XG4gICAgICBucyA9PT0gdGhpcy5hc3NlbWJseS5uYW1lXG4gICAgICAgID8gdGhpcy5hc3NlbWJseVxuICAgICAgICA6IHRoaXMuYXNzZW1ibHkuc3VibW9kdWxlcz8uW25zXTtcblxuICAgIGNvbnN0IHJlYWRtZUxvY2F0aW9uOiBBcGlMb2NhdGlvbiA9IHsgYXBpOiAnbW9kdWxlUmVhZG1lJywgbW9kdWxlRnFuOiBucyB9O1xuXG4gICAgY29uc3QgbW9kdWxlID0gbmV3IFB5dGhvbk1vZHVsZSh0b1BhY2thZ2VOYW1lKG5zLCB0aGlzLmFzc2VtYmx5KSwgbnMsIHtcbiAgICAgIGFzc2VtYmx5OiB0aGlzLmFzc2VtYmx5LFxuICAgICAgYXNzZW1ibHlGaWxlbmFtZTogdGhpcy5nZXRBc3NlbWJseUZpbGVOYW1lKCksXG4gICAgICBwYWNrYWdlOiB0aGlzLnBhY2thZ2UsXG4gICAgICBtb2R1bGVEb2N1bWVudGF0aW9uOiBzdWJtb2R1bGVMaWtlPy5yZWFkbWVcbiAgICAgICAgPyB0aGlzLmNvbnZlcnRNYXJrZG93bihcbiAgICAgICAgICAgIHN1Ym1vZHVsZUxpa2UucmVhZG1lPy5tYXJrZG93bixcbiAgICAgICAgICAgIHJlYWRtZUxvY2F0aW9uLFxuICAgICAgICAgICkudHJpbSgpXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgIH0pO1xuXG4gICAgdGhpcy5wYWNrYWdlLmFkZE1vZHVsZShtb2R1bGUpO1xuICAgIHRoaXMudHlwZXMuc2V0KG5zLCBtb2R1bGUpO1xuICAgIGlmIChucyA9PT0gdGhpcy5hc3NlbWJseS5uYW1lKSB7XG4gICAgICAvLyBUaGlzIGFwcGxpZXMgcmVjdXJzaXZlbHkgdG8gc3VibW9kdWxlcywgc28gbm8gbmVlZCB0byBkdXBsaWNhdGUhXG4gICAgICB0aGlzLnBhY2thZ2UuYWRkRGF0YShtb2R1bGUsICdweS50eXBlZCcsICcnKTtcbiAgICB9XG5cbiAgICBpZiAobnMgPT09IHRoaXMuYXNzZW1ibHkubmFtZSkge1xuICAgICAgdGhpcy5yb290TW9kdWxlID0gbW9kdWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJvb3RNb2R1bGUhLmFkZFB5dGhvbk1vZHVsZShtb2R1bGUpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBvbkVuZE5hbWVzcGFjZShuczogc3RyaW5nKSB7XG4gICAgaWYgKG5zID09PSB0aGlzLmFzc2VtYmx5Lm5hbWUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnJvb3RNb2R1bGU7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG9uQmVnaW5DbGFzcyhjbHM6IHNwZWMuQ2xhc3NUeXBlLCBhYnN0cmFjdDogYm9vbGVhbiB8IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGtsYXNzID0gbmV3IENsYXNzKFxuICAgICAgdGhpcyxcbiAgICAgIHRvUHl0aG9uSWRlbnRpZmllcihjbHMubmFtZSksXG4gICAgICBjbHMsXG4gICAgICBjbHMuZnFuLFxuICAgICAge1xuICAgICAgICBhYnN0cmFjdCxcbiAgICAgICAgYmFzZXM6IGNscy5iYXNlID8gW3RoaXMuZmluZFR5cGUoY2xzLmJhc2UpXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgaW50ZXJmYWNlczogY2xzLmludGVyZmFjZXM/Lm1hcCgoYmFzZSkgPT4gdGhpcy5maW5kVHlwZShiYXNlKSksXG4gICAgICAgIGFic3RyYWN0QmFzZXM6IGFic3RyYWN0ID8gdGhpcy5nZXRBYnN0cmFjdEJhc2VzKGNscykgOiBbXSxcbiAgICAgIH0sXG4gICAgICBjbHMuZG9jcyxcbiAgICApO1xuXG4gICAgaWYgKGNscy5pbml0aWFsaXplciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCB7IHBhcmFtZXRlcnMgPSBbXSB9ID0gY2xzLmluaXRpYWxpemVyO1xuXG4gICAgICBrbGFzcy5hZGRNZW1iZXIoXG4gICAgICAgIG5ldyBJbml0aWFsaXplcihcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgICdfX2luaXRfXycsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIGNscy5pbml0aWFsaXplci5kb2NzLFxuICAgICAgICAgIGZhbHNlLCAvLyBOZXZlciBzdGF0aWNcbiAgICAgICAgICB7IGxpZnRlZFByb3A6IHRoaXMuZ2V0bGlmdGVkUHJvcChjbHMuaW5pdGlhbGl6ZXIpLCBwYXJlbnQ6IGNscyB9LFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZFB5dGhvblR5cGUoa2xhc3MpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uU3RhdGljTWV0aG9kKGNsczogc3BlYy5DbGFzc1R5cGUsIG1ldGhvZDogc3BlYy5NZXRob2QpIHtcbiAgICBjb25zdCB7IHBhcmFtZXRlcnMgPSBbXSB9ID0gbWV0aG9kO1xuXG4gICAgdGhpcy5nZXRQeXRob25UeXBlKGNscy5mcW4pLmFkZE1lbWJlcihcbiAgICAgIG5ldyBTdGF0aWNNZXRob2QoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRvUHl0aG9uTWV0aG9kTmFtZShtZXRob2QubmFtZSksXG4gICAgICAgIG1ldGhvZC5uYW1lLFxuICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICBtZXRob2QucmV0dXJucyxcbiAgICAgICAgbWV0aG9kLmRvY3MsXG4gICAgICAgIHRydWUsIC8vIEFsd2F5cyBzdGF0aWNcbiAgICAgICAge1xuICAgICAgICAgIGFic3RyYWN0OiBtZXRob2QuYWJzdHJhY3QsXG4gICAgICAgICAgbGlmdGVkUHJvcDogdGhpcy5nZXRsaWZ0ZWRQcm9wKG1ldGhvZCksXG4gICAgICAgICAgcGFyZW50OiBjbHMsXG4gICAgICAgIH0sXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25TdGF0aWNQcm9wZXJ0eShjbHM6IHNwZWMuQ2xhc3NUeXBlLCBwcm9wOiBzcGVjLlByb3BlcnR5KSB7XG4gICAgdGhpcy5nZXRQeXRob25UeXBlKGNscy5mcW4pLmFkZE1lbWJlcihcbiAgICAgIG5ldyBTdGF0aWNQcm9wZXJ0eShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdG9QeXRob25Qcm9wZXJ0eU5hbWUocHJvcC5uYW1lLCBwcm9wLmNvbnN0KSxcbiAgICAgICAgcHJvcC5uYW1lLFxuICAgICAgICBwcm9wLFxuICAgICAgICBwcm9wLmRvY3MsXG4gICAgICAgIHtcbiAgICAgICAgICBhYnN0cmFjdDogcHJvcC5hYnN0cmFjdCxcbiAgICAgICAgICBpbW11dGFibGU6IHByb3AuaW1tdXRhYmxlLFxuICAgICAgICAgIGlzU3RhdGljOiBwcm9wLnN0YXRpYyxcbiAgICAgICAgICBwYXJlbnQ6IGNscyxcbiAgICAgICAgfSxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1ldGhvZChjbHM6IHNwZWMuQ2xhc3NUeXBlLCBtZXRob2Q6IHNwZWMuTWV0aG9kKSB7XG4gICAgY29uc3QgeyBwYXJhbWV0ZXJzID0gW10gfSA9IG1ldGhvZDtcblxuICAgIGlmIChtZXRob2QuYXN5bmMpIHtcbiAgICAgIHRoaXMuZ2V0UHl0aG9uVHlwZShjbHMuZnFuKS5hZGRNZW1iZXIoXG4gICAgICAgIG5ldyBBc3luY01ldGhvZChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHRvUHl0aG9uTWV0aG9kTmFtZShtZXRob2QubmFtZSwgbWV0aG9kLnByb3RlY3RlZCksXG4gICAgICAgICAgbWV0aG9kLm5hbWUsXG4gICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICBtZXRob2QucmV0dXJucyxcbiAgICAgICAgICBtZXRob2QuZG9jcyxcbiAgICAgICAgICAhIW1ldGhvZC5zdGF0aWMsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYWJzdHJhY3Q6IG1ldGhvZC5hYnN0cmFjdCxcbiAgICAgICAgICAgIGxpZnRlZFByb3A6IHRoaXMuZ2V0bGlmdGVkUHJvcChtZXRob2QpLFxuICAgICAgICAgICAgcGFyZW50OiBjbHMsXG4gICAgICAgICAgfSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2V0UHl0aG9uVHlwZShjbHMuZnFuKS5hZGRNZW1iZXIoXG4gICAgICAgIG5ldyBNZXRob2QoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICB0b1B5dGhvbk1ldGhvZE5hbWUobWV0aG9kLm5hbWUsIG1ldGhvZC5wcm90ZWN0ZWQpLFxuICAgICAgICAgIG1ldGhvZC5uYW1lLFxuICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgbWV0aG9kLnJldHVybnMsXG4gICAgICAgICAgbWV0aG9kLmRvY3MsXG4gICAgICAgICAgISFtZXRob2Quc3RhdGljLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFic3RyYWN0OiBtZXRob2QuYWJzdHJhY3QsXG4gICAgICAgICAgICBsaWZ0ZWRQcm9wOiB0aGlzLmdldGxpZnRlZFByb3AobWV0aG9kKSxcbiAgICAgICAgICAgIHBhcmVudDogY2xzLFxuICAgICAgICAgIH0sXG4gICAgICAgICksXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBvblByb3BlcnR5KGNsczogc3BlYy5DbGFzc1R5cGUsIHByb3A6IHNwZWMuUHJvcGVydHkpIHtcbiAgICB0aGlzLmdldFB5dGhvblR5cGUoY2xzLmZxbikuYWRkTWVtYmVyKFxuICAgICAgbmV3IFByb3BlcnR5KFxuICAgICAgICB0aGlzLFxuICAgICAgICB0b1B5dGhvblByb3BlcnR5TmFtZShwcm9wLm5hbWUsIHByb3AuY29uc3QsIHByb3AucHJvdGVjdGVkKSxcbiAgICAgICAgcHJvcC5uYW1lLFxuICAgICAgICBwcm9wLFxuICAgICAgICBwcm9wLmRvY3MsXG4gICAgICAgIHtcbiAgICAgICAgICBhYnN0cmFjdDogcHJvcC5hYnN0cmFjdCxcbiAgICAgICAgICBpbW11dGFibGU6IHByb3AuaW1tdXRhYmxlLFxuICAgICAgICAgIGlzU3RhdGljOiBwcm9wLnN0YXRpYyxcbiAgICAgICAgICBwYXJlbnQ6IGNscyxcbiAgICAgICAgfSxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvblVuaW9uUHJvcGVydHkoXG4gICAgY2xzOiBzcGVjLkNsYXNzVHlwZSxcbiAgICBwcm9wOiBzcGVjLlByb3BlcnR5LFxuICAgIF91bmlvbjogc3BlYy5VbmlvblR5cGVSZWZlcmVuY2UsXG4gICkge1xuICAgIHRoaXMub25Qcm9wZXJ0eShjbHMsIHByb3ApO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uQmVnaW5JbnRlcmZhY2UoaWZjOiBzcGVjLkludGVyZmFjZVR5cGUpIHtcbiAgICBsZXQgaWZhY2U6IEludGVyZmFjZSB8IFN0cnVjdDtcblxuICAgIGlmIChpZmMuZGF0YXR5cGUpIHtcbiAgICAgIGlmYWNlID0gbmV3IFN0cnVjdChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdG9QeXRob25JZGVudGlmaWVyKGlmYy5uYW1lKSxcbiAgICAgICAgaWZjLFxuICAgICAgICBpZmMuZnFuLFxuICAgICAgICB7IGJhc2VzOiBpZmMuaW50ZXJmYWNlcz8ubWFwKChiYXNlKSA9PiB0aGlzLmZpbmRUeXBlKGJhc2UpKSB9LFxuICAgICAgICBpZmMuZG9jcyxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmYWNlID0gbmV3IEludGVyZmFjZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdG9QeXRob25JZGVudGlmaWVyKGlmYy5uYW1lKSxcbiAgICAgICAgaWZjLFxuICAgICAgICBpZmMuZnFuLFxuICAgICAgICB7IGJhc2VzOiBpZmMuaW50ZXJmYWNlcz8ubWFwKChiYXNlKSA9PiB0aGlzLmZpbmRUeXBlKGJhc2UpKSB9LFxuICAgICAgICBpZmMuZG9jcyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRQeXRob25UeXBlKGlmYWNlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkVuZEludGVyZmFjZShfaWZjOiBzcGVjLkludGVyZmFjZVR5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm90ZWN0ZWQgb25JbnRlcmZhY2VNZXRob2QoaWZjOiBzcGVjLkludGVyZmFjZVR5cGUsIG1ldGhvZDogc3BlYy5NZXRob2QpIHtcbiAgICBjb25zdCB7IHBhcmFtZXRlcnMgPSBbXSB9ID0gbWV0aG9kO1xuXG4gICAgdGhpcy5nZXRQeXRob25UeXBlKGlmYy5mcW4pLmFkZE1lbWJlcihcbiAgICAgIG5ldyBJbnRlcmZhY2VNZXRob2QoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRvUHl0aG9uTWV0aG9kTmFtZShtZXRob2QubmFtZSwgbWV0aG9kLnByb3RlY3RlZCksXG4gICAgICAgIG1ldGhvZC5uYW1lLFxuICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICBtZXRob2QucmV0dXJucyxcbiAgICAgICAgbWV0aG9kLmRvY3MsXG4gICAgICAgICEhbWV0aG9kLnN0YXRpYyxcbiAgICAgICAgeyBsaWZ0ZWRQcm9wOiB0aGlzLmdldGxpZnRlZFByb3AobWV0aG9kKSwgcGFyZW50OiBpZmMgfSxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkludGVyZmFjZVByb3BlcnR5KGlmYzogc3BlYy5JbnRlcmZhY2VUeXBlLCBwcm9wOiBzcGVjLlByb3BlcnR5KSB7XG4gICAgbGV0IGlmYWNlUHJvcGVydHk6IEludGVyZmFjZVByb3BlcnR5IHwgU3RydWN0RmllbGQ7XG5cbiAgICBpZiAoaWZjLmRhdGF0eXBlKSB7XG4gICAgICBpZmFjZVByb3BlcnR5ID0gbmV3IFN0cnVjdEZpZWxkKHRoaXMsIHByb3AsIGlmYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmYWNlUHJvcGVydHkgPSBuZXcgSW50ZXJmYWNlUHJvcGVydHkoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRvUHl0aG9uUHJvcGVydHlOYW1lKHByb3AubmFtZSwgcHJvcC5jb25zdCwgcHJvcC5wcm90ZWN0ZWQpLFxuICAgICAgICBwcm9wLm5hbWUsXG4gICAgICAgIHByb3AsXG4gICAgICAgIHByb3AuZG9jcyxcbiAgICAgICAgeyBpbW11dGFibGU6IHByb3AuaW1tdXRhYmxlLCBpc1N0YXRpYzogcHJvcC5zdGF0aWMsIHBhcmVudDogaWZjIH0sXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0UHl0aG9uVHlwZShpZmMuZnFuKS5hZGRNZW1iZXIoaWZhY2VQcm9wZXJ0eSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25CZWdpbkVudW0oZW5tOiBzcGVjLkVudW1UeXBlKSB7XG4gICAgdGhpcy5hZGRQeXRob25UeXBlKFxuICAgICAgbmV3IEVudW0odGhpcywgdG9QeXRob25JZGVudGlmaWVyKGVubS5uYW1lKSwgZW5tLCBlbm0uZnFuLCB7fSwgZW5tLmRvY3MpLFxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25FbnVtTWVtYmVyKGVubTogc3BlYy5FbnVtVHlwZSwgbWVtYmVyOiBzcGVjLkVudW1NZW1iZXIpIHtcbiAgICB0aGlzLmdldFB5dGhvblR5cGUoZW5tLmZxbikuYWRkTWVtYmVyKFxuICAgICAgbmV3IEVudW1NZW1iZXIoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRvUHl0aG9uSWRlbnRpZmllcihtZW1iZXIubmFtZSksXG4gICAgICAgIG1lbWJlci5uYW1lLFxuICAgICAgICBtZW1iZXIuZG9jcyxcbiAgICAgICAgZW5tLFxuICAgICAgKSxcbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uSW50ZXJmYWNlTWV0aG9kT3ZlcmxvYWQoXG4gICAgX2lmYzogc3BlYy5JbnRlcmZhY2VUeXBlLFxuICAgIF9vdmVybG9hZDogc3BlYy5NZXRob2QsXG4gICAgX29yaWdpbmFsTWV0aG9kOiBzcGVjLk1ldGhvZCxcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmhhbmRsZWQgVHlwZTogSW50ZXJmYWNlTWV0aG9kT3ZlcmxvYWQnKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1ldGhvZE92ZXJsb2FkKFxuICAgIF9jbHM6IHNwZWMuQ2xhc3NUeXBlLFxuICAgIF9vdmVybG9hZDogc3BlYy5NZXRob2QsXG4gICAgX29yaWdpbmFsTWV0aG9kOiBzcGVjLk1ldGhvZCxcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmhhbmRsZWQgVHlwZTogTWV0aG9kT3ZlcmxvYWQnKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvblN0YXRpY01ldGhvZE92ZXJsb2FkKFxuICAgIF9jbHM6IHNwZWMuQ2xhc3NUeXBlLFxuICAgIF9vdmVybG9hZDogc3BlYy5NZXRob2QsXG4gICAgX29yaWdpbmFsTWV0aG9kOiBzcGVjLk1ldGhvZCxcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmhhbmRsZWQgVHlwZTogU3RhdGljTWV0aG9kT3ZlcmxvYWQnKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0QXNzZW1ibHlNb2R1bGVOYW1lKGFzc206IHNwZWMuQXNzZW1ibHkpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHthc3NtLnRhcmdldHMhLnB5dGhvbiEubW9kdWxlfS5fanNpaWA7XG4gIH1cblxuICBwcml2YXRlIGdldFBhcmVudEZRTihmcW46IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgbSA9IC9eKC4rKVxcLlteLl0rJC8uZXhlYyhmcW4pO1xuXG4gICAgaWYgKG0gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZGV0ZXJtaW5lIHBhcmVudCBGUU4gb2Y6ICR7ZnFufWApO1xuICAgIH1cblxuICAgIHJldHVybiBtWzFdO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRQYXJlbnQoZnFuOiBzdHJpbmcpOiBQeXRob25UeXBlIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQeXRob25UeXBlKHRoaXMuZ2V0UGFyZW50RlFOKGZxbikpO1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRQeXRob25UeXBlKHR5cGU6IFB5dGhvblR5cGUpIHtcbiAgICBpZiAodHlwZS5mcW4gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIGEgUHl0aG9uIHR5cGUgd2l0aG91dCBhIEZRTi4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmdldFBhcmVudCh0eXBlLmZxbikuYWRkTWVtYmVyKHR5cGUpO1xuICAgIHRoaXMudHlwZXMuc2V0KHR5cGUuZnFuLCB0eXBlKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0bGlmdGVkUHJvcChcbiAgICBtZXRob2Q6IHNwZWMuTWV0aG9kIHwgc3BlYy5Jbml0aWFsaXplcixcbiAgKTogc3BlYy5JbnRlcmZhY2VUeXBlIHwgdW5kZWZpbmVkIHtcbiAgICAvLyBJZiB0aGVyZSBhcmUgcGFyYW1ldGVycyB0byB0aGlzIG1ldGhvZCwgYW5kIGlmIHRoZSBsYXN0IHBhcmFtZXRlcidzIHR5cGUgaXNcbiAgICAvLyBhIGRhdGF0eXBlIGludGVyZmFjZSwgdGhlbiB3ZSB3YW50IHRvIGxpZnQgdGhlIG1lbWJlcnMgb2YgdGhhdCBsYXN0IHBhcmFtdGVyXG4gICAgLy8gYXMga2V5d29yZCBhcmd1bWVudHMgdG8gdGhpcyBmdW5jdGlvbi5cbiAgICBpZiAobWV0aG9kLnBhcmFtZXRlcnM/Lmxlbmd0aCA/PyAwID49IDEpIHtcbiAgICAgIGNvbnN0IGxhc3RQYXJhbWV0ZXIgPSBtZXRob2QucGFyYW1ldGVycyEuc2xpY2UoLTEpWzBdO1xuICAgICAgaWYgKFxuICAgICAgICAhbGFzdFBhcmFtZXRlci52YXJpYWRpYyAmJlxuICAgICAgICBzcGVjLmlzTmFtZWRUeXBlUmVmZXJlbmNlKGxhc3RQYXJhbWV0ZXIudHlwZSlcbiAgICAgICkge1xuICAgICAgICBjb25zdCBsYXN0UGFyYW1ldGVyVHlwZSA9IHRoaXMuZmluZFR5cGUobGFzdFBhcmFtZXRlci50eXBlLmZxbik7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBzcGVjLmlzSW50ZXJmYWNlVHlwZShsYXN0UGFyYW1ldGVyVHlwZSkgJiZcbiAgICAgICAgICBsYXN0UGFyYW1ldGVyVHlwZS5kYXRhdHlwZVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gbGFzdFBhcmFtZXRlclR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRBYnN0cmFjdEJhc2VzKGNsczogc3BlYy5DbGFzc1R5cGUpOiBzcGVjLkNsYXNzVHlwZVtdIHtcbiAgICBjb25zdCBhYnN0cmFjdEJhc2VzOiBzcGVjLkNsYXNzVHlwZVtdID0gW107XG5cbiAgICBpZiAoY2xzLmJhc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgYmFzZSA9IHRoaXMuZmluZFR5cGUoY2xzLmJhc2UpO1xuXG4gICAgICBpZiAoIXNwZWMuaXNDbGFzc1R5cGUoYmFzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2xhc3MgaW5oZXJpdGVuY2UgdGhhdCBpc24ndCBhIGNsYXNzP1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJhc2UuYWJzdHJhY3QpIHtcbiAgICAgICAgYWJzdHJhY3RCYXNlcy5wdXNoKGJhc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhYnN0cmFjdEJhc2VzO1xuICB9XG59XG5cbi8qKlxuICogUG9zaXRpb25hbCBhcmd1bWVudCBvciBrZXl3b3JkIHBhcmFtZXRlclxuICovXG5pbnRlcmZhY2UgRG9jdW1lbnRhYmxlQXJndW1lbnQge1xuICBuYW1lOiBzdHJpbmc7XG4gIGRlZmluaW5nVHlwZTogc3BlYy5UeXBlO1xuICBkb2NzPzogc3BlYy5Eb2NzO1xufVxuXG4vKipcbiAqIFJlbmRlciBhIG9uZS1saW5lIGRlc2NyaXB0aW9uIG9mIHRoZSBnaXZlbiBkb2NzLCB1c2VkIGZvciBtZXRob2QgYXJndW1lbnRzIGFuZCBpbmxpbmVkIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gb25lbGluZURlc2NyaXB0aW9uKGRvY3M6IHNwZWMuRG9jcyB8IHVuZGVmaW5lZCkge1xuICAvLyBPbmx5IGNvbnNpZGVyIGEgc3Vic2V0IG9mIGZpZWxkcyBoZXJlLCB3ZSBkb24ndCBoYXZlIGEgbG90IG9mIGZvcm1hdHRpbmcgc3BhY2VcbiAgaWYgKCFkb2NzIHx8IE9iamVjdC5rZXlzKGRvY3MpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnLSc7XG4gIH1cblxuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBpZiAoZG9jcy5zdW1tYXJ5KSB7XG4gICAgcGFydHMucHVzaChtZDJyc3QocmVuZGVyU3VtbWFyeShkb2NzKSkpO1xuICB9XG4gIGlmIChkb2NzLnJlbWFya3MpIHtcbiAgICBwYXJ0cy5wdXNoKG1kMnJzdChkb2NzLnJlbWFya3MpKTtcbiAgfVxuICBpZiAoZG9jcy5kZWZhdWx0KSB7XG4gICAgcGFydHMucHVzaChgRGVmYXVsdDogJHttZDJyc3QoZG9jcy5kZWZhdWx0KX1gKTtcbiAgfVxuICByZXR1cm4gcGFydHMuam9pbignICcpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkTWVudGlvblN0YWJpbGl0eShzOiBzcGVjLlN0YWJpbGl0eSkge1xuICAvLyBEb24ndCByZW5kZXIgXCJzdGFibGVcIiBvciBcImV4dGVybmFsXCIsIHRob3NlIGFyZSBib3RoIHN0YWJsZSBieSBpbXBsaWNhdGlvbi5cbiAgcmV0dXJuIHMgPT09IHNwZWMuU3RhYmlsaXR5LkRlcHJlY2F0ZWQgfHwgcyA9PT0gc3BlYy5TdGFiaWxpdHkuRXhwZXJpbWVudGFsO1xufVxuXG5mdW5jdGlvbiBpc1N0cnVjdChcbiAgdHlwZVN5c3RlbTogcmVmbGVjdC5UeXBlU3lzdGVtLFxuICByZWY6IHNwZWMuVHlwZVJlZmVyZW5jZSxcbik6IGJvb2xlYW4ge1xuICBpZiAoIXNwZWMuaXNOYW1lZFR5cGVSZWZlcmVuY2UocmVmKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB0eXBlID0gdHlwZVN5c3RlbS50cnlGaW5kRnFuKHJlZi5mcW4pO1xuICByZXR1cm4gISEodHlwZT8uaXNJbnRlcmZhY2VUeXBlKCkgJiYgdHlwZT8uaXNEYXRhVHlwZSgpKTtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIGBfYCBhdCB0aGUgZW5kIG9mIGBuYW1lYCB1bnRpbCBpdCBubyBsb25nZXIgY29uZmxpY3RzIHdpdGggYW55IG9mIHRoZVxuICogZW50cmllcyBpbiBgaW5Vc2VgLlxuICpcbiAqIEBwYXJhbSBuYW1lICB0aGUgbmFtZSB0byBiZSBzbHVnaWZpZWQuXG4gKiBAcGFyYW0gaW5Vc2UgdGhlIG5hbWVzIHRoYXQgYXJlIGFscmVhZHkgYmVpbmcgdXNlZC5cbiAqXG4gKiBAcmV0dXJucyB0aGUgc2x1Z2lmaWVkIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHNsdWdpZnlBc05lZWRlZChuYW1lOiBzdHJpbmcsIGluVXNlOiByZWFkb25seSBzdHJpbmdbXSk6IHN0cmluZyB7XG4gIGNvbnN0IGluVXNlU2V0ID0gbmV3IFNldChpblVzZSk7XG4gIHdoaWxlIChpblVzZVNldC5oYXMobmFtZSkpIHtcbiAgICBuYW1lID0gYCR7bmFtZX1fYDtcbiAgfVxuICByZXR1cm4gbmFtZTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEJFSE9MRDogSGVscGVycyB0byBvdXRwdXQgY29kZSB0aGF0IGxvb2tzIGxpa2Ugd2hhdCBCbGFjayB3b3VsZCBmb3JtYXQgaW50by4uLlxuLy9cbi8vIEBzZWUgaHR0cHM6Ly9ibGFjay5yZWFkdGhlZG9jcy5pby9lbi9zdGFibGUvdGhlX2JsYWNrX2NvZGVfc3R5bGUuaHRtbFxuXG5jb25zdCBUQVJHRVRfTElORV9MRU5HVEggPSA4ODtcblxuZnVuY3Rpb24gb3BlblNpZ25hdHVyZShcbiAgY29kZTogQ29kZU1ha2VyLFxuICBrZXl3b3JkOiAnY2xhc3MnLFxuICBuYW1lOiBzdHJpbmcsXG4gIHBhcmFtczogcmVhZG9ubHkgc3RyaW5nW10sXG4pOiB2b2lkO1xuZnVuY3Rpb24gb3BlblNpZ25hdHVyZShcbiAgY29kZTogQ29kZU1ha2VyLFxuICBrZXl3b3JkOiAnZGVmJyxcbiAgbmFtZTogc3RyaW5nLFxuICBwYXJhbXM6IHJlYWRvbmx5IHN0cmluZ1tdLFxuICB0cmFpbGluZ0NvbW1hOiBib29sZWFuLFxuICByZXR1cm5UeXBlOiBzdHJpbmcsXG4pOiB2b2lkO1xuZnVuY3Rpb24gb3BlblNpZ25hdHVyZShcbiAgY29kZTogQ29kZU1ha2VyLFxuICBrZXl3b3JkOiAnY2xhc3MnIHwgJ2RlZicsXG4gIG5hbWU6IHN0cmluZyxcbiAgcGFyYW1zOiByZWFkb25seSBzdHJpbmdbXSxcbiAgdHJhaWxpbmdDb21tYSA9IGZhbHNlLFxuICByZXR1cm5UeXBlPzogc3RyaW5nLFxuKSB7XG4gIGNvbnN0IHByZWZpeCA9IGAke2tleXdvcmR9ICR7bmFtZX1gO1xuICBjb25zdCBzdWZmaXggPSByZXR1cm5UeXBlID8gYCAtPiAke3JldHVyblR5cGV9YCA6ICcnO1xuICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvZGUub3BlbkJsb2NrKGAke3ByZWZpeH0ke3JldHVyblR5cGUgPyAnKCknIDogJyd9JHtzdWZmaXh9YCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgam9pbiA9ICcsICc7XG4gIGNvbnN0IHsgZWxlbWVudHNTaXplLCBqb2luU2l6ZSB9ID0gdG90YWxTaXplT2YocGFyYW1zLCBqb2luKTtcblxuICBjb25zdCBoYXNDb21tZW50cyA9ICFwYXJhbXMuc29tZSgocGFyYW0pID0+IC8jIC4rJC8uZXhlYyhwYXJhbSkpO1xuXG4gIGlmIChcbiAgICBoYXNDb21tZW50cyAmJlxuICAgIFRBUkdFVF9MSU5FX0xFTkdUSCA+XG4gICAgICBjb2RlLmN1cnJlbnRJbmRlbnRMZW5ndGggK1xuICAgICAgICBwcmVmaXgubGVuZ3RoICtcbiAgICAgICAgZWxlbWVudHNTaXplICtcbiAgICAgICAgam9pblNpemUgK1xuICAgICAgICBzdWZmaXgubGVuZ3RoICtcbiAgICAgICAgMlxuICApIHtcbiAgICBjb2RlLm9wZW5CbG9jayhgJHtwcmVmaXh9KCR7cGFyYW1zLmpvaW4oam9pbil9KSR7c3VmZml4fWApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvZGUuaW5kZW50KGAke3ByZWZpeH0oYCk7XG4gIGlmIChcbiAgICAhaGFzQ29tbWVudHMgJiZcbiAgICBUQVJHRVRfTElORV9MRU5HVEggPlxuICAgICAgY29kZS5jdXJyZW50SW5kZW50TGVuZ3RoICtcbiAgICAgICAgZWxlbWVudHNTaXplICtcbiAgICAgICAgam9pblNpemUgK1xuICAgICAgICAodHJhaWxpbmdDb21tYSA/IDEgOiAwKVxuICApIHtcbiAgICBjb2RlLmxpbmUoYCR7cGFyYW1zLmpvaW4oam9pbil9JHt0cmFpbGluZ0NvbW1hID8gJywnIDogJyd9YCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBwYXJhbSBvZiBwYXJhbXMpIHtcbiAgICAgIGNvZGUubGluZShwYXJhbS5yZXBsYWNlKC8oXFxzKiMgLispPyQvLCAnLCQxJykpO1xuICAgIH1cbiAgfVxuICBjb2RlLnVuaW5kZW50KGZhbHNlKTtcbiAgY29kZS5vcGVuQmxvY2soYCkke3N1ZmZpeH1gKTtcbn1cblxuZnVuY3Rpb24gYXNzaWduQ2FsbFJlc3VsdChcbiAgY29kZTogQ29kZU1ha2VyLFxuICB2YXJpYWJsZTogc3RyaW5nLFxuICBmdW5jdDogc3RyaW5nLFxuICBwYXJhbXM6IHJlYWRvbmx5IHN0cmluZ1tdLFxuKSB7XG4gIGNvbnN0IHByZWZpeCA9IGAke3ZhcmlhYmxlfSA9ICR7ZnVuY3R9KGA7XG4gIGNvbnN0IHN1ZmZpeCA9ICcpJztcblxuICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvZGUubGluZShgJHtwcmVmaXh9JHtzdWZmaXh9YCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgam9pbiA9ICcsICc7XG4gIGNvbnN0IHsgZWxlbWVudHNTaXplLCBqb2luU2l6ZSB9ID0gdG90YWxTaXplT2YocGFyYW1zLCBqb2luKTtcblxuICBpZiAoXG4gICAgVEFSR0VUX0xJTkVfTEVOR1RIID5cbiAgICBjb2RlLmN1cnJlbnRJbmRlbnRMZW5ndGggK1xuICAgICAgcHJlZml4Lmxlbmd0aCArXG4gICAgICBlbGVtZW50c1NpemUgK1xuICAgICAgam9pblNpemUgK1xuICAgICAgc3VmZml4Lmxlbmd0aFxuICApIHtcbiAgICBjb2RlLmxpbmUoYCR7cHJlZml4fSR7cGFyYW1zLmpvaW4oam9pbil9JHtzdWZmaXh9YCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29kZS5pbmRlbnQocHJlZml4KTtcbiAgaWYgKFRBUkdFVF9MSU5FX0xFTkdUSCA+IGNvZGUuY3VycmVudEluZGVudExlbmd0aCArIGVsZW1lbnRzU2l6ZSArIGpvaW5TaXplKSB7XG4gICAgY29kZS5saW5lKHBhcmFtcy5qb2luKGpvaW4pKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHBhcmFtcykge1xuICAgICAgY29kZS5saW5lKGAke3BhcmFtfSxgKTtcbiAgICB9XG4gIH1cbiAgY29kZS51bmluZGVudChzdWZmaXgpO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25EaWN0aW9uYXJ5KFxuICBjb2RlOiBDb2RlTWFrZXIsXG4gIHZhcmlhYmxlOiBzdHJpbmcsXG4gIGVsZW1lbnRzOiByZWFkb25seSBzdHJpbmdbXSxcbiAgdHJhaWxpbmc/OiBzdHJpbmcsXG4gIGNvbXBhY3QgPSBmYWxzZSxcbik6IHZvaWQge1xuICBjb25zdCBzcGFjZSA9IGNvbXBhY3QgPyAnJyA6ICcgJztcblxuICBjb25zdCBwcmVmaXggPSBgJHt2YXJpYWJsZX0ke3NwYWNlfT0ke3NwYWNlfXtgO1xuICBjb25zdCBzdWZmaXggPSBgfSR7dHJhaWxpbmcgPz8gJyd9YDtcblxuICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgY29kZS5saW5lKGAke3ByZWZpeH0ke3N1ZmZpeH1gKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29tcGFjdCkge1xuICAgIGNvbnN0IGpvaW4gPSAnLCAnO1xuICAgIGNvbnN0IHsgZWxlbWVudHNTaXplLCBqb2luU2l6ZSB9ID0gdG90YWxTaXplT2YoZWxlbWVudHMsIGpvaW4pO1xuICAgIGlmIChcbiAgICAgIFRBUkdFVF9MSU5FX0xFTkdUSCA+XG4gICAgICBwcmVmaXgubGVuZ3RoICtcbiAgICAgICAgY29kZS5jdXJyZW50SW5kZW50TGVuZ3RoICtcbiAgICAgICAgZWxlbWVudHNTaXplICtcbiAgICAgICAgam9pblNpemUgK1xuICAgICAgICBzdWZmaXgubGVuZ3RoXG4gICAgKSB7XG4gICAgICBjb2RlLmxpbmUoYCR7cHJlZml4fSR7ZWxlbWVudHMuam9pbihqb2luKX0ke3N1ZmZpeH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBjb2RlLmluZGVudChwcmVmaXgpO1xuICBmb3IgKGNvbnN0IGVsdCBvZiBlbGVtZW50cykge1xuICAgIGNvZGUubGluZShgJHtlbHR9LGApO1xuICB9XG4gIGNvZGUudW5pbmRlbnQoc3VmZml4KTtcbn1cblxuZnVuY3Rpb24gZW1pdExpc3QoXG4gIGNvZGU6IENvZGVNYWtlcixcbiAgcHJlZml4OiBzdHJpbmcsXG4gIGVsZW1lbnRzOiByZWFkb25seSBzdHJpbmdbXSxcbiAgc3VmZml4OiBzdHJpbmcsXG4gIG9wdHM/OiB7IGlmTXVsdGk6IFtzdHJpbmcsIHN0cmluZ10gfSxcbikge1xuICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgY29kZS5saW5lKGAke3ByZWZpeH0ke3N1ZmZpeH1gKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBqb2luID0gJywgJztcbiAgY29uc3QgeyBlbGVtZW50c1NpemUsIGpvaW5TaXplIH0gPSB0b3RhbFNpemVPZihlbGVtZW50cywgam9pbik7XG4gIGlmIChcbiAgICBUQVJHRVRfTElORV9MRU5HVEggPlxuICAgIGNvZGUuY3VycmVudEluZGVudExlbmd0aCArXG4gICAgICBwcmVmaXgubGVuZ3RoICtcbiAgICAgIGVsZW1lbnRzU2l6ZSArXG4gICAgICBqb2luU2l6ZSArXG4gICAgICBzdWZmaXgubGVuZ3RoXG4gICkge1xuICAgIGNvZGUubGluZShgJHtwcmVmaXh9JHtlbGVtZW50cy5qb2luKGpvaW4pfSR7c3VmZml4fWApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IFtiZWZvcmUsIGFmdGVyXSA9IG9wdHM/LmlmTXVsdGkgPz8gWycnLCAnJ107XG5cbiAgY29kZS5pbmRlbnQoYCR7cHJlZml4fSR7YmVmb3JlfWApO1xuICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgY29kZS5saW5lKGVsZW1lbnRzWzBdKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoXG4gICAgICBUQVJHRVRfTElORV9MRU5HVEggPlxuICAgICAgY29kZS5jdXJyZW50SW5kZW50TGVuZ3RoICsgZWxlbWVudHNTaXplICsgam9pblNpemVcbiAgICApIHtcbiAgICAgIGNvZGUubGluZShlbGVtZW50cy5qb2luKGpvaW4pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBlbHQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgY29kZS5saW5lKGAke2VsdH0sYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvZGUudW5pbmRlbnQoYCR7YWZ0ZXJ9JHtzdWZmaXh9YCk7XG59XG5cbmZ1bmN0aW9uIHRvdGFsU2l6ZU9mKHN0cmluZ3M6IHJlYWRvbmx5IHN0cmluZ1tdLCBqb2luOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHtcbiAgICBlbGVtZW50c1NpemU6IHN0cmluZ3NcbiAgICAgIC5tYXAoKHN0cikgPT4gc3RyLmxlbmd0aClcbiAgICAgIC5yZWR1Y2UoKGFjYywgZWx0KSA9PiBhY2MgKyBlbHQsIDApLFxuICAgIGpvaW5TaXplOiBzdHJpbmdzLmxlbmd0aCA+IDEgPyBqb2luLmxlbmd0aCAqIChzdHJpbmdzLmxlbmd0aCAtIDEpIDogMCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gbmVzdGVkQ29udGV4dChcbiAgY29udGV4dDogRW1pdENvbnRleHQsXG4gIGZxbjogc3RyaW5nIHwgdW5kZWZpbmVkLFxuKTogRW1pdENvbnRleHQge1xuICByZXR1cm4ge1xuICAgIC4uLmNvbnRleHQsXG4gICAgc3Vycm91bmRpbmdUeXBlRnFuczpcbiAgICAgIGZxbiAhPSBudWxsXG4gICAgICAgID8gWy4uLihjb250ZXh0LnN1cnJvdW5kaW5nVHlwZUZxbnMgPz8gW10pLCBmcW5dXG4gICAgICAgIDogY29udGV4dC5zdXJyb3VuZGluZ1R5cGVGcW5zLFxuICB9O1xufVxuXG5jb25zdCBpc0RlcHJlY2F0ZWQgPSAoeDogUHl0aG9uQmFzZSkgPT4geC5kb2NzPy5kZXByZWNhdGVkICE9PSB1bmRlZmluZWQ7XG4iXX0=