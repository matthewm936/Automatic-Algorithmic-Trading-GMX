"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DotnetBuilder = exports.TARGET_FRAMEWORK = void 0;
const fs = require("fs-extra");
const path = require("path");
const xmlbuilder = require("xmlbuilder");
const logging = require("../logging");
const target_1 = require("../target");
const util_1 = require("../util");
const dotnetgenerator_1 = require("./dotnet/dotnetgenerator");
const version_utils_1 = require("./version-utils");
const _1 = require(".");
exports.TARGET_FRAMEWORK = 'netcoreapp3.1';
/**
 * Build .NET packages all together, by generating an aggregate solution file
 */
class DotnetBuilder {
    constructor(modules, options) {
        this.modules = modules;
        this.options = options;
        this.targetName = 'dotnet';
    }
    async buildModules() {
        if (this.modules.length === 0) {
            return;
        }
        if (this.options.codeOnly) {
            // Simple, just generate code to respective output dirs
            await Promise.all(this.modules.map((module) => this.generateModuleCode(module, this.outputDir(module.outputDirectory))));
            return;
        }
        // Otherwise make a single tempdir to hold all sources, build them together and copy them back out
        const scratchDirs = [];
        try {
            const tempSourceDir = await this.generateAggregateSourceDir(this.modules);
            scratchDirs.push(tempSourceDir);
            // Build solution
            logging.debug('Building .NET');
            await util_1.shell('dotnet', ['build', '--force', '--configuration', 'Release'], {
                cwd: tempSourceDir.directory,
                retry: { maxAttempts: 5 },
            });
            await this.copyOutArtifacts(tempSourceDir.object);
            if (this.options.clean) {
                await util_1.Scratch.cleanupAll(scratchDirs);
            }
        }
        catch (e) {
            logging.warn(`Exception occurred, not cleaning up ${scratchDirs
                .map((s) => s.directory)
                .join(', ')}`);
            throw e;
        }
    }
    async generateAggregateSourceDir(modules) {
        return util_1.Scratch.make(async (tmpDir) => {
            logging.debug(`Generating aggregate .NET source dir at ${tmpDir}`);
            const csProjs = [];
            const ret = [];
            // Code generator will make its own subdirectory
            const generatedModules = modules.map((mod) => this.generateModuleCode(mod, tmpDir).then(() => mod));
            for await (const mod of generatedModules) {
                const loc = projectLocation(mod);
                csProjs.push(loc.projectFile);
                ret.push({
                    outputTargetDirectory: mod.outputDirectory,
                    artifactsDir: path.join(tmpDir, loc.projectDir, 'bin', 'Release'),
                });
            }
            // Use 'dotnet' command line tool to build a solution file from these csprojs
            await util_1.shell('dotnet', ['new', 'sln', '-n', 'JsiiBuild'], { cwd: tmpDir });
            await util_1.shell('dotnet', ['sln', 'add', ...csProjs], { cwd: tmpDir });
            await this.generateNuGetConfigForLocalDeps(tmpDir);
            return ret;
        });
    }
    async copyOutArtifacts(packages) {
        logging.debug('Copying out .NET artifacts');
        await Promise.all(packages.map(copyOutIndividualArtifacts.bind(this)));
        async function copyOutIndividualArtifacts(pkg) {
            const targetDirectory = this.outputDir(pkg.outputTargetDirectory);
            await fs.mkdirp(targetDirectory);
            await fs.copy(pkg.artifactsDir, targetDirectory, {
                recursive: true,
                filter: (_, dst) => {
                    return dst !== path.join(targetDirectory, exports.TARGET_FRAMEWORK);
                },
            });
        }
    }
    async generateModuleCode(module, where) {
        const target = this.makeTarget(module);
        logging.debug(`Generating ${this.targetName} code into ${where}`);
        await target.generateCode(where, module.tarball);
    }
    /**
     * Decide whether or not to append 'dotnet' to the given output directory
     */
    outputDir(declaredDir) {
        return this.options.languageSubdirectory
            ? path.join(declaredDir, this.targetName)
            : declaredDir;
    }
    /**
     * Write a NuGet.config that will include build directories for local packages not in the current build
     *
     */
    async generateNuGetConfigForLocalDeps(where) {
        // Traverse the dependency graph of this module and find all modules that have
        // an <outdir>/dotnet directory. We will add those as local NuGet repositories.
        // This enables building against local modules.
        const allDepsOutputDirs = new Set();
        const resolvedModules = this.modules.map(async (module) => ({
            module,
            localBuildDirs: await target_1.findLocalBuildDirs(module.moduleDirectory, this.targetName),
        }));
        for await (const { module, localBuildDirs } of resolvedModules) {
            util_1.setExtend(allDepsOutputDirs, localBuildDirs);
            // Also include output directory where we're building to, in case we build multiple packages into
            // the same output directory.
            allDepsOutputDirs.add(this.outputDir(module.outputDirectory));
        }
        const localRepos = Array.from(allDepsOutputDirs);
        // If dotnet-runtime is checked-out and we can find a local repository, add it to the list.
        try {
            // eslint-disable-next-line @typescript-eslint/no-var-requires,@typescript-eslint/no-require-imports,import/no-extraneous-dependencies
            const jsiiDotNetRuntime = require('@jsii/dotnet-runtime');
            logging.info(`Using local version of the DotNet jsii runtime package at: ${jsiiDotNetRuntime.repository}`);
            localRepos.push(jsiiDotNetRuntime.repository);
        }
        catch {
            // Couldn't locate @jsii/dotnet-runtime, which is owkay!
        }
        // Filter out nonexistant directories, .NET will be unhappy if paths don't exist
        const existingLocalRepos = await util_1.filterAsync(localRepos, fs.pathExists);
        logging.debug('local NuGet repos:', existingLocalRepos);
        // Construct XML content.
        const configuration = xmlbuilder.create('configuration', {
            encoding: 'UTF-8',
        });
        const packageSources = configuration.ele('packageSources');
        const nugetOrgAdd = packageSources.ele('add');
        nugetOrgAdd.att('key', 'nuget.org');
        nugetOrgAdd.att('value', 'https://api.nuget.org/v3/index.json');
        nugetOrgAdd.att('protocolVersion', '3');
        existingLocalRepos.forEach((repo, index) => {
            const add = packageSources.ele('add');
            add.att('key', `local-${index}`);
            add.att('value', path.join(repo));
        });
        if (this.options.arguments['dotnet-nuget-global-packages-folder']) {
            // Ensure we're not using the configured cache folder
            configuration
                .ele('config')
                .ele('add')
                .att('key', 'globalPackagesFolder')
                .att('value', path.resolve(this.options.arguments['dotnet-nuget-global-packages-folder'], '.nuget', 'packages'));
        }
        const xml = configuration.end({ pretty: true });
        // Write XML content to NuGet.config.
        const filePath = path.join(where, 'NuGet.config');
        logging.debug(`Generated ${filePath}`);
        await fs.writeFile(filePath, xml);
    }
    makeTarget(module) {
        return new Dotnet({
            targetName: this.targetName,
            packageDir: module.moduleDirectory,
            assembly: module.assembly,
            fingerprint: this.options.fingerprint,
            force: this.options.force,
            arguments: this.options.arguments,
            rosetta: this.options.rosetta,
        }, this.modules.map((m) => m.name));
    }
}
exports.DotnetBuilder = DotnetBuilder;
function projectLocation(module) {
    const packageId = module.assembly.targets.dotnet.packageId;
    return {
        projectDir: packageId,
        projectFile: path.join(packageId, `${packageId}.csproj`),
    };
}
class Dotnet extends target_1.Target {
    constructor(options, assembliesCurrentlyBeingCompiled) {
        super(options);
        this.generator = new dotnetgenerator_1.DotNetGenerator(assembliesCurrentlyBeingCompiled, options.rosetta);
    }
    static toPackageInfos(assm) {
        const packageId = assm.targets.dotnet.packageId;
        const version = version_utils_1.toReleaseVersion(assm.version, _1.TargetName.DOTNET);
        const packageInfo = {
            repository: 'Nuget',
            url: `https://www.nuget.org/packages/${packageId}/${version}`,
            usage: {
                csproj: {
                    language: 'xml',
                    code: `<PackageReference Include="${packageId}" Version="${version}" />`,
                },
                dotnet: {
                    language: 'console',
                    code: `dotnet add package ${packageId} --version ${version}`,
                },
                'packages.config': {
                    language: 'xml',
                    code: `<package id="${packageId}" version="${version}" />`,
                },
            },
        };
        return { 'C#': packageInfo };
    }
    static toNativeReference(_type, options) {
        return {
            'c#': `using ${options.namespace};`,
        };
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async build(_sourceDir, _outDir) {
        throw new Error('Should not be called; use builder instead');
    }
}
exports.default = Dotnet;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG90bmV0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZG90bmV0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLCtCQUErQjtBQUMvQiw2QkFBNkI7QUFDN0IseUNBQXlDO0FBR3pDLHNDQUFzQztBQUV0QyxzQ0FLbUI7QUFDbkIsa0NBQWlFO0FBQ2pFLDhEQUEyRDtBQUMzRCxtREFBbUQ7QUFFbkQsd0JBQStCO0FBRWxCLFFBQUEsZ0JBQWdCLEdBQUcsZUFBZSxDQUFDO0FBRWhEOztHQUVHO0FBQ0gsTUFBYSxhQUFhO0lBR3hCLFlBQ21CLE9BQThCLEVBQzlCLE9BQXFCO1FBRHJCLFlBQU8sR0FBUCxPQUFPLENBQXVCO1FBQzlCLFlBQU8sR0FBUCxPQUFPLENBQWM7UUFKdkIsZUFBVSxHQUFHLFFBQVEsQ0FBQztJQUtwQyxDQUFDO0lBRUcsS0FBSyxDQUFDLFlBQVk7UUFDdkIsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDN0IsT0FBTztTQUNSO1FBRUQsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRTtZQUN6Qix1REFBdUQ7WUFDdkQsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUNmLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FDMUIsSUFBSSxDQUFDLGtCQUFrQixDQUNyQixNQUFNLEVBQ04sSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQ3ZDLENBQ0YsQ0FDRixDQUFDO1lBQ0YsT0FBTztTQUNSO1FBRUQsa0dBQWtHO1FBQ2xHLE1BQU0sV0FBVyxHQUF3QixFQUFFLENBQUM7UUFDNUMsSUFBSTtZQUNGLE1BQU0sYUFBYSxHQUFHLE1BQU0sSUFBSSxDQUFDLDBCQUEwQixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUMxRSxXQUFXLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBRWhDLGlCQUFpQjtZQUNqQixPQUFPLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBQy9CLE1BQU0sWUFBSyxDQUNULFFBQVEsRUFDUixDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsU0FBUyxDQUFDLEVBQ2xEO2dCQUNFLEdBQUcsRUFBRSxhQUFhLENBQUMsU0FBUztnQkFDNUIsS0FBSyxFQUFFLEVBQUUsV0FBVyxFQUFFLENBQUMsRUFBRTthQUMxQixDQUNGLENBQUM7WUFFRixNQUFNLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDbEQsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRTtnQkFDdEIsTUFBTSxjQUFPLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQ3ZDO1NBQ0Y7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLE9BQU8sQ0FBQyxJQUFJLENBQ1YsdUNBQXVDLFdBQVc7aUJBQy9DLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztpQkFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQ2hCLENBQUM7WUFDRixNQUFNLENBQUMsQ0FBQztTQUNUO0lBQ0gsQ0FBQztJQUVPLEtBQUssQ0FBQywwQkFBMEIsQ0FDdEMsT0FBOEI7UUFFOUIsT0FBTyxjQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxNQUFjLEVBQUUsRUFBRTtZQUMzQyxPQUFPLENBQUMsS0FBSyxDQUFDLDJDQUEyQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1lBRW5FLE1BQU0sT0FBTyxHQUFHLEVBQUUsQ0FBQztZQUNuQixNQUFNLEdBQUcsR0FBNkIsRUFBRSxDQUFDO1lBRXpDLGdEQUFnRDtZQUNoRCxNQUFNLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUMzQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FDckQsQ0FBQztZQUVGLElBQUksS0FBSyxFQUFFLE1BQU0sR0FBRyxJQUFJLGdCQUFnQixFQUFFO2dCQUN4QyxNQUFNLEdBQUcsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ2pDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO2dCQUM5QixHQUFHLENBQUMsSUFBSSxDQUFDO29CQUNQLHFCQUFxQixFQUFFLEdBQUcsQ0FBQyxlQUFlO29CQUMxQyxZQUFZLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLFVBQVUsRUFBRSxLQUFLLEVBQUUsU0FBUyxDQUFDO2lCQUNsRSxDQUFDLENBQUM7YUFDSjtZQUVELDZFQUE2RTtZQUM3RSxNQUFNLFlBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxXQUFXLENBQUMsRUFBRSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO1lBQzFFLE1BQU0sWUFBSyxDQUFDLFFBQVEsRUFBRSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO1lBRW5FLE1BQU0sSUFBSSxDQUFDLCtCQUErQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRW5ELE9BQU8sR0FBRyxDQUFDO1FBQ2IsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRU8sS0FBSyxDQUFDLGdCQUFnQixDQUFDLFFBQWtDO1FBQy9ELE9BQU8sQ0FBQyxLQUFLLENBQUMsNEJBQTRCLENBQUMsQ0FBQztRQUU1QyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQywwQkFBMEIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXZFLEtBQUssVUFBVSwwQkFBMEIsQ0FFdkMsR0FBMkI7WUFFM0IsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMscUJBQXFCLENBQUMsQ0FBQztZQUVsRSxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUM7WUFDakMsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsZUFBZSxFQUFFO2dCQUMvQyxTQUFTLEVBQUUsSUFBSTtnQkFDZixNQUFNLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUU7b0JBQ2pCLE9BQU8sR0FBRyxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLHdCQUFnQixDQUFDLENBQUM7Z0JBQzlELENBQUM7YUFDRixDQUFDLENBQUM7UUFDTCxDQUFDO0lBQ0gsQ0FBQztJQUVPLEtBQUssQ0FBQyxrQkFBa0IsQ0FDOUIsTUFBa0IsRUFDbEIsS0FBYTtRQUViLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdkMsT0FBTyxDQUFDLEtBQUssQ0FBQyxjQUFjLElBQUksQ0FBQyxVQUFVLGNBQWMsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUNsRSxNQUFNLE1BQU0sQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQ7O09BRUc7SUFDSyxTQUFTLENBQUMsV0FBbUI7UUFDbkMsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLG9CQUFvQjtZQUN0QyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQztZQUN6QyxDQUFDLENBQUMsV0FBVyxDQUFDO0lBQ2xCLENBQUM7SUFFRDs7O09BR0c7SUFDSyxLQUFLLENBQUMsK0JBQStCLENBQUMsS0FBYTtRQUN6RCw4RUFBOEU7UUFDOUUsK0VBQStFO1FBQy9FLCtDQUErQztRQUMvQyxNQUFNLGlCQUFpQixHQUFHLElBQUksR0FBRyxFQUFVLENBQUM7UUFFNUMsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQztZQUMxRCxNQUFNO1lBQ04sY0FBYyxFQUFFLE1BQU0sMkJBQWtCLENBQ3RDLE1BQU0sQ0FBQyxlQUFlLEVBQ3RCLElBQUksQ0FBQyxVQUFVLENBQ2hCO1NBQ0YsQ0FBQyxDQUFDLENBQUM7UUFDSixJQUFJLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLGNBQWMsRUFBRSxJQUFJLGVBQWUsRUFBRTtZQUM5RCxnQkFBUyxDQUFDLGlCQUFpQixFQUFFLGNBQWMsQ0FBQyxDQUFDO1lBRTdDLGlHQUFpRztZQUNqRyw2QkFBNkI7WUFDN0IsaUJBQWlCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7U0FDL0Q7UUFFRCxNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFFakQsMkZBQTJGO1FBQzNGLElBQUk7WUFDRixzSUFBc0k7WUFDdEksTUFBTSxpQkFBaUIsR0FBRyxPQUFPLENBQUMsc0JBQXNCLENBQUMsQ0FBQztZQUMxRCxPQUFPLENBQUMsSUFBSSxDQUNWLDhEQUE4RCxpQkFBaUIsQ0FBQyxVQUFVLEVBQUUsQ0FDN0YsQ0FBQztZQUNGLFVBQVUsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDL0M7UUFBQyxNQUFNO1lBQ04sd0RBQXdEO1NBQ3pEO1FBRUQsZ0ZBQWdGO1FBQ2hGLE1BQU0sa0JBQWtCLEdBQUcsTUFBTSxrQkFBVyxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFeEUsT0FBTyxDQUFDLEtBQUssQ0FBQyxvQkFBb0IsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO1FBRXhELHlCQUF5QjtRQUN6QixNQUFNLGFBQWEsR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDLGVBQWUsRUFBRTtZQUN2RCxRQUFRLEVBQUUsT0FBTztTQUNsQixDQUFDLENBQUM7UUFDSCxNQUFNLGNBQWMsR0FBRyxhQUFhLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFFM0QsTUFBTSxXQUFXLEdBQUcsY0FBYyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM5QyxXQUFXLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQztRQUNwQyxXQUFXLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxxQ0FBcUMsQ0FBQyxDQUFDO1FBQ2hFLFdBQVcsQ0FBQyxHQUFHLENBQUMsaUJBQWlCLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFFeEMsa0JBQWtCLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQ3pDLE1BQU0sR0FBRyxHQUFHLGNBQWMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDdEMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsU0FBUyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1lBQ2pDLEdBQUcsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNwQyxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMscUNBQXFDLENBQUMsRUFBRTtZQUNqRSxxREFBcUQ7WUFDckQsYUFBYTtpQkFDVixHQUFHLENBQUMsUUFBUSxDQUFDO2lCQUNiLEdBQUcsQ0FBQyxLQUFLLENBQUM7aUJBQ1YsR0FBRyxDQUFDLEtBQUssRUFBRSxzQkFBc0IsQ0FBQztpQkFDbEMsR0FBRyxDQUNGLE9BQU8sRUFDUCxJQUFJLENBQUMsT0FBTyxDQUNWLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLHFDQUFxQyxDQUFDLEVBQzdELFFBQVEsRUFDUixVQUFVLENBQ1gsQ0FDRixDQUFDO1NBQ0w7UUFFRCxNQUFNLEdBQUcsR0FBRyxhQUFhLENBQUMsR0FBRyxDQUFDLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7UUFFaEQscUNBQXFDO1FBQ3JDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQ2xELE9BQU8sQ0FBQyxLQUFLLENBQUMsYUFBYSxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZDLE1BQU0sRUFBRSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVPLFVBQVUsQ0FBQyxNQUFrQjtRQUNuQyxPQUFPLElBQUksTUFBTSxDQUNmO1lBQ0UsVUFBVSxFQUFFLElBQUksQ0FBQyxVQUFVO1lBQzNCLFVBQVUsRUFBRSxNQUFNLENBQUMsZUFBZTtZQUNsQyxRQUFRLEVBQUUsTUFBTSxDQUFDLFFBQVE7WUFDekIsV0FBVyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVztZQUNyQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLO1lBQ3pCLFNBQVMsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVM7WUFDakMsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTztTQUM5QixFQUNELElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQ2hDLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUFwT0Qsc0NBb09DO0FBY0QsU0FBUyxlQUFlLENBQUMsTUFBa0I7SUFDekMsTUFBTSxTQUFTLEdBQVcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUFRLENBQUMsTUFBTyxDQUFDLFNBQVMsQ0FBQztJQUNyRSxPQUFPO1FBQ0wsVUFBVSxFQUFFLFNBQVM7UUFDckIsV0FBVyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLEdBQUcsU0FBUyxTQUFTLENBQUM7S0FDekQsQ0FBQztBQUNKLENBQUM7QUFFRCxNQUFxQixNQUFPLFNBQVEsZUFBTTtJQW1DeEMsWUFDRSxPQUFzQixFQUN0QixnQ0FBMEM7UUFFMUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRWYsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLGlDQUFlLENBQ2xDLGdDQUFnQyxFQUNoQyxPQUFPLENBQUMsT0FBTyxDQUNoQixDQUFDO0lBQ0osQ0FBQztJQTVDTSxNQUFNLENBQUMsY0FBYyxDQUFDLElBQW1CO1FBRzlDLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxPQUFRLENBQUMsTUFBTyxDQUFDLFNBQVMsQ0FBQztRQUNsRCxNQUFNLE9BQU8sR0FBRyxnQ0FBZ0IsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLGFBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNsRSxNQUFNLFdBQVcsR0FBZ0I7WUFDL0IsVUFBVSxFQUFFLE9BQU87WUFDbkIsR0FBRyxFQUFFLGtDQUFrQyxTQUFTLElBQUksT0FBTyxFQUFFO1lBQzdELEtBQUssRUFBRTtnQkFDTCxNQUFNLEVBQUU7b0JBQ04sUUFBUSxFQUFFLEtBQUs7b0JBQ2YsSUFBSSxFQUFFLDhCQUE4QixTQUFTLGNBQWMsT0FBTyxNQUFNO2lCQUN6RTtnQkFDRCxNQUFNLEVBQUU7b0JBQ04sUUFBUSxFQUFFLFNBQVM7b0JBQ25CLElBQUksRUFBRSxzQkFBc0IsU0FBUyxjQUFjLE9BQU8sRUFBRTtpQkFDN0Q7Z0JBQ0QsaUJBQWlCLEVBQUU7b0JBQ2pCLFFBQVEsRUFBRSxLQUFLO29CQUNmLElBQUksRUFBRSxnQkFBZ0IsU0FBUyxjQUFjLE9BQU8sTUFBTTtpQkFDM0Q7YUFDRjtTQUNGLENBQUM7UUFDRixPQUFPLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFTSxNQUFNLENBQUMsaUJBQWlCLENBQUMsS0FBZ0IsRUFBRSxPQUFZO1FBQzVELE9BQU87WUFDTCxJQUFJLEVBQUUsU0FBUyxPQUFPLENBQUMsU0FBUyxHQUFHO1NBQ3BDLENBQUM7SUFDSixDQUFDO0lBZ0JELDREQUE0RDtJQUNyRCxLQUFLLENBQUMsS0FBSyxDQUFDLFVBQWtCLEVBQUUsT0FBZTtRQUNwRCxNQUFNLElBQUksS0FBSyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7SUFDL0QsQ0FBQztDQUVGO0FBcERELHlCQW9EQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHNwZWMgZnJvbSAnQGpzaWkvc3BlYyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgeG1sYnVpbGRlciBmcm9tICd4bWxidWlsZGVyJztcblxuaW1wb3J0IHsgVGFyZ2V0QnVpbGRlciwgQnVpbGRPcHRpb25zIH0gZnJvbSAnLi4vYnVpbGRlcic7XG5pbXBvcnQgKiBhcyBsb2dnaW5nIGZyb20gJy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgSnNpaU1vZHVsZSB9IGZyb20gJy4uL3BhY2thZ2luZyc7XG5pbXBvcnQge1xuICBQYWNrYWdlSW5mbyxcbiAgVGFyZ2V0LFxuICBUYXJnZXRPcHRpb25zLFxuICBmaW5kTG9jYWxCdWlsZERpcnMsXG59IGZyb20gJy4uL3RhcmdldCc7XG5pbXBvcnQgeyBzaGVsbCwgU2NyYXRjaCwgc2V0RXh0ZW5kLCBmaWx0ZXJBc3luYyB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHsgRG90TmV0R2VuZXJhdG9yIH0gZnJvbSAnLi9kb3RuZXQvZG90bmV0Z2VuZXJhdG9yJztcbmltcG9ydCB7IHRvUmVsZWFzZVZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24tdXRpbHMnO1xuXG5pbXBvcnQgeyBUYXJnZXROYW1lIH0gZnJvbSAnLic7XG5cbmV4cG9ydCBjb25zdCBUQVJHRVRfRlJBTUVXT1JLID0gJ25ldGNvcmVhcHAzLjEnO1xuXG4vKipcbiAqIEJ1aWxkIC5ORVQgcGFja2FnZXMgYWxsIHRvZ2V0aGVyLCBieSBnZW5lcmF0aW5nIGFuIGFnZ3JlZ2F0ZSBzb2x1dGlvbiBmaWxlXG4gKi9cbmV4cG9ydCBjbGFzcyBEb3RuZXRCdWlsZGVyIGltcGxlbWVudHMgVGFyZ2V0QnVpbGRlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgdGFyZ2V0TmFtZSA9ICdkb3RuZXQnO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1vZHVsZXM6IHJlYWRvbmx5IEpzaWlNb2R1bGVbXSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9wdGlvbnM6IEJ1aWxkT3B0aW9ucyxcbiAgKSB7fVxuXG4gIHB1YmxpYyBhc3luYyBidWlsZE1vZHVsZXMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMubW9kdWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNvZGVPbmx5KSB7XG4gICAgICAvLyBTaW1wbGUsIGp1c3QgZ2VuZXJhdGUgY29kZSB0byByZXNwZWN0aXZlIG91dHB1dCBkaXJzXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgdGhpcy5tb2R1bGVzLm1hcCgobW9kdWxlKSA9PlxuICAgICAgICAgIHRoaXMuZ2VuZXJhdGVNb2R1bGVDb2RlKFxuICAgICAgICAgICAgbW9kdWxlLFxuICAgICAgICAgICAgdGhpcy5vdXRwdXREaXIobW9kdWxlLm91dHB1dERpcmVjdG9yeSksXG4gICAgICAgICAgKSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlIG1ha2UgYSBzaW5nbGUgdGVtcGRpciB0byBob2xkIGFsbCBzb3VyY2VzLCBidWlsZCB0aGVtIHRvZ2V0aGVyIGFuZCBjb3B5IHRoZW0gYmFjayBvdXRcbiAgICBjb25zdCBzY3JhdGNoRGlyczogQXJyYXk8U2NyYXRjaDxhbnk+PiA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB0ZW1wU291cmNlRGlyID0gYXdhaXQgdGhpcy5nZW5lcmF0ZUFnZ3JlZ2F0ZVNvdXJjZURpcih0aGlzLm1vZHVsZXMpO1xuICAgICAgc2NyYXRjaERpcnMucHVzaCh0ZW1wU291cmNlRGlyKTtcblxuICAgICAgLy8gQnVpbGQgc29sdXRpb25cbiAgICAgIGxvZ2dpbmcuZGVidWcoJ0J1aWxkaW5nIC5ORVQnKTtcbiAgICAgIGF3YWl0IHNoZWxsKFxuICAgICAgICAnZG90bmV0JyxcbiAgICAgICAgWydidWlsZCcsICctLWZvcmNlJywgJy0tY29uZmlndXJhdGlvbicsICdSZWxlYXNlJ10sXG4gICAgICAgIHtcbiAgICAgICAgICBjd2Q6IHRlbXBTb3VyY2VEaXIuZGlyZWN0b3J5LFxuICAgICAgICAgIHJldHJ5OiB7IG1heEF0dGVtcHRzOiA1IH0sXG4gICAgICAgIH0sXG4gICAgICApO1xuXG4gICAgICBhd2FpdCB0aGlzLmNvcHlPdXRBcnRpZmFjdHModGVtcFNvdXJjZURpci5vYmplY3QpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbGVhbikge1xuICAgICAgICBhd2FpdCBTY3JhdGNoLmNsZWFudXBBbGwoc2NyYXRjaERpcnMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dpbmcud2FybihcbiAgICAgICAgYEV4Y2VwdGlvbiBvY2N1cnJlZCwgbm90IGNsZWFuaW5nIHVwICR7c2NyYXRjaERpcnNcbiAgICAgICAgICAubWFwKChzKSA9PiBzLmRpcmVjdG9yeSlcbiAgICAgICAgICAuam9pbignLCAnKX1gLFxuICAgICAgKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZUFnZ3JlZ2F0ZVNvdXJjZURpcihcbiAgICBtb2R1bGVzOiByZWFkb25seSBKc2lpTW9kdWxlW10sXG4gICk6IFByb21pc2U8U2NyYXRjaDxUZW1wb3JhcnlEb3RuZXRQYWNrYWdlW10+PiB7XG4gICAgcmV0dXJuIFNjcmF0Y2gubWFrZShhc3luYyAodG1wRGlyOiBzdHJpbmcpID0+IHtcbiAgICAgIGxvZ2dpbmcuZGVidWcoYEdlbmVyYXRpbmcgYWdncmVnYXRlIC5ORVQgc291cmNlIGRpciBhdCAke3RtcERpcn1gKTtcblxuICAgICAgY29uc3QgY3NQcm9qcyA9IFtdO1xuICAgICAgY29uc3QgcmV0OiBUZW1wb3JhcnlEb3RuZXRQYWNrYWdlW10gPSBbXTtcblxuICAgICAgLy8gQ29kZSBnZW5lcmF0b3Igd2lsbCBtYWtlIGl0cyBvd24gc3ViZGlyZWN0b3J5XG4gICAgICBjb25zdCBnZW5lcmF0ZWRNb2R1bGVzID0gbW9kdWxlcy5tYXAoKG1vZCkgPT5cbiAgICAgICAgdGhpcy5nZW5lcmF0ZU1vZHVsZUNvZGUobW9kLCB0bXBEaXIpLnRoZW4oKCkgPT4gbW9kKSxcbiAgICAgICk7XG5cbiAgICAgIGZvciBhd2FpdCAoY29uc3QgbW9kIG9mIGdlbmVyYXRlZE1vZHVsZXMpIHtcbiAgICAgICAgY29uc3QgbG9jID0gcHJvamVjdExvY2F0aW9uKG1vZCk7XG4gICAgICAgIGNzUHJvanMucHVzaChsb2MucHJvamVjdEZpbGUpO1xuICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgb3V0cHV0VGFyZ2V0RGlyZWN0b3J5OiBtb2Qub3V0cHV0RGlyZWN0b3J5LFxuICAgICAgICAgIGFydGlmYWN0c0RpcjogcGF0aC5qb2luKHRtcERpciwgbG9jLnByb2plY3REaXIsICdiaW4nLCAnUmVsZWFzZScpLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gVXNlICdkb3RuZXQnIGNvbW1hbmQgbGluZSB0b29sIHRvIGJ1aWxkIGEgc29sdXRpb24gZmlsZSBmcm9tIHRoZXNlIGNzcHJvanNcbiAgICAgIGF3YWl0IHNoZWxsKCdkb3RuZXQnLCBbJ25ldycsICdzbG4nLCAnLW4nLCAnSnNpaUJ1aWxkJ10sIHsgY3dkOiB0bXBEaXIgfSk7XG4gICAgICBhd2FpdCBzaGVsbCgnZG90bmV0JywgWydzbG4nLCAnYWRkJywgLi4uY3NQcm9qc10sIHsgY3dkOiB0bXBEaXIgfSk7XG5cbiAgICAgIGF3YWl0IHRoaXMuZ2VuZXJhdGVOdUdldENvbmZpZ0ZvckxvY2FsRGVwcyh0bXBEaXIpO1xuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjb3B5T3V0QXJ0aWZhY3RzKHBhY2thZ2VzOiBUZW1wb3JhcnlEb3RuZXRQYWNrYWdlW10pIHtcbiAgICBsb2dnaW5nLmRlYnVnKCdDb3B5aW5nIG91dCAuTkVUIGFydGlmYWN0cycpO1xuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocGFja2FnZXMubWFwKGNvcHlPdXRJbmRpdmlkdWFsQXJ0aWZhY3RzLmJpbmQodGhpcykpKTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNvcHlPdXRJbmRpdmlkdWFsQXJ0aWZhY3RzKFxuICAgICAgdGhpczogRG90bmV0QnVpbGRlcixcbiAgICAgIHBrZzogVGVtcG9yYXJ5RG90bmV0UGFja2FnZSxcbiAgICApIHtcbiAgICAgIGNvbnN0IHRhcmdldERpcmVjdG9yeSA9IHRoaXMub3V0cHV0RGlyKHBrZy5vdXRwdXRUYXJnZXREaXJlY3RvcnkpO1xuXG4gICAgICBhd2FpdCBmcy5ta2RpcnAodGFyZ2V0RGlyZWN0b3J5KTtcbiAgICAgIGF3YWl0IGZzLmNvcHkocGtnLmFydGlmYWN0c0RpciwgdGFyZ2V0RGlyZWN0b3J5LCB7XG4gICAgICAgIHJlY3Vyc2l2ZTogdHJ1ZSxcbiAgICAgICAgZmlsdGVyOiAoXywgZHN0KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGRzdCAhPT0gcGF0aC5qb2luKHRhcmdldERpcmVjdG9yeSwgVEFSR0VUX0ZSQU1FV09SSyk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlTW9kdWxlQ29kZShcbiAgICBtb2R1bGU6IEpzaWlNb2R1bGUsXG4gICAgd2hlcmU6IHN0cmluZyxcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5tYWtlVGFyZ2V0KG1vZHVsZSk7XG4gICAgbG9nZ2luZy5kZWJ1ZyhgR2VuZXJhdGluZyAke3RoaXMudGFyZ2V0TmFtZX0gY29kZSBpbnRvICR7d2hlcmV9YCk7XG4gICAgYXdhaXQgdGFyZ2V0LmdlbmVyYXRlQ29kZSh3aGVyZSwgbW9kdWxlLnRhcmJhbGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY2lkZSB3aGV0aGVyIG9yIG5vdCB0byBhcHBlbmQgJ2RvdG5ldCcgdG8gdGhlIGdpdmVuIG91dHB1dCBkaXJlY3RvcnlcbiAgICovXG4gIHByaXZhdGUgb3V0cHV0RGlyKGRlY2xhcmVkRGlyOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxhbmd1YWdlU3ViZGlyZWN0b3J5XG4gICAgICA/IHBhdGguam9pbihkZWNsYXJlZERpciwgdGhpcy50YXJnZXROYW1lKVxuICAgICAgOiBkZWNsYXJlZERpcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIE51R2V0LmNvbmZpZyB0aGF0IHdpbGwgaW5jbHVkZSBidWlsZCBkaXJlY3RvcmllcyBmb3IgbG9jYWwgcGFja2FnZXMgbm90IGluIHRoZSBjdXJyZW50IGJ1aWxkXG4gICAqXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlTnVHZXRDb25maWdGb3JMb2NhbERlcHMod2hlcmU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIFRyYXZlcnNlIHRoZSBkZXBlbmRlbmN5IGdyYXBoIG9mIHRoaXMgbW9kdWxlIGFuZCBmaW5kIGFsbCBtb2R1bGVzIHRoYXQgaGF2ZVxuICAgIC8vIGFuIDxvdXRkaXI+L2RvdG5ldCBkaXJlY3RvcnkuIFdlIHdpbGwgYWRkIHRob3NlIGFzIGxvY2FsIE51R2V0IHJlcG9zaXRvcmllcy5cbiAgICAvLyBUaGlzIGVuYWJsZXMgYnVpbGRpbmcgYWdhaW5zdCBsb2NhbCBtb2R1bGVzLlxuICAgIGNvbnN0IGFsbERlcHNPdXRwdXREaXJzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgICBjb25zdCByZXNvbHZlZE1vZHVsZXMgPSB0aGlzLm1vZHVsZXMubWFwKGFzeW5jIChtb2R1bGUpID0+ICh7XG4gICAgICBtb2R1bGUsXG4gICAgICBsb2NhbEJ1aWxkRGlyczogYXdhaXQgZmluZExvY2FsQnVpbGREaXJzKFxuICAgICAgICBtb2R1bGUubW9kdWxlRGlyZWN0b3J5LFxuICAgICAgICB0aGlzLnRhcmdldE5hbWUsXG4gICAgICApLFxuICAgIH0pKTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHsgbW9kdWxlLCBsb2NhbEJ1aWxkRGlycyB9IG9mIHJlc29sdmVkTW9kdWxlcykge1xuICAgICAgc2V0RXh0ZW5kKGFsbERlcHNPdXRwdXREaXJzLCBsb2NhbEJ1aWxkRGlycyk7XG5cbiAgICAgIC8vIEFsc28gaW5jbHVkZSBvdXRwdXQgZGlyZWN0b3J5IHdoZXJlIHdlJ3JlIGJ1aWxkaW5nIHRvLCBpbiBjYXNlIHdlIGJ1aWxkIG11bHRpcGxlIHBhY2thZ2VzIGludG9cbiAgICAgIC8vIHRoZSBzYW1lIG91dHB1dCBkaXJlY3RvcnkuXG4gICAgICBhbGxEZXBzT3V0cHV0RGlycy5hZGQodGhpcy5vdXRwdXREaXIobW9kdWxlLm91dHB1dERpcmVjdG9yeSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGxvY2FsUmVwb3MgPSBBcnJheS5mcm9tKGFsbERlcHNPdXRwdXREaXJzKTtcblxuICAgIC8vIElmIGRvdG5ldC1ydW50aW1lIGlzIGNoZWNrZWQtb3V0IGFuZCB3ZSBjYW4gZmluZCBhIGxvY2FsIHJlcG9zaXRvcnksIGFkZCBpdCB0byB0aGUgbGlzdC5cbiAgICB0cnkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXMsQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cyxpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbiAgICAgIGNvbnN0IGpzaWlEb3ROZXRSdW50aW1lID0gcmVxdWlyZSgnQGpzaWkvZG90bmV0LXJ1bnRpbWUnKTtcbiAgICAgIGxvZ2dpbmcuaW5mbyhcbiAgICAgICAgYFVzaW5nIGxvY2FsIHZlcnNpb24gb2YgdGhlIERvdE5ldCBqc2lpIHJ1bnRpbWUgcGFja2FnZSBhdDogJHtqc2lpRG90TmV0UnVudGltZS5yZXBvc2l0b3J5fWAsXG4gICAgICApO1xuICAgICAgbG9jYWxSZXBvcy5wdXNoKGpzaWlEb3ROZXRSdW50aW1lLnJlcG9zaXRvcnkpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gQ291bGRuJ3QgbG9jYXRlIEBqc2lpL2RvdG5ldC1ydW50aW1lLCB3aGljaCBpcyBvd2theSFcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgb3V0IG5vbmV4aXN0YW50IGRpcmVjdG9yaWVzLCAuTkVUIHdpbGwgYmUgdW5oYXBweSBpZiBwYXRocyBkb24ndCBleGlzdFxuICAgIGNvbnN0IGV4aXN0aW5nTG9jYWxSZXBvcyA9IGF3YWl0IGZpbHRlckFzeW5jKGxvY2FsUmVwb3MsIGZzLnBhdGhFeGlzdHMpO1xuXG4gICAgbG9nZ2luZy5kZWJ1ZygnbG9jYWwgTnVHZXQgcmVwb3M6JywgZXhpc3RpbmdMb2NhbFJlcG9zKTtcblxuICAgIC8vIENvbnN0cnVjdCBYTUwgY29udGVudC5cbiAgICBjb25zdCBjb25maWd1cmF0aW9uID0geG1sYnVpbGRlci5jcmVhdGUoJ2NvbmZpZ3VyYXRpb24nLCB7XG4gICAgICBlbmNvZGluZzogJ1VURi04JyxcbiAgICB9KTtcbiAgICBjb25zdCBwYWNrYWdlU291cmNlcyA9IGNvbmZpZ3VyYXRpb24uZWxlKCdwYWNrYWdlU291cmNlcycpO1xuXG4gICAgY29uc3QgbnVnZXRPcmdBZGQgPSBwYWNrYWdlU291cmNlcy5lbGUoJ2FkZCcpO1xuICAgIG51Z2V0T3JnQWRkLmF0dCgna2V5JywgJ251Z2V0Lm9yZycpO1xuICAgIG51Z2V0T3JnQWRkLmF0dCgndmFsdWUnLCAnaHR0cHM6Ly9hcGkubnVnZXQub3JnL3YzL2luZGV4Lmpzb24nKTtcbiAgICBudWdldE9yZ0FkZC5hdHQoJ3Byb3RvY29sVmVyc2lvbicsICczJyk7XG5cbiAgICBleGlzdGluZ0xvY2FsUmVwb3MuZm9yRWFjaCgocmVwbywgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGFkZCA9IHBhY2thZ2VTb3VyY2VzLmVsZSgnYWRkJyk7XG4gICAgICBhZGQuYXR0KCdrZXknLCBgbG9jYWwtJHtpbmRleH1gKTtcbiAgICAgIGFkZC5hdHQoJ3ZhbHVlJywgcGF0aC5qb2luKHJlcG8pKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXJndW1lbnRzWydkb3RuZXQtbnVnZXQtZ2xvYmFsLXBhY2thZ2VzLWZvbGRlciddKSB7XG4gICAgICAvLyBFbnN1cmUgd2UncmUgbm90IHVzaW5nIHRoZSBjb25maWd1cmVkIGNhY2hlIGZvbGRlclxuICAgICAgY29uZmlndXJhdGlvblxuICAgICAgICAuZWxlKCdjb25maWcnKVxuICAgICAgICAuZWxlKCdhZGQnKVxuICAgICAgICAuYXR0KCdrZXknLCAnZ2xvYmFsUGFja2FnZXNGb2xkZXInKVxuICAgICAgICAuYXR0KFxuICAgICAgICAgICd2YWx1ZScsXG4gICAgICAgICAgcGF0aC5yZXNvbHZlKFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmFyZ3VtZW50c1snZG90bmV0LW51Z2V0LWdsb2JhbC1wYWNrYWdlcy1mb2xkZXInXSxcbiAgICAgICAgICAgICcubnVnZXQnLFxuICAgICAgICAgICAgJ3BhY2thZ2VzJyxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHhtbCA9IGNvbmZpZ3VyYXRpb24uZW5kKHsgcHJldHR5OiB0cnVlIH0pO1xuXG4gICAgLy8gV3JpdGUgWE1MIGNvbnRlbnQgdG8gTnVHZXQuY29uZmlnLlxuICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKHdoZXJlLCAnTnVHZXQuY29uZmlnJyk7XG4gICAgbG9nZ2luZy5kZWJ1ZyhgR2VuZXJhdGVkICR7ZmlsZVBhdGh9YCk7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKGZpbGVQYXRoLCB4bWwpO1xuICB9XG5cbiAgcHJpdmF0ZSBtYWtlVGFyZ2V0KG1vZHVsZTogSnNpaU1vZHVsZSk6IERvdG5ldCB7XG4gICAgcmV0dXJuIG5ldyBEb3RuZXQoXG4gICAgICB7XG4gICAgICAgIHRhcmdldE5hbWU6IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgICAgcGFja2FnZURpcjogbW9kdWxlLm1vZHVsZURpcmVjdG9yeSxcbiAgICAgICAgYXNzZW1ibHk6IG1vZHVsZS5hc3NlbWJseSxcbiAgICAgICAgZmluZ2VycHJpbnQ6IHRoaXMub3B0aW9ucy5maW5nZXJwcmludCxcbiAgICAgICAgZm9yY2U6IHRoaXMub3B0aW9ucy5mb3JjZSxcbiAgICAgICAgYXJndW1lbnRzOiB0aGlzLm9wdGlvbnMuYXJndW1lbnRzLFxuICAgICAgICByb3NldHRhOiB0aGlzLm9wdGlvbnMucm9zZXR0YSxcbiAgICAgIH0sXG4gICAgICB0aGlzLm1vZHVsZXMubWFwKChtKSA9PiBtLm5hbWUpLFxuICAgICk7XG4gIH1cbn1cblxuaW50ZXJmYWNlIFRlbXBvcmFyeURvdG5ldFBhY2thZ2Uge1xuICAvKipcbiAgICogV2hlcmUgdGhlIGFydGlmYWN0cyB3aWxsIGJlIHN0b3JlZCBhZnRlciBidWlsZCAocmVsYXRpdmUgdG8gYnVpbGQgZGlyKVxuICAgKi9cbiAgYXJ0aWZhY3RzRGlyOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoZXJlIHRoZSBhcnRpZmFjdHMgb3VnaHQgdG8gZ28gZm9yIHRoaXMgcGFydGljdWxhciBtb2R1bGVcbiAgICovXG4gIG91dHB1dFRhcmdldERpcmVjdG9yeTogc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBwcm9qZWN0TG9jYXRpb24obW9kdWxlOiBKc2lpTW9kdWxlKSB7XG4gIGNvbnN0IHBhY2thZ2VJZDogc3RyaW5nID0gbW9kdWxlLmFzc2VtYmx5LnRhcmdldHMhLmRvdG5ldCEucGFja2FnZUlkO1xuICByZXR1cm4ge1xuICAgIHByb2plY3REaXI6IHBhY2thZ2VJZCxcbiAgICBwcm9qZWN0RmlsZTogcGF0aC5qb2luKHBhY2thZ2VJZCwgYCR7cGFja2FnZUlkfS5jc3Byb2pgKSxcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG90bmV0IGV4dGVuZHMgVGFyZ2V0IHtcbiAgcHVibGljIHN0YXRpYyB0b1BhY2thZ2VJbmZvcyhhc3NtOiBzcGVjLkFzc2VtYmx5KToge1xuICAgIFtsYW5ndWFnZTogc3RyaW5nXTogUGFja2FnZUluZm87XG4gIH0ge1xuICAgIGNvbnN0IHBhY2thZ2VJZCA9IGFzc20udGFyZ2V0cyEuZG90bmV0IS5wYWNrYWdlSWQ7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRvUmVsZWFzZVZlcnNpb24oYXNzbS52ZXJzaW9uLCBUYXJnZXROYW1lLkRPVE5FVCk7XG4gICAgY29uc3QgcGFja2FnZUluZm86IFBhY2thZ2VJbmZvID0ge1xuICAgICAgcmVwb3NpdG9yeTogJ051Z2V0JyxcbiAgICAgIHVybDogYGh0dHBzOi8vd3d3Lm51Z2V0Lm9yZy9wYWNrYWdlcy8ke3BhY2thZ2VJZH0vJHt2ZXJzaW9ufWAsXG4gICAgICB1c2FnZToge1xuICAgICAgICBjc3Byb2o6IHtcbiAgICAgICAgICBsYW5ndWFnZTogJ3htbCcsXG4gICAgICAgICAgY29kZTogYDxQYWNrYWdlUmVmZXJlbmNlIEluY2x1ZGU9XCIke3BhY2thZ2VJZH1cIiBWZXJzaW9uPVwiJHt2ZXJzaW9ufVwiIC8+YCxcbiAgICAgICAgfSxcbiAgICAgICAgZG90bmV0OiB7XG4gICAgICAgICAgbGFuZ3VhZ2U6ICdjb25zb2xlJyxcbiAgICAgICAgICBjb2RlOiBgZG90bmV0IGFkZCBwYWNrYWdlICR7cGFja2FnZUlkfSAtLXZlcnNpb24gJHt2ZXJzaW9ufWAsXG4gICAgICAgIH0sXG4gICAgICAgICdwYWNrYWdlcy5jb25maWcnOiB7XG4gICAgICAgICAgbGFuZ3VhZ2U6ICd4bWwnLFxuICAgICAgICAgIGNvZGU6IGA8cGFja2FnZSBpZD1cIiR7cGFja2FnZUlkfVwiIHZlcnNpb249XCIke3ZlcnNpb259XCIgLz5gLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiB7ICdDIyc6IHBhY2thZ2VJbmZvIH07XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIHRvTmF0aXZlUmVmZXJlbmNlKF90eXBlOiBzcGVjLlR5cGUsIG9wdGlvbnM6IGFueSkge1xuICAgIHJldHVybiB7XG4gICAgICAnYyMnOiBgdXNpbmcgJHtvcHRpb25zLm5hbWVzcGFjZX07YCxcbiAgICB9O1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGdlbmVyYXRvcjogRG90TmV0R2VuZXJhdG9yO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBvcHRpb25zOiBUYXJnZXRPcHRpb25zLFxuICAgIGFzc2VtYmxpZXNDdXJyZW50bHlCZWluZ0NvbXBpbGVkOiBzdHJpbmdbXSxcbiAgKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICB0aGlzLmdlbmVyYXRvciA9IG5ldyBEb3ROZXRHZW5lcmF0b3IoXG4gICAgICBhc3NlbWJsaWVzQ3VycmVudGx5QmVpbmdDb21waWxlZCxcbiAgICAgIG9wdGlvbnMucm9zZXR0YSxcbiAgICApO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXF1aXJlLWF3YWl0XG4gIHB1YmxpYyBhc3luYyBidWlsZChfc291cmNlRGlyOiBzdHJpbmcsIF9vdXREaXI6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCBiZSBjYWxsZWQ7IHVzZSBidWlsZGVyIGluc3RlYWQnKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9yZXF1aXJlLWF3YWl0ICovXG59XG4iXX0=